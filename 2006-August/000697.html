<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r509 - in trunk/src/net/sf/plantlore:	common/exception middleware server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r509%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09common/exception%20middleware%20server&In-Reply-To=%3C200608140914.k7E9EHx7015233%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000696.html">
   <LINK REL="Next"  HREF="000698.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r509 - in trunk/src/net/sf/plantlore:	common/exception middleware server</H1>
    <B>kovo at mail.berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r509%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09common/exception%20middleware%20server&In-Reply-To=%3C200608140914.k7E9EHx7015233%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r509 - in trunk/src/net/sf/plantlore:	common/exception middleware server">kovo at mail.berlios.de
       </A><BR>
    <I>Mon Aug 14 11:14:17 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000696.html">[Plantlore-dev] [Bug #7679] Exception
</A></li>
        <LI>Next message: <A HREF="000698.html">[Plantlore-dev] Vyreseni neprijemne situace s importem nalezovych	dat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#697">[ date ]</a>
              <a href="thread.html#697">[ thread ]</a>
              <a href="subject.html#697">[ subject ]</a>
              <a href="author.html#697">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kovo
Date: 2006-08-14 11:14:10 +0200 (Mon, 14 Aug 2006)
New Revision: 509

Modified:
   trunk/src/net/sf/plantlore/common/exception/DBLayerException.java
   trunk/src/net/sf/plantlore/middleware/DBLayer.java
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
Fix exception handling in DBLayer. Add methods for creating/altering/removing database users (createUser(), alterUser(), dropUser()). For details of these methods see JavaDoc in DBLayer.java

Modified: trunk/src/net/sf/plantlore/common/exception/DBLayerException.java
===================================================================
--- trunk/src/net/sf/plantlore/common/exception/DBLayerException.java	2006-08-13 21:41:19 UTC (rev 508)
+++ trunk/src/net/sf/plantlore/common/exception/DBLayerException.java	2006-08-14 09:14:10 UTC (rev 509)
@@ -41,7 +41,17 @@
         public static final int ERROR_RIGHTS = 10;        
         /** Database not consistent (e.g. tHistoryColumn doesn't contain data) */
         public static final int ERROR_DB = 11;
-        /** Some other error */
+        /** Transaction rolled back - possible locking conflict */ 
+        public static final int ERROR_TRANSACTION = 12;
+        /** Insufficient resources error occurred */
+        public static final int ERROR_RESOURCES = 13;
+        /** Disk full error occurred*/
+        public static final int ERROR_DISK_FULL = 14;
+        /** Out of memmory error occurred */
+        public static final int ERROR_OUT_OF_MEMORY = 15;        
+        /** Maximum number of connections achieved */
+        public static final int ERROR_MAX_CONNECTIONS = 15;                
+        /** Some other error */        
         public static final int ERROR_OTHER = 20;
         // ==============================================
         /** Create new DBLayerException without an error message */
@@ -74,4 +84,56 @@
         public String getErrorInfo() {
             return this.errorInfo;
         }
+        
+        /**
+         *  Translate SQL State to DBLayerException constants. SQL State is obtained from JDBC exceptions
+         *  thrown by the JDBC driver. Only several SQL States are translated, for others ERROR_OTHER is
+         *  returned.
+         *  @param sqlstate String containing SQL State constant
+         *  @return DBLayerException constant identifying a problem
+         */
+        public static int translateSQLState(String sqlstate) {
+            String errorClass = sqlstate.substring(0,2);
+            String errorDetail = sqlstate.substring(2);
+            // Connection exception - Connection does not exist, was interrupted or cannot be established
+            if (errorClass.equals(&quot;08&quot;)) {
+                return ERROR_CONNECT;
+            }
+            // Integrity constraint violation - NOT NULL, FOREIGN KEY, UNIQUE violation
+            if (errorClass.equals(&quot;23&quot;)) {
+                return ERROR_DB;
+            }
+            // Transaction rollback
+            if (errorClass.equals(&quot;40&quot;)) {
+                return ERROR_TRANSACTION;
+            }
+            // Syntax error
+            if (errorClass.equals(&quot;42&quot;)) {
+                return ERROR_DB;
+            }
+            // Insufficient Resources
+            if (errorClass.equals(&quot;53&quot;)) {
+                // Generic &quot;Insufficient resources&quot;
+                if (errorDetail.equals(&quot;000&quot;)) {
+                    return ERROR_RESOURCES;
+                }
+                // Disk Full
+                if (errorDetail.equals(&quot;100&quot;)) {
+                    return ERROR_DISK_FULL;
+                }
+                // Out of memory
+                if (errorDetail.equals(&quot;200&quot;)) {
+                    return ERROR_OUT_OF_MEMORY;
+                }
+                // Too many connections
+                if (errorDetail.equals(&quot;300&quot;)) {
+                    return ERROR_MAX_CONNECTIONS;
+                }                
+            }
+            // System error - External error (such as IO errors)
+            if (errorClass.equals(&quot;58&quot;)) {
+                return ERROR_OTHER;
+            }
+            return ERROR_OTHER;
+        }
 }

Modified: trunk/src/net/sf/plantlore/middleware/DBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-08-13 21:41:19 UTC (rev 508)
+++ trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-08-14 09:14:10 UTC (rev 509)
@@ -283,8 +283,49 @@
      *  @throws RemoteException in case network connection failed
      */
     public void executeDeleteInTransaction(Object data) throws DBLayerException, RemoteException;
+
+    /**
+     *  Method for creating new database user using CREATE USER statement. This method can only be called
+     *  as a part of long running transaction (such as executeInsertInTransaction() method).
+     *
+     *  @param name     Name of the new user
+     *  @param password Password for the new user
+     *  @param isAdmin  Flag whether created user will or will not be an administrator (admin can create other users)
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the DB or the 
+     *                           execution of CREATE USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */
+    public void createUser(String name, String password, boolean isAdmin) throws DBLayerException, RemoteException;
     
     /**
+     *  Method for modifying the database user using ALTER USER statement. This method can only 
+     *  be called as a part of long running transaction (such as executeInsertInTransaction() method).
+     *  Only password and admin flag can be modified. Name of the user cannot be modified.
+     *
+     *  @param name     Name of the user to modify
+     *  @param password New password for the user. Leave blank or null if not modified.
+     *  @param isAdmin  Flag whether the user should or should not be an administrator (admin can 
+     *                  create other users)
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the 
+     *                           DB or the execution of ALTER USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */    
+    public void alterUser(String name, String password, boolean isAdmin) throws DBLayerException, RemoteException;
+    
+    /**
+     *  Method for deleting database user using DROP USER statement. This method can only 
+     *  be called as a part of long running transaction (such as executeInsertInTransaction() method).
+     *  DROP USER statement will fail in case user with the given username does not exist or in case
+     *  the given user is an owner of some database.
+     *
+     *  @param name     Name of the user to drop
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the 
+     *                           DB or the execution of DROP USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */    
+    public void dropUser(String name) throws DBLayerException, RemoteException;
+        
+    /**
      *  Return number of open database connections (instances of Hibernate Session class)
      *  @return number of open database connections
      *  @throws RemoteException in case network connection failed
@@ -301,7 +342,5 @@
      * be used by the DBLayerFactory exclusively.
      */
     public void shutdown() throws RemoteException;
-    
-    public void destroy() throws RemoteException;
-        
+           
 }

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-08-13 21:41:19 UTC (rev 508)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-08-14 09:14:10 UTC (rev 509)
@@ -8,10 +8,14 @@
 package net.sf.plantlore.server;
 
 import java.io.File;
+import java.net.ConnectException;
 import java.rmi.NoSuchObjectException;
 import java.rmi.RemoteException;
 import java.rmi.server.UnicastRemoteObject;
 import java.rmi.server.Unreferenced;
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.SQLException;
 import java.util.Hashtable;
 import java.util.List;
 
@@ -31,13 +35,16 @@
 import net.sf.plantlore.common.record.Territory;
 import net.sf.plantlore.common.record.User;
 import net.sf.plantlore.common.record.Village;
+import net.sf.plantlore.l10n.L10n;
 import org.apache.log4j.Logger;
 import net.sf.plantlore.common.exception.DBLayerException;
 import org.hibernate.HibernateException;
+import org.hibernate.JDBCException;
 import org.hibernate.Query;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
+import org.hibernate.StaleObjectStateException;
 import org.hibernate.cfg.Configuration;
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
@@ -57,9 +64,8 @@
  */
 public class HibernateDBLayer implements DBLayer, Unreferenced {
 	
+    private static final long serialVersionUID = 2006060433222L;
 	
-	private static final long serialVersionUID = 2006060433222L;
-	
     /** Instance of a logger */
     private Logger logger;
     /** Configuration file for Hibernate */
@@ -95,22 +101,18 @@
     
     private DatabaseSettings settings;
     private String currentlyConnectedUser = &quot;&quot;;
-    
-
-    
+        
     public HibernateDBLayer(DatabaseSettings settings) {
     	this(null, settings);
     }
    
     
     /**
-     * Creates a new instance of HibernateDBLayer.
+     *  Creates a new instance of HibernateDBLayer.
      * 
      *  @param undertaker The object that is responsible for cleanup if the client crashes. 
      */
-    public HibernateDBLayer(
-    		Undertaker undertaker, 
-    		DatabaseSettings settings) {
+    public HibernateDBLayer(Undertaker undertaker, DatabaseSettings settings) {
         logger = Logger.getLogger(this.getClass().getPackage().getName());
         logger.debug(&quot;      Constructing a new HibernateDBLayer ...&quot;);
         
@@ -139,7 +141,11 @@
      *  @param password password for the access to plantlore on the server
      *  @return array with two objects - User object with logged in user (index 0) and user's rights 
      *          (Right object, index 1)
-     *  @throws DBLayerException when the hibernate or database connection cannot be initialized
+     *  @throws DBLayerException The following errors can occurr:
+     *          ERROR_LOAD_CONFIG: Unable to load Hibernate configuration file
+     *          ERROR_CONNECT: Unable to establish database connection (build SessionFactory)
+     *          ERROR_SELECT: Unable to read contents of TUSER table
+     *          ERROR_LOGIN: Authentication failed (wrong password, username or account disabled)
      */
     public Object[] initialize(String dbID, String user, String password) throws DBLayerException, RemoteException {
         Configuration cfg;
@@ -154,52 +160,67 @@
             cfg = new Configuration().configure(configFile);
         } catch (HibernateException e) {
             logger.fatal(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_LOAD_CONFIG, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.LoadConfiguration&quot;);
+            ex.setError(ex.ERROR_LOAD_CONFIG, e.getMessage());
             throw ex;
         }
-
+        // Create connections string from the provided data
         if( settings.getConnectionStringSuffix() == null || &quot;&quot;.equals(settings.getConnectionStringSuffix()) )
         	cfg.setProperty(&quot;hibernate.connection.url&quot;, settings.getConnectionStringPrefix() + dbID);
         else
         	cfg.setProperty(&quot;hibernate.connection.url&quot;, settings.getConnectionStringPrefix() + dbID 
         			+ &quot;?&quot; + settings.getConnectionStringSuffix());
-        
+        // Set username and password to access database
         cfg.setProperty(&quot;hibernate.connection.username&quot;, user);
         cfg.setProperty(&quot;hibernate.connection.password&quot;, password);
+        // Build session factory        
         try {
-            // Build session factory
             sessionFactory = cfg.buildSessionFactory();
+        } catch (JDBCException e) {
+            logger.fatal(&quot;Cannot build Hibernate session factory. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.EstablishConnection&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;            
         } catch (HibernateException e) {
             logger.fatal(&quot;Cannot build Hibernate session factory. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Cannot build Hibernate session factory. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_CONNECT, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.EstablishConnection&quot;);
+            ex.setError(ex.ERROR_CONNECT, e.getMessage());
             throw ex;
-        }   
+        }         
         // Authenticate user
         Session sess = sessionFactory.openSession();            
-        // TODO: Password should probably be encrypted            
-        ScrollableResults sr = sess.createCriteria(User.class)
-            .add(Restrictions.eq(User.LOGIN, user))
-            .add(Restrictions.eq(User.PASSWORD, password))
-            .add(Restrictions.isNull(User.DROPWHEN))
-            .scroll();
+        // TODO: Password should probably be encrypted
+        ScrollableResults sr = null;
+        try {
+            sr = sess.createCriteria(User.class)
+                .add(Restrictions.eq(User.LOGIN, user))
+                .add(Restrictions.eq(User.PASSWORD, password))
+                .add(Restrictions.isNull(User.DROPWHEN))
+                .scroll();
+        } catch (HibernateException e) {            
+            logger.fatal(&quot;Selecting records from the database failed. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.SelectQuery&quot;);
+            ex.setError(ex.ERROR_SELECT, e.getMessage());
+            throw ex;            
+        }
         if (!sr.next()) {
             // Authentication failed, close DB connection
             sess.close();
             sessionFactory.close();
             sessionFactory = null;
             logger.warn(&quot;Authentication of user &quot;+user+&quot; failed!&quot;);
-            DBLayerException ex = new DBLayerException(&quot;Authentication of user &quot;+user+&quot; failed!&quot;);
-            ex.setError(ex.ERROR_LOGIN, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.AuthenticationFailed&quot;);
+            ex.setError(ex.ERROR_LOGIN, user);
             throw ex;
         } else {
+            // Save the information about authenticated user
             Object[] userinfo = sr.get();
             User clientUser = (User)userinfo[0];            
             this.rights = clientUser.getRight();           
             this.plantloreUser = clientUser;
             sess.close();
         }
+        // Return User and Right object with users details
         Object[] retValue = new Object[2];
         retValue[0] = this.plantloreUser;
         retValue[1] = this.rights;
@@ -214,14 +235,14 @@
      *  @throws DBLayerException when saving data into the database fails
      */
     public int executeInsert(Object data) throws DBLayerException, RemoteException {
-        int recordId, id, result = 0;        
+        int recordId, id, result = 0;
         String table;
         HistoryColumn column;
         
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -251,7 +272,8 @@
         // Check whether we have sufficient rights
         checkRights(data, INSERT);
         Session session = sessionFactory.openSession();
-        Transaction tx = null;                
+        Transaction tx = null; 
+        recordId = 0;
         try {
             // Begin transaction
             tx = session.beginTransaction();            
@@ -260,16 +282,23 @@
             // Save data to history tables - only for selected tables
             saveHistory(session, data, INSERT, recordId);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();  
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while saving the record into the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.SaveRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
-            e.printStackTrace();
-            DBLayerException ex = new DBLayerException(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_SAVE, null);
-            throw ex;            
+            DBLayerException ex = new DBLayerException(&quot;Exception.SaveRecord&quot;);
+            ex.setError(ex.ERROR_SAVE, e.getMessage());
+            throw ex;  
         } finally {
             session.close();
         }
@@ -289,7 +318,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -326,14 +355,22 @@
             // Save item into the database
             recordId = (Integer)session.save(data);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();  
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while saving the record into the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.SaveRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;            
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_SAVE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.SaveRecord&quot;);
+            ex.setError(ex.ERROR_SAVE, e.getMessage());
             throw ex;            
         } finally {
             session.close();
@@ -355,7 +392,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -366,14 +403,22 @@
             // Update the item in the database
             session.update(data);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();    
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while deleting the record from the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;            
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_DELETE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
+            ex.setError(ex.ERROR_DELETE, e.getMessage());
             throw ex;            
         } finally {
             session.close();
@@ -390,7 +435,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -401,14 +446,22 @@
             // Save item into the database
             session.delete(data);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();                
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while deleting the record from the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_DELETE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
+            ex.setError(ex.ERROR_DELETE, e.getMessage());
             throw ex;
         } finally {
             session.close();
@@ -427,7 +480,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -449,15 +502,30 @@
             // Save item into the database
             session.update(data);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();  
+        } catch (StaleObjectStateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.warn(&quot;StaleObjectStateException caught (Concurrent transactions running and trying to commit). Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.ConcurrentUpdate&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;                        
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while updating the record in the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                                    
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
-            e.printStackTrace();
-            DBLayerException ex = new DBLayerException(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_UPDATE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);
+            ex.setError(ex.ERROR_UPDATE, e.getMessage());
             throw ex;            
         } finally {
             session.close();
@@ -474,7 +542,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -494,14 +562,30 @@
             // Save item into the database
             session.update(data);
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();  
+        } catch (StaleObjectStateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.warn(&quot;StaleObjectStateException caught (Concurrent transactions running and trying to commit). Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.ConcurrentUpdate&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;                        
+        } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while updating the record in the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_UPDATE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);            
+            ex.setError(ex.ERROR_UPDATE, e.getMessage());
             throw ex;
         } finally {
             session.close();
@@ -523,7 +607,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -543,8 +627,25 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }        
-        // Save item into the database
-        txSession.update(data);        
+        try {
+            // Save item into the database
+            txSession.update(data);        
+        } catch (StaleObjectStateException e) {
+            logger.warn(&quot;StaleObjectStateException caught (Concurrent transactions running and trying to commit). Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.ConcurrentUpdate&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;                        
+        } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while updating the record in the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.UpdateRecord&quot;);
+            ex.setError(ex.ERROR_UPDATE, e.getMessage());
+            throw ex;
+        }
     }
     
     /**
@@ -561,14 +662,14 @@
         // Check validity of arguments
         if (from&gt;to) {
             logger.error(&quot;Cannot read rows from &quot;+from+&quot; to &quot;+to+&quot; because from &gt; to&quot;);            
-            DBLayerException ex = new DBLayerException(&quot;Cannot read rows from &quot;+from+&quot; to &quot;+to+&quot; because from &gt; to&quot;);
-            ex.setError(ex.ERROR_OTHER, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.ERROR_OTHER, &quot;Cannot read rows from &quot;+from+&quot; to &quot;+to+&quot; because from &gt; to&quot;);
             throw ex;
         } 
         if (from &lt; 0) {
             logger.error(&quot;Cannot read rows starting at the given index: &quot;+from);
-            DBLayerException ex = new DBLayerException(&quot;Cannot read rows starting at the given index: &quot;+from);
-            ex.setError(ex.ERROR_OTHER, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.ERROR_OTHER, &quot;Cannot read rows starting at the given index: &quot;+from);
             throw ex;
         }
         // Get results for the given resultId
@@ -581,10 +682,15 @@
             } else {
                 res.beforeFirst();
             }
+        } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while retrieving the data from the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;            
         } catch (HibernateException e) {
-            logger.error(&quot;Cannot move to the given row of results: &quot;+from);
-            DBLayerException ex = new DBLayerException(&quot;Cannot move to the given row of results: &quot;+from);
-            ex.setError(ex.ERROR_OTHER, null);
+            logger.error(&quot;Cannot move to the given row of results: &quot;+from+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.ERROR_LOAD_DATA, e.getMessage());
             throw ex;            
         }
         // Allocate space for data
@@ -595,15 +701,16 @@
                 if (res.next()) {
                     data[i] = res.get();
                 } else {
-                    logger.debug(&quot;res.get() would return: &quot;+res.get());
                     logger.error(&quot;Result doesn't have enough rows&quot;);
-                    throw new DBLayerException(&quot;Result doesn't have enough rows&quot;);                
+                    DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);                
+                    ex.setError(ex.ERROR_LOAD_DATA, &quot;Result doesn't have enough rows&quot;);
+                    throw ex;
                 }                
             }
         } catch (HibernateException e) {
             logger.error(&quot;Cannot read data from the results&quot;);
-            DBLayerException ex = new DBLayerException(&quot;Cannot read data from the results&quot;);
-            ex.setError(ex.ERROR_LOAD_DATA, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.ERROR_LOAD_DATA, &quot;Cannot read data from the results&quot;);
             throw ex;            
         }
         return data;
@@ -626,9 +733,9 @@
                 return null;
             }
         } catch (HibernateException e) {
-            logger.fatal(&quot;Database error occured&quot;);
-            DBLayerException ex = new DBLayerException(&quot;Database error occured&quot;);
-            ex.setError(ex.ERROR_OTHER, null);
+            logger.error(&quot;Call to next() failed&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RetrieveData&quot;);
+            ex.setError(ex.ERROR_LOAD_DATA, e.getMessage());
             throw ex;            
         }        
         return res.get();        
@@ -641,6 +748,7 @@
      *  @return number of rows in the given result
      */
     public int getNumRows(int resultId) throws RemoteException {
+        int numRows = 0;
         // Get results for the given resultId
         ScrollableResults res = results.get(resultId);
         // Get the current row in the results
@@ -655,7 +763,7 @@
         res.last();
         int last = res.getRowNumber();        
         // Find out the number of rows between the and the last row
-        int numRows = last - first + 1;
+        numRows = last - first + 1;
         // Return the pointer to it's original position
         if (currentRow == -1) {
             res.beforeFirst();
@@ -674,7 +782,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -682,8 +790,8 @@
             sessionFactory.close();
         } catch (HibernateException e) {
             logger.fatal(&quot;Cannot close session factory&quot;);
-            DBLayerException ex = new DBLayerException(&quot;Cannot close session factory&quot;);
-            ex.setError(ex.ERROR_CLOSE, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.CloseConnection&quot;);
+            ex.setError(ex.ERROR_CLOSE, e.getMessage());
             throw ex;            
         }
     }
@@ -699,12 +807,21 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
-        Session session = sessionFactory.openSession();
-        SelectQuery query = new SelectQueryImplementation(session.createCriteria(classname), queries);
+        SelectQuery query = null;
+        Session session = null;
+        try {
+            session = sessionFactory.openSession();
+            query = new SelectQueryImplementation(session.createCriteria(classname), queries);
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Cannot create new query (Failed to create session)&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.DatabaseQuery&quot;);
+            ex.setError(ex.ERROR_SELECT, e.getMessage());
+            throw ex;                        
+        }
         SelectQuery stub = query;
         
         if(undertaker != null)
@@ -730,7 +847,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -752,7 +869,12 @@
      */
     public int executeQuery(SelectQuery query) throws DBLayerException, RemoteException {
     	SelectQuery selectQuery = queries.get(query);
-    	if(selectQuery == null) throw new DBLayerException(&quot;You can only pass queries created by this DBLayer!&quot;);
+    	if(selectQuery == null) {
+            logger.error(&quot;You can only pass queries created by this DBLayer!&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.DatabaseQuery&quot;);
+            ex.setError(ex.ERROR_SELECT, &quot;You can only pass queries created by this DBLayer!&quot;);
+            throw ex;
+        }
     	
     	assert(selectQuery instanceof SelectQueryImplementation);
     	SelectQueryImplementation sq = (SelectQueryImplementation) selectQuery;
@@ -766,16 +888,21 @@
             tx = session.beginTransaction();
             // Execute detached criteria query
             sq.setProjectionList();
-                res = sq.getCriteria().scroll(); // retrieve Criteria from SelectQuery
+            res = sq.getCriteria().scroll(); // retrieve Criteria from SelectQuery
             // Commit transaction
-            tx.commit();                                      
+            tx.commit();  
+        } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while executing Select query. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DatabaseQuery&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
         } catch (HibernateException e) {
             if (tx != null) {
                 tx.rollback();
             }
             logger.fatal(&quot;Selecting records from the database failed. Details: &quot;+e.getMessage());
-            DBLayerException ex = new DBLayerException(&quot;Selecting records from the database failed. Details: &quot;+e.getMessage());
-            ex.setError(ex.ERROR_SELECT, null);
+            DBLayerException ex = new DBLayerException(&quot;Exception.DatabaseQuery&quot;);
+            ex.setError(ex.ERROR_SELECT, e.getMessage());
             throw ex;            
         }
         // Update current maximum result id and save the results
@@ -801,13 +928,14 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
         Transaction tx = null;
-        Session session = sessionFactory.openSession();
+        Session session = null;
         try {
+            session = sessionFactory.openSession();            
             tx = session.beginTransaction();
             Query hqlQuery;
             String hqlDelete = &quot;delete &quot;+tableClass.getName(); 
@@ -826,14 +954,24 @@
             }
             deletedEntities = hqlQuery.executeUpdate();
             tx.commit();
+       } catch (JDBCException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;JDBC Exception caught while deleting the record from the database. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());            
         } catch (HibernateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }            
             logger.fatal(&quot;Cannot execute conditional delete on table &quot;+tableClass.getName());
-            DBLayerException ex = new DBLayerException(&quot;Cannot execute conditional delete on table &quot;+tableClass.getName());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DeleteRecord&quot;);
             ex.setError(ex.ERROR_DELETE, tableClass.getName());
-            session.close();
             throw ex;
+        } finally {
+            if (session != null) session.close();
         }
-        session.close();
         return deletedEntities;
     }
     
@@ -845,8 +983,8 @@
     public void closeQuery(SelectQuery query) throws RemoteException {
         
         // TODO: Problem - we don't have any session for subqueries
-        
-        Session session = sessions.remove(query);
+        // TODO: We should probably catch HibernateException...
+        Session session = sessions.remove(query);        
         session.close();     
     	// Remove the query from the list of opened queries
         SelectQuery selectQuery = queries.remove(query);        
@@ -887,7 +1025,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -895,10 +1033,21 @@
         if (this.longTx != null) {
             return false;               // Return with an error indicating other transaction is running
         }
-        // Open new session
-        this.txSession = sessionFactory.openSession();
-        // Begin new transaction
-        this.longTx = this.txSession.beginTransaction();        
+        try {
+            // Open new session
+            this.txSession = sessionFactory.openSession();
+            // Begin new transaction
+            this.longTx = this.txSession.beginTransaction();
+       } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while starting database transaction. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.StartTransaction&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());                        
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Cannot start database transaction&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.StartTransaction&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;            
+        }
         return true;                    // Transaction succesfully started
     }
 
@@ -915,7 +1064,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -923,12 +1072,23 @@
         if ((this.longTx == null) || (this.txSession == null)) {
             return false;               // Return with an error indicating we don't have proper conditions
         }
-        // Commit the transaction
-        this.longTx.commit();
-        // Set the transaction object to null
-        this.longTx = null;
-        // Close the session
-        this.txSession.close();
+        try {
+            // Commit the transaction
+            this.longTx.commit();
+            // Set the transaction object to null
+            this.longTx = null;
+            // Close the session
+            this.txSession.close();            
+       } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while commiting database transaction. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.CommitTransaction&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());                        
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Cannot commit database transaction&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.CommitTransaction&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;            
+        }
         return true;
     }
     
@@ -946,7 +1106,7 @@
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -954,12 +1114,23 @@
         if ((this.longTx == null) || (this.txSession == null)) {
             return false;               // Return with an error indicating we don't have proper conditions
         }
-        // Rollback the transaction
-        this.longTx.rollback();
-        // Set the transaction object to null
-        this.longTx = null;
-        // Close the session
-        this.txSession.close();        
+        try {
+            // Rollback the transaction
+            this.longTx.rollback();
+            // Set the transaction object to null
+            this.longTx = null;
+            // Close the session
+            this.txSession.close();
+       } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while rollbacking database transaction. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.RollbackTransaction&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());                        
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Cannot rollback database transaction&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RollbackTransaction&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;            
+        }            
         return true;        
     }
 
@@ -976,12 +1147,12 @@
      *  @throws RemoteException in case server connection failed
      */    
     public int executeInsertInTransaction(Object data) throws DBLayerException, RemoteException {
-        int recordId;
+        int recordId = 0;
         
         // Check whether we are connected to the database
         if (sessionFactory == null) {
             logger.warn(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
-            DBLayerException ex = new DBLayerException(&quot;SessionFactory not available. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }
@@ -1034,9 +1205,19 @@
             aut.setCreatedWho(this.plantloreUser);
             data = aut;
         }
-
-        // Save item into the database
-        recordId = (Integer)this.txSession.save(data);            
+        try {
+            // Save item into the database
+            recordId = (Integer)this.txSession.save(data);            
+       } catch (JDBCException e) {
+            logger.fatal(&quot;JDBC Exception caught while rollbacking database transaction. SQL State: &quot;+e.getSQLState()+&quot;; Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.RollbackTransaction&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());                        
+        } catch (HibernateException e) {
+            logger.fatal(&quot;Cannot rollback database transaction&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.RollbackTransaction&quot;);
+            ex.setError(ex.ERROR_TRANSACTION, e.getMessage());
+            throw ex;            
+        }            
         // Save data to history tables - only for selected tables
         saveHistory(txSession, data, INSERT, recordId);
         // Return new record identifier
@@ -2215,6 +2396,163 @@
     }
 
     /**
+     *  Method for creating new database user using CREATE USER statement. This method can only be called
+     *  as a part of long running transaction (such as executeInsertInTransaction() method).
+     *
+     *  @param name     Name of the new user
+     *  @param password Password for the new user
+     *  @param isAdmin  Flag whether created user will or will not be an administrator (admin can create other users)
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the DB or the 
+     *                           execution of CREATE USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */
+    public void createUser(String name, String password, boolean isAdmin) throws DBLayerException, RemoteException {
+        // Check whether we are connected to the database
+        if (sessionFactory == null) {
+            logger.error(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
+            ex.setError(ex.ERROR_CONNECT, null);
+            throw ex;
+        }
+        // Check whether the user is administrator - only admin can modify users
+        if (this.rights.getAdministrator() != 1) {
+            logger.warn(&quot;User doesn't have sufficient rights for this operation. Entity: &quot;+PlantloreConstants.ENTITY_USER);
+            DBLayerException ex = new DBLayerException(&quot;Exception.InsufficientRights&quot;);
+            ex.setError(ex.ERROR_RIGHTS, PlantloreConstants.ENTITY_USER);
+            throw ex;
+        }
+        // TODO: This is PostgreSQL specific. Think of a way how to provide different statements for
+        //       different databases
+        String admin = &quot;&quot;;
+        if (isAdmin) {
+            admin = &quot; CREATEUSER&quot;;
+        }        
+        try {
+            Connection conn = txSession.connection();        
+            PreparedStatement pstmt = conn.prepareStatement(&quot;CREATE USER ? WITH PASSWORD ?&quot;+admin);
+            pstmt.setString(1, name);
+            pstmt.setString(2, password);
+            pstmt.execute();
+        } catch (HibernateException e) {
+            logger.warn(&quot;Unable to retrieve JDBC connection from the Hibernate session. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.CreateUser&quot;);
+            ex.setError(ex.ERROR_SAVE, e.getMessage());
+            throw ex;            
+        } catch (SQLException e) {
+            logger.warn(&quot;Unable to create new database user using CREATE USER statement. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.CreateUser&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
+        }
+    }
+    
+    /**
+     *  Method for modifying the database user using ALTER USER statement. This method can only 
+     *  be called as a part of long running transaction (such as executeInsertInTransaction() method).
+     *  Only password and admin flag can be modified. Name of the user cannot be modified.
+     *
+     *  @param name     Name of the user to modify
+     *  @param password New password for the user. Leave blank or null if not modified.
+     *  @param isAdmin  Flag whether the user should or should not be an administrator (admin can 
+     *                  create other users)
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the 
+     *                           DB or the execution of ALTER USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */    
+    public void alterUser(String name, String password, boolean isAdmin) throws DBLayerException, RemoteException {
+        // Check whether we are connected to the database
+        if (sessionFactory == null) {
+            logger.error(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
+            ex.setError(ex.ERROR_CONNECT, null);
+            throw ex;
+        }
+        // Check whether the user is administrator - only admin can modify users
+        if (this.rights.getAdministrator() != 1) {
+            logger.warn(&quot;User doesn't have sufficient rights for this operation. Entity: &quot;+PlantloreConstants.ENTITY_USER);
+            DBLayerException ex = new DBLayerException(&quot;Exception.InsufficientRights&quot;);
+            ex.setError(ex.ERROR_RIGHTS, PlantloreConstants.ENTITY_USER);
+            throw ex;
+        }
+        // TODO: This is PostgreSQL specific. Think of a way how to provide different statements for
+        //       different databases
+        try {
+            Connection conn = txSession.connection();
+            // In case password has changed, execute statement to change the password
+            if ((password != null) &amp;&amp; (!password.equals(&quot;&quot;))) {
+                PreparedStatement pstmt = conn.prepareStatement(&quot;ALTER USER ? SET PASSWORD TO ?&quot;);
+                pstmt.setString(1, name);
+                pstmt.setString(2, password);
+                pstmt.execute();
+            }
+            // Now set CREATEUSER/NOCREATUSER flag
+            String admin;
+            if (isAdmin) {
+                admin = &quot;CREATEUSER&quot;;
+            } else {
+                admin = &quot;NOCREATEUSER&quot;;
+            }
+            PreparedStatement pstmt = conn.prepareStatement(&quot;ALTER USER ? &quot;+admin);
+            pstmt.setString(1, name);
+            pstmt.execute();            
+        } catch (HibernateException e) {
+            logger.warn(&quot;Unable to retrieve JDBC connection from the Hibernate session. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.AlterUser&quot;);
+            ex.setError(ex.ERROR_SAVE, e.getMessage());
+            throw ex;            
+        } catch (SQLException e) {
+            logger.warn(&quot;Unable to alter the database user using ALTER USER statement. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.AlterUser&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
+        }        
+    }
+    
+    /**
+     *  Method for deleting database user using DROP USER statement. This method can only 
+     *  be called as a part of long running transaction (such as executeInsertInTransaction() method).
+     *  DROP USER statement will fail in case user with the given username does not exist or in case
+     *  the given user is an owner of some database.
+     *
+     *  @param name     Name of the user to drop
+     *  @throws DBLayerException In case we do not have sufficient rights, are not connected to the 
+     *                           DB or the execution of DROP USER statement failed
+     *  @throws RemoteException In case connection to the server was lost
+     */    
+    public void dropUser(String name) throws DBLayerException, RemoteException {
+        // Check whether we are connected to the database
+        if (sessionFactory == null) {
+            logger.error(&quot;SessionFactory not avilable. Not connected to the database.&quot;);
+            DBLayerException ex = new DBLayerException(&quot;Exception.NotConnected&quot;);
+            ex.setError(ex.ERROR_CONNECT, null);
+            throw ex;
+        }
+        // Check whether the user is administrator - only admin can modify users
+        if (this.rights.getAdministrator() != 1) {
+            logger.warn(&quot;User doesn't have sufficient rights for this operation. Entity: &quot;+PlantloreConstants.ENTITY_USER);
+            DBLayerException ex = new DBLayerException(&quot;Exception.InsufficientRights&quot;);
+            ex.setError(ex.ERROR_RIGHTS, PlantloreConstants.ENTITY_USER);
+            throw ex;
+        }
+        try {
+            Connection conn = txSession.connection();        
+            PreparedStatement pstmt = conn.prepareStatement(&quot;DROP USER ?&quot;);
+            pstmt.setString(1, name);
+            pstmt.execute();
+        } catch (HibernateException e) {
+            logger.warn(&quot;Unable to retrieve JDBC connection from the Hibernate session. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DropUser&quot;);
+            ex.setError(ex.ERROR_SAVE, e.getMessage());
+            throw ex;            
+        } catch (SQLException e) {
+            logger.warn(&quot;Unable to drop database user using the DROP USER statement. Details: &quot;+e.getMessage());
+            DBLayerException ex = new DBLayerException(&quot;Exception.DropUser&quot;);
+            ex.setError(ex.translateSQLState(e.getSQLState()), e.getMessage());
+            throw ex;                        
+        }
+    }
+            
+    /**
      *  Return number of open database connections (instances of Hibernate Session class)
      *  @return number of open database connections
      *  @throws RemoteException in case network connection failed
@@ -2254,13 +2592,6 @@
     	
     }
    
-    // TODO: IS IT OK TO OVERRIDE THIS METHOD?
-    public void destroy() throws RemoteException {
-        if (this.queries.size() &gt; 0) {
-            logger.warn(this.queries.size()+&quot; queries were left unclosed in the DBLayer&quot;);
-        }
-    }
-
     //===============================================================
     // What happens to unreferenced objects? They get buried by the untertaker!
     


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000696.html">[Plantlore-dev] [Bug #7679] Exception
</A></li>
	<LI>Next message: <A HREF="000698.html">[Plantlore-dev] Vyreseni neprijemne situace s importem nalezovych	dat
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#697">[ date ]</a>
              <a href="thread.html#697">[ thread ]</a>
              <a href="subject.html#697">[ subject ]</a>
              <a href="author.html#697">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
