<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] Uvodni bitva prohrana
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-August/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20Uvodni%20bitva%20prohrana&In-Reply-To=%3C1156889294.23123.1.camel%40kryton%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000833.html">
   <LINK REL="Next"  HREF="000835.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] Uvodni bitva prohrana</H1>
    <B>fraktalek</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20Uvodni%20bitva%20prohrana&In-Reply-To=%3C1156889294.23123.1.camel%40kryton%3E"
       TITLE="[Plantlore-dev] Uvodni bitva prohrana">fraktalek at gmx.net
       </A><BR>
    <I>Wed Aug 30 00:08:14 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000833.html">[Plantlore-dev] Uvodni bitva prohrana
</A></li>
        <LI>Next message: <A HREF="000835.html">[Plantlore-dev] r598 - in trunk/src/net/sf/plantlore: client/login	common/record middleware server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#834">[ date ]</a>
              <a href="thread.html#834">[ thread ]</a>
              <a href="subject.html#834">[ subject ]</a>
              <a href="author.html#834">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Zabavny cteni :))

i kdyz je to cely smutny... :-/

me jen napadlo, ze Plant se mozna neprenasi sam jako takovy, protoze se
tam delaji projekce... Vlastne, co se overview tyce tak se tam delaji
projekce skoro vsude. Nemuze to souviset s tim?

Jakub


Erik Kratochv&#237;l p&#237;&#353;e v &#218;t 29. 08. 2006 v 23:46 +0200:
&gt;<i> Vsichni, kdo jsme zkouseli spustit server, jsme byli oblazeni
</I>&gt;<i> zahadnou, ba primo vyslovene magickou, vyjimkou
</I>&gt;<i> 
</I>&gt;<i> java.rmi.UnmarshalException: error unmarshalling return; nested
</I>&gt;<i> exception is: 
</I>&gt;<i>     java.io.WriteAbortedException: writing aborted;
</I>&gt;<i> java.io.NotSerializableException: org.apache.log4j.Logger
</I>&gt;<i>     at sun.rmi.server.UnicastRef.invoke(Unknown Source)
</I>&gt;<i>     at net.sf.plantlore.server.HibernateDBLayer_Stub.initialize
</I>&gt;<i> (Unknown Source)
</I>&gt;<i>     at net.sf.plantlore.client.login.Login$ConnectionTask.task
</I>&gt;<i> (Login.java:297)
</I>&gt;<i>     at net.sf.plantlore.common.Task$1.construct(Task.java :185)
</I>&gt;<i>     at net.sf.plantlore.common.SwingWorker
</I>&gt;<i> $2.run(SwingWorker.java :108)
</I>&gt;<i>     at java.lang.Thread.run(Unknown Source)
</I>&gt;<i> Caused by: java.io.WriteAbortedException: writing aborted;
</I>&gt;<i> java.io.NotSerializableException: org.apache.log4j.Logger
</I>&gt;<i>     at java.io.ObjectInputStream.readObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.defaultReadFields(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readSerialData(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readOrdinaryObject (Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readArray(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectInputStream.readObject(Unknown Source)
</I>&gt;<i>     at sun.rmi.server.UnicastRef.unmarshalValue (Unknown Source)
</I>&gt;<i>     ... 6 more
</I>&gt;<i> Caused by: java.io.NotSerializableException: org.apache.log4j.Logger
</I>&gt;<i>     at java.io.ObjectOutputStream.writeObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.defaultWriteFields (Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.writeSerialData(Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.writeOrdinaryObject(Unknown Source) 
</I>&gt;<i>     at java.io.ObjectOutputStream.writeObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.writeArray(Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.writeObject0(Unknown Source)
</I>&gt;<i>     at java.io.ObjectOutputStream.writeObject (Unknown Source)
</I>&gt;<i>     at sun.rmi.server.UnicastRef.marshalValue(Unknown Source)
</I>&gt;<i>     at sun.rmi.server.UnicastServerRef.dispatch(Unknown Source) 
</I>&gt;<i>     at sun.rmi.transport.Transport$1.run(Unknown Source)
</I>&gt;<i>     at java.security.AccessController.doPrivileged(Native Method)
</I>&gt;<i>     at sun.rmi.transport.Transport.serviceCall(Unknown Source)
</I>&gt;<i>     at sun.rmi.transport.tcp.TCPTransport.handleMessages (Unknown
</I>&gt;<i> Source)
</I>&gt;<i>     at sun.rmi.transport.tcp.TCPTransport$ConnectionHandler.run
</I>&gt;<i> (Unknown Source)
</I>&gt;<i>     ... 1 more
</I>&gt;<i> 
</I>&gt;<i> Pri blizsim zkoumani jsem dosel k nasledujicimu pozorovani:
</I>&gt;<i>      1. Kamen urazu je na strane klienta. &quot;Server&quot; nevykazuje zadne
</I>&gt;<i>         znamky problemu, funguje spravne, vyjimky nehazi.
</I>&gt;<i>      2. Problem nastava, jak je videt, na radku 297. Tento radek
</I>&gt;<i>         obsahuje nasledujici kod:
</I>&gt;<i>      3. Object[] init =
</I>&gt;<i>         currentDBLayer.initialize(dbinfo.getDatabaseIdentifier(),
</I>&gt;<i>         name, password);
</I>&gt;<i>      4. Jelikoz k problemum dochazi na strane klienta (volani
</I>&gt;<i>         initialize() se na strane serveru provede spravne, bezchybne a
</I>&gt;<i>         cele) a naznacuje to i vyjimka UnmarshallException (v podstate
</I>&gt;<i>         unmarshalling znamena slozeni objektu z prichoziho
</I>&gt;<i>         serializovaneho stavu) + pozorovani 1, studujme popis teto
</I>&gt;<i>         vyjimky
</I>&gt;<i> Javadoc 5.0 k tomu rika:
</I>&gt;<i> 
</I>&gt;<i> An UnmarshalException can be thrown while unmarshalling the parameters
</I>&gt;<i> or results of a remote method call if any of the following conditions
</I>&gt;<i> occur: 
</I>&gt;<i>       * if an exception occurs while unmarshalling the call header 
</I>&gt;<i>       * if the protocol for the return value is invalid 
</I>&gt;<i>       * if a java.io.IOException occurs unmarshalling parameters (on
</I>&gt;<i>         the server side) or the return value (on the client side). 
</I>&gt;<i>       * if a java.lang.ClassNotFoundException occurs during
</I>&gt;<i>         unmarshalling parameters or return values 
</I>&gt;<i>       * if no skeleton can be loaded on the server-side; note that
</I>&gt;<i>         skeletons are required in the 1.1 stub protocol, but not in
</I>&gt;<i>         the 1.2 stub protocol. 
</I>&gt;<i>       * if the method hash is invalid (i.e., missing method). 
</I>&gt;<i>       * if there is a failure to create a remote reference object for
</I>&gt;<i>         a remote object's stub when it is unmarshalled.
</I>&gt;<i> Dalsi vyjimky, ktere se objevuji jako cause:
</I>&gt;<i> 
</I>&gt;<i> WriteAbortedException
</I>&gt;<i> 
</I>&gt;<i> Signals that one of the ObjectStreamExceptions was thrown during a
</I>&gt;<i> write operation. Thrown during a read operation when one of the
</I>&gt;<i> ObjectStreamExceptions was thrown during a write operation. The
</I>&gt;<i> exception that terminated the write can be found in the detail field.
</I>&gt;<i> The stream is reset to it's initial state and all references to
</I>&gt;<i> objects already deserialized are discarded. 
</I>&gt;<i> 
</I>&gt;<i> NotSerializableException
</I>&gt;<i> 
</I>&gt;<i> Thrown when an instance is required to have a Serializable interface.
</I>&gt;<i> The serialization runtime or the class of the instance can throw this
</I>&gt;<i> exception. The argument should be the name of the class. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Posledni vyjimka, NotSerializableException, rika, ze se pokousime
</I>&gt;<i> zabalit a poslat po siti objekt, se kterym to udelat nejde. Jmeno toho
</I>&gt;<i> objektu se posila jako parametr: org.apache.log4j.Logger v nasem
</I>&gt;<i> pripade. Diky tomu dojde k vyjimce WriteAbortedException, protoze
</I>&gt;<i> jednu z odesilanych casti proste nejde zabalit a poslat po siti. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Abychom tedy zjistili, jaka tomu pricina, musime se podivat, co se nam
</I>&gt;<i> to ta metoda initialize() snazi vratit.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i>         Session sess = null;
</I>&gt;<i>         try {
</I>&gt;<i>             sessionFactory = cfg.buildSessionFactory ();
</I>&gt;<i>             sess = sessionFactory.openSession();
</I>&gt;<i>             
</I>&gt;<i>              ScrollableResults sr = sess.createCriteria(User.class)
</I>&gt;<i>                 .add(Restrictions.eq(User.LOGIN, user))
</I>&gt;<i>                 .add(Restrictions.isNull(User.DROPWHEN))
</I>&gt;<i>                 .scroll();
</I>&gt;<i>             
</I>&gt;<i>              if( ! sr.next() )
</I>&gt;<i>                   throw new DBLayerException();
</I>&gt;<i> 
</I>&gt;<i>             
</I>&gt;<i>             Object[] userinfo = sr.get();
</I>&gt;<i>             plantloreUser = (User)userinfo[0];
</I>&gt;<i>             rights = plantloreUser.getRight();
</I>&gt;<i>             logger.debug(&quot;DBLayer Initialization - finished!&quot;);
</I>&gt;<i>         } 
</I>&gt;<i>         catch (Exception e) {
</I>&gt;<i>         }
</I>&gt;<i>         finally {
</I>&gt;<i>             if(sess != null) sess.close();
</I>&gt;<i>         }
</I>&gt;<i>         
</I>&gt;<i>         // Return User and Right object with users details
</I>&gt;<i>         return new Object[] { plantloreUser, rights };
</I>&gt;<i> 
</I>&gt;<i> Vidime, ze vracime 2 neskodne holder objekty, ktere primo dedi od
</I>&gt;<i> Record, ktery je Serializable. Pole je serializovano automaticky -
</I>&gt;<i> kdyz uz to umi serializovat slozite provazane dynamicke odkazy, pole
</I>&gt;<i> to umi urcite.
</I>&gt;<i> 
</I>&gt;<i> No a prichazi million dollar question.
</I>&gt;<i> 
</I>&gt;<i> Kde se tam do **** bere logger?
</I>&gt;<i> 
</I>&gt;<i> Logger zije v ramci HibernateDBLayer samosebou na serveru. Klient ma k
</I>&gt;<i> disposici pouze HibernateDBLayer_Stub, ktery dostal ponekud slozitym
</I>&gt;<i> procesem, ktery neni nutno znat, ale provadi se v nem nekolik
</I>&gt;<i> vzdalenych volani taky (sice na jine objekty, ale provadi). Podezrele
</I>&gt;<i> je i to, ze vzdalene volani HibernateDBLayer.setLanguage() projde bez
</I>&gt;<i> potizi, zatimco HibernateDBLayer.initialize(), ktere probiha prakticky
</I>&gt;<i> v zapeti, vraci ********. 
</I>&gt;<i> 
</I>&gt;<i> Jak je tedy mozne, ze dochazi k takove podivuhodne vyjimce, kdyz
</I>&gt;<i> Logger nikdy neopusti server (a proc by taky mel?). Nikdo ho nikam
</I>&gt;<i> neposila, alespon ne v inkriminovanem nami napsanem kodu.
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Je mi to vazne lito, ale jsem ve slepe ulicce. Nemam nejmensi tuseni,
</I>&gt;<i> co ta vyjimka znamena, natoz proc k ni dochazi a tudiz uz vubec ne,
</I>&gt;<i> jak ji odstranit. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Ledaze.... ale to je divny... ledaze by plantloreUser a rights nebyly,
</I>&gt;<i> za co se vydavaji. Trestuhodne. 
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> Provedeme (zkusebne) nasledujici modifikaci:
</I>&gt;<i>    
</I>&gt;<i>         return new Record[] { /*plantloreUser, rights*/ null, null };
</I>&gt;<i> 
</I>&gt;<i> Tedy sproste nahradime hodnotne udaje zbytecnymi nully.... spojeni se
</I>&gt;<i> povede (a trebaze by to clovek ocekaval, NullPointerException se zatim
</I>&gt;<i> nekona). Neco je tedy v neporadku s plantloreUser a rights, reknete
</I>&gt;<i> si! Nedostal by clovek ale runtime exception (ClassCastException ) za
</I>&gt;<i> drzost typu: 
</I>&gt;<i> 
</I>&gt;<i>             plantloreUser = (User)userinfo[0];
</I>&gt;<i> 
</I>&gt;<i> A proc to vlastne pri lokalnim spojeni funguje? Ukazuje se, ze
</I>&gt;<i> plantloreUser i rights jsou opravdu typu User i Right. Overeni bylo
</I>&gt;<i> provedeno primo debuggerem na moje vlastni neverici oci (i pri
</I>&gt;<i> vzdalenem zavolani). Vec divna pripadla mi a neskutecna zcela, kdyz
</I>&gt;<i> bez problemu bylo do plantlore klienta natazeno hejno kytek, vesnic a
</I>&gt;<i> dalsi haveti. Takze jako pres RMI propochoduje objekt typu Plant, ale
</I>&gt;<i> User uz ne? Co chudak objekt typu User udelal, ze se RMI nelibi, boji
</I>&gt;<i> se ho, a posila misto sebe (tajne) Logger? Personifikace je samosebou
</I>&gt;<i> na miste, protoze popsane problemy nemaji se serioznim programovanim
</I>&gt;<i> co do cineni. Tohle je prosim magie nebo pohadka, kde veci vyskakujou
</I>&gt;<i> odnikud bez radneho duvodu!
</I>&gt;<i> 
</I>&gt;<i> Pripadne reseni tototo, ehm, magickeho problemu dodelam zitra -
</I>&gt;<i> potrebuji nacerpat inspiraci v knihach J.K. Rowlingove!
</I>&gt;<i> 
</I>&gt;<i> 
</I>&gt;<i> P.S.
</I>&gt;<i> Shrnuto: prestoze plantloreUser a rights skutecne jsou objekty
</I>&gt;<i> spravneho serializovatelneho typu, kdesi mezi volanim 
</I>&gt;<i> return new Record[] { plantloreUser, rights }; 
</I>&gt;<i> a vyzvednutim vysledku 
</I>&gt;<i> Record[] init =
</I>&gt;<i> currentDBLayer.initialize(dbinfo.getDatabaseIdentifier(), name,
</I>&gt;<i> password);
</I>&gt;<i> kde by spravne mel stat jenom RMI mechanismus pro serializaci,
</I>&gt;<i> transfer a opetovnou deserializaci vysledku, stoji taktez Logger,
</I>&gt;<i> ktery celou akci poctive monitoruje a zamerne sabotuje. 
</I>&gt;<i> _______________________________________________
</I>&gt;<i> Plantlore-dev mailing list
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">Plantlore-dev at lists.berlios.de</A>
</I>&gt;<i> <A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">https://lists.berlios.de/mailman/listinfo/plantlore-dev</A>
</I>

</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000833.html">[Plantlore-dev] Uvodni bitva prohrana
</A></li>
	<LI>Next message: <A HREF="000835.html">[Plantlore-dev] r598 - in trunk/src/net/sf/plantlore: client/login	common/record middleware server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#834">[ date ]</a>
              <a href="thread.html#834">[ thread ]</a>
              <a href="subject.html#834">[ subject ]</a>
              <a href="author.html#834">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
