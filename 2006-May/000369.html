<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r319 - trunk/src/net/sf/plantlore/server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-May/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r319%20-%20trunk/src/net/sf/plantlore/server&In-Reply-To=%3C200605220952.k4M9qTCY011073%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000366.html">
   <LINK REL="Next"  HREF="000370.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r319 - trunk/src/net/sf/plantlore/server</H1>
    <B>kovo at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r319%20-%20trunk/src/net/sf/plantlore/server&In-Reply-To=%3C200605220952.k4M9qTCY011073%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r319 - trunk/src/net/sf/plantlore/server">kovo at berlios.de
       </A><BR>
    <I>Mon May 22 11:52:29 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000366.html">[Plantlore-dev] r318 - in trunk/src: biocase/DataproBioCASE/configuration/querytool/skins net/sf/plantlore/client/export net/sf/plantlore/client/export/builders net/sf/plantlore/common/record
</A></li>
        <LI>Next message: <A HREF="000370.html">[Plantlore-dev] r320 - trunk/src/net/sf/plantlore/client/authors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#369">[ date ]</a>
              <a href="thread.html#369">[ thread ]</a>
              <a href="subject.html#369">[ subject ]</a>
              <a href="author.html#369">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kovo
Date: 2006-05-22 11:52:27 +0200 (Mon, 22 May 2006)
New Revision: 319

Modified:
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
New version of DBLayer with right and history. This version might not work properly and needs more testing (especially with Occurrences)

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-05-21 23:15:03 UTC (rev 318)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-05-22 09:52:27 UTC (rev 319)
@@ -39,6 +39,7 @@
 import org.hibernate.cfg.Configuration;
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
+import java.util.ArrayList;
 
 import org.hibernate.Transaction;
 import org.hibernate.criterion.Restrictions;
@@ -136,6 +137,8 @@
         }
         // TODO: this should be loaded from a configuration file on the server
         // We are temporarily using this for DB authetication and user athentication as well
+        System.out.println(&quot;USER: &quot;+user);
+        System.out.println(&quot;PASSWORD: &quot;+password); 
         cfg.setProperty(&quot;hibernate.connection.url&quot;, dbID);
         cfg.setProperty(&quot;hibernate.connection.username&quot;, user);
         cfg.setProperty(&quot;hibernate.connection.password&quot;, password);        
@@ -148,20 +151,15 @@
             ex.setError(ex.ERROR_CONNECT, null);
             throw ex;
         }   
-        
         // Authenticate user
-        try {
-            SelectQuery sq = this.createQuery(User.class);            
-            sq.addRestriction(PlantloreConstants.RESTR_EQ, User.LOGIN, null, user, null);
-            // TODO: Password should probably be encrypted
-            // sq.addRestriction(PlantloreConstants.RESTR_EQ, User.PASSWORD, null, password, null);
-            sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, User.DROPWHEN, null, null, null);
-            result = this.executeQuery(sq);
-        } catch (RemoteException e) {
-            logger.fatal(&quot;Cannot load user information. Details: &quot;+e.getMessage());            
-        }
-        Object[] userinfo = next(result);
-        if (userinfo == null) {
+        Session sess = sessionFactory.openSession();            
+        // TODO: Password should probably be encrypted            
+        ScrollableResults sr = sess.createCriteria(User.class)
+            .add(Restrictions.eq(User.LOGIN, user))
+            .add(Restrictions.eq(User.PASSWORD, password))
+            .add(Restrictions.isNull(User.DROPWHEN))
+            .scroll();
+        if (!sr.next()) {
             // Authentication failed, close DB connection
             sessionFactory.close();
             sessionFactory = null;
@@ -170,6 +168,7 @@
             ex.setError(ex.ERROR_LOGIN, null);
             throw ex;
         } else {
+            Object[] userinfo = sr.get();
             User clientUser = (User)userinfo[0];            
             this.rights = clientUser.getRight();           
             this.plantloreUser = clientUser;
@@ -214,16 +213,20 @@
             Author aut = (Author)data;
             aut.setCreatedWho(this.plantloreUser);
             data = aut;
-        }        
+        }
+        // Check whether we have sufficient rights
+        checkRights(data, INSERT);
         Session session = sessionFactory.openSession();
         Transaction tx = null;                
         try {
             // Begin transaction
             tx = session.beginTransaction();            
             // Save item into the database
+            if (data instanceof Habitat)
+            System.out.println(&quot;HABITAT ID: &quot;+((Habitat)data).getId());
             recordId = (Integer)session.save(data);            
             // Save data to history tables - only for selected tables
-            // this.saveHistory(session, data, INSERT, recordId);
+            // saveHistory(session, data, INSERT, recordId);
             // Commit transaction
             tx.commit();                                      
         } catch (HibernateException e) {
@@ -273,6 +276,8 @@
             aut.setCreatedWho(this.plantloreUser);
             data = aut;
         }
+        // Check whether we have sufficient rights
+        checkRights(data, INSERT);        
         Session session = sessionFactory.openSession();
         Transaction tx = null;        
         try {
@@ -316,64 +321,10 @@
         }
         Session session = sessionFactory.openSession();        
         Transaction tx = null;
-        // Save records to history if required
-        try {        
-            if ((data instanceof Publication) || (data instanceof Author) || (data instanceof Occurrence)) {
-                HistoryChange historyChange = new HistoryChange();
-                if (data instanceof Occurrence) {
-                    historyChange.setOccurrence((Occurrence)data);
-                    historyChange.setRecordId(0);
-                    table = PlantloreConstants.ENTITY_OCCURRENCE;
-                } else {
-                    historyChange.setOccurrence(null);
-                    if (data instanceof Publication) {
-                        id = ((Publication)data).getId();
-                        table = PlantloreConstants.ENTITY_PUBLICATION;
-                    } else if (data instanceof Author) {
-                        id = ((Author)data).getId();
-                        table = PlantloreConstants.ENTITY_AUTHOR;                        
-                    } else {
-                        id = 0;
-                        table = &quot;&quot;;
-                    }
-                    historyChange.setRecordId(id);
-                }
-                historyChange.setOldRecordId(0);
-                historyChange.setOperation(PlantloreConstants.DELETE);
-                historyChange.setWho(this.plantloreUser);
-                historyChange.setWhen(new java.util.Date());
-                
-                // Load record from THistoryColumn table
-                try {
-                    SelectQuery sq = this.createQuery(HistoryColumn.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
-                    sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
-                    result = this.executeQuery(sq);
-                } catch (RemoteException e) {
-                    logger.fatal(&quot;Cannot load HistoryChange information. Details: &quot;+e.getMessage());
-                }
-                Object[] objCol = next(result);
-                if (objCol == null) {                
-                    logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
-                    DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
-                    ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_HISTORYCOLUMN);
-                    throw ex;
-                } else {
-                    column = (HistoryColumn)objCol[0];
-                }                
-                HistoryRecord history = new HistoryRecord();
-                history.setHistoryChange(historyChange);
-                history.setHistoryColumn(column);
-                history.setNewValue(null);
-                history.setOldValue(null);
-                // Save into the database
-                session.save(historyChange);
-                session.save(history);                
-            }        
-            // Save the data itself
+        try {
             tx = session.beginTransaction();
-            // Save item into the database
-            session.delete(data);
+            // Update the item in the database
+            session.update(data);
             // Commit transaction
             tx.commit();                                      
         } catch (HibernateException e) {
@@ -447,44 +398,14 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        // Check whether we have sufficient rights
+        checkRights(data, UPDATE);        
         Session session = sessionFactory.openSession();
         Transaction tx = null;        
         try {
             tx = session.beginTransaction();            
-/*            
-            // Save data into history tables if required
-            if ((data instanceof Occurrence) || (data instanceof Author) ||
-                (data instanceof Publication) || (data instanceof Territory) ||
-                (data instanceof Village) || (data instanceof Phytochorion)) {
-                
-                HistoryChange historyChange = new HistoryChange();            
-                historyChange.setOperation(PlantloreConstants.UPDATE);
-                historyChange.setWhen(new java.util.Date());
-                historyChange.setWho(this.plantloreUser);
-                if (data instanceof Occurrence) {
-                    historyChange.setOccurrence((Occurrence)data);
-                    
-                    id = ((Publication)data).getId();                    
-                } else {
-                    historyChange.setOccurrence(null);
-                    historyChange.setOldRecordId(0);
-                    if (data instanceof Publication) {
-                        id = ((Publication)data).getId();
-                    } else if (data instanceof Author) {
-                        id = ((Author)data).getId();
-                    } else if (data instanceof Territory) {
-                        id = ((Territory)data).getId();                        
-                    } else if (data instanceof Village) {
-                        id = ((Village)data).getId();
-                    } else if (data instanceof Phytochorion) {
-                        id = ((Phytochorion)data).getId();
-                    } else {
-                        id = 0;
-                    }
-                    historyChange.setRecordId(id);
-                }                
-            }
-*/            
+            // Save records into the history
+            saveHistory(session, data, UPDATE, null);            
             // Save item into the database
             session.update(data);
             // Commit transaction
@@ -523,6 +444,8 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }        
+        // Check whether we have sufficient rights
+        checkRights(data, UPDATE);                
         Session session = sessionFactory.openSession();
         Transaction tx = null;
         try {
@@ -588,9 +511,7 @@
         Object[] data = new Object[to-from+1];
         // Read all the selected rows
         try {
-            System.out.println(&quot;to-from = &quot;+(to-from));
             for (int i=0; i&lt;=(to-from); i++) {
-                logger.debug(&quot;About to get result number &quot;+i);
                 if (res.next()) {
                     data[i] = res.get();
                 } else {
@@ -640,17 +561,26 @@
      *  @return number of rows in the given result
      */
     public int getNumRows(int resultId) throws RemoteException {
-        int numRows;
-            
         // Get results for the given resultId
-        ScrollableResults res = results.get(resultId);        
-        int currentRow = res.getRowNumber();        
-        res.afterLast();
-        if (res.getRowNumber() != currentRow) {
-            numRows = res.getRowNumber();
+        ScrollableResults res = results.get(resultId);
+        // Get the current row in the results
+        int currentRow = res.getRowNumber();
+        // Go to the first row of the results        
+        boolean hasResults = res.first();
+        if (hasResults == false) {
+            return 0;
+        }
+        int first = res.getRowNumber();
+        // Go to the last row of the results
+        res.last();
+        int last = res.getRowNumber();        
+        // Find out the number of rows between the and the last row
+        int numRows = last - first + 1;
+        // Return the pointer to it's original position
+        if (currentRow == -1) {
+            res.beforeFirst();
+        } else {
             res.setRowNumber(currentRow);
-        } else {
-            numRows = 0;
         }
         return numRows;
     }
@@ -947,7 +877,7 @@
                     .add(Restrictions.eq(Author.ID, ((Author)data).getId()))
                     .scroll();
                 // If we haven't found the author in the database, raise exception
-                if (sc.next()) {
+                if (!sc.next()) {
                     logger.error(&quot;To-be-updated/deleted author not found in the database. Author ID:&quot;+((Author)data).getId());
                     ex = new DBLayerException(&quot;To-be-updated/deleted author not found in the database. Author ID:&quot;+((Author)data).getId());
                     ex.setError(ex.ERROR_OTHER, null);
@@ -965,14 +895,15 @@
                     equal = true;
                 }
                 // Then check for indirect (group) ownership
-                String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
-                String strId;
-                for (int i=0;i&lt;group.length;i++) {
-                    strId = this.plantloreUser.getId().toString();
-                    if (strId.equals(group[i])) {
-                        equal = true;
-                        break;
-                    }
+                if (this.rights.getEditGroup() != null) {
+                    String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
+                    String strId = aut.getCreatedWho().getId().toString();
+                    for (int i=0;i&lt;group.length;i++) {
+                        if (strId.equals(group[i])) {
+                            equal = true;
+                            break;
+                        }
+                    }                    
                 }
                 if (equal == false) {
                     logger.warn(&quot;User doesn't have sufficient rights for this operation. Entity: &quot;+PlantloreConstants.ENTITY_AUTHOR);
@@ -1041,6 +972,7 @@
                 throw ex;                            
             } else if (type == DELETE) {
                 // Tu to bude zlozitejsie...
+                // TODO
             }           
         }        
         // Check rights for table TPUBLICATIONS
@@ -1052,7 +984,7 @@
                     .add(Restrictions.eq(Publication.ID, ((Publication)data).getId()))
                     .scroll();
                 // If we haven't found the publication in the database, raise exception
-                if (sc.next()) {
+                if (!sc.next()) {
                     logger.error(&quot;To-be-updated/deleted publication not found in the database. Publication ID:&quot;+((Publication)data).getId());
                     ex = new DBLayerException(&quot;To-be-updated/deleted publication not found in the database. Publication ID:&quot;+((Publication)data).getId());
                     ex.setError(ex.ERROR_OTHER, null);
@@ -1070,13 +1002,14 @@
                     equal = true;
                 }                
                 // Then check for indirect (group) ownership
-                String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
-                String strId;
-                for (int i=0;i&lt;group.length;i++) {
-                    strId = this.plantloreUser.getId().toString();
-                    if (strId.equals(group[i])) {
-                        equal = true;
-                        break;
+                if (this.rights.getEditGroup() != null) {                
+                    String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
+                    String strId = pub.getCreatedWho().getId().toString();
+                    for (int i=0;i&lt;group.length;i++) {
+                        if (strId.equals(group[i])) {
+                            equal = true;
+                            break;
+                        }
                     }
                 }
                 if (equal == false) {
@@ -1105,7 +1038,7 @@
                     .add(Restrictions.eq(Occurrence.ID, ((Occurrence)data).getId()))
                     .scroll();
                 // If we haven't found the occurrence in the database, raise exception
-                if (sc.next()) {
+                if (!sc.next()) {
                     logger.error(&quot;To-be-updated/deleted occurrence not found in the database. Occurrence ID:&quot;+((Publication)data).getId());
                     ex = new DBLayerException(&quot;To-be-updated/deleted occurrence not found in the database. Occurrence ID:&quot;+((Publication)data).getId());
                     ex.setError(ex.ERROR_OTHER, null);
@@ -1123,13 +1056,14 @@
                     equal = true;
                 }
                 // Then check for indirect (group) ownership
-                String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
-                String strId;
-                for (int i=0;i&lt;group.length;i++) {
-                    strId = this.plantloreUser.getId().toString();
-                    if (strId.equals(group[i])) {
-                        equal = true;
-                        break;
+                if (this.rights.getEditGroup() != null) {                
+                    String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
+                    String strId = occ.getCreatedWho().getId().toString();
+                    for (int i=0;i&lt;group.length;i++) {
+                        if (strId.equals(group[i])) {
+                            equal = true;
+                            break;
+                        }
                     }
                 }
                 if (equal == false) {
@@ -1154,11 +1088,11 @@
             if ((type == DELETE) || (type == UPDATE)) {
                 // Only data of the user and those listed in CEDITGROUP
                 sess = this.sessionFactory.openSession();
-                ScrollableResults sc = sess.createCriteria(Occurrence.class)
-                    .add(Restrictions.eq(Occurrence.ID, ((Habitat)data).getId()))
+                ScrollableResults sc = sess.createCriteria(Habitat.class)
+                    .add(Restrictions.eq(Habitat.ID, ((Habitat)data).getId()))
                     .scroll();
-                // If we haven't found the occurrence in the database, raise exception
-                if (sc.next()) {
+                // If we haven't found the habitat in the database, raise exception
+                if (!sc.next()) {
                     logger.error(&quot;To-be-updated/deleted habitat not found in the database. Occurrence ID:&quot;+((Habitat)data).getId());
                     ex = new DBLayerException(&quot;To-be-updated/deleted habitat not found in the database. Occurrence ID:&quot;+((Habitat)data).getId());
                     ex.setError(ex.ERROR_OTHER, null);
@@ -1167,25 +1101,36 @@
                 Object[] res = sc.get();
                 Habitat hab = (Habitat)res[0];
                 boolean equal = false;
-                // Check for direct ownership first                
-                // TODO - FINISH
-                /*
-                if (hab.getCreatedWho().equals(this.plantloreUser))) {
+                // Check for direct ownership first. Find owner of associated occurrence
+                sc = sess.createCriteria(Occurrence.class)
+                    .add(Restrictions.eq(Occurrence.HABITAT, hab.getId()))
+                    .scroll();
+                // If no occurrence was found
+                if (!sc.next()) {
+                    logger.error(&quot;No occurrence references selected habitat. Habitat ID:&quot;+hab.getId());
+                    ex = new DBLayerException(&quot;No occurrence references selected habitat. Habitat ID:&quot;+hab.getId());
+                    ex.setError(ex.ERROR_DB, null);
+                    throw ex;                          
+                }                
+                res = sc.get();
+                Occurrence occ = (Occurrence)res[0];
+                if (occ.getCreatedWho().equals(this.plantloreUser)) {
                     equal = true;
-                }
-                 */
+                }                
                 // Check for administrator rights
+                // TODO: This should be done at the beginning to save one query if the user is admin
                 if (this.plantloreUser.getRight().getAdministrator() == 1) {
                     equal = true;
                 }
                 // Then check for indirect (group) ownership
-                String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
-                String strId;
-                for (int i=0;i&lt;group.length;i++) {
-                    strId = this.plantloreUser.getId().toString();
-                    if (strId.equals(group[i])) {
-                        equal = true;
-                        break;
+                if (this.rights.getEditGroup() != null) {                
+                    String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
+                    String strId = occ.getCreatedWho().getId().toString();
+                    for (int i=0;i&lt;group.length;i++) {
+                        if (strId.equals(group[i])) {
+                            equal = true;
+                            break;
+                        }
                     }
                 }
                 if (equal == false) {
@@ -1214,7 +1159,7 @@
                     .add(Restrictions.eq(AuthorOccurrence.ID, ((AuthorOccurrence)data).getId()))
                     .scroll();
                 // If we haven't found the occurrence in the database, raise exception
-                if (sc.next()) {
+                if (!sc.next()) {
                     logger.error(&quot;To-be-updated/deleted authoroccurrence not found in the database. Occurrence ID:&quot;+((AuthorOccurrence)data).getId());
                     ex = new DBLayerException(&quot;To-be-updated/deleted authoroccurrence not found in the database. Occurrence ID:&quot;+((AuthorOccurrence)data).getId());
                     ex.setError(ex.ERROR_OTHER, null);
@@ -1228,17 +1173,19 @@
                     equal = true;
                 }
                 // Check for administrator rights
+                // TODO: This should be done at the beginning to save one query
                 if (this.plantloreUser.getRight().getAdministrator() == 1) {
                     equal = true;
                 }
                 // Then check for indirect (group) ownership
-                String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
-                String strId;
-                for (int i=0;i&lt;group.length;i++) {
-                    strId = this.plantloreUser.getId().toString();
-                    if (strId.equals(group[i])) {
-                        equal = true;
-                        break;
+                if (this.rights.getEditGroup() != null) {                
+                    String[] group = this.rights.getEditGroup().split(&quot;,&quot;);
+                    String strId = ao.getOccurrence().getCreatedWho().getId().toString();
+                    for (int i=0;i&lt;group.length;i++) {
+                        if (strId.equals(group[i])) {
+                            equal = true;
+                            break;
+                        }
                     }
                 }
                 if (equal == false) {
@@ -1262,70 +1209,392 @@
     
     private void saveHistory(Session sess, Object data, int type, Integer recordId) throws DBLayerException {
         String table;
-        Integer result = 0;
+        Integer id, result = 0;
         HistoryColumn column;
         Integer recId;
         Object[] objCol = null;
-        
+        String tableId = &quot;&quot;;
+        Class updated = null;
+        Integer updatedId = null;
+
+        // Update tMetaData.cDateModified for any operation on Occurrences and Habitats
+        if ((data instanceof Occurrence) || (data instanceof Habitat)) {
+            ScrollableResults sr;
+            if (data instanceof Occurrence) {
+                // Read the associated metadata
+                sr = sess.createCriteria(Occurrence.class)
+                    .add(Restrictions.eq(Occurrence.ID, ((Occurrence)data).getId()))
+                    .scroll();
+            } else {
+                // Read the associated occurrence and metadata
+                sr = sess.createCriteria(Occurrence.class)
+                    .add(Restrictions.eq(Occurrence.HABITAT, ((Habitat)data).getId()))
+                    .scroll();                    
+             }
+            if (!sr.next()) {
+                logger.error(&quot;Occurrence record for the given Metadata not found&quot;);
+                DBLayerException ex = new DBLayerException(&quot;Occurrence record for the given Metadata not found&quot;);
+                ex.setError(ex.ERROR_OTHER, null);
+                throw ex;                    
+            }
+            Object[] res = sr.get();
+            Occurrence occ = (Occurrence)res[0];
+            occ.getMetadata().setDateModified(new java.util.Date());
+            sess.update(occ.getMetadata());
+        }
+        // Saving history when new record is inserted
         if (type == INSERT) {
-            if ((data instanceof Publication) || (data instanceof Author) ||
-                (data instanceof Occurrence)) {
-                HistoryChange historyChange = new HistoryChange();
-                if (data instanceof Occurrence) {
-                    historyChange.setOccurrence((Occurrence)data);
-                    historyChange.setRecordId(0);
-                    table = PlantloreConstants.ENTITY_OCCURRENCE;
+            HistoryChange historyChange = new HistoryChange();            
+            if (data instanceof Occurrence) {
+                historyChange.setOccurrence((Occurrence)data);
+                historyChange.setRecordId(0);
+                table = PlantloreConstants.ENTITY_OCCURRENCE;
+            } else {
+                historyChange.setOccurrence(null);
+                if (data instanceof Publication) {
+                    table = PlantloreConstants.ENTITY_PUBLICATION;
+                } else if (data instanceof Author) {
+                    table = PlantloreConstants.ENTITY_AUTHOR;                        
+                } else if (data instanceof Phytochorion) {
+                    table = PlantloreConstants.ENTITY_PHYTOCHORION;                        
+                } else if (data instanceof Village) {
+                    table = PlantloreConstants.ENTITY_VILLAGE;
+                } else if (data instanceof Territory) {
+                    table = PlantloreConstants.ENTITY_TERRITORY;                        
                 } else {
-                    historyChange.setOccurrence(null);
-                    if (data instanceof Publication) {
-                        table = PlantloreConstants.ENTITY_PUBLICATION;
-                    } else if (data instanceof Author) {
-                        table = PlantloreConstants.ENTITY_AUTHOR;                        
-                    } else {
-                        table = &quot;&quot;;
+                    return;
+                }
+                historyChange.setRecordId(recordId);
+            }
+            historyChange.setOldRecordId(0);
+            historyChange.setOperation(PlantloreConstants.INSERT);
+            historyChange.setWho(this.plantloreUser);
+            historyChange.setWhen(new java.util.Date());
+            // Load record from THistoryColumn table
+            try {
+                SelectQuery sq = this.createQuery(HistoryColumn.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
+                sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
+                result = this.executeQuery(sq);
+                objCol = next(result);                
+            } catch (RemoteException e) {
+                logger.error(&quot;Remote exception caught in DBLayer. This should never happen. Details: &quot;+e.getMessage());
+            }
+            if (objCol == null) {                
+                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_HISTORYCOLUMN);
+                throw ex;
+            } else {
+                column = (HistoryColumn)objCol[0];
+            }                
+            HistoryRecord history = new HistoryRecord();
+            history.setHistoryColumn(column);
+            history.setNewValue(null);
+            history.setOldValue(null);
+            // Save into the database
+            recId = (Integer)sess.save(historyChange);
+            history.setHistoryChange(historyChange);                
+            recId = (Integer)sess.save(history);                
+        }
+        // Saving history when new record is inserted        
+        if (type == UPDATE){            
+            HistoryChange historyChange = new HistoryChange();                        
+            if ((data instanceof Author) || (data instanceof Publication) ||
+                (data instanceof Territory) || (data instanceof Phytochorion) ||
+                (data instanceof Village)) {            
+                historyChange.setOccurrence(null);
+                historyChange.setOldRecordId(0);                
+                historyChange.setOperation(PlantloreConstants.UPDATE);
+                historyChange.setWhen(new java.util.Date());
+                historyChange.setWho(this.plantloreUser);
+                if (data instanceof Author) {
+                    updated = Author.class;
+                    updatedId = ((Author)data).getId();
+                    tableId = Author.ID;                    
+                    historyChange.setRecordId(((Author)data).getId());
+                } else
+                if (data instanceof Publication) {
+                    updated = Publication.class;
+                    updatedId = ((Publication)data).getId();                    
+                    tableId = Publication.ID;                    
+                    historyChange.setRecordId(((Publication)data).getId());                    
+                } else
+                if (data instanceof Territory) {
+                    updated = Territory.class;
+                    updatedId = ((Territory)data).getId();                    
+                    tableId = Territory.ID;
+                    historyChange.setRecordId(((Territory)data).getId());                    
+                } else
+                if (data instanceof Phytochorion) {
+                    updated = Phytochorion.class;
+                    updatedId = ((Phytochorion)data).getId();                    
+                    tableId = Phytochorion.ID;
+                    historyChange.setRecordId(((Phytochorion)data).getId());                    
+                } else
+                if (data instanceof Village) {
+                    updated = Village.class;
+                    updatedId = ((Village)data).getId();
+                    tableId = Village.ID;
+                    historyChange.setRecordId(((Village)data).getId());                    
+                }                    
+                // Save the HistoryChange object
+                sess.save(historyChange);
+                // Read the to-be-updated object
+                Session tempSess = this.sessionFactory.openSession(); 
+                ScrollableResults res = tempSess.createCriteria(updated)
+                    .add(Restrictions.eq(tableId, updatedId))
+                    .scroll();
+                if (!res.next()) {
+                    logger.error(&quot;To-be-updated record was not found in the database. Type: &quot;+updated.getName()+&quot; ID:&quot;+updatedId);
+                    DBLayerException ex = new DBLayerException(&quot;To-be-updated record was not found in the database. Type: &quot;+updated.getName()+&quot; ID:&quot;+updatedId);
+                    ex.setError(ex.ERROR_UPDATE, updated.getName());
+                    throw ex;
+                }
+                Object[] original = res.get();
+                tempSess.close();
+                // Object origRec, newRec;
+                if (data instanceof Author) {
+                    Author origRec = (Author)original[0];
+                    Author newRec = (Author)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i&lt;cols.size();i++) {
+                        if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                            // Read record from THISTORYCOLUMN first                            
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_AUTHOR))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_AUTHOR);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Save record into THISTORY
+                            HistoryRecord hist = new HistoryRecord();
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            sess.save(hist);                            
+                        }
                     }
-                    historyChange.setRecordId(recordId);
+                } else if (data instanceof Publication) {
+                    Publication origRec = (Publication)original[0];                    
+                    Publication newRec = (Publication)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i&lt;cols.size();i++) {
+                        if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                            // Read record from THISTORYCOLUMN first
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_PUBLICATION))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_PUBLICATION);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Save record into THISTORY
+                            HistoryRecord hist = new HistoryRecord();
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            sess.save(hist);                            
+                        }
+                    }
+                } else if (data instanceof Territory) {
+                    Territory origRec = (Territory)original[0];                    
+                    Territory newRec = (Territory)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i&lt;cols.size();i++) {
+                        if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                            // Read record from THISTORYCOLUMN first
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_TERRITORY))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_TERRITORY);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Save record into THISTORY
+                            HistoryRecord hist = new HistoryRecord();
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            sess.save(hist);                            
+                        }
+                    }
+                } else if (data instanceof Phytochorion) {
+                    Phytochorion origRec = (Phytochorion)original[0];                    
+                    Phytochorion newRec = (Phytochorion)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i&lt;cols.size();i++) {
+                        if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                            // Read record from THISTORYCOLUMN first
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_PHYTOCHORION))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_PHYTOCHORION);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Save record into THISTORY
+                            HistoryRecord hist = new HistoryRecord();
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            sess.save(hist);
+                        }
+                    }
+                } else if (data instanceof Village) {
+                    Village origRec = (Village)original[0];                    
+                    Village newRec = (Village)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i&lt;cols.size();i++) {
+                        if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                            // Read record from THISTORYCOLUMN first
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_VILLAGE))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_VILLAGE);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Save record into THISTORY
+                            HistoryRecord hist = new HistoryRecord();
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            sess.save(hist);
+                        }
+                    }
                 }
-                historyChange.setOldRecordId(0);
-                historyChange.setOperation(PlantloreConstants.INSERT);
-                historyChange.setWho(this.plantloreUser);
+            }
+            if (data instanceof Occurrence) {
+                historyChange.setOccurrence((Occurrence)data);
+                historyChange.setRecordId(((Occurrence)data).getId());
+                historyChange.setOperation(PlantloreConstants.UPDATE);
                 historyChange.setWhen(new java.util.Date());
-                
-                // Load record from THistoryColumn table
-                try {
-                    SelectQuery sq = this.createQuery(HistoryColumn.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
-                    sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
-                    result = this.executeQuery(sq);
-                } catch (RemoteException e) {
-                    logger.fatal(&quot;Cannot load HistoryChange information. Details: &quot;+e.getMessage());
+                historyChange.setWho(this.plantloreUser);                
+                // Read the original occurrence
+                ScrollableResults res = sess.createCriteria(Occurrence.class)
+                    .add(Restrictions.eq(Occurrence.ID, ((Occurrence)data).getId()))
+                    .scroll();
+                if (!res.next()) {
+                    logger.error(&quot;To-be-updated Occurrence was not found in the database. ID:&quot;+((Occurrence)data).getId());
+                    DBLayerException ex = new DBLayerException(&quot;To-be-updated Occurrence was not found in the database. ID:&quot;+((Occurrence)data).getId());
+                    ex.setError(ex.ERROR_UPDATE, Occurrence.class.getName());
+                    throw ex;
                 }
-                try {
-                    objCol = next(result);
-                } catch (RemoteException e) {
-                                        
+                Object[] original = res.get();
+                Occurrence origRec = (Occurrence)original[0];
+                Occurrence newRec = (Occurrence)data;
+                ArrayList cols = (ArrayList)origRec.getColumns();
+                for (int i=0;i&lt;cols.size();i++) {
+                    if (!origRec.getValue((String)cols.get(i)).equals(newRec.getValue((String)cols.get(i)))) {
+                        // Read record from THISTORYCOLUMN first
+                        res = sess.createCriteria(HistoryColumn.class)
+                            .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_OCCURRENCE))
+                            .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                            .scroll();
+                        if (!res.next()) {
+                            logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                            DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                            ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_OCCURRENCE);
+                            throw ex;                                
+                        }
+                        Object[] colNames = res.get();
+                        // Save OldRecordId if neccessary
+                        if ((((String)cols.get(i)).equals(Occurrence.PLANT)) || (((String)cols.get(i)).equals(Occurrence.PUBLICATION))) {
+                            historyChange.setOldRecordId((Integer)newRec.getValue((String)cols.get(i)));
+                        }
+                        // Save record into THISTORY
+                        HistoryRecord hist = new HistoryRecord();
+                        hist.setHistoryChange(historyChange);
+                        hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
+                        hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
+                        hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                        sess.save(hist);
+                    }
                 }
-                if (objCol == null) {                
-                    logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
-                    DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
-                    ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_HISTORYCOLUMN);
-                    throw ex;
+                // Save the historyChange
+                sess.save(historyChange);
+            }
+        }
+        // Saving history when record is deleted
+        if (type == DELETE) {
+            HistoryChange historyChange = new HistoryChange();
+            if (data instanceof Occurrence) {
+                historyChange.setOccurrence((Occurrence)data);
+                historyChange.setRecordId(0);
+                table = PlantloreConstants.ENTITY_OCCURRENCE;
+            } else {
+                historyChange.setOccurrence(null);
+                if (data instanceof Publication) {
+                    id = ((Publication)data).getId();
+                    table = PlantloreConstants.ENTITY_PUBLICATION;
+                } else if (data instanceof Author) {
+                    id = ((Author)data).getId();
+                    table = PlantloreConstants.ENTITY_AUTHOR;                        
                 } else {
-                    column = (HistoryColumn)objCol[0];
-                }                
-                HistoryRecord history = new HistoryRecord();
-                history.setHistoryColumn(column);
-                history.setNewValue(null);
-                history.setOldValue(null);
-                // Save into the database
-                recId = (Integer)sess.save(historyChange);
-                history.setHistoryChange(historyChange);                
-                recId = (Integer)sess.save(history);                
-            }            
-        }
-        if (type == UPDATE){
-            
-        }
+                    id = 0;
+                    table = &quot;&quot;;
+                }
+                historyChange.setRecordId(id);
+            }
+            historyChange.setOldRecordId(0);
+            historyChange.setOperation(PlantloreConstants.DELETE);
+            historyChange.setWho(this.plantloreUser);
+            historyChange.setWhen(new java.util.Date());
+
+            // Load record from THistoryColumn table
+            try {
+                SelectQuery sq = this.createQuery(HistoryColumn.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
+                sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
+                result = this.executeQuery(sq);
+                objCol = next(result);                
+            } catch (RemoteException e) {
+                logger.error(&quot;Remote exception caught in DBLayer. This should never happen. Details: &quot;+e.getMessage());
+            }
+            if (objCol == null) {                
+                logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                DBLayerException ex = new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);
+                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_HISTORYCOLUMN);
+                throw ex;
+            } else {
+                column = (HistoryColumn)objCol[0];
+            }                
+            HistoryRecord history = new HistoryRecord();
+            history.setHistoryChange(historyChange);
+            history.setHistoryColumn(column);
+            history.setNewValue(null);
+            history.setOldValue(null);
+            // Save into the database
+            sess.save(historyChange);
+            sess.save(history);           
+        }    
     }
     
     


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000366.html">[Plantlore-dev] r318 - in trunk/src: biocase/DataproBioCASE/configuration/querytool/skins net/sf/plantlore/client/export net/sf/plantlore/client/export/builders net/sf/plantlore/common/record
</A></li>
	<LI>Next message: <A HREF="000370.html">[Plantlore-dev] r320 - trunk/src/net/sf/plantlore/client/authors
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#369">[ date ]</a>
              <a href="thread.html#369">[ thread ]</a>
              <a href="subject.html#369">[ subject ]</a>
              <a href="author.html#369">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
