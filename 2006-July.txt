From Lada at mail.berlios.de  Thu Jul 13 15:45:50 2006
From: Lada at mail.berlios.de (Lada at mail.berlios.de)
Date: Thu, 13 Jul 2006 15:45:50 +0200
Subject: [Plantlore-dev] r466 - in trunk: analysis/database
	src/net/sf/plantlore/client/history
	src/net/sf/plantlore/common/record
	src/net/sf/plantlore/config/hibernate src/net/sf/plantlore/server
Message-ID: <200607131345.k6DDjooq011605@sheep.berlios.de>

Author: Lada
Date: 2006-07-13 15:45:46 +0200 (Thu, 13 Jul 2006)
New Revision: 466

Modified:
   trunk/analysis/database/UkladaniHistorie.odt
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
   trunk/src/net/sf/plantlore/common/record/AuthorOccurrence.java
   trunk/src/net/sf/plantlore/common/record/HistoryChange.java
   trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
HibernateDBLayer.java - fix saving history (function saveHistory). Saving history is correct now and it is prepared for three types of history ( history of Occurrence = data from table tOccurrences + tAuthorOccurrence, history of habitat = data from table tHabitats, whole history ). Form more information about saving history you can read UkladaniHistorie.odt.
Same changes in database were neccessary (Add new data to table tHistoryColumn, delete column cOccurrenceId from table tHistoryChanges).


Modified: trunk/analysis/database/UkladaniHistorie.odt
===================================================================
(Binary files differ)

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-13 13:45:46 UTC (rev 466)
@@ -103,7 +103,7 @@
     /** Operation whitch was used*/   
     private int operation;
     /** Date and time when the reccord was changed*/
-    private java.util.Date when = new Date();	
+    private java.util.Date when = null;	
     /** Old value of attribute*/    
     private String oldValue;
     /** New value of attribute*/
@@ -202,29 +202,34 @@
             
        // Create new Select query
        SelectQuery query = null;
+       int resultIdInsert = 0;
+       Object[] object = null;
+       
        try {
        	    query = database.createQuery(HistoryChange.class);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.OCCURRENCE, null, occurrence, null);
+       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.RECORDID, null, occurrenceId, null);
        	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.OPERATION, null, HistoryChange.HISTORYCHANGE_INSERT, null);
+       	    resultIdInsert = database.executeQuery(query);
+       	    object = database.next(resultIdInsert);
+       	    database.closeQuery(query);
        } catch(RemoteException e) {
        	    System.err.println("RemoteException- searchInsertInfo(), createQuery");       	  
        } catch(DBLayerException e) {
        	    System.err.println("DBLayerException - searchInsertInfo(), createQuery");
        }            
-       
-       int resultIdInsert = 0;
-       try {
-           // Execute query                    
-           resultIdInsert = database.executeQuery(query); 
-           // Save "insert" history data
-           setInsertResult(resultIdInsert);
-           database.closeQuery(query);           
-       } catch (DBLayerException e) {
-           // Log and set an error                   
-           logger.error("Searching history data with condition 'operation = insert' failed. Unable to execute search query.");          
-       } catch (RemoteException e) {		 
-    	   System.err.println("RemoteException- searchInsertInfo(), executeQuery");
+        
+       if (object == null) {
+    	   logger.error("tHistoryChange doesn't contain required data");
+       } else {
+    	   //TODO: INFORMACE O INSERTU NALEZU BY SE DALY ZJISKAT Z TABULKY TOCCURRENCE - TO BUDE I LEPSI 
+    	   setWhen(((HistoryChange)object[0]).getWhen());
+           setNameUser(((HistoryChange)object[0]).getWho().getWholeName());
+           // TOTO BUDE LEPSI 
+           setWhen(occurrence.getCreatedWhen());
+           setNameUser(occurrence.getCreatedWho().getWholeName());
+          
        }
+       
     }
     
     
@@ -245,7 +250,7 @@
 	        query.createAlias("historyChange", "hc");        
 	        // Add restriction to COPERATION column of tJistoryChange table
 	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.operation", null, HistoryChange.HISTORYCHANGE_EDIT, null);        
-	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.occurrence", null, occurrence, null);    	
+	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.recordId", null, occurrence.getId(), null);    	
 	        query.addOrder(PlantloreConstants.DIRECT_DESC, "hc.when");
 	} catch (RemoteException e) {
 		System.err.println("RemoteException - searchEditHistory(), createQuery");
@@ -269,35 +274,7 @@
         //zde nejde zavrit session closeQuery
     }
     
-    
-    /**     
-     * Sets information about data (date, name of user) entries concerned with specified occurrence 
-     * @param result result of a database operation INSERT. Result has one row.
-     */
-    public void setInsertResult(int resultIdInsert) {
-   	    	
-    	if (getResultRows() > 1) {                
-            logger.error("Too many results for searching insert operation.");  
-    	}
-            	
-    	logger.debug("Retrieving query results."); 
-    	Object[] objectHistory = null;
-        try {
-        	 // Retrieve selected row interval         	
-         	try {
-         		objectHistory = database.more(resultIdInsert, 0, 0);  
-         	} catch(RemoteException e) {             	
-             	logger.debug("RemoteException- setInsertResult, more");
-             	return;
-             }   
-         	Object[] objHis = (Object[])objectHistory[0];                 
-         	setWhen(((HistoryChange)objHis[0]).getWhen());
-         	setNameUser(((HistoryChange)objHis[0]).getWho().getWholeName());         	
-        } catch (DBLayerException e) {         
-            logger.error("Processing search (inserting) results failed: "+e.toString());            
-        }       
-    }
-    
+       
     /**
      *
      */
@@ -573,7 +550,7 @@
         Object[] object = searchObject("AuthorOccurrence", recordId);
         AuthorOccurrence authorOccurrence = (AuthorOccurrence)object[0];  
         
-        occurrenceId = historyChange.getOccurrence().getId();	
+        occurrenceId = historyChange.getRecordId();	
         
         //test, zda jiz dany zaznam byl editovan
         boolean objectList = editObjectList.contains((Record)authorOccurrence); 
@@ -621,8 +598,10 @@
     public void undoOccurrence() {
         
         //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
-        occurrence = historyChange.getOccurrence();           
-        occurrenceId = historyChange.getOccurrence().getId();	
+    	occurrenceId = historyChange.getRecordId();
+    	//Select record Occurrence where id = occurrenceId 
+        Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+        occurrence = (Occurrence)objectOcc[0];                           	
         
         boolean objectList = editObjectList.contains((Record)occurrence);
         if (!objectList) {
@@ -743,9 +722,10 @@
      */
     public void undoHabitat() {
         
-        //zaznam v ramci, ktereho doslo k editaci tabulky tHabitats        
-        Habitat habitat = historyChange.getOccurrence().getHabitat();
-        occurrenceId = historyChange.getOccurrence().getId();	
+        //historie lokalit se sleduje zvlast                
+        int habitatId = historyChange.getRecordId();	
+        Object[] object = searchObject("Habitat",habitatId);        
+        Habitat habitat = (Habitat)object[0];
       
         //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu
         //protoze neni k dispozici kaskadovy update musi se do seznamu objektu pridat i Habitat, i kdyz na nej muzem pristupovat pres konkretni zaznam
@@ -1499,7 +1479,10 @@
         //podle tableName najdeme podrobnosti o konkretnim objektu (autor, publikace, nalez,...)
          if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
               //Get details for occurrence
-              Occurrence occurrence = historyChange.getOccurrence();             
+              int occurrenceId = historyChange.getRecordId();
+              //Select record Occurrence where id = occurrenceId 
+              Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+              Occurrence occurrence = (Occurrence)objectOcc[0]; 
               detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE + "."+ Occurrence.PLANT) + ": "+ occurrence.getPlant().getTaxon()+"\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_AUTHOROCCURRENCE+"."+ AuthorOccurrence.AUTHOR) + ": " +getAllNameOfAuthors(getAllAuthors(occurrence, 0)) + "\n";

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-13 13:45:46 UTC (rev 466)
@@ -143,7 +143,8 @@
         whoInsertLabel.setFont(new java.awt.Font("Tahoma", 1, 11));
         whoInsertLabel.setText(L10n.getString("History.WhoInsert"));
 
-        whenInsertValueLabel.setText(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(model.getWhen()) );
+        String whenInsert = (model.getWhen() == null) ? null : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(model.getWhen());
+        whenInsertValueLabel.setText(whenInsert);
 
         whoInsertValueLabel.setText(model.getNameUser());
 

Modified: trunk/src/net/sf/plantlore/common/record/AuthorOccurrence.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/AuthorOccurrence.java	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/common/record/AuthorOccurrence.java	2006-07-13 13:45:46 UTC (rev 466)
@@ -49,6 +49,10 @@
     	return asList( AUTHOR, OCCURRENCE, ROLE, NOTE, DELETED );
     }
     
+    public List<String> getHistoryColumns() {
+        return asList( ROLE, NOTE);
+    }
+    
     @Override
     public void setValue(String column, Object value) {
     	if(value instanceof String && "".equals(value) )

Modified: trunk/src/net/sf/plantlore/common/record/HistoryChange.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/HistoryChange.java	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/common/record/HistoryChange.java	2006-07-13 13:45:46 UTC (rev 466)
@@ -22,8 +22,7 @@
     // Constants for HistoryChange operations (field COPERATION)
     public static final int HISTORYCHANGE_INSERT = 1;
     public static final int HISTORYCHANGE_EDIT = 2;
-    public static final int HISTORYCHANGE_DELETE = 3;
-    public static final int HISTORYCHANGE_EDITGROUP = 4;    
+    public static final int HISTORYCHANGE_DELETE = 3;    
     
     /** Parameters of the HistoryChange. For detailed explanation see data model documentation. */
     private Integer id;
@@ -35,8 +34,7 @@
     private User who;
     
     /** Constants with column mapping (used for building select queries) */
-    public static final String ID = "id";
-    public static final String OCCURRENCE = "occurrence";    
+    public static final String ID = "id";     
     public static final String RECORDID = "recordId";
     public static final String OLDRECORDID = "oldRecordId";
     public static final String OPERATION = "operation";
@@ -71,26 +69,8 @@
     public void setId(Integer id) {
         this.id = id;
     }
-
+ 
     /**
-     *  Get occurrence associated with this HistoryChange record
-     *  @return occurrence associated with this record
-     *  @see setOccurrence
-     */
-    public Occurrence getOccurrence() {        
-        return this.occurrence;
-    }
-    
-    /**
-     *  Set occurrence associated with this HistoryChange record
-     *  @param occurrence occurrence associated with this record
-     *  @see getOccurrence
-     */
-    public void setOccurrence(Occurrence occurrence) {
-        this.occurrence= occurrence;
-    }
-
-    /**
      *   Get identifier of the record which was changed
      *   @return identifier of the record which was changed
      *   @see setRecordId

Modified: trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml
===================================================================
--- trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml	2006-07-13 13:45:46 UTC (rev 466)
@@ -8,11 +8,7 @@
       <id column="CID" name="id" type="java.lang.Integer">
          <generator class="increment"/>
       </id>
-
-      <many-to-one name="occurrence" 
-                   class="net.sf.plantlore.common.record.Occurrence" 
-                   column="COCCURRENCEID"
-                   fetch="select"/>           
+                 
       <property column="CRECORDID"                
                 name="recordId"
                 not-null="true"

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-06-30 14:46:49 UTC (rev 465)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-13 13:45:46 UTC (rev 466)
@@ -1570,32 +1570,38 @@
             sess.update(occ.getMetadata());
         }
 */ 
+        // Set right type of operation for AuthorOccurrence
+        int aoInsert = 0;
+        if (data instanceof AuthorOccurrence) {
+        	if (type == INSERT) {
+        		aoInsert = 1;
+        		type = UPDATE;
+        	}        	
+        }
+        
         // Saving history when new record is inserted
         if (type == INSERT) {
-            HistoryChange historyChange = new HistoryChange();            
-            if (data instanceof Occurrence) {
-                historyChange.setOccurrence((Occurrence)data);
-                historyChange.setRecordId(0);
-                table = PlantloreConstants.ENTITY_OCCURRENCE;
-            } else {
-                historyChange.setOccurrence(null);
-                if (data instanceof Publication) {
-                    table = PlantloreConstants.ENTITY_PUBLICATION;
-                } else if (data instanceof Author) {
-                    table = PlantloreConstants.ENTITY_AUTHOR;                        
-                } else if (data instanceof Phytochorion) {
-                    table = PlantloreConstants.ENTITY_PHYTOCHORION;                        
-                } else if (data instanceof Village) {
-                    table = PlantloreConstants.ENTITY_VILLAGE;
-                } else if (data instanceof Territory) {
-                    table = PlantloreConstants.ENTITY_TERRITORY;                        
-                } else if (data instanceof Metadata) {
-                    table = PlantloreConstants.ENTITY_METADATA;                    
-                } else {
-                    return;
-                }
-                historyChange.setRecordId(recordId);
-            }
+            HistoryChange historyChange = new HistoryChange();                                    
+	        if (data instanceof Occurrence) {
+	        	table = PlantloreConstants.ENTITY_OCCURRENCE;
+	        } else if (data instanceof Habitat) {
+	            table = PlantloreConstants.ENTITY_HABITAT;
+	        } else if (data instanceof Publication) {
+	            table = PlantloreConstants.ENTITY_PUBLICATION;
+	        } else if (data instanceof Author) {
+	            table = PlantloreConstants.ENTITY_AUTHOR;                        
+	        } else if (data instanceof Phytochorion) {
+	            table = PlantloreConstants.ENTITY_PHYTOCHORION;                        
+	        } else if (data instanceof Village) {
+	            table = PlantloreConstants.ENTITY_VILLAGE;
+	        } else if (data instanceof Territory) {
+	            table = PlantloreConstants.ENTITY_TERRITORY;                        
+	        } else if (data instanceof Metadata) {
+	            table = PlantloreConstants.ENTITY_METADATA;                    
+	        } else {
+	        	return;
+	        }
+	        historyChange.setRecordId(recordId);            
             historyChange.setOldRecordId(0);
             historyChange.setOperation(INSERT);
             historyChange.setWho(this.plantloreUser);
@@ -1627,14 +1633,14 @@
             history.setHistoryChange(historyChange);                
             recId = (Integer)sess.save(history);                
         }
-        // Saving history when new record is inserted        
+        // Saving history when record is updated        
         if (type == UPDATE){            
             HistoryChange historyChange = new HistoryChange();                        
             // Check whether we are dealing with delete (seting CDELETE to 0)
             if ((data instanceof Author) || (data instanceof Publication) || 
-                (data instanceof Metadata) || (data instanceof Occurrence)) {
-                Integer delete = 0;
-                historyChange.setOccurrence(null);                
+                (data instanceof Metadata) || (data instanceof Occurrence) || 
+                (data instanceof Habitat)) {
+                Integer delete = 0;                  
                 if (data instanceof Author) {
                     delete = ((Author)data).getDeleted();
                     id = ((Author)data).getId();
@@ -1648,12 +1654,20 @@
                 if (data instanceof Occurrence) {
                     delete = ((Occurrence)data).getDeleted();                    
                     id = ((Occurrence)data).getId();         
-                    table = PlantloreConstants.ENTITY_OCCURRENCE;                    
-                    historyChange.setOccurrence((Occurrence)data);                    
-                } else {                    
+                    table = PlantloreConstants.ENTITY_OCCURRENCE;                                                         
+                } else 
+                if (data instanceof Habitat) {
+                    delete = ((Habitat)data).getDeleted();                    
+                    id = ((Habitat)data).getId();         
+                    table = PlantloreConstants.ENTITY_HABITAT;                                                         
+                } else 
+                if (data instanceof Metadata){                    
                     delete = ((Metadata)data).getDeleted();
                     id = ((Metadata)data).getId();               
                     table = PlantloreConstants.ENTITY_METADATA;                    
+                } else {                	
+                	id = 0;
+                	table = "";
                 }
                 if (delete == 1) {
                     // CDELETE was set to 1, we are deleting record
@@ -1688,12 +1702,31 @@
             }
             if ((data instanceof Author) || (data instanceof Publication) ||
                 (data instanceof Territory) || (data instanceof Phytochorion) ||
-                (data instanceof Village) || (data instanceof Metadata)) {                
-                historyChange.setOccurrence(null);
+                (data instanceof Village) || (data instanceof Metadata) ||
+                (data instanceof Occurrence) || (data instanceof Habitat) ||
+                (data instanceof AuthorOccurrence)) {                               
                 historyChange.setOldRecordId(0);                
                 historyChange.setOperation(UPDATE);
                 historyChange.setWhen(new java.util.Date());
                 historyChange.setWho(this.plantloreUser);
+                if (data instanceof Occurrence) {
+                    updated = Occurrence.class;
+                    updatedId = ((Occurrence)data).getId();
+                    tableId = Occurrence.ID;                    
+                    historyChange.setRecordId(((Occurrence)data).getId());
+                } else
+                if (data instanceof AuthorOccurrence) {
+                    updated = AuthorOccurrence.class;
+                    updatedId = ((AuthorOccurrence)data).getId();
+                    tableId = AuthorOccurrence.ID;                    
+                    historyChange.setRecordId(((AuthorOccurrence)data).getId());
+                } else
+                if (data instanceof Habitat) {
+                    updated = Habitat.class;
+                    updatedId = ((Habitat)data).getId();
+                    tableId = Habitat.ID;                    
+                    historyChange.setRecordId(((Habitat)data).getId());
+                } else
                 if (data instanceof Author) {
                     updated = Author.class;
                     updatedId = ((Author)data).getId();
@@ -1729,25 +1762,205 @@
                     updatedId = ((Village)data).getId();
                     tableId = Village.ID;
                     historyChange.setRecordId(((Village)data).getId());                    
-                }                    
-                // Save the HistoryChange object
-                sess.save(historyChange);
+                }                                  
                 // Read the to-be-updated object
                 Session tempSess = this.sessionFactory.openSession(); 
                 ScrollableResults res = tempSess.createCriteria(updated)
                     .add(Restrictions.eq(tableId, updatedId))
                     .scroll();
-                if (!res.next()) {
+                if (!res.next() && aoInsert != 1) {
                     logger.error("To-be-updated record was not found in the database. Type: "+updated.getName()+" ID:"+updatedId);
                     DBLayerException ex = new DBLayerException("To-be-updated record was not found in the database. Type: "+updated.getName()+" ID:"+updatedId);
                     ex.setError(ex.ERROR_UPDATE, updated.getName());
                     tempSess.close();
                     throw ex;
                 }
-                Object[] original = res.get();
+                Object[] original = null;
+                if (aoInsert != 1) {
+                    original = res.get();
+                }
                 tempSess.close();
                 // Object origRec, newRec;
-                if (data instanceof Author) {
+                if (data instanceof Occurrence) {                	
+                    Occurrence origRec = (Occurrence)original[0];
+                    Occurrence newRec = (Occurrence)data;                    
+                    // Seeing is believing.
+                    List<String> cols = origRec.getHistoryColumns();
+                    for(String columnName : cols) {
+                    	
+                    	Object 
+                    	origValue = origRec.getValue(columnName),
+                    	newValue = newRec.getValue(columnName);
+                    	
+                    	if( origValue == null && newValue == null)
+                    		continue;
+                    	
+                    	if( origValue == null || newValue == null || !origValue.equals(newValue) ) {
+                    		System.out.println(" >> DIFFERENT_COLUMN: " + columnName);
+                    		// Read record from THISTORYCOLUMN first
+                    		res = sess.createCriteria(HistoryColumn.class).
+                    		add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_OCCURRENCE)).
+                    		add(Restrictions.eq(HistoryColumn.COLUMNNAME, columnName)).
+                    		scroll();
+                    		if ( !res.next() ) {
+                    			logger.error("tHistoryColumn doesn't contain the required data ("+columnName+").");
+                    			DBLayerException ex = new DBLayerException("Error.CorruptedDatabase");
+                    			ex.setError(DBLayerException.ERROR_DB, PlantloreConstants.ENTITY_OCCURRENCE);
+                    			throw ex;
+                    		}
+                    		Object[] colNames = res.get();
+                    		// Create new history record
+                    		HistoryRecord historyRecord = new HistoryRecord();
+                    		// Save OldRecordId if neccessary
+                    		                    		
+                    		// TODO: Save oldRecordId
+                    		 if (((String)columnName).equals(Occurrence.PLANT)) {
+                    			 //TODO: tato situace by nastat nemela - zmenou kytky dojde k vlozeni noveho nalezu
+                    			 historyChange.setOldRecordId(((Plant)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldValue(((Plant)origValue).getTaxon());
+                         		 historyRecord.setNewValue(((Plant)newValue).getTaxon());
+                    		 } else if (((String)columnName).equals(Occurrence.PUBLICATION)) {
+                    			 historyChange.setOldRecordId(((Publication)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldValue(((Publication)origValue).getReferenceCitation());
+                         		 historyRecord.setNewValue(((Publication)newValue).getReferenceCitation());
+                    		 } else if (((String)columnName).equals(Occurrence.HABITAT)) {
+                    			 historyChange.setOldRecordId(((Habitat)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldValue(((Habitat)origValue).getDescription());
+                         		 historyRecord.setNewValue(((Habitat)newValue).getDescription());
+                    		 } else {
+                    			String origValueString = (origValue == null) ? null : origValue.toString(),
+                         			   newValueString = (newValue == null) ? null : newValue.toString(); 
+                    			historyRecord.setOldValue(origValueString);
+                         		historyRecord.setNewValue(newValueString);
+                    		 }
+                    		                     		 
+                    		 //Save the HistoryChange object
+                             sess.save(historyChange);
+                    		// Save record into THISTORY                    		
+                    		historyRecord.setHistoryChange(historyChange);
+                    		historyRecord.setHistoryColumn((HistoryColumn) colNames[0]);                    		
+                    		sess.save(historyRecord);
+                    	}
+                    }
+                } else if (data instanceof AuthorOccurrence) { 
+                	AuthorOccurrence newRec = (AuthorOccurrence)data;
+                	// Save the HistoryChange object
+                    sess.save(historyChange);
+                	//delete == 0 ...edit information about Author in occurrence
+                	//delete == 1 ...delete Auhtor from occurrence
+                	//aoInsert == 1 ...add new Author to occurrence                      
+                	if (newRec.getDeleted() == 1 || aoInsert == 1) {                                              
+                        // Read HistoryColumn table
+                        sr = sess.createCriteria(HistoryColumn.class)
+                            .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_AUTHOROCCURRENCE))
+                            .add(Restrictions.isNull(HistoryColumn.COLUMNNAME))
+                            .scroll();
+                        if (!sr.next()) {
+                            logger.error("tHistoryColumn doesn't contain required data");
+                            DBLayerException ex = new DBLayerException("tHistoryColumn doesn't contain required data");
+                            ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_AUTHOROCCURRENCE);
+                            throw ex;                                                        
+                        }
+                        Object[] hc = sr.get();                        
+                        HistoryRecord hist = new HistoryRecord(); 
+                        hist.setHistoryChange(historyChange);                        
+                        hist.setHistoryColumn((HistoryColumn)hc[0]);
+                        if ( newRec.getDeleted() == 1) {
+	                        hist.setNewValue(null);
+	                        hist.setOldValue(newRec.getAuthor().getWholeName());
+                        } else if (aoInsert == 1) {
+                        	hist.setNewValue(newRec.getAuthor().getWholeName());
+	                        hist.setOldValue(null);
+                        }
+                        // Save History record
+                        sess.save(hist);                                                       
+                	} else {
+                		AuthorOccurrence origRec = (AuthorOccurrence)original[0];
+                		ArrayList cols = (ArrayList)origRec.getColumns();
+                        for (int i=0;i<cols.size();i++) {
+                            Object origValue = (origRec.getValue((String)cols.get(i)) == null) ? new String("") : origRec.getValue((String)cols.get(i));                        
+                            Object newValue = (newRec.getValue((String)cols.get(i)) == null) ? new String("") : newRec.getValue((String)cols.get(i));                                                
+                            if (!origValue.equals(newValue)) {
+                            	//Read record from THISTORYCOLUMN first                              	
+                                res = sess.createCriteria(HistoryColumn.class)
+                                    .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_AUTHOROCCURRENCE))
+                                    .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                    .scroll();                                
+                                if (!res.next()) {
+                                    logger.error("tHistoryColumn doesn't contain required data");
+                                    DBLayerException ex = new DBLayerException("tHistoryColumn doesn't contain required data");
+                                    ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_AUTHOROCCURRENCE);
+                                    throw ex;                                
+                                }
+                            
+	                            Object[] colNames = res.get();                                             
+	                            
+	                            // Save record into THISTORY
+	                            HistoryRecord hist = new HistoryRecord();
+	                            hist.setHistoryChange(historyChange);	                            	                           
+	                            hist.setHistoryColumn((HistoryColumn)colNames[0]);  
+	                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+	                           			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+	                      		hist.setOldValue(origValueString);
+	                           	hist.setNewValue(newValueString);	                            
+	                            sess.save(hist);  
+                            }
+                        }
+                	} 
+                } else if (data instanceof Habitat) {
+                	Habitat origRec = (Habitat)original[0];
+                	Habitat newRec = (Habitat)data;
+                    ArrayList cols = (ArrayList)origRec.getColumns();
+                    for (int i=0;i<cols.size();i++) {
+                        Object origValue = (origRec.getValue((String)cols.get(i)) == null) ? new String("") : origRec.getValue((String)cols.get(i));                        
+                        Object newValue = (newRec.getValue((String)cols.get(i)) == null) ? new String("") : newRec.getValue((String)cols.get(i));                                                
+                        if (!origValue.equals(newValue)) {
+                            // Read record from THISTORYCOLUMN first                           	
+                            res = sess.createCriteria(HistoryColumn.class)
+                                .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_HABITAT))
+                                .add(Restrictions.eq(HistoryColumn.COLUMNNAME, (String)cols.get(i)))
+                                .scroll();
+                            if (!res.next()) {
+                                logger.error("tHistoryColumn doesn't contain required data");
+                                //TODO
+                                DBLayerException ex = new DBLayerException("tHistoryColumn doesn't contain required data");
+                                ex.setError(ex.ERROR_DB, PlantloreConstants.ENTITY_HABITAT);
+                                throw ex;                                
+                            }
+                            Object[] colNames = res.get();
+                            // Create new history record
+                            HistoryRecord hist = new HistoryRecord();
+                            // Save OldRecordId if neccessary
+                            
+                    		 //TODO: Save oldRecordId
+                    		 if (((String)cols.get(i)).equals(Habitat.TERRITORY)) {                    			 
+                    			 historyChange.setOldRecordId(((Territory)newRec.getValue((String)cols.get(i))).getId());
+                    			 hist.setOldValue(((Territory)origRec.getValue((String)cols.get(i))).getName());
+                                 hist.setNewValue(((Territory)newRec.getValue((String)cols.get(i))).getName());
+                    		 } else if (((String)cols.get(i)).equals(Habitat.PHYTOCHORION)) {
+                    			 historyChange.setOldRecordId(((Phytochorion)newRec.getValue((String)cols.get(i))).getId());
+                    			 hist.setOldValue(((Phytochorion)origRec.getValue((String)cols.get(i))).getName());
+                                 hist.setNewValue(((Phytochorion)newRec.getValue((String)cols.get(i))).getName());
+                    		 } else if (((String)cols.get(i)).equals(Habitat.VILLAGE)) {
+                    			 historyChange.setOldRecordId(((Village)newRec.getValue((String)cols.get(i))).getId());
+                    			 hist.setOldValue(((Village)origRec.getValue((String)cols.get(i))).getName());
+                                 hist.setNewValue(((Village)newRec.getValue((String)cols.get(i))).getName());
+                    		 } else {
+                    			 String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                           			    newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                      			 hist.setOldValue(origValueString);
+                           		 hist.setNewValue(newValueString);                    			
+                    		 }
+                    		 
+                            // Save the HistoryChange object
+                             sess.save(historyChange);
+                            // Save record into THISTORY                            
+                            hist.setHistoryChange(historyChange);
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                                                        
+                            sess.save(hist);                            
+                        }
+                    }
+                } else if (data instanceof Author) {
                     Author origRec = (Author)original[0];
                     Author newRec = (Author)data;
                     ArrayList cols = (ArrayList)origRec.getColumns();
@@ -1767,12 +1980,16 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            //Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);    
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                           
                             sess.save(hist);                            
                         }
                     }
@@ -1796,12 +2013,16 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            //Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]); 
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                            
                             sess.save(hist);     
                         }
                     }
@@ -1825,12 +2046,16 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            // Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);   
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                            
                             sess.save(hist);                            
                         }
                     }
@@ -1854,12 +2079,16 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            // Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);   
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                            
                             sess.save(hist);
                         }
                     }                    
@@ -1883,12 +2112,16 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            // Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);  
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                            
                             sess.save(hist);
                         }
                     }
@@ -1912,88 +2145,21 @@
                                 throw ex;                                
                             }
                             Object[] colNames = res.get();
+                            // Save the HistoryChange object
+                            sess.save(historyChange);
                             // Save record into THISTORY
                             HistoryRecord hist = new HistoryRecord();
                             hist.setHistoryChange(historyChange);
-                            hist.setHistoryColumn((HistoryColumn)colNames[0]);                            
-                            hist.setOldValue((String)origRec.getValue((String)cols.get(i)));
-                            hist.setNewValue((String)newRec.getValue((String)cols.get(i)));
+                            hist.setHistoryColumn((HistoryColumn)colNames[0]);     
+                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
+                        			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
+                   			hist.setOldValue(origValueString);
+                        	hist.setNewValue(newValueString);                           
                             sess.save(hist);
                         }
                     }
                 }
-            }
-            if (data instanceof Occurrence) {
-                historyChange.setOccurrence((Occurrence)data);
-                historyChange.setRecordId(((Occurrence)data).getId());
-                historyChange.setOperation(UPDATE);
-                historyChange.setWhen(new java.util.Date());
-                historyChange.setWho(this.plantloreUser);                
-                // Read the original occurrence
-                Session tempSess = this.sessionFactory.openSession();
-                ScrollableResults res = tempSess.createCriteria(Occurrence.class)
-                    .add(Restrictions.eq(Occurrence.ID, ((Occurrence)data).getId()))
-                    .scroll();
-                if (!res.next()) {
-                    logger.error("To-be-updated Occurrence was not found in the database. ID:"+((Occurrence)data).getId());
-                    DBLayerException ex = new DBLayerException("To-be-updated Occurrence was not found in the database. ID:"+((Occurrence)data).getId());
-                    ex.setError(ex.ERROR_UPDATE, Occurrence.class.getName());
-                    tempSess.close();
-                    throw ex;
-                }
-                Object[] original = res.get();
-                tempSess.close();
-                Occurrence origRec = (Occurrence)original[0];
-                Occurrence newRec = (Occurrence)data;
-                // Save the historyChange
-                sess.save(historyChange);
-                // Seeing is believing.
-                List<String> cols = origRec.getHistoryColumns();
-                for(String columnName : cols) {
-                	
-                	Object 
-                	origValue = origRec.getValue(columnName),
-                	newValue = newRec.getValue(columnName);
-                	
-                	if( origValue == null && newValue == null)
-                		continue;
-                	
-                	if( origValue == null || newValue == null ||
-                			!origValue.equals(newValue) ) {
-                		System.out.println(" >> DIFFERENT_COLUMN: " + columnName);
-                		// Read record from THISTORYCOLUMN first
-                		res = sess.createCriteria(HistoryColumn.class).
-                		add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_OCCURRENCE)).
-                		add(Restrictions.eq(HistoryColumn.COLUMNNAME, columnName)).
-                		scroll();
-                		if ( !res.next() ) {
-                			logger.error("tHistoryColumn doesn't contain the required data ("+columnName+").");
-                			DBLayerException ex = new DBLayerException("Error.CorruptedDatabase");
-                			ex.setError(DBLayerException.ERROR_DB, PlantloreConstants.ENTITY_OCCURRENCE);
-                			throw ex;
-                		}
-                		Object[] colNames = res.get();
-                		// Save OldRecordId if neccessary
-                		
-                		// TODO: Save oldRecordId
-                		// if ((((String)cols.get(i)).equals(Occurrence.PLANT))
-                		// ||
-                		// (((String)cols.get(i)).equals(Occurrence.PUBLICATION)))
-                		// {
-                		// historyChange.setOldRecordId((Integer)newRec.getValue((String)cols.get(i)));
-                		// }
-                		// Save record into THISTORY
-                		HistoryRecord historyRecord = new HistoryRecord();
-                		historyRecord.setHistoryChange(historyChange);
-                		historyRecord.setHistoryColumn((HistoryColumn) colNames[0]);
-                		String origValueString = (origValue == null) ? null : origValue.toString(),
-                				newValueString = (newValue == null) ? null : newValue.toString();
-                		historyRecord.setOldValue(origValueString);
-                		historyRecord.setNewValue(newValueString);
-                		sess.save(historyRecord);
-                	}
-                }
-            }
+            }                                  
         }
     }
     



From lada at mail.berlios.de  Mon Jul 17 19:11:32 2006
From: lada at mail.berlios.de (lada at mail.berlios.de)
Date: Mon, 17 Jul 2006 19:11:32 +0200
Subject: [Plantlore-dev] r467 - in trunk/src/net/sf/plantlore:
	client/history server
Message-ID: <200607171711.k6HHBWVr029355@sheep.berlios.de>

Author: lada
Date: 2006-07-17 19:11:29 +0200 (Mon, 17 Jul 2006)
New Revision: 467

Modified:
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
Others changes in history - test and repair bugs, comment...

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -24,6 +24,7 @@
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Habitat;
 import net.sf.plantlore.common.record.HistoryChange;
+import net.sf.plantlore.common.record.HistoryColumn;
 import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.common.record.Metadata;
 import net.sf.plantlore.common.record.Occurrence;
@@ -45,10 +46,12 @@
  */
 public class History extends Observable {
     
-      /** Instance of a logger */
+    /** Instance of a logger */
     private Logger logger;      
     /** Instance of a database management object */
     private DBLayer database;   
+    /** Exception with details about an error */
+    private String error = null;
     /** Constant with default number of rows to display */
     private static final int DEFAULT_DISPLAY_ROWS = 6;    
     /** Actual number of rows to display */
@@ -62,9 +65,9 @@
     /** Result of the search query */
     private int resultId = 0;
     /** List of data (results of a search query) displayed in the table */
-    private ArrayList<HistoryRecord> historyDataList = new ArrayList();     
+    private ArrayList<HistoryRecord> historyDataList = new ArrayList<HistoryRecord>();     
     // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
-    private ArrayList<Record> editObjectList = new ArrayList<Record>();    
+    private ArrayList<Object> editObjectList = new ArrayList<Object>();    
     // informace pro uzivatele o record undo
     private String messageUndo;
 
@@ -72,11 +75,12 @@
     //seznam id vsech oznacenych polozek
     private HashSet markListId = new HashSet();
     //Seznam Item + maxIdItem (nejstarsi oznacene id pro dany Item=sloupec)
-    private ArrayList<Object[]> markItem = new ArrayList();
+    private ArrayList<Object[]> markItem = new ArrayList<Object[]>();
     //Informuje o tom, zda byla zvolena volba "SelectAll"
     private boolean selectAll;    
     
-    //*********************Record of history, ... ***************************************//    
+    //*********************Record of history, ... ***************************************//   
+    private Object data;
     private Occurrence occurrence;
     private Habitat habitat;
     private AuthorOccurrence authorOccurrence;
@@ -105,9 +109,7 @@
     /** Date and time when the reccord was changed*/
     private java.util.Date when = null;	
     /** Old value of attribute*/    
-    private String oldValue;
-    /** New value of attribute*/
-    //private String newValue;
+    private String oldValue;      
    /** Name of user who did changed*/
     private String nameUser;
     
@@ -119,8 +121,7 @@
     /** Informaciton about location for specified occurrenc*/
     private String location;
     
-    //********************************************************//
-    /** Mapping of entities */           
+    //********************************************************//          
     private Hashtable<String, Integer> authorsOccurrenceHash;
     private Hashtable<String, Integer> occurrenceHash; 
     private Hashtable<String, Integer> authorHash;
@@ -128,211 +129,222 @@
     private Hashtable<String, Integer> metadataHash;
     private Hashtable<String, Integer> publicationHash;
     private Hashtable<String, Enum> editTypeHash;
-    //pro territory, village a phytochorion neni treba tvorit mapovani
     
+    //*********************************************************//
+    public static final String ERROR_SEARCH_RECORD = L10n.getString("Error.historyRecordSearchFailed");
+    public static final String ERROR_SEARCH_DATA = L10n.getString("Error.historyDataSearchFailed");
+    public static final String ERROR_SEARCH_OBJECT = L10n.getString("Error.historyObjectSearchFailed");
+    public static final String ERROR_SEARCH_AUTHOR = L10n.getString("Error.historyAuthorSearchFailed");
+    public static final String ERROR_PROCESS = L10n.getString("Error.historyProcessResultsFailed");
+    public static final String ERROR_UPDATE = L10n.getString("Error.historyUpdateResultsFailed");
+    public static final String ERROR_DELETE = L10n.getString("Error.historyDeleteResultsFailed");  
         
     /**
-     * Creates a new instance of History - history of whole database
+     * Creates a new instance of History - history of Occurrences, Habitats, Authors, 
+     * Publications, Metadata, Territories, Phytochorions, Villages
+     * @param database Instance of a database management object
      */
-    public History(DBLayer database) {
+    public History(DBLayer database){
           
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
        this.database = database;
        
-       //nacist vsechny data z historie -->bez podminky, jen je seradit podle casu
+       //Search history data (without condition, order by date)
        searchWholeHistoryData();
-       //opet funkci pro vyzadani si dat postupne
+       //Process results 
        processResult(1, displayRows);
     }
     
     /**  
      *  Creates a new instance of History - history of specific occurrence 
      *  @param database Instance of a database management object
-     *  @param idOcc
+     *  @param idObj identifier of specific occurrence
      * */
-    public History(DBLayer database, int idOcc)
+    public History(DBLayer database, int idObj)
     {
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
        this.database = database;       
        
        SelectQuery query = null;
-       int resultId = 0;
-       Object[] objectOccurrence = null;
-       Object[] objHis = null;
+       int resultIdRecord = 0;
+       Object[] object = null;      
        
-       try {
-       	    query = database.createQuery(Occurrence.class);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, idOcc, null);            
-            resultId = database.executeQuery(query);
-            objectOccurrence = database.more(resultId, 0, 0);       
-            objHis = (Object[])objectOccurrence[0];                            
+       try {    	  
+		    query = database.createQuery(Occurrence.class);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, idObj, null);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.DELETED, null, 0, null);    	                   
+            resultIdRecord = database.executeQuery(query);
+            object = database.next(resultIdRecord);                    
+            database.closeQuery(query);
        } catch(RemoteException e) {
-       	    System.err.println("RemoteException - History(), createQuery");       	  
+       	    logger.error("Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);
+       	    return;
        } catch(DBLayerException e) {
-       	    System.err.println("DBLayerException - History(), createQuery");       	  
-            logger.error("Processing search occurrence results failed: "+e.toString());            
+    	    logger.error("Search selected occurrence failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);             
+            return;
        }                                          
+       if (object == null) {
+    	   logger.error("tOccurrence doesn't contain required data");  
+    	   setError(ERROR_SEARCH_RECORD); 
+       } else {
+    	   
+    	   occurrence = (Occurrence)object[0];    	   
+    	   setData(occurrence);
+    	   
+	       //Save basic information about specific occurrence 
+	       setNameAuthor(getAllNameOfAuthors(getAllAuthors(occurrence, 0)));
+	       setNamePlant(occurrence.getPlant().getTaxon());       
+	       setLocation(occurrence.getHabitat().getNearestVillage().getName());	            
+	       
+	       //Save information about data entries concerned with specific occurrence
+	       setWhen(occurrence.getCreatedWhen());
+	       setNameUser(occurrence.getCreatedWho().getWholeName());
+	       
+	       //Searching for information about data editing concerned with specific occurrence
+	       searchEditHistory(occurrence);
+	       
+	       //Process results of a search "edit" query 
+	       processResult(1,displayRows);
+       }
+    }	
 
-       occurrence = ((Occurrence)objHis[0]);
+    /**  
+     *  Creates a new instance of History - history of specific habitat 
+     *  @param database Instance of a database management object
+     *  @param idObj integer containing identifier of specific habitat
+     *  @param infoHabitat
+     * */
+    public History(DBLayer database, int idObj, String infoHabitat)
+    {
+       logger = Logger.getLogger(this.getClass().getPackage().getName());	 
+       this.database = database;       
        
-       //FIXME: bude nutno dovyhledavat autory
-       setNameAuthor(getAllNameOfAuthors(getAllAuthors(occurrence, 0)));
-       setNamePlant(occurrence.getPlant().getTaxon());       
-       setLocation(occurrence.getHabitat().getNearestVillage().getName());
+       SelectQuery query = null;
+       int resultIdRecord = 0;
+       Object[] object = null;      
        
-       try {           
+       try {    	  
+		    query = database.createQuery(Habitat.class);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, idObj, null);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.DELETED, null, 0, null);    	                   
+            resultIdRecord = database.executeQuery(query);
+            object = database.next(resultIdRecord);                    
             database.closeQuery(query);
        } catch(RemoteException e) {
-       	    System.err.println("RemoteException");
-       }           
-       
-       //Searching for information about data entries concerned with specified occurrence
-       searchInsertInfo();
-       //Searching for information about data editing concerned with specified occurrence
-       searchEditHistory();
-       //Process results of a search "edit" query 
-       processResult(1,displayRows);
-    }	
-    
-    
-    /**
-     *  Searches for information about data entries concerned with specified occurrence.   
-     */
-    public void searchInsertInfo() {
-            
-       // Create new Select query
-       SelectQuery query = null;
-       int resultIdInsert = 0;
-       Object[] object = null;
-       
-       try {
-       	    query = database.createQuery(HistoryChange.class);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.RECORDID, null, occurrenceId, null);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.OPERATION, null, HistoryChange.HISTORYCHANGE_INSERT, null);
-       	    resultIdInsert = database.executeQuery(query);
-       	    object = database.next(resultIdInsert);
-       	    database.closeQuery(query);
-       } catch(RemoteException e) {
-       	    System.err.println("RemoteException- searchInsertInfo(), createQuery");       	  
+       	    logger.error("Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);
+       	    return;
        } catch(DBLayerException e) {
-       	    System.err.println("DBLayerException - searchInsertInfo(), createQuery");
-       }            
-        
+    	    logger.error("Search selected habitat failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);             
+            return;
+       }                                          
        if (object == null) {
-    	   logger.error("tHistoryChange doesn't contain required data");
+    	   logger.error("tHabitat doesn't contain required data");  
+    	   setError(ERROR_SEARCH_RECORD); 
        } else {
-    	   //TODO: INFORMACE O INSERTU NALEZU BY SE DALY ZJISKAT Z TABULKY TOCCURRENCE - TO BUDE I LEPSI 
-    	   setWhen(((HistoryChange)object[0]).getWhen());
-           setNameUser(((HistoryChange)object[0]).getWho().getWholeName());
-           // TOTO BUDE LEPSI 
-           setWhen(occurrence.getCreatedWhen());
-           setNameUser(occurrence.getCreatedWho().getWholeName());
-          
+    	   
+    	   habitat = (Habitat)object[0];    	   
+    	   setData(habitat);
+    	   
+    	   //TODO
+	       //Save basic information about specific habitat	             	      	  
+	       setLocation(habitat.getNearestVillage().getName());	            	       	       
+	       
+	       //Searching for information about data editing concerned with specific habitat
+	       searchEditHistory(habitat);
+	       
+	       //Process results of a search "edit" query 
+	       processResult(1,displayRows);
        }
-       
-    }
+    }	
     
     
     /**     
-     * Searches for information about data editing concerned with specified occurrence. 
-     */
-     
-    public void searchEditHistory()
-    {  
-    	    	
+     * Searches for information about data editing concerned with specific occurrence or habitat. 
+     * @param data object containing specific occurrence or habitat
+     */     
+    public void searchEditHistory(Object data)
+    {      	    	
         //Create new Select query
-        SelectQuery query = null;       
+        SelectQuery query = null; 
+        int resultIdEdit = 0;
 
     	//  Select data from tHistory table
         try {
-		query = database.createQuery(HistoryRecord.class);
-		// Create aliases for table tHistoryChange.      
+		    query = database.createQuery(HistoryRecord.class);
+		    // Create aliases for table tHistoryChange.      
 	        query.createAlias("historyChange", "hc");        
-	        // Add restriction to COPERATION column of tJistoryChange table
-	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.operation", null, HistoryChange.HISTORYCHANGE_EDIT, null);        
-	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.recordId", null, occurrence.getId(), null);    	
+	        // Add restriction to COPERATION column of tHistoryChange table
+	        if (data instanceof Occurrence) {	        	       
+		        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.recordId", null, ((Occurrence)data).getId(), null);  
+	        } else if (data instanceof Habitat) {	        	        
+		        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.recordId", null, ((Habitat)data).getId(), null);  
+	        }	
+	        query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.operation", null, HistoryChange.HISTORYCHANGE_EDIT, null);
 	        query.addOrder(PlantloreConstants.DIRECT_DESC, "hc.when");
-	} catch (RemoteException e) {
-		System.err.println("RemoteException - searchEditHistory(), createQuery");
-	} catch (DBLayerException e) {
-		System.err.println("DBLayerException - searchEditHistory(), createQuery");
-	}                
-
-        int resultIdEdit = 0;
-        try {
-            // Execute query                    
-            resultIdEdit = database.executeQuery(query); 
-            // Save "edit" history data
-            setResultId(resultIdEdit);
-        } catch (DBLayerException e) {
-            // Log and set an error                   
-            logger.error("Searching history data with condition 'operation = edit' failed. Unable to execute search query.");           
-        } catch (RemoteException e) { 		   
-     	   System.err.println("RemoteException- searchEditHistory(), executeQuery");
-	 	}    
-        
-        //zde nejde zavrit session closeQuery
+	        resultIdEdit = database.executeQuery(query); 
+		} catch (RemoteException e) {
+			logger.error("Remote exception caught in History (searchEditHistory). Details: "+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+		} catch (DBLayerException e) {
+			logger.error("DBLayer exception caught in History (searchEditHistory). Details: "+e.getMessage());
+			setError(ERROR_SEARCH_DATA);            
+		}                
+		setResultId(resultIdEdit);                
     }
     
        
     /**
-     *
+     * Searches for information about data concerned with occurrence, habitat, author, metadata, publication,
+     * territory, village and phytochorion.
      */
     public void searchWholeHistoryData() {
         
         //Create new Select query
-        SelectQuery query = null;       
+        SelectQuery query = null;
+        int resultIdWHistory = 0;
 
     	//  Select data from tHistory table
         try {
 			query = database.createQuery(HistoryRecord.class);
 			// Create aliases for table tHistoryChange.
-			query.createAlias("historyChange", "hc");
-			// sort by date/time
+			query.createAlias("historyChange", "hc");			
 			query.addOrder(PlantloreConstants.DIRECT_DESC, "hc.when");
-	} catch (RemoteException e) {
-                System.err.println("RemoteException - searchWholeHistoryData(), createQuery");
-	} catch (DBLayerException e) {
-                System.err.println("DBLayerException - searchWholeHistoryData(), createQuery");
-        }
-
-    	
-        int resultId = 0;
-        try {
-            // Execute query                    
-            resultId = database.executeQuery(query);
-            // Save "edit" history data
-            setResultId(resultId);    
-        } catch (DBLayerException e) {                            
-            logger.error("Searching whole history data failed. Unable to execute search query.");           
-        } catch (RemoteException e) { 		   
-     	   System.err.println("RemoteException- searchWholeHistoryData(), executeQuery");
-        }   
-        
-        //zde nelze zavrit session closeQuery
+			resultIdWHistory = database.executeQuery(query);
+		} catch (RemoteException e) {
+			logger.error("Remote exception caught in History (searchWholeHistoryData). Details: "+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+		} catch (DBLayerException e) {
+			logger.error("DBLayer exception caught in History (searchWholeHistoryData). Details: "+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+	    }
+		setResultId(resultIdWHistory);                 
     }
     
    /**
      * Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field of the class. 
-     * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
+     * @param from number of the first row to show in table. Number of the first row to retraieve is 1.
      * @param count number of rows to retrieve 
      */
-    public void processResult(int fromTable, int count) {
+    public void processResult(int from, int count) {
         
         if (this.resultId != 0) {
             int currentRow = getResultRows();
             logger.debug("Rows in the result: "+currentRow);
-            logger.debug("Max available rows: "+(fromTable+count-1));
+            logger.debug("Max available rows: "+(from+count-1));
            
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
-            int to = Math.min(currentRow, fromTable+count-1);           
+            int to = Math.min(currentRow, from+count-1);           
             if (to <= 0) {
             	historyDataList = new ArrayList<HistoryRecord>(); 
             	setDisplayRows(0);
             	setCurrentDisplayRows("0-0");
             } else {
                 logger.debug("Retrieving query results: 1 - "+to);
-                setCurrentDisplayRows(fromTable+ "-" + to);
+                setCurrentDisplayRows(from+ "-" + to);
                 try {                	 
                      // Retrieve selected row interval 
                 	Object[] objectHistory;
@@ -351,62 +363,62 @@
                     for (int i=0; i<countResult; i++ ) {                    							
 						Object[] objHis = (Object[])objectHistory[i];
                         this.historyDataList.add((HistoryRecord)objHis[0]);
-                    }           
-                    //Update current first displayed row (only if data retrieval was successful)
-                    setCurrentFirstRow(fromTable); 
+                    }                               
                 } catch (DBLayerException e) {                  
-                    logger.error("Processing search results failed: "+e.toString());            
-                }             
+                    logger.error("Processing search results failed: "+e.toString());   
+                    setError(this.ERROR_PROCESS);
+                }    
+                // Update current first displayed row (only if data retrieval was successful).
+                if (!this.isError()) {
+                    logger.info("Results successfuly retrieved");                   
+                    setCurrentFirstRow(from);
+                }
             }
-        }         
+            // Tell observers to update
+            setChanged();
+            notifyObservers();
+            // Clean error flag 
+            this.error = null;
+         }         
     }
     
     /**
-     *
+     *  Rollback changes from now to date of selected record 
+     *  @param toResult int containing identifier of selected record
      */
     public void undoToDate(int toResult) {
         
-        //Inicalization of hashTable
+        //Initialization of hashTable
         initAuthorsOccurrenceHash();
     	initOccurrenceHash();
     	initHabitatHash();   
         initPublicationHash();
         initAuthorHash();      
         initMetadataHash();
-        	
-    	//number of result
-    	//int countResult = this.historyDataList.size();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
-    	//relationship = false;
-    	//editHabitat = false;
-    	
-    	//take from younger record to older record, undo tu selected row
-    	for( int i=0; i < toResult; i++) {
-    		
+        	    	
+    	//read record from younger to older until selected row        
+    	for( int i=0; i < toResult; i++) {    		
     		//init history data 
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();
-                recordId = historyChange.getRecordId();
-                operation = historyChange.getOperation();
-    		                                                
-               /** 
-                * Pri insertu a editu nedohledavam column --> prvne rozdelit podle operace a pro edit dale rozdelit podle column
-                */
-                if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
-                    undoInsertDelete(1);
-                } else if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
-                    undoEdit();
-                } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
-                    undoInsertDelete(0);
-                } else {
-                    logger.error("Incorrect opreration code: "+ operation);
-                }                
+            recordId = historyChange.getRecordId();
+            operation = historyChange.getOperation();
+		  
+            if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
+                undoInsertDelete(1);
+            } else if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
+                undoEdit();
+            } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
+                undoInsertDelete(0);
+            } else {
+                logger.error("Incorrect opreration code: "+ operation);
+            }                
         }
     }
     
     /**
-     *  Volani UNDO z historie pro jeden nalez
+     *  Rollback selected data editing concerned with specific occurrence or habitat. 
      */
     public void undoSelected() {
     	
@@ -416,35 +428,30 @@
     	initHabitatHash();    	  
         	
     	//number of result
-    	int countResult = getResultRows();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu    	
+    	int countResult = getResultRows();    	   
     	
-    	//take from younger record to older record
+    	//take record from younger to older
     	for( int i=0; i < countResult; i++) {
     		if (! markListId.contains(i)) {
     			continue;
     		}
     		
-    		// init history data about edit of record
+    		// init history data about editing concerned with record
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();    		  		    			           
-                recordId = historyChange.getRecordId();           	   
-                operation = historyChange.getOperation();
-       
-            
-            //zavolani funkce, ktera undo pro operaci edit
+            recordId = historyChange.getRecordId();           	   
+            operation = historyChange.getOperation();
+                               
             undoEdit();    		
     	}
-    	//generated information form user
+    	//generated information message for user
     	generateMessageUndo();
     }
     
     /**
-     * ??? Habitat - nemuselo by se zaznamenavat cDelete
-     * v tabulkach Phytochorion, Village, Territory nebude mo?no mazat zaznamy (ani se nepredpoklada, ze by k t?to operaci m?lo dochazet), proto v nich nen? ani CDELETE.
-     * delete == 1 ... smazat
-     * delete == 0 ... obnovit
+     *   Rollback operation insert or delete. 
+     *   @param isDelete int containing informaciton about insertion or erasure of record. 
      */
     public void undoInsertDelete(int isDelete) {
         if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)){
@@ -454,7 +461,7 @@
              //Add to list of changed Record
              if (!editObjectList.contains((Record)occurrence))                 
                 editObjectList.add((Record)occurrence);       
-             //pripsat PRI obnovani z DELETE obnoveni i autoru (autorOcc)
+             //Update author of specific occurrence
              isDelete = (isDelete == 1) ? 2 : isDelete;
              Object[] objects = getAllAuthors(occurrence, 2-isDelete);
              int countResult = objects.length;               
@@ -473,8 +480,7 @@
              //Add to list of changed Record             
              if (!editObjectList.contains((Record)authorOccurrence))                 
                 editObjectList.add((Record)authorOccurrence);             
-       } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
-            //jeste rozmyslet, zda to tu bude
+       } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {            
                Object[] object = searchObject("Habitat",recordId);  
                Habitat habitat = (Habitat)object[0];
                habitat.setDeleted(isDelete);
@@ -504,16 +510,16 @@
              if (!editObjectList.contains((Record)author))                 
                 editObjectList.add((Record)author);             
         }  else {
-            logger.error("No table defined");
+            logger.error("Name of table is incorrect.");
         }
     }
     
     /**
-     *
+     * Rollaback operation Update.
      */
     public void undoEdit() {
         
-        //init history data about edit of record
+        //init history data about editing concerned with record
         columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
         oldRecordId = historyChange.getOldRecordId();                        	           
         oldValue = historyRecord.getOldValue();
@@ -537,42 +543,58 @@
         } else if (tableName.equals(PlantloreConstants.ENTITY_VILLAGE)) {
                 undoVillage();
         } else {
-            logger.error("No table defined");
+            logger.error("Name of table is incorrect.");
         }
     }
 
     
-      /**
-     *
+     /**
+     *  Rollback data editing concerned with specific occurrence and author
      */
     public void undoAuthorOccurrence() {
         
-        Object[] object = searchObject("AuthorOccurrence", recordId);
-        AuthorOccurrence authorOccurrence = (AuthorOccurrence)object[0];  
-        
-        occurrenceId = historyChange.getRecordId();	
-        
-        //test, zda jiz dany zaznam byl editovan
+    	int authorOccId = historyChange.getRecordId();
+    	occurrenceId = historyChange.getRecordId();	
+    	AuthorOccurrence authorOccurrence = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof AuthorOccurrence) {    			
+    			int listAutOccId = ((AuthorOccurrence)(editObjectList.get(i))).getId();
+    			if (authorOccId == listAutOccId) {
+    				contain = true;
+    				placings = i;   
+    				authorOccurrence = (AuthorOccurrence)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	}    
+    	
+    	if (!contain) {
+        	// Select record AuthorOccurrence where id = authorOccurrenceId 
+    		Object[] object = searchObject("AuthorOccurrence", authorOccId);
+            authorOccurrence = (AuthorOccurrence)object[0];
+        }     	                 
+                
         boolean objectList = editObjectList.contains((Record)authorOccurrence); 
         if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+        	//add object to list of editing object
             editObjectList.add((Record)authorOccurrence);
         }
-        logger.debug("editObjectList.contains: "+objectList);
-        logger.debug("authorOccurrence: "+ authorOccurrence.getId());
-        logger.debug("columnName: "+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+       
+       // Get number of columnName from authorOccurrence mapping
         int columnConstant;
-        if (authorsOccurrenceHash.containsKey(columnName)) {
-                 columnConstant = (Integer)authorsOccurrenceHash.get(columnName); 
+        if (columnName == null) {
+        	columnConstant = 1;
+        } else if (authorsOccurrenceHash.containsKey(columnName)) {
+            columnConstant = (Integer)authorsOccurrenceHash.get(columnName); 
         } else {
-             columnConstant = 0;
+            columnConstant = 0;
         }        	    			
       
         // Save new value for the column        		
         switch (columnConstant) {
-            case 1:  //Author
+            case 1:  //Author of occurrence - add author, remove author or change role of author
                 if (authorOccurrence.getDeleted() == 1) {
                     authorOccurrence.setDeleted(0);
                 } else {
@@ -590,35 +612,44 @@
             default:
                 logger.error("No column defined for name "+ columnName);	                   
         }
+        
+        if (contain) {        	
+        	editObjectList.set(placings, (Record)authorOccurrence);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add authorOccurrence");
+            editObjectList.add(authorOccurrence);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific occurrence
      */
     public void undoOccurrence() {
-        
-        //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
+               
     	occurrenceId = historyChange.getRecordId();
-    	//Select record Occurrence where id = occurrenceId 
-        Object[] objectOcc = searchObject("Occurrence",occurrenceId);
-        occurrence = (Occurrence)objectOcc[0];                           	
-        
-        boolean objectList = editObjectList.contains((Record)occurrence);
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            logger.debug("ObjectList... add occurrences");
-            editObjectList.add((Record)occurrence);
-        }
-        
-        logger.debug("editObjectList: "+objectList);
-        logger.debug("OccurrenceID: "+occurrence.getId());
-        logger.debug("columnName: "+columnName);
+    	Occurrence occ = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Occurrence) {    			
+    			int listOccId = ((Occurrence)(editObjectList.get(i))).getId();
+    			if (occurrenceId.equals(listOccId)) {
+    				contain = true;
+    				placings = i;   
+    				occ = (Occurrence)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	}    	    	               
                 
-        if (occurrenceId != recordId){
-            logger.error("Inccorect information in history tables --> occurrenceId != recordId ... Incorrect identifier of Occurrence.");
-        }
-
-        //Get a specified number of columnName from occurrence mapping.
+        if (!contain) {
+        	// Select record Occurrence where id = occurrenceId 
+            Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+            occ = (Occurrence)objectOcc[0];                    	
+        }    
+                
+        //Get number of columnName from occurrence mapping.
         int columnConstant;
         if (occurrenceHash.containsKey(columnName)) {
                  columnConstant = (Integer)occurrenceHash.get(columnName); 
@@ -636,38 +667,38 @@
                 Object[] object = searchObject("Plant",oldRecordId);
                 Plant plant = (Plant)object[0];
                 //Set old value to attribute plantID
-                occurrence.setPlant(plant);
+                occ.setPlant(plant);
                 logger.debug("Set selected value for update of attribute Taxon.");	
             } else {
                  logger.error("UNDO - Incorrect oldRecordId for Phytochoria.");
             } 
             break;
         case 2: //Year	
-            //Set old value to attribute Year          		
-                occurrence.setYearCollected(Integer.parseInt(oldValue));
+               //Set old value to attribute Year          		
+                occ.setYearCollected(Integer.parseInt(oldValue));
                 logger.debug("Set selected value for update of attribute Year.");
                 //Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(Integer.parseInt(oldValue),occ.getMonthCollected(),occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
                 break;
         case 3: //Month 
                 // Set old value to attribute Month 
-                occurrence.setMonthCollected(Integer.parseInt(oldValue));
+                occ.setMonthCollected(Integer.parseInt(oldValue));
                 logger.debug("Set selected value for update of attribute Month.");
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(occ.getYearCollected(), Integer.parseInt(oldValue), occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());              		
             break;
         case 4: //Day	                	
                 // Set old value to attribute Day            		
-                occurrence.setDayCollected(Integer.parseInt(oldValue));
+                occ.setDayCollected(Integer.parseInt(oldValue));
                 logger.debug("Set selected value for update of attribute Day.");
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(occ.getYearCollected(), occ.getMonthCollected(), Integer.parseInt(oldValue));
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());
                 break;
         case 5: //Time 	                		                	
                 // Set old value to attribute Time   
@@ -678,26 +709,26 @@
                 } catch (ParseException e) {
                         logger.error("Parse time failed. "+ e);
                 }
-                occurrence.setTimeCollected(time);
+                occ.setTimeCollected(time);
                 logger.debug("Set selected value for update of attribute Time.");
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
                 isoDateTime.setTime(time);
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                isoDateTime.set(occ.getYearCollected(), occ.getMonthCollected(), occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());
             break;
         case 6: //Source	                	
                 // Set old value to attribute Source 
-                occurrence.setDataSource(oldValue);
+                occ.setDataSource(oldValue);
                 logger.debug("Set selected value for update of attribute DataSource.");		                	            	
                 break;
         case 7: //Herbarium
                 // Set old value to attribute Herbarium
-                occurrence.setHerbarium(oldValue);
+                occ.setHerbarium(oldValue);
                 logger.debug("Set selected value for update of attribute Herbarium.");	                		          
             break;
         case 8: //Note occurrence	
                 // Set old value to attribute Note occurence	                	
-                occurrence.setNote(oldValue);
+                occ.setNote(oldValue);
                 logger.debug("Set selected value for update of attribute NoteOccurrence.");	                		        	
                 break;
         case 9: //Publication  
@@ -706,39 +737,77 @@
                     Object[] objectPubl = searchObject("Publication",oldRecordId);
                     Publication publication = (Publication)objectPubl[0];
                     //Set old value to attribute publicationID
-                    occurrence.setPublication(publication);
+                    occ.setPublication(publication);
                     logger.debug("Set selected value for update of attribute Publication.");
                 }else {
                     logger.error("UNDO - Incorrect oldRecordId for Phytochoria.");
                 }
             break;
+        case 10: //metadata
+        		//Select record Publication where id = oldRocordId 
+	            if (oldRecordId > 0){
+	                Object[] objectMetadata = searchObject("Metadata",oldRecordId);
+	                Metadata metadata = (Metadata)objectMetadata[0];
+	                //Set old value to attribute metadataID
+	                occ.setMetadata(metadata);
+	                logger.debug("Set selected value for update of attribute Metadata.");
+	            }else {
+	                logger.error("UNDO - Incorrect oldRecordId for Metadata.");
+	            }
+        	break;
+        case 11: //habitat
+        		//Select record Publication where id = oldRocordId 
+	            if (oldRecordId > 0){
+	                Object[] objectHabitat = searchObject("Habitat",oldRecordId);
+	                Habitat habitat = (Habitat)objectHabitat[0];
+	                //Set old value to attribute habitatID
+	                occ.setHabitat(habitat);
+	                logger.debug("Set selected value for update of attribute Habitat.");
+	            }else {
+	                logger.error("UNDO - Incorrect oldRecordId for Habitat.");
+	            }
+        	break;
         default:            
             logger.error("No column defined for name "+ columnName);	                   
-        }         
+        }    
+        
+        if (contain) {        	
+        	editObjectList.set(placings, (Record)occ);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add occurrences");
+            editObjectList.add(occ);
+        }
     }
         
     /**
-     *
+     * Rollback data editing concerned with specific habitat
      */
     public void undoHabitat() {
-        
-        //historie lokalit se sleduje zvlast                
-        int habitatId = historyChange.getRecordId();	
-        Object[] object = searchObject("Habitat",habitatId);        
-        Habitat habitat = (Habitat)object[0];
-      
-        //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu
-        //protoze neni k dispozici kaskadovy update musi se do seznamu objektu pridat i Habitat, i kdyz na nej muzem pristupovat pres konkretni zaznam
-        boolean objectList = editObjectList.contains((Record)habitat); 
-        if (!objectList) {
-            //pridani objektu do listu - informace o tom, ze byl dany objekt editovan (editace habitat vzdy v ramci occurrence)
-            editObjectList.add((Record)habitat);
-        }
-        logger.debug("editObjectList: "+objectList);
-        logger.debug("Habitat - OccurrenceID: "+habitat.getId());
-        logger.debug("columnName: "+columnName);
-        
-        // Get a specified number of columnName from habitat mapping.
+                         
+        int habitatId = historyChange.getRecordId();	        
+        Habitat hab = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Habitat) {    			
+    			int listHabId = ((Habitat)(editObjectList.get(i))).getId();
+    			if (habitatId == listHabId) {
+    				contain = true;
+    				placings = i; 
+    				hab = (Habitat)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Habitat where id = habitatId 
+    		Object[] object = searchObject("Habitat",habitatId);        
+            hab = (Habitat)object[0];
+        } 
+                             
+        // Get number of columnName from habitat mapping.
         int columnConstant;
         if (habitatHash.containsKey(columnName)) {
                  columnConstant = (Integer)habitatHash.get(columnName); 
@@ -748,95 +817,108 @@
 
         // Save new value for the column        		
         switch (columnConstant) {
-        case 1:  //Quadrant     	                	
-                /* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
-                 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
-                 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
-                 */ 	                		  
-                occurrence.getHabitat().setQuadrant(oldValue);		                	
+        case 1:  //Quadrant     	                	                	                		  
+                hab.setQuadrant(oldValue);		                	
                 logger.debug("Set selected value for update of attribute Quadrant.");                	
             break;
         case 2: //Place description 	                	 	                			                		 
-                occurrence.getHabitat().setDescription(oldValue);		                	
+                hab.setDescription(oldValue);		                	
                 logger.debug("Set selected value for update of attribute Description.");              	              	
                 break;
         case 3:  //Country 	                	 	                			                		 
-                occurrence.getHabitat().setCountry(oldValue);		                	
+                hab.setCountry(oldValue);		                	
                 logger.debug("Set selected value for update of attribute Country.");                
             break;
         case 4: //Altitude 	                	                			                		 
-                occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
+                hab.setAltitude(Double.parseDouble(oldValue));		                	
                 logger.debug("Set selected value for update of attribute Altitude.");                
                 break;
         case 5:  //Latitude   	                		                			                		  
-                occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
+                hab.setLatitude(Double.parseDouble(oldValue));		                	
                 logger.debug("Set selected value for update of attribute Latitude.");                
             break;
         case 6: //Longitude 	                		                			                		
-                occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
+                hab.setLongitude(Double.parseDouble(oldValue));		                	
                 logger.debug("Set selected value for update of attribute Longitude.");                
                 break;
         case 7: //Nearest bigger seat   	                	 	                			                		 
-                //Nacteni Village pro nasledny update tHabitat.cNearestVillageId
+                //Select record Village where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectVill = searchObject("Village",oldRecordId);
                         Village village = (Village)objectVill[0];
-                occurrence.getHabitat().setNearestVillage(village);
+                hab.setNearestVillage(village);
                 logger.debug("Set selected value for update of attribute NearesVillage.");
                 } else {
                         logger.error("UNDO - Incorrect oldRecordId for Village.");
                 }                
             break;
         case 8: //Phytochorion or phytochorion code 	                	             			                		 
-                // Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
+                // Select record Phytochoria where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectPhyt = searchObject("Phytochorion",oldRecordId);
                         Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
-                        occurrence.getHabitat().setPhytochorion(phytochorion);
+                        hab.setPhytochorion(phytochorion);
                         logger.debug("Set selected value for update of attribute Phytochorion.");
                 }else {
                         logger.error("UNDO - Incorrect oldRecordId for Phytochoria.");
                 }                
             break; 	               
         case 9:  //Territory   	                	                			                		  
-                // Nacteni Territory pro nasledny update tHabitat.cTerritory
+                // Select record Territory where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectTerr = searchObject("Territory",oldRecordId);
                         Territory territory = (Territory)objectTerr[0];
-                        occurrence.getHabitat().setTerritory(territory);
+                        hab.setTerritory(territory);
                         logger.debug("Set selected value for update of attribute Territory.");
                 }else {
                         logger.error("UNDO - Incorrect oldRecordId for Territory.");
                 }	               
             break;
         case 10: //Note habitat	                		                			                		  
-                occurrence.getHabitat().setNote(oldValue);		                	
+                hab.setNote(oldValue);		                	
                 logger.debug("Set selected value for update of attribute Note.");                
                 break;
         default:            
             logger.error("Habitat - No column defined for name "+ columnName);	                   
-        }  	          
+        }
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)hab);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add habitat");
+            editObjectList.add(hab);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific publication
      */
     public void undoPublication() {
-                
-        Object[] object = searchObject("Publication", recordId);
-        publication = (Publication)object[0];
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)publication); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)publication);
-        }
-        logger.debug("editObjectList.contains: "+objectList);
-        logger.debug("Publication: "+publication.getId());
-        logger.debug("columnName: "+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+         
+    	int publicationId = historyChange.getRecordId();	        
+        Publication publication = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Publication) {    			
+    			int listPubId = ((Publication)(editObjectList.get(i))).getId();
+    			if (publicationId == listPubId) {
+    				contain = true;
+    				placings = i; 
+    				publication = (Publication)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Publication where id = publicationId 
+    		Object[] object = searchObject("Publication", publicationId);
+            publication = (Publication)object[0];
+        } 
+            	        
+       // Get number of columnName from publication mapping.
         int columnConstant;
         if (publicationHash.containsKey(columnName)) {
                  columnConstant = (Integer)publicationHash.get(columnName); 
@@ -877,27 +959,44 @@
         default:            
             logger.error("Publication - No column defined for name "+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)publication);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add publication");
+            editObjectList.add(publication);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific author
      */
     public void undoAuthor() {
         
-       Object[] object = searchObject("Author", recordId);
-       author = (Author)object[0];
+    	int authorId = historyChange.getRecordId();	        
+        Author author = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Author) {    			
+    			int listAutId = ((Author)(editObjectList.get(i))).getId();
+    			if (authorId == listAutId) {
+    				contain = true;
+    				placings = i; 
+    				author = (Author)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Author where id = authorId 
+    		Object[] object = searchObject("Author", authorId);
+            author = (Author)object[0];
+        } 	
        
-       //test, zda jiz dany zaznam byl editovan
-       boolean objectList = editObjectList.contains((Record)author); 
-       if (!objectList) {
-       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-           editObjectList.add((Record)author);
-       }
-       logger.debug("editObjectList.contains: "+objectList);
-       logger.debug("author: "+author.getId());
-       logger.debug("columnName: "+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+    	// Get number of columnName from author mapping.
         int columnConstant;
         if (authorHash.containsKey(columnName)) {
                  columnConstant = (Integer)authorHash.get(columnName); 
@@ -942,27 +1041,44 @@
         default:            
             logger.error("Author - No column defined for name "+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)author);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add author");
+            editObjectList.add(author);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific metadata
      */
     public void undoMetadata() {
-        
-       Object[] object = searchObject("Metadata", recordId);
-       metadata = (Metadata)object[0];
        
-       //test, zda jiz dany zaznam byl editovan
-       boolean objectList = editObjectList.contains((Record)metadata); 
-       if (!objectList) {
-       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-           editObjectList.add((Record)metadata);
-       }
-       logger.debug("editObjectList.contains: "+objectList);
-       logger.debug("metadata: "+ metadata.getId());
-       logger.debug("columnName: "+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+    	int metadataId = historyChange.getRecordId();	        
+        Metadata metadata = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Metadata) {    			
+    			int listOccId = ((Metadata)(editObjectList.get(i))).getId();
+    			if (metadataId == listOccId) {
+    				contain = true;
+    				placings = i; 
+    				author = (Author)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Metadata where id = metadataId 
+    		Object[] object = searchObject("Metadata", metadataId);
+    	    metadata = (Metadata)object[0];
+        }
+    	
+        // Get number of columnName from metadata mapping.
         int columnConstant;
         if (metadataHash.containsKey(columnName)) {
                  columnConstant = (Integer)metadataHash.get(columnName); 
@@ -1027,28 +1143,45 @@
         default:            
             logger.error("Metadata - No column defined for name "+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)metadata);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add metadata");
+            editObjectList.add(metadata);
+        }
     }
     
     
     /**
-     *
+     * Rollback data editing concerned with specific phytochorion
      */
     public void undoPhytochorion() {
         
-        Object[] object = searchObject("Phytochorion", recordId);
-        phytochorion = (Phytochorion)object[0];     
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)phytochorion); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)phytochorion);
+    	int phytId = historyChange.getRecordId();	        
+        Phytochorion phytochorion = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Phytochorion) {    			
+    			int listPhytId = ((Phytochorion)(editObjectList.get(i))).getId();
+    			if (phytId == listPhytId) {
+    				contain = true;
+    				placings = i; 
+    				phytochorion = (Phytochorion)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Phytochorion where id = phytochorionId 
+    		Object[] object = searchObject("Phytochorion", phytId);
+            phytochorion = (Phytochorion)object[0];     
         }
-        logger.debug("editObjectList.contains: "+objectList);
-        logger.debug("phytochorion: "+phytochorion.getId());
-        logger.debug("columnName: "+columnName);
-      
-        if (columnName.equals("namePhytochorion")) {
+    	
+    	if (columnName.equals("namePhytochorion")) {
             phytochorion.setCode(oldValue);	                 
             logger.debug("Phytochorion - Set selected value for update of attribute WholeName.");                 	
         } else if (columnName.equals("code")) {
@@ -1056,70 +1189,115 @@
              logger.debug("Phytochorion - Set selected value for update of attribute Address.");                 	             	
         } else {
             logger.error("Phytochorion - No column defined for name "+ columnName);
-        }              
+        }   
+    	
+    	if (contain) {        	
+        	editObjectList.set(placings,(Record)phytochorion);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add phytochorion");
+            editObjectList.add(phytochorion);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific village
      */
     public void undoVillage() {
        
-        Object[] object = searchObject("Village", recordId);
-        village = (Village)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)village); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)village);
+    	int villageId = historyChange.getRecordId();	        
+        Village village = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Village) {    			
+    			int listVillId = ((Village)(editObjectList.get(i))).getId();
+    			if (villageId == listVillId) {
+    				contain = true;
+    				placings = i; 
+    				village = (Village)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Village where id = villageId 
+    		Object[] object = searchObject("Village", villageId);
+            village = (Village)object[0];     
         }
-        logger.debug("editObjectList.contains: "+objectList);
-        logger.debug("village: "+village.getId());
-        logger.debug("columnName: "+columnName);
-        
+       
        // Save new value for the column
         if (columnName.equals("nameVillage")) {
             village.setName(oldValue);	                 
             logger.debug("Village - Set selected value for update of attribute Name.");                 	
         } else {
             logger.error("Village - No column defined for name "+ columnName);	                   
-        }       
+        }   
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)village);        
+        } else {
+        	// add object to list of editing object
+            logger.debug("ObjectList - add village");
+            editObjectList.add(village);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific territory
      */
     public void undoTerritory() {
        
-        Object[] object = searchObject("Territory", recordId);
-        territory = (Territory)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)territory); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)territory);
+    	int territoryId = historyChange.getRecordId();	        
+        Territory territory = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i < editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Territory) {    			
+    			int listTerrId = ((Territory)(editObjectList.get(i))).getId();
+    			if (territoryId == listTerrId) {
+    				contain = true;
+    				placings = i; 
+    				territory = (Territory)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Territory where id = territoryId 
+    		Object[] object = searchObject("Territory", territoryId);
+    		territory = (Territory)object[0];     
         }
-        logger.debug("editObjectList.contains: "+objectList);
-        logger.debug("territory: "+territory.getId());
-        logger.debug("columnName: "+columnName);
-        
+    	        
        if (columnName.equals("nameTerritory")) {
            territory.setName(oldValue);	                 
            logger.debug("Territory - Set selected value for update of attribute Name.");                 	 
        } else {
            logger.error("Territory - No column defined for name "+ columnName);	                   
-       }        
+       }     
+       
+       if (contain) {        	
+       	   editObjectList.set(placings,(Record)territory);        
+       } else {
+       	// add object to list of editing object
+           logger.debug("ObjectList - add territory");
+           editObjectList.add(territory);
+       }
     }
     
     /**
      * 
-     * @param id
-     * @return
+     * @param typeObject string containing information about type of object
+     * @param id int containing identifier of record
+     * @return object defined by parameters typeObject and id
      */
     public Object[] searchObject(String typeObject, int id) {       
     	SelectQuery query = null;
-
+    	int resultIdObject = 0;
+    	Object[] object = null;
+    	
         try {
             if (typeObject.equals("Occurrence")){
                 query = database.createQuery(Occurrence.class);
@@ -1153,97 +1331,88 @@
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Metadata.ID, null, id , null);
             } else {
                 logger.error("SearchObject() - Incorrect type of object.");
+                
             }
+            resultIdObject = database.executeQuery(query);
+            object = database.next(resultIdObject);
+            database.closeQuery(query);
         } catch(RemoteException e) {
-            System.err.println("RemoteException, searchObject() - "+typeObject+", createQuery");
+        	logger.error("Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_SEARCH_OBJECT);
+	       	 //Tell observers to update
+	         setChanged();
+	         notifyObservers();
         } catch(DBLayerException e) {
-            System.err.println("DBLayerException, searchObject() - "+typeObject+", createQuery");
+        	logger.error("Search selected " + typeObject  +" failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_OBJECT);   
+            //Tell observers to update
+            setChanged();
+            notifyObservers();
         }
-        
-        int resultId = 0;
-        try {                   
-            resultId = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error("Searching " +typeObject+ " failed. Unable to execute search query.");
-        } catch (RemoteException e) {		 
-     	   System.err.println("RemoteException- executeQuery " +typeObject);
- 	} 
-       Object[] objects = null;
-       Object[] object = null;
-       try {
-       	    // Retrieve selected row interval         	
-            try {
-                 objects = database.more(resultId, 0, 0);  
-            } catch(RemoteException e) {            	
-                logger.debug("RemoteException- searchObject, more");            	
-            }   
-            object = (Object[])objects[0];           
-            //close session
-            database.closeQuery(query);            
-       } catch (DBLayerException e) {
-           // Log and set error in case of an exception
-           logger.error("Processing search " +typeObject+ " results failed: "+e.toString());            
-       } catch (RemoteException e) {
-           // Log and set error in case of an exception
-           logger.error("Processing search " +typeObject+ " results failed: "+e.toString());            
-       }       
-       return object; 	       	          	   
-           	        
+       
+        //TODO
+	   if (object == null) {
+		   logger.error("t"+typeObject+ " doesn't contain required data");  
+		   setError(ERROR_SEARCH_OBJECT);		   
+		   //Tell observers to update
+           setChanged();
+           notifyObservers();
+	   } 	   
+       return object; 	       	          	              	        
     }
     
-    /*
-     * Funkce, ktera mi dohleda vsechny autory ke konkretnimu nalezu
-     * isDlete - rekne, zda pozadujeme vsechny aktivni nebo neaktivni zaznamy
+    /**     
+     * Seach all authors concerned with specific occurrence
+     * @param occurrence 
+     * @param idDelete 
      */
     public Object[] getAllAuthors(Occurrence occurrence, int isDelete) {        
         
         SelectQuery query = null;        
-        int resultId = 0;        
+        int resultIdAuthors = 0; 
+        Object[] objects = null;
         try {
             query = database.createQuery(AuthorOccurrence.class);
             query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.OCCURRENCE, null, occurrence , null);
-            if (isDelete == 1) {
-                query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 1 , null);
+            if (isDelete == 0) {
+                query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 0 , null);
             } else {
-                Object[] args = new Object[8];
-                args[0] = PlantloreConstants.RESTR_EQ;
-                args[1] = AuthorOccurrence.DELETED;
-                args[2] = null;
-                args[3] = 0;                    
-                args[4] = PlantloreConstants.RESTR_EQ;
-                args[5] = AuthorOccurrence.DELETED;
-                args[6] = null;
-                args[7] = 2;
-                query.addOrRestriction(args);                
+            	query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 2 , null);                               
             }
-            resultId = database.executeQuery(query);
+            resultIdAuthors = database.executeQuery(query);
+            int to = database.getNumRows(resultIdAuthors); 
+            if (to > 0)
+                objects = database.more(resultIdAuthors, 0, to-1);
+            database.closeQuery(query);
         } catch(RemoteException e) {
-            System.err.println("RemoteException, getAllAuthors() - AuthorOccurrence, createQuery");
+        	logger.error("Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_SEARCH_AUTHOR);
+       	    //Tell observers to update
+            setChanged();
+            notifyObservers();
         } catch(DBLayerException e) {
-            System.err.println("RemoteException, getAllAuthors() - AuthorOccurrence, createQuery");
+        	logger.error("Search authors failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_AUTHOR); 
+            //Tell observers to update
+            setChanged();
+            notifyObservers();
+        }     
+        
+        //TODO
+        if(objects == null ) {
+        	logger.error("tAuthorOccurrence doesn't contain required data");  
+ 		    setError(ERROR_SEARCH_AUTHOR);
+ 		    //Tell observers to update
+            setChanged();
+            notifyObservers();
         }
-       Object[] objects = null;   
-       
-       try {
-            int to = database.getNumRows(resultId); 
-            if (to > 0)
-                objects = database.more(resultId, 0, to-1);  
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        }         
-       //close session
-        try {
-            database.closeQuery(query);
-        } catch(RemoteException e) {
-            System.err.println("RemoteException, getAllAuthors() - AuthorOccurrence, createQuery");
-        }         
+        
        return objects;
     }
     
-    /*
-     * Funkce, ktera vrati jmena autoru pro dany nalez
+    /**
+     *  Get names of authors for specific occurrence
+     *  @param objects  
      */
     public String getAllNameOfAuthors(Object[] objects) {
         if (objects == null)
@@ -1262,12 +1431,11 @@
     }
     
     /**
-     *  ..... pri whole history se bude do promennych occurrence, atd. nacitat vice ruznych objektu s jinym ID
-     *  ....Musim si ty jednotlive objekty pamatovat --> pole objektu, kde budou jednotlive editovane objekty
+     *  Update data in the database.
      */
     public void commitUpdate() {    	                
         
-        ArrayList<Enum> editType = new ArrayList();
+        ArrayList<Enum> editType = new ArrayList<Enum>();
         String type;
         Enum key;
         initEditTypeHash();
@@ -1275,28 +1443,35 @@
     	int count = editObjectList.size();        
     	for (int i=0; i< count; i++) {
     		try {
-    			logger.debug("Object for update: "+editObjectList.get(i).getId()); 
-                        
-                        type = editObjectList.get(i).getClass().getSimpleName();
-                         if (editTypeHash.containsKey(type)) {
-                                 key = (Enum)editTypeHash.get(type); 
-                                 if(!editType.contains(key))
-                                     editType.add(key);
-                        }                         
-                            
-                        database.executeUpdateHistory(editObjectList.get(i));
+    			logger.debug("Object for update: "+ ((Record)editObjectList.get(i)).getId());                         
+                type = editObjectList.get(i).getClass().getSimpleName();
+                 if (editTypeHash.containsKey(type)) {
+                         key = (Enum)editTypeHash.get(type); 
+                         if(!editType.contains(key))
+                             editType.add(key);
+                }                                                     
+                database.executeUpdateHistory(editObjectList.get(i));
 	        } catch (RemoteException e) {
-	                logger.error("CommitUpdate - RemoteException: "+e.toString());
+	        	logger.error("Update data failed.Remote exception caught in History. Details: "+e.getMessage());
+	       	    setError(ERROR_UPDATE);
+	       	    //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 	        } catch (DBLayerException e) {
-	                logger.error("CommitUpdate - DBLayerException: "+e.toString());
+	        	logger.error("Update data failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+	            setError(ERROR_UPDATE); 
+	            //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 	        }                
        }    	
-       
+    	//Create array of editing object and call notifyObservers
         informMethod(editType);
     }
     
     /**
-     *  Metoda vytvori pole typu editovanych objektu a preda je v parametru notifyObserver
+     *  Create array of editing object and give this array to parrent
+     *  @param editType
      */
     public void informMethod(ArrayList<Enum> editType) {
         int count = editType.size();
@@ -1310,22 +1485,23 @@
     }
     
     /**
-     *  vycisteni seznamu editovany objektu: 
+     *  Clear list of editing object
      */
     public void clearEditObjectList() {
     	editObjectList.clear();
     }
        
     /**
-     * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
-     * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
+     * Delete selected data from history table. During delete data from table tHistoryChange verify foring key from table tHistory.
+     * @param toResult
+     * @param typeHistory
      */
     public void deleteHistory(int toResult, boolean typeHistory) {
    	
     	//take from younger record to older record
     	for( int i=0; i < toResult; i++) {
-    		if (typeHistory && !markListId.contains(i)) {
-    			logger.debug("History of one occurence: "+markListId.contains(i));
+    		if (typeHistory && !markListId.contains(i)) {    			
+    			//History of occurence or habitat. The record is not selected.
     			continue;    			
     		}    		    		
     		historyRecord = (HistoryRecord)historyDataList.get(i); 
@@ -1334,135 +1510,106 @@
 	    	try {
 				database.executeDeleteHistory(historyRecord);
 				logger.debug("Deleting historyRecord successfully. Number of result: "+i);
-			} catch (RemoteException e) {
-				logger.error("Deleting historyRecord - remoteException. "+e.toString());
-			} catch (DBLayerException e) {
-				logger.error("Deleting historyRecord failed. "+e.toString());
+			} catch (RemoteException e) {				
+				logger.error("Deleting historyRecord failed.Remote exception caught in History. Details: "+e.getMessage());
+	       	    setError(ERROR_DELETE);
+	       	    //Tell observers to update
+	            setChanged();
+	            notifyObservers();
+			} catch (DBLayerException e) {				
+				logger.error("Deleting historyRecord failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+	            setError(ERROR_DELETE); 
+	            //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 			}
 			int countResult = getRelationshipHistoryChange(historyChange.getId());			
-			if (countResult == 0) {
-				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
-				//pokud po smazani zaznamu z tHistory jsme nasli alespon jeden zaznam, ktery ma stejny FK na zaznam z tChangeHistory
+			if (countResult == 0) {				
 				try {
 					database.executeDeleteHistory(historyChange);
 					logger.debug("Deleting historyChange successfully.");
 				} catch (RemoteException e) {
-					logger.error("Deleting historyChange - remoteException. "+e.toString());
+					logger.error("Deleting historyChange failed.Remote exception caught in History. Details: "+e.getMessage());
+		       	    setError(ERROR_DELETE);
+		       	    //Tell observers to update
+		            setChanged();
+		            notifyObservers();
 				} catch (DBLayerException e) {
-					logger.error("Deleting historyChange failed. "+e.toString());
+					logger.error("Deleting historyChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+		            setError(ERROR_DELETE); 
+		            //Tell observers to update
+		            setChanged();
+		            notifyObservers();
 				}
 			} else {
 				logger.debug("Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.");
 			}
     	}    	
-		//Clear list 
+		//Clear lists 
     	markListId.clear();
     	markItem.clear();    		
     } 
     
     /**
-     * Zjisteni kolik zaznamu v tabulce tHistory je provazano s konkretnim zaznamem z tHistoryHange 
-     * @param id
-     * @return
+     * Get number of record from tHistory, whitch has the value of attribute cChangeId equals id
+     * @param id identifier of historyChange record 
+     * @return int number of record from tHistory, whitch has the value of attribute cChangeId equals id
      */
     public int getRelationshipHistoryChange(int id){    	
     	SelectQuery query = null;
+    	int resultIdChange = 0;
+    	int countResult = 100;
         try {
                 query = database.createQuery(HistoryRecord.class);
                 // Create aliases for table tHistoryChange.      
                 query.createAlias("historyChange", "hc");  
                 // Add restriction to cChangeId column 
                 query.addRestriction(PlantloreConstants.RESTR_EQ, "hc.id", null, id , null);
+                resultIdChange = database.executeQuery(query);
+                countResult = database.getNumRows(resultIdChange);
+                database.closeQuery(query);
         } catch(RemoteException e) {
-        	System.err.println("RemoteException - searchHistoryChangeId(), createQuery");       	  
+        	logger.error("Searching historyChange failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);       	   
+            setChanged();
+            notifyObservers();       	  
         } catch(DBLayerException e) {
-        	System.err.println("DBLayerException - searchHistoryChangeId(), createQuery");       	  
-        }
-        
-        
-        int resultIdChange = 0;
-        try {                   
-        	resultIdChange = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error("Searching historyChangeId failed. Unable to execute search query.");
-        } catch (RemoteException e) {		 
-     	   System.err.println("RemoteException- getRelationshipHistoryChange(), executeQuery");
-        } 
-
-        int countResult = 100;
-        try {
-            countResult = database.getNumRows(resultIdChange);
-            logger.debug("getRelationshipHistoryChange - Number of result: "+countResult);
-            //close session
-            database.closeQuery(query);
-        } catch (RemoteException e) {
-            System.err.println("RemoteException- getRelationshipHistoryChange(), getNumRows");
-        }
-	return countResult;
-    }
-    
-    /*
-     * Tato funkce vrati pocet zaznamu z tOccurrence, ktere jsou provazany s konktretnim zaznamem v tHabitats
-     */
-    public int getRelationshipHabitat() {
-        SelectQuery query = null;
-        try {
-                query = database.createQuery(Occurrence.class);                
-                query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.HABITAT , null, occurrence.getHabitat() , null);
-        } catch(RemoteException e) {
-        	System.err.println("RemoteException - getRelationshipHabitat(), createQuery");       	  
-        } catch(DBLayerException e) {
-        	System.err.println("DBLayerException - getRelationshipHabitat(), createQuery");       	  
+        	logger.error("Searching historyChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);            
+            setChanged();
+            notifyObservers();       	  
         }        
-        
-        int resultIdHabitat = 0;
-        try {                   
-        	resultIdHabitat = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error("Searching habitatId failed. Unable to execute search query.");
-        } catch (RemoteException e) {		 
-     	   System.err.println("RemoteException- getRelationshipHabitat(), executeQuery");
-        } 
-
-        int countResult = 100;
-        try {
-            countResult = database.getNumRows(resultIdHabitat);
-            logger.debug("getRelationshipHabitat - Number of result: "+countResult);
-            //close session
-            database.closeQuery(query);
-        } catch (RemoteException e) {
-            System.err.println("RemoteException- searchHistoryChangeId(), getNumRows");
-        }
-	return countResult;
+       	return countResult;
     }
-    
-    /*
-     * Tato funkce je volana jen pro UNDO RECORD, coz znamena, ze pracuje jen s konkretnim nalezem
+         
+    /**
+     * Create message contains information about selected items. 
      */
     public void generateMessageUndo() {    	
     	messageUndo = "";      
-    	int count = markItem.size();
+    	int count = markItem.size();    	
     	for (int i=0; i<count; i++) {
     		Object[] itemList = (Object[])(markItem.get(i));
     		String item = (String)itemList[0];
     		Integer maxId = (Integer)itemList[1];      		
     		oldValue = ((HistoryRecord)historyDataList.get(maxId)).getOldValue(); 
     		messageUndo = messageUndo + item + "  -->  " + oldValue + "\n";
-    	}
-        //pracuji stale s konkretnim occurrence
-        int countResult = getRelationshipHabitat();			
-        if (countResult > 1) {
-            messageUndo = "\n" + messageUndo + L10n.getString("Question.UndoDetail");
-    	}
+    	}       
     }    
 
+    /**
+     * Create message containinig information about operation which will be realised    
+     * @param toDate  Date to which all the changes will be turned back.
+     * @return message containinig information about operation which will be realised
+     */
     public String getMessageUndoToDate(String toDate) {
-        String message = "V?echny zm?ny od " + toDate + " budou zru?eny."; 
+        String message = "V?echny zm?ny do " + toDate + " budou navr?ceny."; //All changes to 12.4.06 will be turned back.
         return message;
     }
     
-    /*
-     * Funkce ktera zjisti podrobne informace o polozce, ktera byla editovana
+    /**
+     *  Create message containing details about record
+     *  @param resultNumber 
      */
     public String getDetailsMessage(int resultNumber) {
         
@@ -1474,10 +1621,8 @@
         historyChange = historyRecord.getHistoryChange();
         tableName = historyRecord.getHistoryColumn().getTableName();
         recordId = historyChange.getRecordId();
-                
-        
-        //podle tableName najdeme podrobnosti o konkretnim objektu (autor, publikace, nalez,...)
-         if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
+                        
+        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
               //Get details for occurrence
               int occurrenceId = historyChange.getRecordId();
               //Select record Occurrence where id = occurrenceId 
@@ -1494,11 +1639,22 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.COUNTRY) + ": " + occurrence.getHabitat().getCountry() +"\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +"."+ Occurrence.DATASOURCE) + ": " + occurrence.getDataSource() + "\n";
               if (occurrence.getPublication() != null)
-                detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +"."+ Occurrence.PUBLICATION) + ": " + occurrence.getPublication().getReferenceCitation() + "\n";
+            	  detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +"."+ Occurrence.PUBLICATION) + ": " + occurrence.getPublication().getReferenceCitation() + "\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +"."+ Occurrence.HERBARIUM) + ": " + occurrence.getHerbarium() +"\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +"."+ Occurrence.NOTE) + ": " + occurrence.getNote() + "\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + occurrence.getHabitat().getNote() +"\n";
-        } else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
+        }else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
+        	  //Get details for Publication
+              Object[] object = searchObject("Habitat",recordId);
+              Habitat habitat = (Habitat)object[0];
+              detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NEARESTVILLAGE) + ": "+ occurrence.getHabitat().getNearestVillage().getName() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.DESCRIPTION) + ": "+ occurrence.getHabitat().getDescription() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.TERRITORY) + ": "+ occurrence.getHabitat().getTerritory().getName() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.PHYTOCHORION) + ": "+ occurrence.getHabitat().getPhytochorion().getName() +" (Code: " + occurrence.getHabitat().getPhytochorion().getCode() + ")\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.COUNTRY) + ": " + occurrence.getHabitat().getCountry() +"\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + occurrence.getHabitat().getNote() +"\n";
+    	}else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
               //Get details for Publication
               Object[] object = searchObject("Publication",recordId); 
               Publication publication = (Publication)object[0];
@@ -1574,15 +1730,13 @@
         return detailsMessage;
     }
     
-    /*
-     * Tato funkce smaze vsechny data z tabulky tHistoryChange a z tHistory
-     * delete from tHistory;
-     * delete from tHistoryChange;
+    /**
+     *  Delete all date from tables tHistorz and tHistoryChange
      */
     public void clearHistory() {        
         
         try {
-            //smazani dat z tabulky tHistory
+            //delete data from table tHistory
             database.conditionDelete(HistoryRecord.class, HistoryRecord.ID, ">", 0);
         } catch (RemoteException ex) {
             ex.printStackTrace();
@@ -1591,7 +1745,7 @@
         }
         
         try {            
-            //smazani dat z tabulky tHistoryChange
+            //delete data from  table tHistoryChange
             database.conditionDelete(HistoryChange.class, HistoryChange.ID, ">", 0);
         } catch (DBLayerException ex) {
             ex.printStackTrace();
@@ -1601,10 +1755,8 @@
         
     }
     
-    /*
-     * Tato funkce projde tabulky s cdelete - tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications
-     * a smaze v techto tabulkach zaznamy, ktere maji cdelete == 1
-     * delete from tAuthors where cdelete = 1;
+    /**
+     * Delete all record with cdelete equals 1 from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications
      */
     public void clearDatabase() {
         try {
@@ -1668,6 +1820,7 @@
         occurrenceHash.put(Occurrence.NOTE, 8);
         occurrenceHash.put(Occurrence.PUBLICATION, 9);       
         occurrenceHash.put(Occurrence.METADATA, 10);
+        occurrenceHash.put(Occurrence.HABITAT, 11);
     }    
     
     private void initHabitatHash() {
@@ -1741,6 +1894,43 @@
     //**************************//
     
     /**
+     *  Set an error flag.
+     *  @param msg  message explaining the error which occured
+     */
+    public void setError(String msg) {
+        this.error = msg;
+    }
+    
+    /**
+     *  Checks whether an error flag is set.
+     *  return true if an error occured and error message is available, false otherwise
+     */
+    public boolean isError() {
+        if (this.error != null) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    /**
+     *  Get error message for the error that occured
+     *  @return message explaining the error which occured
+     */
+    public String getError() {
+        return this.error;
+    }
+    
+    
+    public Object getData() {
+    	return data;
+    }
+    
+    public void setData(Object data) {
+    	this.data = data;
+    }
+    
+    /**
      * @return true if all recorda were selected.
      */
     public boolean getSelectAll() {

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -154,7 +154,7 @@
         	   logger.debug("Button OK was press.");
         	   model.commitUpdate();
         	   model.deleteHistory(model.getResultRows(), true);
-        	   model.searchEditHistory();
+        	   model.searchEditHistory(model.getData());
         	   model.processResult(1,model.getDisplayRows());
         	   view.getTable().setModel(new HistoryTableModel(model));
         	   int resultRows = model.getResultRows();

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -1827,6 +1827,10 @@
                     			 historyChange.setOldRecordId(((Habitat)newRec.getValue(columnName)).getId());
                     			 historyRecord.setOldValue(((Habitat)origValue).getDescription());
                          		 historyRecord.setNewValue(((Habitat)newValue).getDescription());
+                    		 } else if (((String)columnName).equals(Occurrence.METADATA)) {
+                    			 historyChange.setOldRecordId(((Metadata)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldValue(((Metadata)origValue).getDataSetTitle());
+                         		 historyRecord.setNewValue(((Metadata)newValue).getDataSetTitle());
                     		 } else {
                     			String origValueString = (origValue == null) ? null : origValue.toString(),
                          			   newValueString = (newValue == null) ? null : newValue.toString(); 
@@ -1843,9 +1847,7 @@
                     	}
                     }
                 } else if (data instanceof AuthorOccurrence) { 
-                	AuthorOccurrence newRec = (AuthorOccurrence)data;
-                	// Save the HistoryChange object
-                    sess.save(historyChange);
+                	AuthorOccurrence newRec = (AuthorOccurrence)data;                	
                 	//delete == 0 ...edit information about Author in occurrence
                 	//delete == 1 ...delete Auhtor from occurrence
                 	//aoInsert == 1 ...add new Author to occurrence                      
@@ -1872,6 +1874,8 @@
                         	hist.setNewValue(newRec.getAuthor().getWholeName());
 	                        hist.setOldValue(null);
                         }
+                        // Save the HistoryChange object
+                        sess.save(historyChange);
                         // Save History record
                         sess.save(hist);                                                       
                 	} else {
@@ -1902,7 +1906,10 @@
 	                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
 	                           			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
 	                      		hist.setOldValue(origValueString);
-	                           	hist.setNewValue(newValueString);	                            
+	                           	hist.setNewValue(newValueString);
+	                            // Save the HistoryChange object
+	                            sess.save(historyChange);
+	                            // Save the History object
 	                            sess.save(hist);  
                             }
                         }
@@ -1915,6 +1922,7 @@
                         Object origValue = (origRec.getValue((String)cols.get(i)) == null) ? new String("") : origRec.getValue((String)cols.get(i));                        
                         Object newValue = (newRec.getValue((String)cols.get(i)) == null) ? new String("") : newRec.getValue((String)cols.get(i));                                                
                         if (!origValue.equals(newValue)) {
+                        	System.out.println(" >> DIFFERENT_COLUMN: " + (String)cols.get(i));
                             // Read record from THISTORYCOLUMN first                           	
                             res = sess.createCriteria(HistoryColumn.class)
                                 .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_HABITAT))



From tkovarik at gmail.com  Wed Jul 19 17:06:17 2006
From: tkovarik at gmail.com (Tomas Kovarik)
Date: Wed, 19 Jul 2006 17:06:17 +0200
Subject: [Plantlore-dev] Plantlore
Message-ID: <ea88f1620607190806l10018c42ke4b5a69256b939f4@mail.gmail.com>

Dobry den,

ospravedlnujeme sa, ze sme sa chvilu neozyvali, vacsina z nas bola nejaky
cas mimo Prahu. Pustili sme sa opat do prace na projekte a dokoncujeme veci
ktore ostali nedotiahnute. Taktiez sme riesili ako zapracovat pripomienky od
botanikov, ktorym sme Plantlore ukazovali.
Uvazovali sme, ze by sme sa mohli opat stretnut a prediskutovat v akom je
Plantlore stave a na com sa pracuje, preto sme sa chceli opytat ci sa
niekedy v priebehu tyzdna nachadzate na fakulte na Malej Strane a kedy by
vam to vyhovovalo (idealny by bol asi buduci tyzden alebo zaciatok augusta).

Za cely tim

Tomas Kovarik
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060719/40e0df1f/attachment.html>

From tkovarik at gmail.com  Fri Jul 21 16:15:35 2006
From: tkovarik at gmail.com (Tomas Kovarik)
Date: Fri, 21 Jul 2006 16:15:35 +0200
Subject: [Plantlore-dev] Fwd: Plantlore
In-Reply-To: <20060720072707.4dc3d2a7@ksint.ms.mff.cuni.cz>
References: <ea88f1620607190806l10018c42ke4b5a69256b939f4@mail.gmail.com>
	<20060720072707.4dc3d2a7@ksint.ms.mff.cuni.cz>
Message-ID: <ea88f1620607210715n2bccefa0s4e6b020a8a212af4@mail.gmail.com>

---------- Forwarded message ----------
From: Antonin Riha <riha at ksi.ms.mff.cuni.cz>
Date: Jul 20, 2006 9:27 AM
Subject: Re: Plantlore
To: Tomas Kovarik <tkovarik at gmail.com>

Mily kolego,
zrovna jsem na vas projektanty vzpominal. Na fakultu ted jezdim
jen pokud se vyskytne nezbytnost, ale s vami se ovsem rad setkam.
Mam dojednanou dovolenou 29.7.-4.8., takze skutecne bychom se
mohli sejit pristi tyden nebo az cca od 8. srpna. Pristi tyden
bych mohl prijet tradicne v utery nejdrive tak v 15 hod. anebo
ve stredu celkem kdykoli.
Zdravi  A.Riha

P.S. Ptal se me zde dnes jeden kolega, zda bych nevedel o dvou
informaticich, kteri by chteli pracovat ve firme, kde pracuje
jeho manzelka a delaji tam zhruba receno databaze a warehousy
pro Ceskou pojistovnu. Pozaduji predevsim Javu a Oracle. Sice
by uvitali absolventy, ale to neni v teto chvili mozno dojednat,
ale kdyby mel zajem nekdo z vas nebo byste vedeli o nekom
spolehlivem, zkontaktoval bych ho s tim kolegou.
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060721/4ae6cd93/attachment.html>

From discontinuum at gmail.com  Fri Jul 21 17:06:50 2006
From: discontinuum at gmail.com (Erik Kratochvil)
Date: Fri, 21 Jul 2006 17:06:50 +0200
Subject: [Plantlore-dev] Import & Export
Message-ID: <f4dc39b90607210806x6f903cefl2dff0bb16dcf7c4c@mail.gmail.com>

Zdravim, jenom par informaci o importu a exportu. Export buildery jsou
trivialne predelatelny tak, aby zvladali i velky fajly. Problem je s
importem, jestlize to chceme mit tak, aby to zvladalo i velky soubory, tak
reseni neni lehky. DOM se na to nehodi, cili sem zkoumal SAX, jenze tam je
problem ten, ze SAX funguje na principu callbacku, kdezto import je
navrzenej tak, ze si o jednotlivy ty zaznamy rika sam, tj. je to presne
opacne.

V SAXu se vezme soubor, a v podstate se jen zavola SAX.parse( soubor
);Tahle metoda potom vola zpetne vas handler - s informaci, na jakej
element
narazil, co obsahuje, jaky ma atributy a tak. Prusvih je, ze to provede
"vsechno naraz", tj. projde celym tim souborem a vsechno to preparsuje. Parser
vola nejaky dalsi metody. Import oproti tomu ceka, ze dostane vzdycky jeden
kompletne zrekonstruovanej zaznam a rika si o nej sam - hasNextRecord() a
fetchNextRecord(); Tzn, ze director si vola parser.

Cili, jsou 3 moznosti (podle slozitosti):
1. nechat to, jak to je [Ostrich - strkani hlavy do pisku],
2. naprogramovat vlastni parser na XML; problem je, jak zajistit spravny
"preklady" veci jako &gt; co se v tom textu muzou vyskytnout, a ktery
napriklad Dom4j dela za mne... [tam je otazka, co vsechno by to muselo umet]
3. kompletne to preprogramovat s pouzitim SAXu [nedokazu dohlidnout, jak by
to ovlivnilo pripadny dalsi parsery (zatim jiny nez XML nemame)]

Nejaky nazory?
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060721/07d5da1b/attachment.html>

From lada at mail.berlios.de  Sat Jul 22 04:28:40 2006
From: lada at mail.berlios.de (lada at mail.berlios.de)
Date: Sat, 22 Jul 2006 04:28:40 +0200
Subject: [Plantlore-dev] r468 - in trunk/src/net/sf/plantlore: client
	client/history common/record config/hibernate server
Message-ID: <200607220228.k6M2Seul007764@sheep.berlios.de>

Author: lada
Date: 2006-07-22 04:28:35 +0200 (Sat, 22 Jul 2006)
New Revision: 468

Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/history/DetailsHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
   trunk/src/net/sf/plantlore/common/record/Habitat.java
   trunk/src/net/sf/plantlore/common/record/HistoryChange.java
   trunk/src/net/sf/plantlore/common/record/HistoryRecord.java
   trunk/src/net/sf/plantlore/config/hibernate/Habitats.hbm.xml
   trunk/src/net/sf/plantlore/config/hibernate/History.hbm.xml
   trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
History - test and fix other bugs (logic of selectAll and unselectedAll, work with cOldRecordId, rights, exception and display error message, comment).
HibernateDBLayer - add setting of tHabitat.cCreateWho for operation INSERT. Fix work with cOldRecordId. 
AppCoreCtrl - add test of administrator right (Only user, who has administrator right, can display dialog for WholeHistory, MetadataManager and UserManager). Call message dialog if constructor of history ends with mistake.
Database was changed - we need new version of the database.

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -379,7 +379,7 @@
 		detailCtrl = new DetailCtrl(detailModel, detailView);
 	}
 
-	private void setDatabaseDependentCommandsEnabled(boolean enabled) {
+	private void setDatabaseDependentCommandsEnabled(boolean enabled) {				
 		settingsAction.setEnabled(enabled);
 		printAction.setEnabled(enabled);
 		exportAction.setEnabled(enabled);
@@ -399,7 +399,7 @@
 		addAction.setEnabled(enabled);
 		editAction.setEnabled(enabled);
 		deleteAction.setEnabled(enabled);
-
+		
 		selectAllAction.setEnabled(enabled);
 		selectNoneAction.setEnabled(enabled);
 		invertSelectedAction.setEnabled(enabled);
@@ -407,6 +407,13 @@
 		prevPageAction.setEnabled(enabled);
 		view.recordsPerPage.setEnabled(enabled);
 		refreshAction.setEnabled(enabled);
+		
+		if (model.getAccessRights() != null) 
+			if	(model.getAccessRights().getAdministrator() != 1) {
+				dataMetadataAction.setEnabled(false);
+				dataWholeHistoryAction.setEnabled(false);
+				dataUserAction.setEnabled(false);
+		} 
 	}
 
 	/**
@@ -1192,21 +1199,19 @@
 		}
 
 		public void actionPerformed(ActionEvent e) {
-			System.out.println("Undo selected");
-			// toto volani historie nebude v menu, ale jako tlacitko pro vybrany
-			// zaznam
-			// o vybranem zaznamu predame informace, ktere chceme o nem v
-			// historii zobrazit
-			// jmeno rosliny, jmeno autora a lokaci a idOccurrences
-
-			historyModel = new History(model.getDatabase(), model
-					.getSelectedOccurrence());
+			System.out.println("History od record: "+ model.getDatabase());	
+			
+			historyModel = new History(model.getDatabase(), model.getSelectedOccurrence());
+			if (historyModel.isError()) {				
+				JOptionPane.showMessageDialog(view, historyModel.getError(), L10n.getString("Error.HistorySearchTitle"),
+						JOptionPane.WARNING_MESSAGE);				
+			} else {	
 			historyView = new HistoryView(historyModel, view, true);
 			historyCtrl = new HistoryCtrl(historyModel, historyView);
 			historyModel.addObserver(managerBridge);
 			historyView.setVisible(true);
+			}
 		}
-
 	}
 
 	class DataWholeHistoryAction extends AbstractAction {
@@ -1215,15 +1220,22 @@
 		}
 
 		public void actionPerformed(ActionEvent actionEvent) {
-			System.out.println("Whole history - Undo selected");
+			System.out.println("Whole history");
 
 			wholeHistoryModel = new History(model.getDatabase());
-			wholeHistoryView = new WholeHistoryView(wholeHistoryModel, view,
-					true);
-			wholeHistoryCtrl = new WholeHistoryCtrl(wholeHistoryModel,
-					wholeHistoryView);
-			wholeHistoryModel.addObserver(managerBridge);
-			wholeHistoryView.setVisible(true);
+			if (wholeHistoryModel.isError()) {
+				//TODO: zjistit nejdrive o jakou chybu jde
+				JOptionPane.showMessageDialog(view, wholeHistoryModel.getError(), L10n.getString("Error.HistorySearchTitle"),
+						JOptionPane.WARNING_MESSAGE);				
+				logger.error("");
+			} else {			
+				wholeHistoryView = new WholeHistoryView(wholeHistoryModel, view,
+						true);
+				wholeHistoryCtrl = new WholeHistoryCtrl(wholeHistoryModel,
+						wholeHistoryView);
+				wholeHistoryModel.addObserver(managerBridge);
+				wholeHistoryView.setVisible(true);
+			}
 		}
 	}
 

Modified: trunk/src/net/sf/plantlore/client/history/DetailsHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/DetailsHistoryCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/DetailsHistoryCtrl.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -11,32 +11,34 @@
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-import org.apache.log4j.Logger;
 
 /**
+ * Controller for the DetailsHistory dialog (part of the DetailsHistory MVC).
  *
- * @author Lada
+ * @author Lada Oberreiterova
+ * @version 1.0
  */
 public class DetailsHistoryCtrl {
-    
-    private Logger logger;   
+     
+	/** View of the DerailsHistory MVC*/
     private DetailsHistoryView view;
     
-    /** Creates a new instance of DetailsHistoryCtrl */
+    /** 
+     * Creates a new instance of DetailsHistoryCtrl
+     * @param view View of the DerailsHistory MVC 
+     */
     public DetailsHistoryCtrl(DetailsHistoryView view) {
-        
-        logger = Logger.getLogger(this.getClass().getPackage().getName());              
+                          
         this.view = view;
-        
+        // Add action listeners to buttons
         view.closeButton.addActionListener(new closeButtonListener());
         view.helpButton.addActionListener(new helpButtonListener());
     }
-     
-  
-   /**
-    * On Cancel just hides the view.
-    *
-    */
+       
+    /** 
+     * ActionListener class controlling the <b>OK</b> button on the form.
+     * On Ok makes the model store() the preferences and hides the view.     
+     */
    class closeButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
@@ -45,13 +47,12 @@
    }
    
    /**
-    * On Help should call help.
-    *
+    * ActionListener class controlling the <b>HELP</b> button on the form.
+    * Display help viewer
     */
    class helpButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {    	  
-    	   // Display help viewer            
+       {    	      	           
     	   System.out.println("Tady se bude volat Help!");
        }
    }

Modified: trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -13,30 +13,45 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
- *
- * @author  Lada
+ * View for the DetailsHistory dialog (part of the DetailsHistory MVC). Used for displaying the detailed information about the record.
+ * 
+ * @author  Lada Oberreiterova
+ * @version 1.0
  */
 public class DetailsHistoryView extends javax.swing.JDialog implements Observer {
     
-    /**
-     * Creates new form DetailsHistoryView
+    
+	private static final long serialVersionUID = 2142390888514121396L;
+	
+	/**
+     * Creates new form DetailsHistoryView     
+     * @param parent parent of this dialog
+     * @param modal boolean flag whether the dialog should be modal or not
      */
     public DetailsHistoryView(javax.swing.JDialog parent, boolean modal) {
         super(parent, modal);
         setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
         initComponents(); 
+        //Init Help
         PlantloreHelp.addKeyHelp(PlantloreHelp.HISTORY_MANAGER, this.getRootPane());
         PlantloreHelp.addButtonHelp(PlantloreHelp.HISTORY_MANAGER, this.helpButton);        
         this.detailsTextArea.setEditable(false);
     }
-    
+        
     public void update(Observable observable, Object object) {
     } 
     
+    /**
+     * Display generic message containing detailed information about the record
+     * @param detailsMessage Message we want to display     
+     */
     public void setDetailsMessage(String detailsMessage) {
         this.detailsTextArea.setText(detailsMessage);
     }
     
+    /**
+     * Close this dialog.    
+     */
     public void close() {
         dispose();
     }
@@ -102,18 +117,7 @@
         );
         pack();
     }// </editor-fold>//GEN-END:initComponents
-    
-    /**
-     * @param args the command line arguments
-     */
-    public static void main(String args[]) {
-        java.awt.EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                new DetailsHistoryView(new javax.swing.JDialog(), true).setVisible(true);
-            }
-        });
-    }
-    
+      
     // Variables declaration - do not modify//GEN-BEGIN:variables
     protected javax.swing.JButton closeButton;
     protected javax.swing.JTextArea detailsTextArea;

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -24,7 +24,6 @@
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Habitat;
 import net.sf.plantlore.common.record.HistoryChange;
-import net.sf.plantlore.common.record.HistoryColumn;
 import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.common.record.Metadata;
 import net.sf.plantlore.common.record.Occurrence;
@@ -41,8 +40,12 @@
 import org.apache.log4j.Logger;
 
 /**
- *
- * @author Lada
+ * History model. Contains bussines logic and data fields of the History. Implements
+ * operations including search history data, undo, cleare database.
+ * 
+ * @author Lada Oberreiterova
+ * @version 1.0 
+ * 
  */
 public class History extends Observable {
     
@@ -53,47 +56,29 @@
     /** Exception with details about an error */
     private String error = null;
     /** Constant with default number of rows to display */
-    private static final int DEFAULT_DISPLAY_ROWS = 6;    
+    private static final int DEFAULT_DISPLAY_ROWS = 12;    
     /** Actual number of rows to display */
     private int displayRows = DEFAULT_DISPLAY_ROWS;   
     /** Index of the first record shown in the table */
     private int currentFirstRow;
     /** Information about current display rows*/
-    private String displayRow;    
-    
-    //*******Informations about searching Result from database*****//
+    private String displayRow;          
     /** Result of the search query */
     private int resultId = 0;
-    /** List of data (results of a search query) displayed in the table */
+    /** List of data (results of a search query) displayed in the view dialog */
     private ArrayList<HistoryRecord> historyDataList = new ArrayList<HistoryRecord>();     
-    // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
+    /** List of editing object */
     private ArrayList<Object> editObjectList = new ArrayList<Object>();    
-    // informace pro uzivatele o record undo
-    private String messageUndo;
-
-    //************************************pro historii jednoho nalezu*********************/
-    //seznam id vsech oznacenych polozek
+    /** Information message */
+    private String messageUndo;    
+    /** List of identifier of selected item */
     private HashSet markListId = new HashSet();
-    //Seznam Item + maxIdItem (nejstarsi oznacene id pro dany Item=sloupec)
+    /** List of pairs (Item, identifier of the oldest change of this Item) */
     private ArrayList<Object[]> markItem = new ArrayList<Object[]>();
-    //Informuje o tom, zda byla zvolena volba "SelectAll"
-    private boolean selectAll;    
-    
-    //*********************Record of history, ... ***************************************//   
-    private Object data;
-    private Occurrence occurrence;
-    private Habitat habitat;
-    private AuthorOccurrence authorOccurrence;
-    private HistoryRecord historyRecord;
-    private HistoryChange historyChange;
-    private Publication publication;
-    private Author author;
-    private Village village;
-    private Territory territory;
-    private Phytochorion phytochorion;
-    private Metadata metadata;
-    
-     //	**************Informations about HistoryRecord*************//	
+    /** Information about useing function Select All*/
+    private boolean selectAll;
+    /** Information about useing function Unselected All*/
+    private boolean unselectedAll;    
     /** Name of the table where value was changed*/
     private String tableName;  
     /** Name of the column where value was changed*/
@@ -112,16 +97,19 @@
     private String oldValue;      
    /** Name of user who did changed*/
     private String nameUser;
-    
-    //**************Informations about occurrences***************//
-    /** Name of plant for specified occurrenc*/
+    /** Name of plant for specific occurrence*/
     private String namePlant;
-    /** Name of author for specified occurrenc*/
+    /** Name of author for specific occurrence*/
     private String nameAuthor;
-    /** Informaciton about location for specified occurrenc*/
-    private String location;
+    /** Informaciton about location for specific occurrence*/
+    private String location;    
     
-    //********************************************************//          
+    /** Instances of Record */
+    private Object data;        
+    private HistoryRecord historyRecord;
+    private HistoryChange historyChange;
+         
+    /** */    
     private Hashtable<String, Integer> authorsOccurrenceHash;
     private Hashtable<String, Integer> occurrenceHash; 
     private Hashtable<String, Integer> authorHash;
@@ -130,7 +118,7 @@
     private Hashtable<String, Integer> publicationHash;
     private Hashtable<String, Enum> editTypeHash;
     
-    //*********************************************************//
+    /** Constants used for description of errors */
     public static final String ERROR_SEARCH_RECORD = L10n.getString("Error.historyRecordSearchFailed");
     public static final String ERROR_SEARCH_DATA = L10n.getString("Error.historyDataSearchFailed");
     public static final String ERROR_SEARCH_OBJECT = L10n.getString("Error.historyObjectSearchFailed");
@@ -138,7 +126,12 @@
     public static final String ERROR_PROCESS = L10n.getString("Error.historyProcessResultsFailed");
     public static final String ERROR_UPDATE = L10n.getString("Error.historyUpdateResultsFailed");
     public static final String ERROR_DELETE = L10n.getString("Error.historyDeleteResultsFailed");  
-        
+    public static final String ERROR_CLEAR_DATABASE = L10n.getString("Error.historyClearDatabase");
+    public static final String ERROR_CLEAR_HISTORY = L10n.getString("Error.historyClearHistory");
+    public static final String ERROR_PARSE_DATE = L10n.getString("Error.historyParseData");
+    public static final String ERROR_NUMBER_ROWS = L10n.getString("Error.historyGetNumberRows");
+    public static final String ERROR_NO_RIGHTS = L10n.getString("Error.historyNoRights"); 
+    
     /**
      * Creates a new instance of History - history of Occurrences, Habitats, Authors, 
      * Publications, Metadata, Territories, Phytochorions, Villages
@@ -163,7 +156,7 @@
     public History(DBLayer database, int idObj)
     {
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
-       this.database = database;       
+       this.database = database;                     
        
        SelectQuery query = null;
        int resultIdRecord = 0;
@@ -190,9 +183,15 @@
     	   setError(ERROR_SEARCH_RECORD); 
        } else {
     	   
-    	   occurrence = (Occurrence)object[0];    	   
+    	   Occurrence occurrence = (Occurrence)object[0];    	   
     	   setData(occurrence);
     	   
+    	   //Check rights
+    	   if(! hasRights(occurrence.getCreatedWho().getId())) {
+    		   setError(ERROR_NO_RIGHTS);
+    		   return;
+    	   }
+    	   
 	       //Save basic information about specific occurrence 
 	       setNameAuthor(getAllNameOfAuthors(getAllAuthors(occurrence, 0)));
 	       setNamePlant(occurrence.getPlant().getTaxon());       
@@ -214,7 +213,7 @@
      *  Creates a new instance of History - history of specific habitat 
      *  @param database Instance of a database management object
      *  @param idObj integer containing identifier of specific habitat
-     *  @param infoHabitat
+     *  @param infoHabitat 
      * */
     public History(DBLayer database, int idObj, String infoHabitat)
     {
@@ -246,8 +245,14 @@
     	   setError(ERROR_SEARCH_RECORD); 
        } else {
     	   
-    	   habitat = (Habitat)object[0];    	   
+    	   Habitat habitat = (Habitat)object[0];    	   
     	   setData(habitat);
+
+    	   //Check rights
+    	   if(! hasRights(habitat.getCreatedWho().getId())) {
+    		   setError(ERROR_NO_RIGHTS);
+    		   return;
+    	   }
     	   
     	   //TODO
 	       //Save basic information about specific habitat	             	      	  
@@ -267,7 +272,9 @@
      * @param data object containing specific occurrence or habitat
      */     
     public void searchEditHistory(Object data)
-    {      	    	
+    {    
+    	//Cleare historyDataList
+    	historyDataList.clear();
         //Create new Select query
         SelectQuery query = null; 
         int resultIdEdit = 0;
@@ -303,6 +310,8 @@
      */
     public void searchWholeHistoryData() {
         
+    	// Cleare historyDataList
+    	historyDataList.clear();
         //Create new Select query
         SelectQuery query = null;
         int resultIdWHistory = 0;
@@ -334,51 +343,59 @@
         if (this.resultId != 0) {
             int currentRow = getResultRows();
             logger.debug("Rows in the result: "+currentRow);
-            logger.debug("Max available rows: "+(from+count-1));
+            logger.debug("Max available rows: "+(from+count-1));            
            
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
-            int to = Math.min(currentRow, from+count-1);           
+            int to = Math.min(currentRow, from+count-1);             
             if (to <= 0) {
             	historyDataList = new ArrayList<HistoryRecord>(); 
             	setDisplayRows(0);
             	setCurrentDisplayRows("0-0");
+            } else if (historyDataList.size() >= to) {
+            	logger.debug("Retrieving query results: 1 - " + to);
+            	setCurrentDisplayRows(from+ "-" + to);
+            	setCurrentFirstRow(from);
             } else {
-                logger.debug("Retrieving query results: 1 - "+to);
-                setCurrentDisplayRows(from+ "-" + to);
-                try {                	 
-                     // Retrieve selected row interval 
-                	Object[] objectHistory;
-                 	try {
-                 		objectHistory = database.more(this.resultId, 0, to-1);  
-                 	} catch(RemoteException e) {
-                     	System.err.println("RemoteException- processEditResult, more");
-                     	logger.debug("RemoteException- processEditResult, more");
-                     	return;
-                     }                   
-                    int countResult = objectHistory.length;  
-                    logger.debug("Results retrieved. Count: "+ countResult);
-                    // Create storage for the results
-                    this.historyDataList = new ArrayList<HistoryRecord>();
-                    // Cast the results to the HistoryRecord objects
-                    for (int i=0; i<countResult; i++ ) {                    							
-						Object[] objHis = (Object[])objectHistory[i];
-                        this.historyDataList.add((HistoryRecord)objHis[0]);
-                    }                               
+                logger.debug("Retrieving query results: 1 - "+ to);
+                setCurrentDisplayRows(from+ "-" + to);                              	 
+                // Retrieve selected row interval 
+            	Object[] objectHistory;
+             	try {
+             		objectHistory = database.more(this.resultId, 0, to-1);  
+             	} catch(RemoteException e) {
+             		logger.error("Remote exception caught in History (processResult). Details: "+e.getMessage());
+        			setError(ERROR_SEARCH_DATA);
+        			setChanged();
+                    notifyObservers();
+                 	return;                                                                                       
                 } catch (DBLayerException e) {                  
-                    logger.error("Processing search results failed: "+e.toString());   
-                    setError(this.ERROR_PROCESS);
-                }    
-                // Update current first displayed row (only if data retrieval was successful).
-                if (!this.isError()) {
-                    logger.info("Results successfuly retrieved");                   
-                    setCurrentFirstRow(from);
+                    logger.error("Processing search results failed: " + e.getMessage());   
+                    setError(ERROR_PROCESS);
+                    setChanged();
+                    notifyObservers();
+                    return;
+                }  
+                if (objectHistory == null) {
+                	logger.error("tHistoryChange doesn`t contain required data");
+                	setError(ERROR_PROCESS);
+                    setChanged();
+                    notifyObservers();
+                    return;
                 }
-            }
-            // Tell observers to update
-            setChanged();
-            notifyObservers();
-            // Clean error flag 
-            this.error = null;
+                int countResult = objectHistory.length;  
+                logger.debug("Results retrieved. Count: "+ countResult);                
+                this.historyDataList = new ArrayList<HistoryRecord>();
+                // Cast the results to the HistoryRecord objects
+                for (int i=0; i<countResult; i++ ) {                    							
+					Object[] objHis = (Object[])objectHistory[i];
+                    this.historyDataList.add((HistoryRecord)objHis[0]);
+                    logger.debug("RESULT: " + ((HistoryRecord)objHis[0]).getId());
+                }
+               
+                // Update current first displayed row                
+                logger.info("Results successfuly retrieved");                   
+                setCurrentFirstRow(from);
+            }                        
          }         
     }
     
@@ -397,7 +414,8 @@
         initMetadataHash();
         	    	
     	//read record from younger to older until selected row        
-    	for( int i=0; i < toResult; i++) {    		
+    	for( int i=0; i < toResult; i++) {    
+    		if (isError()) return;
     		//init history data 
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
@@ -432,9 +450,8 @@
     	
     	//take record from younger to older
     	for( int i=0; i < countResult; i++) {
-    		if (! markListId.contains(i)) {
-    			continue;
-    		}
+    		if (isError())return;
+    		if (! markListId.contains(i)) continue;    		
     		
     		// init history data about editing concerned with record
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
@@ -454,10 +471,11 @@
      *   @param isDelete int containing informaciton about insertion or erasure of record. 
      */
     public void undoInsertDelete(int isDelete) {
-        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)){
-             Object[] object = searchObject("Occurrence",recordId);             
-             Occurrence occurrence = (Occurrence)object[0];             
-             occurrence.setDeleted(isDelete);              
+        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)){        	
+        	Object[] object = searchObject("Occurrence",recordId);        	        	
+        	if (isError()) return; //tOccurrence doesn`t contain required data        	       		        		
+        	Occurrence occurrence = (Occurrence)object[0];             
+            occurrence.setDeleted(isDelete);                      	     	 
              //Add to list of changed Record
              if (!editObjectList.contains((Record)occurrence))                 
                 editObjectList.add((Record)occurrence);       
@@ -474,7 +492,8 @@
                     editObjectList.add((Record)authorOccurrence);                 
             }                                     
         } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {
-             Object[] object = searchObject("AuthorOccurrence",recordId);  
+             Object[] object = searchObject("AuthorOccurrence",recordId);               
+             if (isError()) return; //tAuthorOccurrence doesn`t contain required data
              AuthorOccurrence authorOccurrence = (AuthorOccurrence)object[0];
              authorOccurrence.setDeleted(isDelete);             
              //Add to list of changed Record             
@@ -482,28 +501,31 @@
                 editObjectList.add((Record)authorOccurrence);             
        } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {            
                Object[] object = searchObject("Habitat",recordId);  
+               if (isError()) return; //tHabitat doesn`t contain required data
                Habitat habitat = (Habitat)object[0];
                habitat.setDeleted(isDelete);
                //Add to list of changed Record             
                if (!editObjectList.contains((Record)habitat))                 
                    editObjectList.add((Record)habitat);             
         } else if (tableName.equals(PlantloreConstants.ENTITY_METADATA)) {
-             Object[] object = searchObject("Metadata",recordId);  
+             Object[] object = searchObject("Metadata",recordId); 
+             if (isError()) return; //tMetadata doesn`t contain required data
              Metadata metadata = (Metadata)object[0];
              metadata.setDeleted(isDelete);
              //Add to list of changed Record             
              if (!editObjectList.contains((Record)metadata))                 
                 editObjectList.add((Record)metadata);             
         } else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
-             Object[] object = searchObject("Publication",recordId);  
+             Object[] object = searchObject("Publication",recordId);
+             if (isError()) return; //tPublication doesn`t contain required data
              Publication publication = (Publication)object[0];
              publication.setDeleted(isDelete);
              //Add to list of changed Record             
              if (!editObjectList.contains((Record)publication))                 
                 editObjectList.add((Record)publication);             
-        } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOR)) {
-             logger.debug("AUTHOR HISTORY: "+ isDelete);
-             Object[] object = searchObject("Author",recordId);   
+        } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOR)) {             
+             Object[] object = searchObject("Author",recordId);  
+             if (isError()) return; //tAuthor doesn`t contain required data
              Author author = (Author)object[0];
              author.setDeleted(isDelete);
              //Add to list of changed Record             
@@ -521,7 +543,7 @@
         
         //init history data about editing concerned with record
         columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
-        oldRecordId = historyChange.getOldRecordId();                        	           
+        oldRecordId = historyRecord.getOldRecordId();                        	           
         oldValue = historyRecord.getOldValue();
         
         if (tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {
@@ -573,6 +595,7 @@
     	if (!contain) {
         	// Select record AuthorOccurrence where id = authorOccurrenceId 
     		Object[] object = searchObject("AuthorOccurrence", authorOccId);
+    		if (isError()) return; //tAuthorOccurrence doesn`t contain required data
             authorOccurrence = (AuthorOccurrence)object[0];
         }     	                 
                 
@@ -646,6 +669,7 @@
         if (!contain) {
         	// Select record Occurrence where id = occurrenceId 
             Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+            if (isError()) return; //tOccurrence doesn`t contain required data
             occ = (Occurrence)objectOcc[0];                    	
         }    
                 
@@ -665,6 +689,7 @@
             if (oldRecordId > 0 ) {
                 //Select record Plant where id = oldRocordId 
                 Object[] object = searchObject("Plant",oldRecordId);
+                if (isError()) return; //tPlant doesn`t contain required data
                 Plant plant = (Plant)object[0];
                 //Set old value to attribute plantID
                 occ.setPlant(plant);
@@ -708,6 +733,7 @@
                         time = df.parse( oldValue );
                 } catch (ParseException e) {
                         logger.error("Parse time failed. "+ e);
+                        setError(ERROR_PARSE_DATE);
                 }
                 occ.setTimeCollected(time);
                 logger.debug("Set selected value for update of attribute Time.");
@@ -735,6 +761,7 @@
                 //Select record Publication where id = oldRocordId 
                 if (oldRecordId > 0){
                     Object[] objectPubl = searchObject("Publication",oldRecordId);
+                    if (isError()) return; //tPublication doesn`t contain required data
                     Publication publication = (Publication)objectPubl[0];
                     //Set old value to attribute publicationID
                     occ.setPublication(publication);
@@ -747,6 +774,7 @@
         		//Select record Publication where id = oldRocordId 
 	            if (oldRecordId > 0){
 	                Object[] objectMetadata = searchObject("Metadata",oldRecordId);
+	                if (isError()) return; //tMetadata doesn`t contain required data
 	                Metadata metadata = (Metadata)objectMetadata[0];
 	                //Set old value to attribute metadataID
 	                occ.setMetadata(metadata);
@@ -759,6 +787,7 @@
         		//Select record Publication where id = oldRocordId 
 	            if (oldRecordId > 0){
 	                Object[] objectHabitat = searchObject("Habitat",oldRecordId);
+	                if (isError()) return; //tHabitat doesn`t contain required data
 	                Habitat habitat = (Habitat)objectHabitat[0];
 	                //Set old value to attribute habitatID
 	                occ.setHabitat(habitat);
@@ -783,8 +812,8 @@
     /**
      * Rollback data editing concerned with specific habitat
      */
-    public void undoHabitat() {
-                         
+    public void undoHabitat() {            	
+    	
         int habitatId = historyChange.getRecordId();	        
         Habitat hab = null;
     	int placings = 0;
@@ -803,7 +832,8 @@
     	
     	if (!contain) {
         	// Select record Habitat where id = habitatId 
-    		Object[] object = searchObject("Habitat",habitatId);        
+    		Object[] object = searchObject("Habitat",habitatId);
+    		if (isError()) return; //tHabitat doesn`t contain required data
             hab = (Habitat)object[0];
         } 
                              
@@ -845,6 +875,7 @@
                 //Select record Village where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectVill = searchObject("Village",oldRecordId);
+                        if (isError()) return; //tVillage doesn`t contain required data
                         Village village = (Village)objectVill[0];
                 hab.setNearestVillage(village);
                 logger.debug("Set selected value for update of attribute NearesVillage.");
@@ -856,6 +887,7 @@
                 // Select record Phytochoria where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectPhyt = searchObject("Phytochorion",oldRecordId);
+                        if (isError()) return; //tPhytochorion doesn`t contain required data
                         Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
                         hab.setPhytochorion(phytochorion);
                         logger.debug("Set selected value for update of attribute Phytochorion.");
@@ -867,8 +899,9 @@
                 // Select record Territory where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectTerr = searchObject("Territory",oldRecordId);
+                        if (isError()) return; //tTerritory doesn`t contain required data
                         Territory territory = (Territory)objectTerr[0];
-                        hab.setTerritory(territory);
+                        hab.setTerritory(territory);                                                            
                         logger.debug("Set selected value for update of attribute Territory.");
                 }else {
                         logger.error("UNDO - Incorrect oldRecordId for Territory.");
@@ -915,6 +948,7 @@
     	if (!contain) {
         	// Select record Publication where id = publicationId 
     		Object[] object = searchObject("Publication", publicationId);
+    		if (isError()) return; //tPublication doesn`t contain required data
             publication = (Publication)object[0];
         } 
             	        
@@ -993,6 +1027,7 @@
     	if (!contain) {
         	// Select record Author where id = authorId 
     		Object[] object = searchObject("Author", authorId);
+    		if (isError()) return; //tAuthor doesn`t contain required data
             author = (Author)object[0];
         } 	
        
@@ -1066,7 +1101,7 @@
     			if (metadataId == listOccId) {
     				contain = true;
     				placings = i; 
-    				author = (Author)(editObjectList.get(i));
+    				metadata = (Metadata)(editObjectList.get(i));
     				break;
     			}
     		}
@@ -1075,6 +1110,7 @@
     	if (!contain) {
         	// Select record Metadata where id = metadataId 
     		Object[] object = searchObject("Metadata", metadataId);
+    		if (isError()) return; //tMetadata doesn`t contain required data
     	    metadata = (Metadata)object[0];
         }
     	
@@ -1178,6 +1214,7 @@
     	if (!contain) {
         	// Select record Phytochorion where id = phytochorionId 
     		Object[] object = searchObject("Phytochorion", phytId);
+    		if (isError()) return; //tPhytochorion doesn`t contain required data
             phytochorion = (Phytochorion)object[0];     
         }
     	
@@ -1224,6 +1261,7 @@
     	if (!contain) {
         	// Select record Village where id = villageId 
     		Object[] object = searchObject("Village", villageId);
+    		if (isError()) return; //tVillage doesn`t contain required data
             village = (Village)object[0];     
         }
        
@@ -1268,6 +1306,7 @@
     	if (!contain) {
         	// Select record Territory where id = territoryId 
     		Object[] object = searchObject("Territory", territoryId);
+    		if (isError()) return; //tTerritory doesn`t contain required data
     		territory = (Territory)object[0];     
         }
     	        
@@ -1291,7 +1330,7 @@
      * 
      * @param typeObject string containing information about type of object
      * @param id int containing identifier of record
-     * @return object defined by parameters typeObject and id
+     * @return object[] array of object defined by parameters typeObject and id
      */
     public Object[] searchObject(String typeObject, int id) {       
     	SelectQuery query = null;
@@ -1349,22 +1388,22 @@
             setChanged();
             notifyObservers();
         }
-       
-        //TODO
+              
 	   if (object == null) {
 		   logger.error("t"+typeObject+ " doesn't contain required data");  
 		   setError(ERROR_SEARCH_OBJECT);		   
 		   //Tell observers to update
            setChanged();
-           notifyObservers();
-	   } 	   
+           notifyObservers();           
+	   } 	 
        return object; 	       	          	              	        
     }
     
     /**     
      * Seach all authors concerned with specific occurrence
-     * @param occurrence 
-     * @param idDelete 
+     * @param occurrence specific occurrence
+     * @param idDelete int containing information about type of author - active, inactive
+     * @return object[] names of authors for specific occurrence
      */
     public Object[] getAllAuthors(Occurrence occurrence, int isDelete) {        
         
@@ -1397,22 +1436,14 @@
             setChanged();
             notifyObservers();
         }     
-        
-        //TODO
-        if(objects == null ) {
-        	logger.error("tAuthorOccurrence doesn't contain required data");  
- 		    setError(ERROR_SEARCH_AUTHOR);
- 		    //Tell observers to update
-            setChanged();
-            notifyObservers();
-        }
-        
+               
        return objects;
     }
     
     /**
      *  Get names of authors for specific occurrence
      *  @param objects  
+     *  @return String containing names of authors for specific occurrence
      */
     public String getAllNameOfAuthors(Object[] objects) {
         if (objects == null)
@@ -1440,7 +1471,8 @@
         Enum key;
         initEditTypeHash();
         
-    	int count = editObjectList.size();        
+    	int count = editObjectList.size();
+              	
     	for (int i=0; i< count; i++) {
     		try {
     			logger.debug("Object for update: "+ ((Record)editObjectList.get(i)).getId());                         
@@ -1457,13 +1489,15 @@
 	       	    //Tell observers to update
 	            setChanged();
 	            notifyObservers();
+	            return;
 	        } catch (DBLayerException e) {
 	        	logger.error("Update data failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
 	            setError(ERROR_UPDATE); 
 	            //Tell observers to update
 	            setChanged();
 	            notifyObservers();
-	        }                
+	            return;
+	        } 
        }    	
     	//Create array of editing object and call notifyObservers
         informMethod(editType);
@@ -1471,7 +1505,7 @@
     
     /**
      *  Create array of editing object and give this array to parrent
-     *  @param editType
+     *  @param editType containing list of type of editing object 
      */
     public void informMethod(ArrayList<Enum> editType) {
         int count = editType.size();
@@ -1493,8 +1527,8 @@
        
     /**
      * Delete selected data from history table. During delete data from table tHistoryChange verify foring key from table tHistory.
-     * @param toResult
-     * @param typeHistory
+     * @param toResult identifier of the oldest changes which will be restored
+     * @param typeHistory containing information about type of history (whole history or history of record)
      */
     public void deleteHistory(int toResult, boolean typeHistory) {
    	
@@ -1553,7 +1587,7 @@
     /**
      * Get number of record from tHistory, whitch has the value of attribute cChangeId equals id
      * @param id identifier of historyChange record 
-     * @return int number of record from tHistory, whitch has the value of attribute cChangeId equals id
+     * @return int number of record from tHistory, where attribute cChangeId is equaled prameter "id"
      */
     public int getRelationshipHistoryChange(int id){    	
     	SelectQuery query = null;
@@ -1591,7 +1625,7 @@
     	for (int i=0; i<count; i++) {
     		Object[] itemList = (Object[])(markItem.get(i));
     		String item = (String)itemList[0];
-    		Integer maxId = (Integer)itemList[1];      		
+    		Integer maxId = (Integer)itemList[1];      		      		
     		oldValue = ((HistoryRecord)historyDataList.get(maxId)).getOldValue(); 
     		messageUndo = messageUndo + item + "  -->  " + oldValue + "\n";
     	}       
@@ -1608,8 +1642,9 @@
     }
     
     /**
-     *  Create message containing details about record
-     *  @param resultNumber 
+     *  Create message containing details of record
+     *  @param resultNumber identifier of selected record
+     *  @return String containing details of record 
      */
     public String getDetailsMessage(int resultNumber) {
         
@@ -1627,6 +1662,7 @@
               int occurrenceId = historyChange.getRecordId();
               //Select record Occurrence where id = occurrenceId 
               Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+              if (isError()) return ""; //tOccurrence doesn`t contain required data
               Occurrence occurrence = (Occurrence)objectOcc[0]; 
               detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE + "."+ Occurrence.PLANT) + ": "+ occurrence.getPlant().getTaxon()+"\n";
@@ -1646,17 +1682,19 @@
         }else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
         	  //Get details for Publication
               Object[] object = searchObject("Habitat",recordId);
+              if (isError()) return ""; //tHabitat doesn`t contain required data
               Habitat habitat = (Habitat)object[0];
               detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NEARESTVILLAGE) + ": "+ occurrence.getHabitat().getNearestVillage().getName() + "\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.DESCRIPTION) + ": "+ occurrence.getHabitat().getDescription() + "\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.TERRITORY) + ": "+ occurrence.getHabitat().getTerritory().getName() + "\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.PHYTOCHORION) + ": "+ occurrence.getHabitat().getPhytochorion().getName() +" (Code: " + occurrence.getHabitat().getPhytochorion().getCode() + ")\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.COUNTRY) + ": " + occurrence.getHabitat().getCountry() +"\n";
-              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + occurrence.getHabitat().getNote() +"\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NEARESTVILLAGE) + ": "+ habitat.getNearestVillage().getName() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.DESCRIPTION) + ": "+ habitat.getDescription() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.TERRITORY) + ": "+ habitat.getTerritory().getName() + "\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.PHYTOCHORION) + ": "+ habitat.getPhytochorion().getName() +" (Code: " + habitat.getPhytochorion().getCode() + ")\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.COUNTRY) + ": " + habitat.getCountry() +"\n";
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + habitat.getNote() +"\n";
     	}else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
               //Get details for Publication
-              Object[] object = searchObject("Publication",recordId); 
+              Object[] object = searchObject("Publication",recordId);
+              if (isError()) return ""; //tPublication doesn`t contain required data
               Publication publication = (Publication)object[0];
               detailsMessage = L10n.getString("History.DetailsPublication") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PUBLICATION +"."+ Publication.COLLECTIONNAME) + ": " + publication.getCollectionName() + "\n";
@@ -1667,7 +1705,8 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PUBLICATION +"."+ Publication.NOTE) + ": " + publication.getNote() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOR)) {
               //Get details for Author
-              Object[] object = searchObject("Author",recordId);   
+              Object[] object = searchObject("Author",recordId); 
+              if (isError()) return ""; //tAuthor doesn`t contain required data
               Author author = (Author)object[0];
               detailsMessage = L10n.getString("History.DetailsAuthor") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_AUTHOR +"."+ Author.WHOLENAME)+ ": " + author.getWholeName() + "\n";
@@ -1680,7 +1719,8 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_AUTHOR +"."+ Author.NOTE)+ ": "  + author.getNote() + "\n";
         }  else if (tableName.equals(PlantloreConstants.ENTITY_METADATA)) {
              //Get details for Metadata
-              Object[] object = searchObject("Metadata",recordId);   
+              Object[] object = searchObject("Metadata",recordId); 
+              if (isError()) return ""; //tMetadata doesn`t contain required data
               Metadata metadata = (Metadata)object[0];
               detailsMessage = L10n.getString("History.DetailsMetadata") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString("History.DetailsMetadata.Institution") + "\n";
@@ -1705,19 +1745,22 @@
         } else if (tableName.equals(PlantloreConstants.ENTITY_PHYTOCHORION)) {
               //Get details for Phytochorion
               Object[] object = searchObject("Phytochorion",recordId); 
+              if (isError()) return ""; //tPhytochorion doesn`t contain required data
               Phytochorion  phytochorion = (Phytochorion)object[0];
               detailsMessage = L10n.getString("History.DetailsPhytochorion") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PHYTOCHORION +"."+ Phytochorion.NAME) + ": " + phytochorion.getName() + "\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PHYTOCHORION +"."+ Phytochorion.CODE) + ": " + phytochorion.getCode() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_TERRITORY)) {
               //Get details for Territory
-              Object[] object = searchObject("Territory",recordId); 
+              Object[] object = searchObject("Territory",recordId);
+              if (isError()) return ""; //tTerritory doesn`t contain required data
               Territory territory = (Territory)object[0];
               detailsMessage = L10n.getString("History.DetailsTerritory") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_TERRITORY +"."+ Territory.NAME) + ": " + territory.getName() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_VILLAGE)) {
               //Get details for Village
-              Object[] object = searchObject("Village",recordId);  
+              Object[] object = searchObject("Village",recordId);
+              if (isError()) return ""; //tVillage doesn`t contain required data
               Village village = (Village)object[0];
               detailsMessage = L10n.getString("History.detailsVillage") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_VILLAGE +"."+ Village.NAME) + ": " + village.getName() + "\n";
@@ -1731,76 +1774,175 @@
     }
     
     /**
-     *  Delete all date from tables tHistorz and tHistoryChange
+     *  Delete all date from tables tHistory and tHistoryChange
      */
     public void clearHistory() {        
         
+    	//TODO uzavrit to do dlouhotrvajici transakce
         try {
             //delete data from table tHistory
             database.conditionDelete(HistoryRecord.class, HistoryRecord.ID, ">", 0);
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        }
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tHistory failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_HISTORY);       	   
+            setChanged();
+            notifyObservers();    
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tHistory failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_HISTORY);            
+            setChanged();
+            notifyObservers(); 
+            return;
+        }        
         
         try {            
             //delete data from  table tHistoryChange
             database.conditionDelete(HistoryChange.class, HistoryChange.ID, ">", 0);
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        }
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tHistoryChange failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_HISTORY);       	   
+            setChanged();
+            notifyObservers();  
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tHistoryChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_HISTORY);            
+            setChanged();
+            notifyObservers();
+            return;
+        }        
         
     }
     
     /**
-     * Delete all record with cdelete equals 1 from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications
+     * Delete records from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications with condition cdelete == 1 
      */
     public void clearDatabase() {
+    	
+    	//TODO - osetrit proti smazani zaznamu na ktery existuje FK
+    	//Uzavrit to do dlouho trvajici transakce, at se to provede bud vse nebo nic 
+    	
         try {
-            
+            // delete data from table tAuthor with contidion cDelete == 1
             database.conditionDelete(Author.class, Author.DELETED, "=", 1);
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        }
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tAuthor failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_DATABASE);       	   
+            setChanged();
+            notifyObservers();   
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tAuthor failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_DATABASE);            
+            setChanged();
+            notifyObservers();  
+            return;
+        }        
         try {
-            database.conditionDelete(AuthorOccurrence.class, AuthorOccurrence.DELETED, "=", 1);
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        }
+        	//delete data from table tAuthorOccurrence with contidion cDelete > 0
+            database.conditionDelete(AuthorOccurrence.class, AuthorOccurrence.DELETED, ">", 0);
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tAuthorOccurrence failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_DATABASE);       	   
+            setChanged();
+            notifyObservers();
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tAuthorOccurrence failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_DATABASE);            
+            setChanged();
+            notifyObservers();
+            return;
+        }        
         try {
+        	// delete data from table tOccurrence with contidion cDelete == 1
             database.conditionDelete(Occurrence.class, Occurrence.DELETED, "=", 1);
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        }
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tOccurrence failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_DATABASE);       	   
+            setChanged();
+            notifyObservers();
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tOccurrence failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_DATABASE);            
+            setChanged();
+            notifyObservers();
+            return;
+        }        
         try {
+        	// delete data from table tHabitat with contidion cDelete == 1
             database.conditionDelete(Habitat.class, Habitat.DELETED, "=", 1);
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        }
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tHabitat failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_DATABASE);       	   
+            setChanged();
+            notifyObservers();
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tHabitat failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_DATABASE);            
+            setChanged();
+            notifyObservers();
+            return;
+        }        
         try {
+        	// delete data from table tPublication with contidion cDelete == 1
             database.conditionDelete(Publication.class, Publication.DELETED, "=", 1);
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
+        } catch (RemoteException e) {
+        	logger.error("Delete data from tPublication failed.Remote exception caught in History. Details: "+e.getMessage());
+       	    setError(ERROR_CLEAR_DATABASE);       	   
+            setChanged();
+            notifyObservers();
+            return;
+        } catch(DBLayerException e) {
+        	logger.error("Delete data from tPublication failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+            setError(ERROR_CLEAR_DATABASE);            
+            setChanged();
+            notifyObservers();
+            return;
+        }        
+    }
+    
+    /**
+     * Check right for working with history of the record 
+     * @param createWhoId identifier of user who inserted the record into database
+     * @return true if user has right to work with history of record
+     */
+    public boolean hasRights(Integer createWhoId) {
+        String[] group;     
+        try {
+            // Administrator can work with history of any record
+            if (database.getUserRights().getAdministrator() == 1) {
+                return true;                        
+            } else { 
+                // Check whether the user can work with history of all the records
+                if (database.getUserRights().getEditAll() == 1) {
+                    return true;
+                }
+                // Check whether the user can work with history of the record through some other user
+                group = database.getUserRights().getEditGroup().split(",");                
+                // Check whether someone in the group is an owner of the publication
+                for (int i=0;i<group.length;i++) {
+                    if (createWhoId.toString().equals(group[i])) {
+                        return true;
+                    }
+                }
+                // No rights to work with history of the record
+                return false;
+            }
+        } catch (RemoteException e) {
+        	logger.error("GetUserRight() failed. Remote exception caught in History. Details: "+e.getMessage());       	                
         }
+        return false;
     }
     
      //***************************//
     //****Init Hashtable*********//
     //**************************//
     
+    /** Init hash table for AuthorOccurence */
     private void initAuthorsOccurrenceHash() {
         authorsOccurrenceHash = new Hashtable<String, Integer>(3);
         authorsOccurrenceHash.put(AuthorOccurrence.AUTHOR, 1);
@@ -1808,6 +1950,7 @@
         authorsOccurrenceHash.put(AuthorOccurrence.NOTE, 3);
     }
     
+    /** Init hash table for Occurence */
     private void initOccurrenceHash() {
     	occurrenceHash = new Hashtable<String, Integer>(10); 
         occurrenceHash.put(Occurrence.PLANT, 1);
@@ -1823,6 +1966,7 @@
         occurrenceHash.put(Occurrence.HABITAT, 11);
     }    
     
+    /** Init hash table for Habitat */
     private void initHabitatHash() {
     	habitatHash = new Hashtable<String, Integer>(11);         
         habitatHash.put(Habitat.QUADRANT, 1);
@@ -1838,6 +1982,7 @@
         habitatHash.put(Habitat.NOTE, 10);
     }    
     
+    /** Init hash table for Metadata */
     private void initMetadataHash() {
         metadataHash = new Hashtable<String, Integer>(16);
         metadataHash.put(Metadata.TECHNICALCONTACTNAME, 1);
@@ -1855,6 +2000,7 @@
         metadataHash.put(Metadata.BIOTOPETEXT, 13);        
     }
     
+    /** Init hash table for Publication */
     private void initPublicationHash() {
         publicationHash = new Hashtable<String, Integer>(6);
         publicationHash.put(Publication.COLLECTIONNAME, 1);
@@ -1865,6 +2011,7 @@
         publicationHash.put(Publication.URL, 6);      
     }
     
+    /** Init hash table for Author */
     private void initAuthorHash() {
         authorHash = new Hashtable<String, Integer>(7);
         authorHash.put(Author.WHOLENAME, 1);        
@@ -1876,6 +2023,7 @@
         authorHash.put(Author.NOTE, 7);        
     }              
     
+    /** Init hash table for editing object*/
     private void initEditTypeHash() {
         editTypeHash = new Hashtable<String, Enum>(5);
         editTypeHash.put("Occurrence", PlantloreConstants.Table.OCCURRENCE);                
@@ -1903,7 +2051,7 @@
     
     /**
      *  Checks whether an error flag is set.
-     *  return true if an error occured and error message is available, false otherwise
+     *  @return true if an error occured and error message is available, false otherwise
      */
     public boolean isError() {
         if (this.error != null) {
@@ -1919,18 +2067,10 @@
      */
     public String getError() {
         return this.error;
-    }
+    }    
     
-    
-    public Object getData() {
-    	return data;
-    }
-    
-    public void setData(Object data) {
-    	this.data = data;
-    }
-    
     /**
+     * Get information about selecting of all record
      * @return true if all recorda were selected.
      */
     public boolean getSelectAll() {
@@ -1938,74 +2078,158 @@
 	   }
 
     /**
-     * Set information if all records were selected. 
-     * @param selectAll
+     * Set information if all records were selected 
+     * @param selectAll true if all records were selected
      */
 	 public void setSelectAll(boolean selectAll) {
 		  this.selectAll = selectAll;		  
 	 } 
+
+    /**
+     * Get information about unselecting of all record
+     * @return true if all recorda were unselected.
+     */
+    public boolean getUnselectedAll() {
+		  return this.unselectedAll;		  
+	   }
+
+    /**
+     * Set information if all records were unselected 
+     * @param unselectedAll true if all records were unselected
+     */
+	 public void setUnselectedAll(boolean unselectedAll) {
+		  this.unselectedAll = unselectedAll;		  
+	 } 
+	 
+	/**
+	 * Get object whitch history of changes is displayed (Habitat or Occurrence) 
+	 * @return object whitch history of changes is displayed (Habitat or Occurrence)
+	 */ 
+    public Object getData() {
+    	return data;
+    }
+       
+    /**
+     * Set object whitch history of changes is displayed (Habitat or Occurrence)
+     * @param data object whitch history of changes is displayed (Habitat or Occurrence)
+     */
+    public void setData(Object data) {
+    	this.data = data;
+    }	
     
+    /**
+     * Get list of identifiers of selected items (history of record)
+     * @return list of identifiers of selected items (history of record)
+     */
 	 public HashSet getMarkListId() {
 		  return this.markListId;		  
 	   }
 
+	 /**
+	  * Set list of identifiers of selected items (history of record)
+	  * @param markListId list of identifiers of selected items (history of record)
+	  */
 	 public void setMarkListId(HashSet markListId) {
 		  this.markListId = markListId;		  
 	 } 
-	 
+	
+	 /**
+	  * Get list of pairs (Item, identifier of the oldest change of this Item
+	  * @return list of pairs (Item, identifier of the oldest change of this Item
+	  */
     public ArrayList<Object[]> getMarkItem() {
 		  return this.markItem;		  
 	   }
 
+    /**
+     * Set list of pairs (Item, identifier of the oldest change of this Item
+     * @param markItem list of pairs (Item, identifier of the oldest change of this Item
+     */
 	 public void setMarkItem(ArrayList<Object[]> markItem) {
 		  this.markItem = markItem;		  
 	 } 
+	 
+	 /**
+	  * Get results of a search query for dislpaying in history dialog
+	  * @return results of a search query for dislpaying in history dialog
+	  */
+	 public ArrayList<HistoryRecord> getHistoryDataList() {
+         return this.historyDataList;		  
+     }
+
+	 /**
+	  * Set results of a search query for dislpaying in history dialog
+	  * @param historyDataList results of a search query for dislpaying in history dialog
+	  */
+	public void setHistoryDataList(ArrayList<HistoryRecord> historyDataList) {
+	         this.historyDataList = historyDataList;		  
+	} 
+	
+	/**
+	 * Get information about current display rows
+	 * @return information about current display rows
+	 */
+	public String getCurrentDisplayRows() {
+		  return this.displayRow;		  
+	  }
+	
+	/**
+	 * Set information about current display rows
+	 * @param displayRow information about current display rows
+	 */
+	public void setCurrentDisplayRows(String displayRow) {
+	         this.displayRow = displayRow;		  
+	} 
+	
+	/**
+	 * Get message with information for user
+	 * @return message with information for user
+	 */
+	public String getMessageUndo() {
+		  return this.messageUndo;		  
+	  }
+	
+	/**
+	 * Set message with information for user
+	 * @param messageUndo message with information for user
+	 */
+	public void setMessageUndo(String messageUndo) {
+	         this.messageUndo = messageUndo;		  
+	} 
+
     
-    
-    //id vysledku po vyhledavani v db
+	 /**
+	  * Set result of a database operation. This is used only for search operations.
+      * @param resultId id of the SelectQuery result	  
+	  */
     public void setResultId(int resultId) {
         this.resultId = resultId;
     }
     
+    /**
+     *  Get results of last database operation. This is used only for search operations.
+     *  @return resultId identifying the SelectQuery result
+     */
     public int getResultId() {
         return this.resultId;
     }
     
+    /**
+     * Get the number of results for the current SelectQuery
+     * @return number of results for the current SelectQuery
+     */
     public int getResultRows() {
         int resultCount = 0;
         if (resultId != 0) try {
-                resultCount = database.getNumRows(resultId);        	
+             resultCount = database.getNumRows(resultId);        	
         } catch(RemoteException e) {
-                System.err.println("Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException");
+        	logger.error("Get number of results failed.Remote exception caught in History. Details: "+e.getMessage());  
+        	setError(ERROR_NUMBER_ROWS);
         }
         return resultCount;
     }
-
-    public ArrayList<HistoryRecord> getHistoryDataList() {
-              return this.historyDataList;		  
-       }
-
-     public void setHistoryDataList(ArrayList<HistoryRecord> historyDataList) {
-              this.historyDataList = historyDataList;		  
-     } 
-    
-     public String getCurrentDisplayRows() {
-		  return this.displayRow;		  
-	   }
-
-     public void setCurrentDisplayRows(String displayRow) {
-              this.displayRow = displayRow;		  
-     } 
-     
-     public String getMessageUndo() {
-		  return this.messageUndo;		  
-	   }
-
-     public void setMessageUndo(String messageUndo) {
-              this.messageUndo = messageUndo;		  
-     } 
-     
-         /**
+        
+     /**
      *  Get index of the first row currently displayed in the list of record changes. This is an index in the results returned by a search query.
      *  @return index of the first row currently displayed in the list of history
      */
@@ -2037,26 +2261,50 @@
         this.displayRows = rows;
     }
     
+    /**
+     * Get name of the plant
+     * @return name of the plant
+     */
     public String getNamePlant() {
 		  return this.namePlant;
 	   }
 
+    /**
+     * Set name of the plant
+     * @param namePlant name of the plant
+     */
     public void setNamePlant(String namePlant) {
 		  this.namePlant = namePlant;
 	}   
     
+    /**
+     * Get name of the author
+     * @return name of the author
+     */
     public String getNameAuthor() {
 		  return this.nameAuthor;
 	   }
 
+    /**
+     * Set name of the author
+     * @param nameAuthor name of the author
+     */
 	 public void setNameAuthor(String nameAuthor) {
 		  this.nameAuthor = nameAuthor;
 	 } 
 	 
+	 /**
+	  * Get name of the nearest village where the record was found 
+	  * @return name of the nearest village where the record was found
+	  */
 	 public String getLocation() {
 		  return this.location;
 	   }
-	
+	 
+	/**
+	 * Set name of the nearest village where the record was found
+	 * @param location name of the nearest village where the record was found 
+	 */
 	 public void setLocation(String location) {
 		  this.location = location;
 	}    

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -1,34 +1,39 @@
-/**
- * 
- */
+
 package net.sf.plantlore.client.history;
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-import java.util.ArrayList;
-import net.sf.plantlore.common.PlantloreHelp;
-
-
-
 import org.apache.log4j.Logger;
 
 /**
- * @author Lada
+ * Controller for the main History dialog (part of the History MVC).
+ * 
+ * @author Lada Oberreiterova
+ * @version 1.0
  *
  */
 public class HistoryCtrl {
 
+	/** Instance of a logger */
 	private Logger logger;
+	/** Model of the History MVC */
     private History model;
+    /** View of the History MVC */
     private HistoryView view;
     
-    /** Creates a new instance of HistoryCtrl */
+    /** 
+     *  Creates a new instance of HistoryCtrl 
+     *  @param model model of the History MVC
+     *  @param view  view of the History MVC
+     * 
+     */
     public HistoryCtrl(History model, HistoryView view)
-    {
+    {    	
         logger = Logger.getLogger(this.getClass().getPackage().getName());        
-        this.model = model;
+        this.model = model;        
         this.view = view;
              
+        //Add action listeners to buttons
         view.okButton.addActionListener(new okButtonListener());
         view.closeButton.addActionListener(new closeButtonListener());
         view.previousButton.addActionListener(new previousButtonListener());
@@ -39,9 +44,9 @@
         view.toDisplayValueTextField.addActionListener(new rowSetDisplayChangeListener());           
     }
     
-        /** 
-    * On Ok makes the model store() the preferences and hides the view.
-    * 
+   /** 
+    * ActionListener class controlling the <b>OK</b> button on the form.
+    * On Ok makes the model store() the preferences and hides the view.     
     */
    class okButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
@@ -51,8 +56,8 @@
    }
   
    /**
-    * On Cancel just hides the view.
-    *
+    * ActionListener class controlling the <b>CLOSE</b> button on the form.
+    * On Close hides the view.
     */
    class closeButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
@@ -62,45 +67,60 @@
    }
    
    /**
-    * 
-    *
+    *  ActionListener class controlling the <b>PREV</b> button on the form.
+    *  The button PREV is used for browsing the search results.
     */
    class previousButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {
-    	   //   Call processResults only if we don't see the first page (should not happen, button should be disabled)
-    	   logger.debug("FIRST");
-    	   logger.debug("current first row: "+model.getCurrentFirstRow());
-           logger.debug("num rows in the result: "+ model.getResultRows());            
-           logger.debug("display rows: "+ view.getTable().getRowCount());      
+       {    	  
+    	   // Check whether an error flag is set
+           if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Get previous page of results
            if (model.getCurrentFirstRow() > 1) {
                int firstRow = Math.max(model.getCurrentFirstRow()- model.getDisplayRows(), 1);
                model.processResult(firstRow, model.getDisplayRows()); 
+               if (model.isError()) return;
                if (model.getCurrentFirstRow() > 1){
                }
                view.getTable().setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
                view.setCurrentRowsInfo(from + "-" + to);
-           }                           
+           }      
+           //Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.getTable().getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }
    }
    
    /**
-    * 
-    *
+    * ActionListener class controlling the <b>NEXT</b> button on the form.
+    * The button NEXT is used for browsing the search results.    
     */
    class nextButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
-    	   //Call processResults only if we don't see the last page
-    	   logger.debug("NEXT");
-           logger.debug("current first row: "+model.getCurrentFirstRow());
-           logger.debug("num rows in the result: "+ model.getResultRows());            
-           logger.debug("display rows: "+ model.getDisplayRows());
-           logger.debug("num rows in table (view) "+ view.getTable().getRowCount());              
+    	   // Check whether an error flag is set 
+           if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Get next page of result
            if (model.getCurrentFirstRow()+ view.getTable().getRowCount()<=model.getResultRows()) {
                model.processResult(model.getCurrentFirstRow()+ model.getDisplayRows(), view.getTable().getRowCount());
+               if (model.isError()) return;
                view.getTable().setModel(new HistoryTableModel(model));             
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
@@ -109,78 +129,114 @@
                }else {
             	   view.setCurrentRowsInfo(from + "-" + to);
                }               
-           }                       
+           }  
+           //Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.getTable().getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }
    }
    
    /**
-    * 
-    *
+    *  ActionListener class controlling the <b>SelectALL</b> button on the form.
+    *  On selectSll All record from active page will be selected. 
+    *  Each younger records with the same ITEM as seleced record will be selected too. 
     */
    class selectAllButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {    	   
-    	   model.setSelectAll(true);
-    	   model.processResult(1,model.getResultRows());    	   
+       {   
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }    	   
+    	   model.setSelectAll(true);    	  	   
     	   view.getTable().setModel(new HistoryTableModel(model));  
        }
    }
    
    /**
-    * 
-    *
+    *  ActionListener class controlling the <b>UnselectAll</b> button on the form.
+    *  On UnselecAll All record from active page will be unselected. 
+    *  Each older records with the same ITEM as unseleced record will be unselected too.
     */
    class unselectAllButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {    
-    	   ArrayList<Object[]> markItem = new ArrayList();    	   
-    	   model.setMarkItem(markItem); 
+       {   
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+    	   model.setUnselectedAll(true); 
     	   view.getTable().setModel(new HistoryTableModel(model));
        }
    }
    
    /**
-    * 
-    *
+    * ActionListener class controlling the <b>UndoSelected</b> button on the form.
+    * On UndoSelected All selected changes will be restored.
     */
    class undoSelectedButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {    	   
-           model.undoSelected();            
-           int okCancle = view.messageUndo(model.getMessageUndo());
-           logger.debug("button "+okCancle);
-           if (okCancle == 0){
-        	   //Button OK was press
-        	   logger.debug("Button OK was press.");
-        	   model.commitUpdate();
-        	   model.deleteHistory(model.getResultRows(), true);
-        	   model.searchEditHistory(model.getData());
-        	   model.processResult(1,model.getDisplayRows());
-        	   view.getTable().setModel(new HistoryTableModel(model));
-        	   int resultRows = model.getResultRows();
-        	   if (resultRows == 0) {
-        		   view.setCurrentRowsInfo("0-0"); 
-        	   } else {
-        		   int from = model.getCurrentFirstRow();
-                   int to = from + view.getTable().getRowCount() - 1;               
-                   view.setCurrentRowsInfo(from + "-" + to);    
-        	   }               
-                   view.setCountResutl(resultRows);
+       {   
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }    	   
+    	   // process selected record
+           model.undoSelected();  
+           // Check whether an error flag after processing selected records is set
+           if (!model.isError()) {
+        	   int okCancle = view.messageUndo(model.getMessageUndo());
+               logger.debug("button "+okCancle);
+               if (okCancle == 0){
+            	   //Button OK was press
+            	   logger.debug("Button OK was press.");
+            	   model.commitUpdate();
+            	   model.deleteHistory(model.getResultRows(), true);            	   
+            	   model.searchEditHistory(model.getData());
+            	   model.processResult(1,model.getDisplayRows());
+            	   view.getTable().setModel(new HistoryTableModel(model));
+            	   int resultRows = model.getResultRows();
+            	   if (resultRows == 0) {
+            		   view.setCurrentRowsInfo("0-0"); 
+            	   } else {
+            		   int from = model.getCurrentFirstRow();
+                       int to = from + view.getTable().getRowCount() - 1;               
+                       view.setCurrentRowsInfo(from + "-" + to);    
+            	   }               
+                       view.setCountResutl(resultRows);   
+               } else {            	  
+            	   logger.debug("Button Cancle was press."); 
+               }
            } else {
-        	   //Button Cancle was press
-        	   //neco jako rollback - bude se volat nebo to bude zarizeno tim, ze se nezavola executeUpdate??
-        	   logger.debug("Button Cancle was press.");
-           }           
+        	   model.setError(null);        	           	  
+           }
        }
    }
     
 
    /**
-    * 
+    * ActionListener class controlling the text field on the form for set number of rows to displayed.  
     */
     class rowSetDisplayChangeListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent) {
-           // Save old value
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Save old value 
            int oldValue = model.getDisplayRows();           
            // Check whether new value > 0
            if (view.getDisplayRows() < 1) {
@@ -189,19 +245,31 @@
            }
            if (view.getDisplayRows() > model.getResultRows()){
         	   view.setDisplayRows(model.getResultRows());
-           } 
-           
+           }            
            // Set new value in the model
            model.setDisplayRows(view.getDisplayRows());
            logger.debug("New display rows: "+view.getDisplayRows());
            // If neccessary reload search results
            if ((oldValue != view.getDisplayRows()) && (model.getDisplayRows() <= model.getResultRows())) {
                model.processResult(model.getCurrentFirstRow(), view.getDisplayRows());
+               if (model.isError()) return;
                view.getTable().setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
                view.setCurrentRowsInfo(from + "-" + to);               
            }
+           // Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.getTable().getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }        	   
    }
   

Modified: trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -1,31 +1,34 @@
 package net.sf.plantlore.client.history;
 
 import java.text.DateFormat;
-import java.text.DateFormat;
 import java.util.ArrayList;
 import java.util.Date;
 import java.util.HashSet;
 import javax.swing.table.AbstractTableModel;
-
 import org.apache.log4j.Logger;
-
 import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.l10n.L10n;
 
 /** 
- * Implements a table model for the history data.
+ * Implements a table model for the History.
+ * 
  * @author Lada Oberreiterova
+ * @version 1.0
  */
+
 public class HistoryTableModel extends AbstractTableModel
-{
-    //Logger
+{    
+	private static final long serialVersionUID = 2027550749272023845L;
+	/** Instance of a logger */
     private Logger logger;
-    // History model
+    /** Model of the History MVC */
     private History model; 
+    /** Results of a search query for displaying */
     private ArrayList<HistoryRecord> editHistoryDataList;
+    /** List of identifier of selected item */
     private HashSet markListId;
-    private ArrayList<Object[]> markItem;
-	
+    /** List of pairs (Item, identifier of the oldest change of this Item) */
+    private ArrayList<Object[]> markItem;	
     /** Names of the columns */
     private String[] columnNames;
     /** Size of the columns */
@@ -33,6 +36,7 @@
     /** Data values displayed in the table*/
     private Object[][] data;
 
+    /** Constants used for identification of columns of table */
     public final static int MARK = 0;
     public final static int DATE = 1; 
     public final static int USER = 2;
@@ -42,18 +46,20 @@
     
 
     /** 
-     *  Creates a new instance of HistoryTableModel with the specified data values  
-     *  @param model
+     *  Creates a new instance of HistoryTableModel  
+     *  @param model model of the Hisotry MVC
      */
     public HistoryTableModel(History model)
     {
     	logger = Logger.getLogger(this.getClass().getPackage().getName());
     	this.model = model;        
-    	initColumns();    	
-        initColumnSize();
+    	initColumns();    	        
     	initData();    	       
     }  
    
+    /**
+     * Init names of columns.
+     */
     private void initColumns() {
         columnNames = new String[6];        
         columnNames[0] = L10n.getString("History.ColumnX");        
@@ -64,6 +70,9 @@
         columnNames[5] = L10n.getString("History.ColumnNewValue");           
     }       
     
+    /**
+     * Init size of columns.    
+     */
     private void initColumnSize() {
         columnSizes = new int[6];
         columnSizes[0] = 30;
@@ -75,12 +84,13 @@
     }
     
     /**
-     * Load data for dislaying 
+     * Load data for dislaying. 
      */
-    public void initData() {
-    	
-    	logger.debug("Init data.");
-    	
+    public void initData() {    	
+    	logger.debug("HistoryTableModel: Init data for displaying.");
+    	// init size of column
+    	initColumnSize();
+    	// load data
     	editHistoryDataList = model.getHistoryDataList();
     	if (editHistoryDataList.size()==0 ){
     		this.data = new Object[0][];
@@ -91,48 +101,51 @@
     	int countResult = Math.min(editHistoryDataList.size(), firstRow+ model.getDisplayRows()-1);
     	int countRow = countResult - firstRow + 1;
     	boolean mark = false;
-    	int ii = 0;  
-    	//If was use button "sellect all" we must init list of mark item
+    	int ii = 0;      	
     	boolean selectAll = model.getSelectAll();
-    	if (selectAll) {
-    		initMarkAllItem();
+      	if (selectAll) {
+      		//If was pressed button SellectAll we must update list of mark item
+    		initMarkAllItem(firstRow-1, countResult, true);
     		mark = true;    		
-    	}                
-        
-    	//loud data for view
+    	}else if (model.getUnselectedAll()) {
+    		// If was pressed button UnsellectAll we must update list of mark item
+    		initMarkAllItem(firstRow-1, countResult, false);
+    	}        
+    	//load data for view
         Object[][] editHistoryData = new Object[countRow][6];   
     	for (int i=firstRow-1; i < countResult; i++) { 
                 String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
                 String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
     		String item = L10n.getString(tableName+"."+columnName);    		
-    		if (! selectAll){     			
-    			mark = isMark(item, i);
-    		}
+    		if (! selectAll)	
+    			mark = isMark(item, i);    		
             editHistoryData[ii][0] = new Boolean(mark);  
             Date when = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWhen();
     	    editHistoryData[ii][1] = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(when); 
     	    editHistoryData[ii][2] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWho().getWholeName();    	   
     	    editHistoryData[ii][3] = item;
+    	    logger.debug("XXXXXXXXXX: "+ item);
     	    editHistoryData[ii][4] = ((HistoryRecord)editHistoryDataList.get(i)).getOldValue();
     	    editHistoryData[ii][5] = ((HistoryRecord)editHistoryDataList.get(i)).getNewValue();
     	    ii++;
     	}      	
     	model.setSelectAll(false);
+    	model.setUnselectedAll(false);
     	this.data = editHistoryData;    	
     }    
     
     /**
-     * Check marking row
-     * @param item
-     * @return
+     * Check marking rows.
+     * @param item string containing description of changed attribute
+     * @param itemId identifier of slelected record 
+     * @return true if record is selected, in other way false      
      */
     public boolean isMark(String item, int itemId) {    	
     	int count = markItem.size();       	
     	for( int i=0; i < count; i++){
     		Object[] itemList = (Object[])(markItem.get(i));
     		String itemFromList = (String)itemList[0];
-    		Integer maxId = (Integer)itemList[1];
-    		logger.debug("IsMark - itemFromList: "+itemFromList + ", item: "+ item + ", maxId: "+ maxId + ", itemId: "+ itemId);
+    		Integer maxId = (Integer)itemList[1];    		
     		if (item.equals(itemFromList)) {
     			if (itemId <= maxId) {
     				return true;
@@ -143,21 +156,19 @@
     }
  
     /**
-     * 
-     * @param row
-     * @param value
+     * Update MarkList containing information about selected ITEMs and identifiers of their oldest change.
+     * @param item string containing description of changed attribute 
+     * @param row index of row in table of dialog
+     * @param value true if record is selected
      */
     public void updateMarkList(String item, int row, boolean value) {    	    	    	
     	int itemId = row + model.getCurrentFirstRow() - 1;
     	boolean contains = false;    	
-    	int count = markItem.size();
-    	logger.debug("Update markListItem. Count item: "+count);
-    	//ArrayList<Object[]> tmpMarkItem = markItem;
+    	int count = markItem.size();    	  
     	for( int i=0; i < count; i++){
     		Object[] itemList = (Object[])(markItem.get(i));
     		String itemFromList = (String)itemList[0];
-    		Integer maxId = (Integer)itemList[1];    
-    		logger.debug("MarkItem update - item: "+ itemFromList + ", maxId: " + maxId);
+    		Integer maxId = (Integer)itemList[1];        		
     		if (value) {    		    			    			
     			if (item.equals(itemFromList)) { 
     				contains = true;
@@ -176,21 +187,20 @@
 		    			if (newId != -1) {
 		    				itemList[1] = newId;
 			    			markItem.set(i,itemList);
-			    			logger.debug("Unmark - new itemId is "+ itemList[1].toString());
+			    			//logger.debug("Unmark - new itemId is "+ itemList[1].toString());
 		    			} else {
 		    				markItem.remove(i);
-			    			logger.debug("Unmark - remote record has id: "+ itemId);
+			    			//logger.debug("Unmark - remote record has id: "+ itemId);
 			    			return;
-		    			}
-		    	    }else {		    		
-		    			markItem.remove(i);
-		    			logger.debug("Unmark - remote record has id: "+ itemId);
+		    			}		    	    
+		    	    } else {		    			
+		    			//logger.debug("This situation is possible only for unselectedAll.");
 		    			return;
 		    		}
 		    	}				 
 			}      	
     	}
-    	if (! contains) {
+    	if (! contains && value) {
     		Object [] itemList = new Object[2];    		
 			itemList[0] = item;
 			itemList[1] = itemId;
@@ -199,35 +209,33 @@
     }
  
     /**
-     * 
-     *
+     *  Update list of selected item. Call after press SelectAll or UnselectAll buttons.
+     *  @param from indentifier of first record in table 
+     *  @param to identifier of last record in table
+     *  @param isSelect true if SelecteAll button has been pressed, false if UnselectAll button has been pressed
      */
-    public void initMarkAllItem() {    	
-    	editHistoryDataList = model.getHistoryDataList();    	
-    	int countResult = editHistoryDataList.size();    	
-    	for (int i=0; i < countResult; i++) {    
-                String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
-                String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
+    public void initMarkAllItem(int from, int to, boolean isSelect) {    	    	    	    	    	
+    	for (int i=to-1; i >= from; i--) {    
+            String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
+            String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
     		String item = L10n.getString(tableName+"."+columnName);        		
-    		updateMarkList(item, i, true);
+    		updateMarkList(item, i - from, isSelect);
     	} 
     	model.setMarkItem(markItem);
-    	updateMarkListId();
-    	logger.debug("All records were selected.");    	
+    	updateMarkListId();    	   	
     }
-    
+        
     /**
-     * v markListId se drzi seznam polozek, ktere jsou oznaceny
-     *
-     */
-    public void updateMarkListId() {
+     * Update list of identifiers of selected record.      
+     */    
+	public void updateMarkListId() {
     	markListId = new HashSet();
     	editHistoryDataList = model.getHistoryDataList();
     	markItem = model.getMarkItem();
     	int countResult = editHistoryDataList.size();    	
     	for (int i=0; i < countResult; i++) {  
     		String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
-                String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
+            String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
     		String item = L10n.getString(tableName+"."+columnName);    
     		if (isMark(item, i)){
     			markListId.add(i);
@@ -270,21 +278,25 @@
         	 //Update list of selected record
         	 updateMarkListId();
         	 //update view
-        	 this.fireTableDataChanged();
+        	 fireTableDataChanged();
         }        
     }
 
     /**
-     * 
-     * @param item
-     * @param itemId
-     * @return
+     * Search younger change of ITEM.
+     * @param item string containing description of changed attribute
+     * @param itemId identifier of slelected record
+     * @return identifier of record containing younger change of ITEM or -1 if there isn1t younger change 
      */
-    public int searchSmaller(String item, int itemId) {    	    	
-    	int firstRow = model.getCurrentFirstRow();
-    	for( int i=itemId-firstRow; i >=0 ; i--){
-    		if (getValueAt(i,3).equals(item)){
-    			return i+firstRow-1;
+    public int searchSmaller(String item, int itemId) {    	    	    	
+    	for( int i=itemId - 1; i >=0 ; i--){
+    		String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
+            String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
+    		String itemData = L10n.getString(tableName+"."+columnName); 
+    		logger.debug("itemData: " + itemData + " item:" + item + " itemId: " + itemId );
+    		if (itemData.equals(item)){
+    			logger.debug("return " + i);
+    			return i;    			
     		}    		
     	}
     	return -1;
@@ -296,7 +308,7 @@
      * @param column index of column
      */
     public Object getValueAt(int row, int column)
-    {
+    {    	
         return data[row][column];
     }    
     
@@ -318,7 +330,10 @@
         return columnNames.length;
     }
      
-     
+    /**
+     * Set size of columns
+     * @param columnSizes size of columns
+     */ 
     public void setColumnSizes(int[] columnSizes) {
           this.columnSizes=columnSizes;
     }
@@ -336,8 +351,8 @@
      * Gets right Class for Boolean Object in the MARK column, Date Object in the DATE column and String Object in other columns. 
      * @param column index of column
      * @return the Class for Object instances in the specified column.
-     */
-    public Class getColumnClass(int column) {
+     */    
+	public Class getColumnClass(int column) {
     	switch (column) {
             case 0: return Boolean.class;
             case 1: return DateFormat.class;

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -12,40 +12,56 @@
 import javax.swing.JDialog;
 import javax.swing.JOptionPane;
 import javax.swing.JTable;
-import javax.swing.table.TableColumn;
 import net.sf.plantlore.common.PlantloreHelp;
 import net.sf.plantlore.l10n.L10n;
 
 /**
- *
- * @author  Lada
+ * View for the main History dialog (part of the History MVC). Used for displaying the search results.
+ * @author  Lada Oberreiterov?
+ * @version 1.0
  */
 public class HistoryView extends javax.swing.JDialog implements Observer{
+        
+	private static final long serialVersionUID = -6749177153586329145L;
+	/** Model of the History MVC*/
+	private History model;      
     
-    //History model
-    private History model;  
-    //data
-    private Object[][] data;
-    
     /**
      * Creates new form HistoryView
+     * @param model model of the History MVC
+     * @param parent parent of this dialog
+     * @param modal boolean flag whether the dialog should be modal or not
      */
     public HistoryView(History model, java.awt.Frame parent, boolean modal) {
                 
         super(parent, modal);
         this.model = model;
+        // Register observer
+        model.addObserver(this);
         setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
         initComponents();
+        //Init Help
         PlantloreHelp.addKeyHelp(PlantloreHelp.HISTORY_MANAGER, this.getRootPane());
         PlantloreHelp.addButtonHelp(PlantloreHelp.HISTORY_MANAGER, this.helpButton);        
-        getTable().setModel(new HistoryTableModel(model));           
+        getTable().setModel(new HistoryTableModel(model));         
+        previousButton.setEnabled(false);
+        if (getTable().getRowCount() <= model.getDisplayRows()) {
+        	nextButton.setEnabled(false);
+        }
     }
     
+    /**
+     * Reload the view dialog or display some kind of error.
+     */
       public void update(Observable observable, Object object)
     {                                
-       
+    	  //Check whether we have some kind of error to display
+          if (model.isError()) {
+              showErrorMessage(model.getError());                          
+              return;
+          } 
     } 
-    
+      
     /** This method is called from within the constructor to
      * initialize the form.
      * WARNING: Do NOT modify this code. The content of this method is
@@ -332,20 +348,21 @@
                 .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
         );
         pack();
-    }// </editor-fold>//GEN-END:initComponents
+    }// </editor-fold>//GEN-END:initComponents       
     
     /**
-     * @param args the command line arguments
+     *  Display generic error message.
+     *  @param message Message we want to display
      */
-    public static void main(String args[]) {
-        java.awt.EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                new HistoryView(null, new javax.swing.JFrame(), true).setVisible(true);
-            }
-        });
-    }
-    
-     
+    public void showErrorMessage(String message) {
+        JOptionPane.showMessageDialog(this, message, L10n.getString("Common.ErrorMessageTitle"), JOptionPane.ERROR_MESSAGE);               
+    }  
+   
+    /**
+     * Display generic message
+     * @param message Message we want to display
+     * @return information about user selection. <ul><li> 0 if user press OK button</li> <li>1 if user press Cancle button</li> <li>2 if warnnig message has been displayed</li></ul>
+     */
     public int messageUndo(String message) {
         if (message.equals("")) {
             JOptionPane.showMessageDialog(this, L10n.getString("Warning.EmptySelection"), L10n.getString("Warning.EmptySelectionTitle"), JOptionPane.ERROR_MESSAGE);               
@@ -356,28 +373,44 @@
         }
     }
 
+    /**
+     * Close this dialog.     
+     */
     public void close() {
         dispose();
     }
   
+    /**
+     * Get main table whitch displays changes of Records
+     * @return main table whitch displays changes of Records
+     */
     public JTable getTable()
     {
     	return this.tableEditList;
     }
     
-    /** Total results */
+    /** 
+     * Set number of rows in results
+     * @param resultRows number of rows in results
+     */
     public void setCountResutl(Integer resultRows)
     {
     	this.totalResultValueLabel.setText(resultRows.toString());
     }
     
-    /**Displayed rows */
+    /**
+     * Set number of rows displayed on active page 
+     * @param displayedRows number of rows displayed on active page
+     */
     public void setCurrentRowsInfo(String displayedRows)
     {
     	this.displayedValueLabel.setText(displayedRows);
     }
     
-    /**Rows to display */
+    /**
+     * Get numger of rows to displaying on one page
+     * @return numger of rows to displaying on one page
+     */
     public Integer getDisplayRows() {
          Integer countRows;
         try {
@@ -388,7 +421,10 @@
         return countRows;
     }
     
-    /**Rows to display*/
+    /**
+     * Set numger of rows to displaying on one page
+     * @param value numger of rows to displaying on one page
+     */
     public void setDisplayRows(Integer value) {
         this.toDisplayValueTextField.setText(value.toString());
     }  

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -11,30 +11,35 @@
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
-import java.text.DateFormat;
-import java.util.Date;
-import net.sf.plantlore.common.PlantloreHelp;
-import net.sf.plantlore.l10n.L10n;
 import org.apache.log4j.Logger;
 
-
 /**
+ * Controller for the main WholeHistory dialog (part of the WholeHistory MVC).
  *
- * @author Lada
+ * @author Lada Oberreiterova
+ * @version 1.0
  */
 public class WholeHistoryCtrl {
    
+	/** Instance of a logger */
     private Logger logger;
+    /** Model of the WholeHistory MVC */
     private History model;
+    /** View of the WholeHistory MVC */
     private WholeHistoryView view;
     
-    /** Creates a new instance of WholeHistoryCtrl */
+    /** 
+     *  Creates a new instance of WholeHistoryCtrl 
+     *  @param model model of the WholeHistory MVC
+     *  @param view  view of the WholeHistory MVC
+     */
     public WholeHistoryCtrl(History model, WholeHistoryView view) {
       
         logger = Logger.getLogger(this.getClass().getPackage().getName());        
         this.model = model;
         this.view = view;
-                  
+          
+        // Add action listeners to buttons
         view.okButton.addActionListener(new okButtonListener());
         view.closeButton.addActionListener(new closeButtonListener());
         view.previousButton.addActionListener(new previousButtonListener());
@@ -45,10 +50,10 @@
         view.clearHistoryButton.addActionListener(new clearHistoryListener());
     }
     
-            /** 
-    * On Ok makes the model store() the preferences and hides the view.
-    * 
-    */
+    /** 
+     * ActionListener class controlling the <b>OK</b> button on the form.
+     * On Ok makes the model store() the preferences and hides the view.     
+     */  
    class okButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {       
@@ -57,8 +62,8 @@
    }
   
    /**
-    * On Cancel just hides the view.
-    *
+    * ActionListener class controlling the <b>CLOSE</b> button on the form.
+    * On Close hides the view.
     */
    class closeButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
@@ -68,46 +73,61 @@
    }
    
    /**
-    * 
-    *
+    *  ActionListener class controlling the <b>PREV</b> button on the form.
+    *  The button PREV is used for browsing the search results.
     */
    class previousButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {
-    	   //   Call processResults only if we don't see the first page (should not happen, button should be disabled)
-    	   logger.debug("FIRST");
-    	   logger.debug("current first row: "+model.getCurrentFirstRow());
-           logger.debug("num rows in the result: "+ model.getResultRows());            
-           logger.debug("display rows: "+ view.tableHistoryList.getRowCount());      
+       {    	  
+    	   // Check whether an error flag is set
+           if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Get previous page of results
            if (model.getCurrentFirstRow() > 1) {
                int firstRow = Math.max(model.getCurrentFirstRow()- model.getDisplayRows(), 1);
                model.processResult(firstRow, model.getDisplayRows()); 
+               if (model.isError()) return;
                if (model.getCurrentFirstRow() > 1){
                }
                view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.tableHistoryList.getRowCount() - 1;
                view.displayedValueLabel.setText(from + "-" + to);
-           }                           
+           }      
+           //Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.tableHistoryList.getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }
    }
    
    /**
-    * 
-    *
+    * ActionListener class controlling the <b>NEXT</b> button on the form.
+    * The button NEXT is used for browsing the search results.    
     */
    class nextButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
-    	   //Call processResults only if we don't see the last page
-    	   logger.debug("NEXT");
-           logger.debug("current first row: "+model.getCurrentFirstRow());
-           logger.debug("num rows in the result: "+ model.getResultRows());            
-           logger.debug("display rows: "+ model.getDisplayRows());
-           logger.debug("num rows in table (view) "+ view.tableHistoryList.getRowCount());              
+    	   // Check whether an error flag is set 
+           if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Get next page of result
            if (model.getCurrentFirstRow()+ view.tableHistoryList.getRowCount()<=model.getResultRows()) {
                model.processResult(model.getCurrentFirstRow()+ model.getDisplayRows(), view.tableHistoryList.getRowCount());
-               view.tableHistoryList.setModel(new WholeHistoryTableModel(model));             
+               if (model.isError()) return;
+               view.tableHistoryList.setModel(new HistoryTableModel(model));             
                int from = model.getCurrentFirstRow();
                int to = from + view.tableHistoryList.getRowCount() - 1;
                if (to <= 0){
@@ -115,16 +135,33 @@
                }else {
             	   view.displayedValueLabel.setText(from + "-" + to);
                }               
-           }                       
+           }  
+           //Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.tableHistoryList.getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }
    }
    
-      /**
-    * 
+   /**
+    * ActionListener class controlling the text field on the form for set number of rows to displayed.  
     */
-     class rowSetDisplayChangeListener implements ActionListener {
+    class rowSetDisplayChangeListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent) {
-           // Save old value
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
+           // Save old value 
            int oldValue = model.getDisplayRows();           
            // Check whether new value > 0
            if (view.getDisplayRows() < 1) {
@@ -133,74 +170,102 @@
            }
            if (view.getDisplayRows() > model.getResultRows()){
         	   view.setDisplayRows(model.getResultRows());
-           } 
-           
+           }            
            // Set new value in the model
            model.setDisplayRows(view.getDisplayRows());
            logger.debug("New display rows: "+view.getDisplayRows());
            // If neccessary reload search results
            if ((oldValue != view.getDisplayRows()) && (model.getDisplayRows() <= model.getResultRows())) {
                model.processResult(model.getCurrentFirstRow(), view.getDisplayRows());
-               view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
+               if (model.isError()) return;
+               view.tableHistoryList.setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.tableHistoryList.getRowCount() - 1;
                view.displayedValueLabel.setText(from + "-" + to);               
            }
+           // Set button prev active if we see the first page, in other way set it inactive
+           if (model.getCurrentFirstRow() > 1) {
+        	   view.previousButton.setEnabled(true);
+           } else {
+        	   view.previousButton.setEnabled(false);
+           }
+           //Set button next inactive if we see the last page, in other way set it active
+           if (model.getCurrentFirstRow()+ view.tableHistoryList.getRowCount() - 1 < model.getResultRows()) {
+        	   view.nextButton.setEnabled(true);
+           } else {
+        	   view.nextButton.setEnabled(false);
+           }
        }        	   
    }
    
-   /**
-    *
-    */  
+    /**
+     * ActionListener class controlling the <b>UndoToSelected</b> button on the form.
+     * On UndoToSelected All changes from now to selected date will be restored.
+     */  
     class undoToDateButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }
            if (view.tableHistoryList.getSelectedRow() < 0) {    
                view.messageSelection();
            } else {
-               logger.debug("Undo to date - id of selected row: "+ view.tableHistoryList.getSelectedRow());
+               logger.debug("Undo to date - id of selected row is: "+ view.tableHistoryList.getSelectedRow());
                int selectedRow = view.tableHistoryList.getSelectedRow();
                int toResult = selectedRow + model.getCurrentFirstRow();
                Object toDate = view.tableHistoryList.getValueAt(selectedRow, 0);                   	       
                model.clearEditObjectList();
                model.undoToDate(toResult);
-               int okCancle = view.messageUndo(toDate.toString());     
-               if (okCancle == 0){
-                   //Button OK was press
-                   logger.debug("Button OK was press.");    
-                   model.commitUpdate();
-                   model.deleteHistory(toResult, false);
-                   model.searchWholeHistoryData();        	
-                   model.processResult(1,model.getDisplayRows());
-                   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
-                   Integer resultRows = model.getResultRows();
-                   if (resultRows == 0) {
-                           view.displayedValueLabel.setText("0-0"); 
-                   } else {
-                           int from = model.getCurrentFirstRow();
-                   int to = from + view.tableHistoryList.getRowCount() - 1;               
-                   view.displayedValueLabel.setText(from + "-" + to);    
-                   }               
-                   view.totalResultValueLabel.setText(resultRows.toString());
-               } else {
-                       //Button Cancle was press
-                       //neco jako rollback - bude se volat nebo to bude zarizeno tim, ze se nezavola executeUpdate??
-                       logger.debug("Button Cancle was press.");
-               } 
-           }
-       }
-    }
+               // Check whether an error flag after processing records is set
+               if (! model.isError()) {
+	               int okCancle = view.messageUndo(toDate.toString());     
+	               if (okCancle == 0){
+	                   //Button OK was press
+	                   logger.debug("Button OK was press.");    
+	                   model.commitUpdate();
+	                   model.deleteHistory(toResult, false);
+	                   model.searchWholeHistoryData();        	
+	                   model.processResult(1,model.getDisplayRows());
+	                   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
+	                   Integer resultRows = model.getResultRows();
+	                   if (resultRows == 0) {
+	                           view.displayedValueLabel.setText("0-0"); 
+	                   } else {
+	                           int from = model.getCurrentFirstRow();
+	                   int to = from + view.tableHistoryList.getRowCount() - 1;               
+	                   view.displayedValueLabel.setText(from + "-" + to);    
+	                   }               
+	                   view.totalResultValueLabel.setText(resultRows.toString());
+	               } else {	                       	                     
+	                       logger.debug("Button Cancle was press.");
+	               } 
+                } else {
+                	model.setError(null);
+                }
+            }
+         }
+     }
     
     /**
-    *
-    */  
+     * ActionListener class controlling the <b>Details</b> button on the form.
+     * Display dialog with details of record.
+     */  
     class detailsHistoryListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
-           if (view.tableHistoryList.getSelectedRow() < 0) {    
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }        
+           if (view.tableHistoryList.getSelectedRow() < 0) {
+        	   // No row is selected
                view.messageSelection();
            } else {
-               //zobrazi se detailni informace o vybranem zaznamu
+               // Generate and display details of record
                int resultNumber = view.tableHistoryList.getSelectedRow() + model.getCurrentFirstRow()-1;             
                String detailsMessage = model.getDetailsMessage(resultNumber);
                DetailsHistoryView detailsView = new DetailsHistoryView(view, true);
@@ -212,20 +277,26 @@
     }
     
     /**
-    *
+    *   ActionListener class controlling the <b>CleareDatabase</b> button on the form.
+    *   Delete data from history table and delete records, which have attribute cDelete set on one or greater.
     */  
     class clearHistoryListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {
-           int okCancle = view.messageClearHistory();
+    	   // Check whether an error flag is set
+    	   if (model.isError()) {
+        	   view.showErrorMessage(model.getError());
+        	   return;
+           }       
+           int okCancle = view.messageUndo("CH");
            if (okCancle == 0){
                    //Button OK was press
                    logger.debug("Button OK was press.");  
-                   //smazani dat z tabulek tHistoryChange a tHistory
-                   model.clearHistory();
-                   //smaznamu, ktere maji deleted = 1
-                   //model.clearDatabase
-                   //aktualizovat zobrazeni dat
+                   // delete records whit contition cdelete > 0
+                   model.clearDatabase();
+                   //deleta data from tables tHistoryChange and tHistory
+                   model.clearHistory();                   
+                   //load data
                    model.searchWholeHistoryData();        	
                    model.processResult(1,model.getDisplayRows());
                    view.tableHistoryList.setModel(new WholeHistoryTableModel(model));

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -18,22 +18,28 @@
 import org.apache.log4j.Logger;
 
 /**
+ * Implements a table model for the WholeHistory.
  *
  * @author Lada Oberreiterova
+ * @version 1.0
  */
 public class WholeHistoryTableModel extends AbstractTableModel {
     
-    //Logger
+	private static final long serialVersionUID = 5203388116532684569L;
+	/** Instance of a logger */
     private Logger logger;
-    // History model
-    private History model; 
-    private ArrayList<HistoryRecord> editHistoryDataList;
-    
+    /** Model of the History MVC */
+    private History model;
+    /** Results of a search query for displaying */
+    private ArrayList<HistoryRecord> editHistoryDataList;    
     /** Names of the columns */
     private String[] columnNames;
+    /** Size of the columns */
+    private int[] columnSizes;
     /** Data values displayed in the table*/
     private Object[][] data;
 
+    /** Constants used for identification of columns of table */
     public final static int DATE = 0;
     public final static int OPERATION = 1; 
     public final static int USER = 2;
@@ -41,14 +47,20 @@
     public final static int OLD_VALUE = 4;
     public final static int NEW_VALUE = 5;
     
-    /** Creates a new instance of WholeHistoryTableModel */
+    /** 
+     *  Creates a new instance of WholeHistoryTableModel 
+     *  @param model model of the WholeHisotry MVC
+     */
     public WholeHistoryTableModel(History model) {
         logger = Logger.getLogger(this.getClass().getPackage().getName());
     	this.model = model;        
     	initColumns();    	
-    	initData();    	
+    	initData();     	
     }  
    
+    /**
+     * Init names of columns.
+     */
     private void initColumns() {
         columnNames = new String[6];                      
         columnNames[0] = L10n.getString("History.ColumnDate"); 
@@ -56,17 +68,29 @@
         columnNames[2] = L10n.getString("History.ColumnUser");        
         columnNames[3] = L10n.getString("History.ColumnItem");        
         columnNames[4] = L10n.getString("History.ColumnOldValue");       
-        columnNames[5] = L10n.getString("History.ColumnNewValue");     
-        
-    }       
+        columnNames[5] = L10n.getString("History.ColumnNewValue");            
+    }   
     
     /**
+     * Init size of columns.    
+     */
+    private void initColumnSize() {
+        columnSizes = new int[6];
+        columnSizes[0] = 30;
+        columnSizes[1] = 100;
+        columnSizes[2] = 100;
+        columnSizes[3] = 100;
+        columnSizes[4] = 100;
+        columnSizes[5] = 100;
+    }
+    
+    /**
      * Load data for dislaying 
      */
     public void initData() {
-    	
-    	logger.debug("WholeHistory - Init data.");
-    	
+    	logger.debug("WholeHistoryTableModel: Init data for displaying.");
+    	// init size of column
+    	initColumnSize();    	  	
     	editHistoryDataList = model.getHistoryDataList();
     	if (editHistoryDataList.size()==0 ){
     		this.data = new Object[0][];
@@ -76,9 +100,9 @@
     	int countResult = Math.min(editHistoryDataList.size(), firstRow+ model.getDisplayRows()-1);
     	int countRow = countResult - firstRow + 1;   
         int ii = 0;
-    	//loud data for view
+    	//load data for view
         Object[][] editHistoryData = new Object[countRow][6];   
-    	for (int i=firstRow-1; i < countResult; i++) {     
+    	for (int i=firstRow-1; i < countResult; i++) {         		
             String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
             String tableName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getTableName();
             String item = L10n.getString(tableName+"."+columnName);             
@@ -88,6 +112,7 @@
             editHistoryData[ii][1] = L10n.getString( "History.Operation"+((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getOperation());
     	    editHistoryData[ii][2] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWho().getWholeName();    	   
     	    editHistoryData[ii][3] = item;
+    	    logger.debug("WWWWWWWWWW: "+ item);
     	    editHistoryData[ii][4] = ((HistoryRecord)editHistoryDataList.get(i)).getOldValue();
     	    editHistoryData[ii][5] = ((HistoryRecord)editHistoryDataList.get(i)).getNewValue();
     	    ii++;
@@ -136,8 +161,8 @@
      * Gets right Class Integer Object for OPERATION column, Date Object in the DATE column and String Object in other columns. 
      * @param column index of column
      * @return the Class for Object instances in the specified column.
-     */
-    public Class getColumnClass(int column) {
+     */   
+	public Class getColumnClass(int column) {
     	switch (column) {
             case 0: return DateFormat.class;
             case 1: return Integer.class;

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -15,30 +15,52 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
- *
- * @author  Lada
+ * View for the main WholeHistory dialog (part of the WholeHistory MVC). Used for displaying the search results.
+ * @author  Lada Oberreiterov?
+ * @version 1.0
  */
 public class WholeHistoryView extends javax.swing.JDialog implements Observer{
-    
-    //Whole History model
+       
+	private static final long serialVersionUID = -3610428060548385487L;
+	/** Model of the History MVC*/
     private History model;  
   
-    /** Creates new form WholeHistoryView */
+    /**
+     * Creates new form WholeHistoryView
+     * @param model model of the WholeHistory MVC
+     * @param parent parent of this dialog
+     * @param modal boolean flag whether the dialog should be modal or not
+     */
     public WholeHistoryView(History model, java.awt.Frame parent, boolean modal) {
         
         super(parent, modal);
         this.model = model;
+        // Register observer
+        model.addObserver(this);
         setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
         initComponents();
+        // Init Help
         PlantloreHelp.addKeyHelp(PlantloreHelp.HISTORY_MANAGER, this.getRootPane());
         PlantloreHelp.addButtonHelp(PlantloreHelp.HISTORY_MANAGER, this.helpButton);        
         this.tableHistoryList.setRowSelectionAllowed(true);
         this.tableHistoryList.setSelectionMode(DefaultListSelectionModel.SINGLE_SELECTION);
-        this.tableHistoryList.setModel(new WholeHistoryTableModel(model));                
+        this.tableHistoryList.setModel(new WholeHistoryTableModel(model));     
+        previousButton.setEnabled(false);
+        if (this.tableHistoryList.getRowCount() <= model.getDisplayRows()) {
+        	nextButton.setEnabled(false);
+        }
     }
     
+    /**
+     * Reload the view dialog or display some kind of error.
+     */
     public void update(Observable observable, Object object)
     {
+    	// Check whether we have some kind of error to display
+        if (model.isError()) {
+            showErrorMessage(model.getError());                          
+            return;
+        } 
     }
     
     /** This method is called from within the constructor to
@@ -218,40 +240,50 @@
         );
         pack();
     }// </editor-fold>//GEN-END:initComponents
+      
     
     /**
-     * @param args the command line arguments
+     * Close this dialog.
      */
-    public static void main(String args[]) {
-        java.awt.EventQueue.invokeLater(new Runnable() {
-            public void run() {
-                new WholeHistoryView(null, new javax.swing.JFrame(), true).setVisible(true);
-            }
-        });
-    }
-  
-    /**
-     *
-     */
     public void close() {
         dispose();
     }
     
-     public int messageUndo(String message) {
-    	int okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.Undo") + "  "+ message, L10n.getString("Question.UndoTitle"), JOptionPane.OK_CANCEL_OPTION);
+    /**
+     *  Display generic error message.
+     *  @param message Message we want to display
+     */
+    public void showErrorMessage(String message) {
+        JOptionPane.showMessageDialog(this, message, L10n.getString("Common.ErrorMessageTitle"), JOptionPane.ERROR_MESSAGE);               
+    }  
+    
+    /**
+     * Display generic message
+     * @param message Message we want to display
+     * @return information about user selection. <ul><li> 0 if user press OK button</li> <li>1 if user press Cancle button</li></ul>
+     */
+    public int messageUndo(String message) {
+    	int okCancle = 1;
+    	if (message.equals("cHistory")) {
+    		okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.ClearHistoryMessage"), L10n.getString("Question.ClearHistoryMessageTitle"), JOptionPane.OK_CANCEL_OPTION);
+    	}else {
+    		okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.Undo") + "  "+ message, L10n.getString("Question.UndoTitle"), JOptionPane.OK_CANCEL_OPTION);
+    	}
     	return okCancle;
     }
-     
+    
+    /**
+     * Display generic warning message
+     * @param message Message we want to display     
+     */
     public void messageSelection() {
     	JOptionPane.showMessageDialog(this, L10n.getString("Warning.EmptySelection"), L10n.getString("Warning.EmptySelectionTitle"), JOptionPane.ERROR_MESSAGE);               
     }
-    
-    public int messageClearHistory() {
-    	int okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.ClearHistoryMessage"), L10n.getString("Question.ClearHistoryMessageTitle"), JOptionPane.OK_CANCEL_OPTION);
-    	return okCancle;
-    }
-    
-    /**Rows to display */
+      
+    /**
+     * Get numger of rows to displaying on one page
+     * @return numger of rows to displaying on one page
+     */
     public Integer getDisplayRows() { 
         Integer countRows;
         try {
@@ -262,7 +294,10 @@
         return countRows;
     }
     
-    /**Rows to display*/
+    /**
+     * Set numger of rows to displaying on one page
+     * @param value numger of rows to displaying on one page
+     */
     public void setDisplayRows(Integer value) {
         this.toDisplayValueTextField.setText(value.toString());
     }  

Modified: trunk/src/net/sf/plantlore/common/record/Habitat.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/Habitat.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/common/record/Habitat.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -34,6 +34,7 @@
     private Double latitude;
     private Double longitude;
     private Integer deleted;
+    private User createdWho;
     private String note;
     
     /** Constants with column mapping (used for building select queries) */
@@ -48,6 +49,7 @@
     public static final String LATITUDE = "latitude";    
     public static final String LONGITUDE = "longitude";    
     public static final String DELETED = "deleted";    
+    public static final String CREATEDWHO = "createdWho"; 
     public static final String NOTE = "note";
     
     public static final String VILLAGE = "village";
@@ -93,6 +95,7 @@
 		else if(column.equals(QUADRANT)) setQuadrant((String)value);
 		else if(column.equals(DESCRIPTION)) setDescription((String)value);
 		else if(column.equals(COUNTRY)) setCountry((String)value);
+		else if(column.equals(CREATEDWHO)) setCreatedWho((User)value); 
 		else if(column.equals(ALTITUDE)) {
 			if (value != null && value instanceof String) 
 				setAltitude(Double.parseDouble((String) value));
@@ -446,4 +449,24 @@
     public void setNote(String note) {
         this.note = note;
     }
+    
+    /**
+     *  Get user who created this Habitat 
+     *  @return User who created this Habitat
+     *  @see setCreatedWho
+     */
+    public User getCreatedWho() {        
+        //obligatory
+        return this.createdWho;
+    }
+    
+    /**
+     *  Set user who created this Habitat
+     *  @param createdWho user who created this Habitat
+     *  @see getCreatedWho
+     */
+    public void setCreatedWho(User createdWho) {
+        this.createdWho = createdWho;
+    }    
+    
 }

Modified: trunk/src/net/sf/plantlore/common/record/HistoryChange.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/HistoryChange.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/common/record/HistoryChange.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -26,22 +26,19 @@
     
     /** Parameters of the HistoryChange. For detailed explanation see data model documentation. */
     private Integer id;
-    private Occurrence occurrence;
-    private int recordId;
-    private int oldRecordId;
+    private int recordId;    
     private int operation;   
     private java.util.Date when;
     private User who;
     
     /** Constants with column mapping (used for building select queries) */
     public static final String ID = "id";     
-    public static final String RECORDID = "recordId";
-    public static final String OLDRECORDID = "oldRecordId";
+    public static final String RECORDID = "recordId";    
     public static final String OPERATION = "operation";
     public static final String WHEN = "when";
     public static final String WHO = "who";    
     
-    //public enum Column {ID, OCCURRENCE, RECORDID, OLDRECORDID, OPERATION, WHEN, WHO};
+    //public enum Column {ID, OCCURRENCE, RECORDID, OPERATION, WHEN, WHO};
     
     /**
      *   Default constructor to create new class HistoryChange
@@ -89,26 +86,6 @@
     }
 
     /**
-     *   Get old identifier of the record before his changed. 
-     *   This is defined only in case if the identifier was changed.
-     *   @return identifier of the record before his changed. 
-     *   @see setOldRecordId
-     */
-    public int getOldRecordId() {
-        return this.oldRecordId;
-    }
-    
-    /**
-     *  Set old identifier of the record before his changed. 
-     *  This is defined only in case if the identifier was changed.
-     *  @param oldRecordId string containing identifier of the record before his changed.
-     *  @see getOldRecordId
-     */
-    public void setOldRecordId(int oldRecordId) {
-        this.oldRecordId = oldRecordId;
-    }    
-    
-    /**
      *   Get operation which was used. See constants defined for different operations.
      *
      *   @return operation which was used

Modified: trunk/src/net/sf/plantlore/common/record/HistoryRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/HistoryRecord.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/common/record/HistoryRecord.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -19,6 +19,7 @@
     private HistoryChange historyChange;
     private String oldValue;
     private String newValue;
+    private int oldRecordId;
     
     /** Constants with column mapping (used for building select queries) */
     public static final String ID = "id";
@@ -26,8 +27,9 @@
     public static final String HISTORYCHANGE = "historyChange";
     public static final String OLDVALUE = "oldValue";    
     public static final String NEWVALUE = "newValue";
+    public static final String OLDRECORDID = "oldRecordId";
 
-    //public enum Column {ID, HISTORYCOLUMN, HISTORYCHANGE, OLDVALUE, NEWVALUE};
+    //public enum Column {ID, HISTORYCOLUMN, HISTORYCHANGE, OLDVALUE, NEWVALUE, OLDRECORDID};
     
     /** Creates a new instance of HistoryRecord */
     public HistoryRecord() {
@@ -124,4 +126,25 @@
     public void setNewValue(String newValue) {
         this.newValue = newValue;
     }
+    
+    /**
+     *   Get old identifier of the record before his changed. 
+     *   This is defined only in case if the identifier was changed.
+     *   @return identifier of the record before his changed. 
+     *   @see setOldRecordId
+     */
+    public int getOldRecordId() {
+        return this.oldRecordId;
+    }
+    
+    /**
+     *  Set old identifier of the record before his changed. 
+     *  This is defined only in case if the identifier was changed.
+     *  @param oldRecordId string containing identifier of the record before his changed.
+     *  @see getOldRecordId
+     */
+    public void setOldRecordId(int oldRecordId) {
+        this.oldRecordId = oldRecordId;
+    }    
+    
 }

Modified: trunk/src/net/sf/plantlore/config/hibernate/Habitats.hbm.xml
===================================================================
--- trunk/src/net/sf/plantlore/config/hibernate/Habitats.hbm.xml	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/config/hibernate/Habitats.hbm.xml	2006-07-22 02:28:35 UTC (rev 468)
@@ -52,7 +52,11 @@
                 length="4096"
                 name="note"
                 not-null="false"                
-                type="java.lang.String"/>                                           
+                type="java.lang.String"/>  
+      <many-to-one name="createdWho" 
+                   class="net.sf.plantlore.common.record.User" 
+                   column="CCREATEWHO"
+                   fetch="select"/>                                           
       <property column="CDELETE"
                 name="deleted"
                 not-null="true"

Modified: trunk/src/net/sf/plantlore/config/hibernate/History.hbm.xml
===================================================================
--- trunk/src/net/sf/plantlore/config/hibernate/History.hbm.xml	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/config/hibernate/History.hbm.xml	2006-07-22 02:28:35 UTC (rev 468)
@@ -25,6 +25,10 @@
                 length="4096"
                 name="newValue"
                 not-null="false"                
-                type="java.lang.String"/>                                              
+                type="java.lang.String"/>   
+      <property column="COLDRECORDID"                
+                name="oldRecordId"
+                not-null="false"
+                type="java.lang.Integer"/>                                                           
    </class>
 </hibernate-mapping>

Modified: trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml
===================================================================
--- trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/config/hibernate/HistoryChange.hbm.xml	2006-07-22 02:28:35 UTC (rev 468)
@@ -12,11 +12,7 @@
       <property column="CRECORDID"                
                 name="recordId"
                 not-null="true"
-                type="java.lang.Integer"/>
-      <property column="COLDRECORDID"                
-                name="oldRecordId"
-                not-null="false"
-                type="java.lang.Integer"/>                
+                type="java.lang.Integer"/>      
       <property column="COPERATION"               
                 name="operation"
                 not-null="true"

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-17 17:11:29 UTC (rev 467)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-22 02:28:35 UTC (rev 468)
@@ -233,6 +233,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -296,6 +301,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -983,6 +993,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -1004,6 +1019,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -1053,6 +1073,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -1074,6 +1099,11 @@
             occ.setUpdatedWho(this.plantloreUser);
             data = occ;
         }
+        if (data instanceof Habitat) {
+            Habitat hab = (Habitat)data;
+            hab.setCreatedWho(this.plantloreUser);
+            data = hab;
+        }
         if (data instanceof Publication) {
             Publication pub = (Publication)data;
             pub.setCreatedWho(this.plantloreUser);
@@ -1601,8 +1631,7 @@
 	        } else {
 	        	return;
 	        }
-	        historyChange.setRecordId(recordId);            
-            historyChange.setOldRecordId(0);
+	        historyChange.setRecordId(recordId);                        
             historyChange.setOperation(INSERT);
             historyChange.setWho(this.plantloreUser);
             historyChange.setWhen(new java.util.Date());
@@ -1626,6 +1655,7 @@
             }                
             HistoryRecord history = new HistoryRecord();
             history.setHistoryColumn(column);
+            history.setOldRecordId(0);
             history.setNewValue(null);
             history.setOldValue(null);
             // Save into the database
@@ -1670,8 +1700,7 @@
                 	table = "";
                 }
                 if (delete == 1) {
-                    // CDELETE was set to 1, we are deleting record
-                    historyChange.setOldRecordId(0);
+                    // CDELETE was set to 1, we are deleting record                    
                     historyChange.setOperation(DELETE);
                     historyChange.setRecordId(id);
                     historyChange.setWhen(new java.util.Date());
@@ -1692,6 +1721,7 @@
                     }
                     Object[] hc = sr.get();
                     hist.setHistoryChange(historyChange);
+                    hist.setOldRecordId(0);
                     hist.setNewValue(null);
                     hist.setOldValue(null);
                     hist.setHistoryColumn((HistoryColumn)hc[0]);
@@ -1704,8 +1734,7 @@
                 (data instanceof Territory) || (data instanceof Phytochorion) ||
                 (data instanceof Village) || (data instanceof Metadata) ||
                 (data instanceof Occurrence) || (data instanceof Habitat) ||
-                (data instanceof AuthorOccurrence)) {                               
-                historyChange.setOldRecordId(0);                
+                (data instanceof AuthorOccurrence)) {                                                               
                 historyChange.setOperation(UPDATE);
                 historyChange.setWhen(new java.util.Date());
                 historyChange.setWho(this.plantloreUser);
@@ -1812,23 +1841,21 @@
                     		// Create new history record
                     		HistoryRecord historyRecord = new HistoryRecord();
                     		// Save OldRecordId if neccessary
-                    		                    		
-                    		// TODO: Save oldRecordId
                     		 if (((String)columnName).equals(Occurrence.PLANT)) {
-                    			 //TODO: tato situace by nastat nemela - zmenou kytky dojde k vlozeni noveho nalezu
-                    			 historyChange.setOldRecordId(((Plant)newRec.getValue(columnName)).getId());
+                    			 //this situation is improbability (new occurrence is insert into database during editinig of plant)   
+                    			 historyRecord.setOldRecordId(((Plant)newRec.getValue(columnName)).getId());
                     			 historyRecord.setOldValue(((Plant)origValue).getTaxon());
                          		 historyRecord.setNewValue(((Plant)newValue).getTaxon());
                     		 } else if (((String)columnName).equals(Occurrence.PUBLICATION)) {
-                    			 historyChange.setOldRecordId(((Publication)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldRecordId(((Publication)newRec.getValue(columnName)).getId());
                     			 historyRecord.setOldValue(((Publication)origValue).getReferenceCitation());
                          		 historyRecord.setNewValue(((Publication)newValue).getReferenceCitation());
                     		 } else if (((String)columnName).equals(Occurrence.HABITAT)) {
-                    			 historyChange.setOldRecordId(((Habitat)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldRecordId(((Habitat)newRec.getValue(columnName)).getId());
                     			 historyRecord.setOldValue(((Habitat)origValue).getDescription());
                          		 historyRecord.setNewValue(((Habitat)newValue).getDescription());
                     		 } else if (((String)columnName).equals(Occurrence.METADATA)) {
-                    			 historyChange.setOldRecordId(((Metadata)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldRecordId(((Metadata)newRec.getValue(columnName)).getId());                    			 
                     			 historyRecord.setOldValue(((Metadata)origValue).getDataSetTitle());
                          		 historyRecord.setNewValue(((Metadata)newValue).getDataSetTitle());
                     		 } else {
@@ -1836,6 +1863,7 @@
                          			   newValueString = (newValue == null) ? null : newValue.toString(); 
                     			historyRecord.setOldValue(origValueString);
                          		historyRecord.setNewValue(newValueString);
+                         		historyRecord.setOldRecordId(0);
                     		 }
                     		                     		 
                     		 //Save the HistoryChange object
@@ -1867,6 +1895,7 @@
                         HistoryRecord hist = new HistoryRecord(); 
                         hist.setHistoryChange(historyChange);                        
                         hist.setHistoryColumn((HistoryColumn)hc[0]);
+                        hist.setOldRecordId(0);
                         if ( newRec.getDeleted() == 1) {
 	                        hist.setNewValue(null);
 	                        hist.setOldValue(newRec.getAuthor().getWholeName());
@@ -1903,6 +1932,7 @@
 	                            HistoryRecord hist = new HistoryRecord();
 	                            hist.setHistoryChange(historyChange);	                            	                           
 	                            hist.setHistoryColumn((HistoryColumn)colNames[0]);  
+	                            hist.setOldRecordId(0);
 	                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
 	                           			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
 	                      		hist.setOldValue(origValueString);
@@ -1941,23 +1971,30 @@
                             // Save OldRecordId if neccessary
                             
                     		 //TODO: Save oldRecordId
-                    		 if (((String)cols.get(i)).equals(Habitat.TERRITORY)) {                    			 
-                    			 historyChange.setOldRecordId(((Territory)newRec.getValue((String)cols.get(i))).getId());
+                    		 if (((String)cols.get(i)).equals(Habitat.TERRITORY)) { 
+                    			 logger.debug("TERRITORY: " + ((Territory)newRec.getValue((String)cols.get(i))).getId());
+                    			 logger.debug("TERRITORY: " + ((Territory)newRec.getValue((String)cols.get(i))).getName());
+                    			 hist.setOldRecordId(((Territory)newRec.getValue((String)cols.get(i))).getId());
                     			 hist.setOldValue(((Territory)origRec.getValue((String)cols.get(i))).getName());
                                  hist.setNewValue(((Territory)newRec.getValue((String)cols.get(i))).getName());
                     		 } else if (((String)cols.get(i)).equals(Habitat.PHYTOCHORION)) {
-                    			 historyChange.setOldRecordId(((Phytochorion)newRec.getValue((String)cols.get(i))).getId());
+                    			 logger.debug("PHYTOCHORION: " + ((Phytochorion)newRec.getValue((String)cols.get(i))).getId());
+                    			 logger.debug("PHYTOCHORION: " + ((Phytochorion)newRec.getValue((String)cols.get(i))).getName());
+                    			 hist.setOldRecordId(((Phytochorion)newRec.getValue((String)cols.get(i))).getId());
                     			 hist.setOldValue(((Phytochorion)origRec.getValue((String)cols.get(i))).getName());
                                  hist.setNewValue(((Phytochorion)newRec.getValue((String)cols.get(i))).getName());
                     		 } else if (((String)cols.get(i)).equals(Habitat.VILLAGE)) {
-                    			 historyChange.setOldRecordId(((Village)newRec.getValue((String)cols.get(i))).getId());
+                    			 logger.debug("VILLAGE: " + ((Village)newRec.getValue((String)cols.get(i))).getId());
+                    			 logger.debug("VILLAGE: " + ((Village)newRec.getValue((String)cols.get(i))).getName());
+                    			 hist.setOldRecordId(((Village)newRec.getValue((String)cols.get(i))).getId());
                     			 hist.setOldValue(((Village)origRec.getValue((String)cols.get(i))).getName());
                                  hist.setNewValue(((Village)newRec.getValue((String)cols.get(i))).getName());
                     		 } else {
                     			 String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                            			    newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                       			 hist.setOldValue(origValueString);
-                           		 hist.setNewValue(newValueString);                    			
+                           		 hist.setNewValue(newValueString);  
+                           		 hist.setOldRecordId(0);
                     		 }
                     		 
                             // Save the HistoryChange object
@@ -1997,7 +2034,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                           
+                        	hist.setNewValue(newValueString); 
+                        	hist.setOldRecordId(0);
                             sess.save(hist);                            
                         }
                     }
@@ -2030,7 +2068,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                            
+                        	hist.setNewValue(newValueString);  
+                        	hist.setOldRecordId(0);
                             sess.save(hist);     
                         }
                     }
@@ -2063,7 +2102,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                            
+                        	hist.setNewValue(newValueString); 
+                        	hist.setOldRecordId(0);
                             sess.save(hist);                            
                         }
                     }
@@ -2096,7 +2136,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                            
+                        	hist.setNewValue(newValueString); 
+                        	hist.setOldRecordId(0);
                             sess.save(hist);
                         }
                     }                    
@@ -2129,7 +2170,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                            
+                        	hist.setNewValue(newValueString); 
+                        	hist.setOldRecordId(0);
                             sess.save(hist);
                         }
                     }
@@ -2162,7 +2204,8 @@
                             String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
                         			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
                    			hist.setOldValue(origValueString);
-                        	hist.setNewValue(newValueString);                           
+                        	hist.setNewValue(newValueString);  
+                        	hist.setOldRecordId(0);
                             sess.save(hist);
                         }
                     }



From lada at mail.berlios.de  Sat Jul 22 04:33:34 2006
From: lada at mail.berlios.de (lada at mail.berlios.de)
Date: Sat, 22 Jul 2006 04:33:34 +0200
Subject: [Plantlore-dev] r469 - trunk/analysis/database
Message-ID: <200607220233.k6M2XY18008775@sheep.berlios.de>

Author: lada
Date: 2006-07-22 04:33:30 +0200 (Sat, 22 Jul 2006)
New Revision: 469

Modified:
   trunk/analysis/database/DBModel_postgres.sql
   trunk/analysis/database/DBmodel.sql
   trunk/analysis/database/DBmodel_MySQL.sql
Log:
Database has been changed 
- attribute tHistoryChange.cOldRecordId has been dropped
- attribute tHistory.cOldRecordId has been added
- attribute tHabitat.cCreateWho has been added
- attribute in table Publication are bigger now (varchar(255))

Modified: trunk/analysis/database/DBModel_postgres.sql
===================================================================
--- trunk/analysis/database/DBModel_postgres.sql	2006-07-22 02:28:35 UTC (rev 468)
+++ trunk/analysis/database/DBModel_postgres.sql	2006-07-22 02:33:30 UTC (rev 469)
@@ -44,7 +44,7 @@
     COCCURRENCEID      INTEGER NOT NULL,
     CID                INTEGER NOT NULL,
     CROLE              VARCHAR(20),
-    CNOTE  VARCHAR(4096),
+    CNOTE              VARCHAR(4096),
     CDELETE           SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID));
 
@@ -61,6 +61,7 @@
     CLATITUDE          DOUBLE PRECISION,
     CLONGITUDE         DOUBLE PRECISION,
     CNOTE              VARCHAR(4096),
+    CCREATEWHO        INTEGER NOT NULL,
     CDELETE            SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID));
 
@@ -71,14 +72,13 @@
         CCHANGEID INTEGER NOT NULL,
         COLDVALUE VARCHAR(4096),
         CNEWVALUE VARCHAR(4096),
+        COLDRECORDID   INTEGER,
 PRIMARY KEY (CID));
 
 /* Table: THISTORYCHANGE */
 CREATE TABLE THISTORYCHANGE (
-    CID            SERIAL NOT NULL,
-    COCCURRENCEID  INTEGER  DEFAULT 0,
-    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,
-    COLDRECORDID   INTEGER,
+    CID            SERIAL NOT NULL,    
+    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,    
     COPERATION     SMALLINT  DEFAULT 0 NOT NULL,
     CWHEN          TIMESTAMP NOT NULL,
     CWHO           INTEGER NOT NULL,
@@ -160,12 +160,12 @@
 /* Table: TPUBLICATIONS */
 CREATE TABLE TPUBLICATIONS (
     CID                         SERIAL NOT NULL,
-    CCOLLECTIONNAME             VARCHAR(30),
+    CCOLLECTIONNAME             VARCHAR(255),
     CCOLLECTIONYEARPUBLICATION  SMALLINT,
-    CJOURNALNAME                VARCHAR(60),
-    CJOURNALAUTHORNAME          VARCHAR(30),
-    CREFERENCECITATION          VARCHAR(255) NOT NULL,
-    CREFERENCEDETAIL            VARCHAR(20),
+    CJOURNALNAME                VARCHAR(255),
+    CJOURNALAUTHORNAME          VARCHAR(255),
+    CREFERENCECITATION          VARCHAR(4096) NOT NULL,
+    CREFERENCEDETAIL            VARCHAR(100),
     CURL                        VARCHAR(100),
     CNOTE                       VARCHAR(4096),
     CCREATEWHO                  INTEGER NOT NULL,
@@ -247,6 +247,8 @@
 
 ALTER TABLE TPUBLICATIONS ADD FOREIGN KEY (CCREATEWHO) REFERENCES TUSER (CID);
 
+ALTER TABLE THABITATS ADD FOREIGN KEY (CCREATEWHO) REFERENCES TUSER (CID);
+
 CREATE USER plantlore
   PASSWORD 'plantlore'
   NOCREATEDB NOCREATEUSER;
@@ -339,10 +341,10 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (7, 'TERRITORY', NULL);
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (8, 'VILLAGE', NULL);
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (9, 'PHYTOCHORION', NULL);
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (10, 'AUTHOROCCURRENCE', 'author');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (11, 'AUTHOROCCURRENCE', 'role');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (12, 'AUTHOROCCURRENCE', 'resultRevision');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (13, 'OCCURRENCE', 'plant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (10, 'AUTHOROCCURRENCE', 'role');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (11, 'AUTHOROCCURRENCE', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (12, 'OCCURRENCE', 'plant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (13, 'OCCURRENCE', 'habitat');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (14, 'OCCURRENCE', 'yearCollected');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (15, 'OCCURRENCE', 'monthCollected');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (16, 'OCCURRENCE', 'dayCollected');
@@ -354,7 +356,7 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (22, 'OCCURRENCE', 'note');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (23, 'HABITAT', 'territory');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (24, 'HABITAT', 'phytochorion');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (25, 'HABITAT', 'nearestVillage');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (25, 'HABITAT', 'village');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (26, 'HABITAT', 'quadrant');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (27, 'HABITAT', 'description');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (28, 'HABITAT', 'country');
@@ -387,7 +389,7 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (55, 'METADATA', 'biotopeText');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (56, 'METADATA', 'versionPlantsFile');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (57, 'PUBLICATION', 'collectionName');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (58, 'PUBLICATION', 'collectionYearPublication');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (58, 'PUBLICATION', 'collectionYearPUBLICATION');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (59, 'PUBLICATION', 'journalName');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (60, 'PUBLICATION', 'journalAuthorName');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (61, 'PUBLICATION', 'referenceCitation');
@@ -398,4 +400,3 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (66, 'TERRITORY', 'name');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (67, 'PHYTOCHORIA', 'name');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (68, 'PHYTOCHORIA', 'code');
-

Modified: trunk/analysis/database/DBmodel.sql
===================================================================
--- trunk/analysis/database/DBmodel.sql	2006-07-22 02:28:35 UTC (rev 468)
+++ trunk/analysis/database/DBmodel.sql	2006-07-22 02:33:30 UTC (rev 469)
@@ -68,6 +68,7 @@
     CLATITUDE          DOUBLE PRECISION,
     CLONGITUDE         DOUBLE PRECISION,
     CNOTE              VARCHAR(4096),
+    CCREATEWHO        INTEGER NOT NULL,
     CDELETE            SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID));
 
@@ -78,14 +79,13 @@
         CCHANGEID INTEGER NOT NULL,
         COLDVALUE VARCHAR(4096),
         CNEWVALUE VARCHAR(4096),
+        COLDRECORDID   INTEGER  DEFAULT 0,
 PRIMARY KEY (CID));
 
 /* Table: THISTORYCHANGE, Owner: SYSDBA */
 CREATE TABLE THISTORYCHANGE (
-    CID            INTEGER NOT NULL,
-    COCCURRENCEID  INTEGER,
-    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,
-    COLDRECORDID   INTEGER  DEFAULT 0,
+    CID            INTEGER NOT NULL,    
+    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,    
     COPERATION     SMALLINT  DEFAULT 0 NOT NULL,
     CWHEN          TIMESTAMP NOT NULL,
     CWHO           INTEGER NOT NULL,
@@ -167,12 +167,12 @@
 /* Table: TPUBLICATIONS, Owner: SYSDBA */
 CREATE TABLE TPUBLICATIONS (
     CID                         INTEGER NOT NULL,
-    CCOLLECTIONNAME             VARCHAR(30),
+    CCOLLECTIONNAME             VARCHAR(255),
     CCOLLECTIONYEARPUBLICATION  SMALLINT,
-    CJOURNALNAME                VARCHAR(60),
-    CJOURNALAUTHORNAME          VARCHAR(30),
-    CREFERENCECITATION          VARCHAR(255) NOT NULL,
-    CREFERENCEDETAIL            VARCHAR(20),
+    CJOURNALNAME                VARCHAR(255),
+    CJOURNALAUTHORNAME          VARCHAR(255),
+    CREFERENCECITATION          VARCHAR(4096) NOT NULL,
+    CREFERENCEDETAIL            VARCHAR(100),
     CURL                        VARCHAR(100),
     CNOTE                       VARCHAR(4096),
     CCREATEWHO                  INTEGER NOT NULL,
@@ -254,6 +254,8 @@
 
 ALTER TABLE TPUBLICATIONS ADD FOREIGN KEY (CCREATEWHO) REFERENCES TUSER (CID);
 
+ALTER TABLE THABITATS ADD FOREIGN KEY (CCREATEWHO) REFERENCES TUSER (CID);
+
 /* Grant role for this database */
 
 /* Role: BOTANIK, Owner: SYSDBA */
@@ -323,3 +325,72 @@
 from TAUTHORS A JOIN TAUTHORSOCCURRENCES AO ON (A.CID = AO.cauthorid)
 WHERE AO.crole = 'identify'
 ;
+
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (1, 'AUTHOROCCURRENCE', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (2, 'OCCURRENCE', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (3, 'HABITAT', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (4, 'AUTHOR', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (5, 'METADATA', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (6, 'PUBLICATION', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (7, 'TERRITORY', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (8, 'VILLAGE', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (9, 'PHYTOCHORION', NULL);
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (10, 'AUTHOROCCURRENCE', 'role');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (11, 'AUTHOROCCURRENCE', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (12, 'OCCURRENCE', 'plant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (13, 'OCCURRENCE', 'habitat');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (14, 'OCCURRENCE', 'yearCollected');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (15, 'OCCURRENCE', 'monthCollected');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (16, 'OCCURRENCE', 'dayCollected');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (17, 'OCCURRENCE', 'timeCollected');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (18, 'OCCURRENCE', 'dataSource');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (19, 'OCCURRENCE', 'publication');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (20, 'OCCURRENCE', 'herbarium');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (21, 'OCCURRENCE', 'metadata');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (22, 'OCCURRENCE', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (23, 'HABITAT', 'territory');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (24, 'HABITAT', 'phytochorion');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (25, 'HABITAT', 'village');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (26, 'HABITAT', 'quadrant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (27, 'HABITAT', 'description');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (28, 'HABITAT', 'country');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (29, 'HABITAT', 'altitude');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (30, 'HABITAT', 'latitude');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (31, 'HABITAT', 'longitude');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (32, 'HABITAT', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (33, 'AUTHOR', 'wholeName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (34, 'AUTHOR', 'organization');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (35, 'AUTHOR', 'role');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (36, 'AUTHOR', 'address');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (37, 'AUTHOR', 'phoneNumber');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (38, 'AUTHOR', 'email');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (39, 'AUTHOR', 'url');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (40, 'AUTHOR', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (41, 'METADATA', 'technicalContactName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (42, 'METADATA', 'technicalContactAddress');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (43, 'METADATA', 'technicalContactEmail');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (44, 'METADATA', 'contentContactName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (45, 'METADATA', 'contentContactAddress');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (46, 'METADATA', 'contentContactEmail');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (47, 'METADATA', 'dataSetTitle');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (48, 'METADATA', 'dataSetDetails');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (49, 'METADATA', 'sourceInstitutionId');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (50, 'METADATA', 'sourceId');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (51, 'METADATA', 'ownerOrganizationAbbrev');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (52, 'METADATA', 'dateCreate');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (53, 'METADATA', 'dateModified');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (54, 'METADATA', 'recordBasis');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (55, 'METADATA', 'biotopeText');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (56, 'METADATA', 'versionPlantsFile');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (57, 'PUBLICATION', 'collectionName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (58, 'PUBLICATION', 'collectionYearPUBLICATION');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (59, 'PUBLICATION', 'journalName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (60, 'PUBLICATION', 'journalAuthorName');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (61, 'PUBLICATION', 'referenceCitation');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (62, 'PUBLICATION', 'referenceDetail');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (63, 'PUBLICATION', 'url');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (64, 'PUBLICATION', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (65, 'VILLAGE', 'name');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (66, 'TERRITORY', 'name');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (67, 'PHYTOCHORIA', 'name');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (68, 'PHYTOCHORIA', 'code');

Modified: trunk/analysis/database/DBmodel_MySQL.sql
===================================================================
--- trunk/analysis/database/DBmodel_MySQL.sql	2006-07-22 02:28:35 UTC (rev 468)
+++ trunk/analysis/database/DBmodel_MySQL.sql	2006-07-22 02:33:30 UTC (rev 469)
@@ -85,21 +85,21 @@
     CDATEMODIFIED             TIMESTAMP NOT NULL,
     CRECORDBASIS              VARCHAR(15) CHARACTER SET UTF8,
     CBIOTOPETEXT              VARCHAR(50) CHARACTER SET UTF8,    
-    CDELETE                   SMALLINT DEFAULT 0,
+    CDELETE                   SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID));
 
 CREATE TABLE TPUBLICATIONS (
     CID                         INTEGER NOT NULL auto_increment,
-    CCOLLECTIONNAME             VARCHAR(30) CHARACTER SET UTF8,
+    CCOLLECTIONNAME             VARCHAR(255) CHARACTER SET UTF8,
     CCOLLECTIONYEARPUBLICATION  SMALLINT,
-    CJOURNALNAME                VARCHAR(60) CHARACTER SET UTF8,
-    CJOURNALAUTHORNAME          VARCHAR(30) CHARACTER SET UTF8,
-    CREFERENCECITATION          VARCHAR(255) NOT NULL,
-    CREFERENCEDETAIL            VARCHAR(20) CHARACTER SET UTF8,
+    CJOURNALNAME                VARCHAR(255) CHARACTER SET UTF8,
+    CJOURNALAUTHORNAME          VARCHAR(255) CHARACTER SET UTF8,
+    CREFERENCECITATION          VARCHAR(4096) NOT NULL,
+    CREFERENCEDETAIL            VARCHAR(100) CHARACTER SET UTF8,
     CURL                        VARCHAR(100) CHARACTER SET UTF8,
     CNOTE                       VARCHAR(4096) CHARACTER SET UTF8,
     CCREATEWHO                  INTEGER NOT NULL,
-    CDELETE                     SMALLINT DEFAULT 0,
+    CDELETE                     SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID),
 FOREIGN KEY (CCREATEWHO) REFERENCES TUSER(CID));
 
@@ -114,7 +114,7 @@
     CURL              VARCHAR(255) CHARACTER SET UTF8,
     CNOTE             VARCHAR(4096) CHARACTER SET UTF8,
     CCREATEWHO         INTEGER NOT NULL,
-    CDELETE           SMALLINT DEFAULT 0,
+    CDELETE           SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID),
 FOREIGN KEY (CCREATEWHO) REFERENCES TUSER(CID));
 
@@ -130,10 +130,12 @@
     CLATITUDE          DOUBLE PRECISION,
     CLONGITUDE         DOUBLE PRECISION,
     CNOTE              VARCHAR(4096) CHARACTER SET UTF8,
-    CDELETE            SMALLINT DEFAULT 0 ,
+    CCREATEWHO        INTEGER NOT NULL,
+    CDELETE            SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID),
 FOREIGN KEY (CTERRITORYID) REFERENCES TTERRITORIES(CID),
 FOREIGN KEY (CPHYTOCHORIAID) REFERENCES TPHYTOCHORIA(CID),
+FOREIGN KEY (CCREATEWHO) REFERENCES TUSER(CID),
 FOREIGN KEY (CNEARESTVILLAGEID) REFERENCES TVILLAGES(CID));
 
 
@@ -157,7 +159,7 @@
     CUPDATEWHO         INTEGER NOT NULL,
     CNOTE              VARCHAR(4096) CHARACTER SET UTF8,
     CMETADATAID        INTEGER NOT NULL,
-    CDELETE            SMALLINT DEFAULT 0,
+    CDELETE            SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID),
 FOREIGN KEY (CHABITATID) REFERENCES THABITATS(CID),
 FOREIGN KEY (CPLANTID) REFERENCES TPLANTS(CID),
@@ -172,7 +174,7 @@
     CID                INTEGER NOT NULL,
     CROLE              VARCHAR(20) CHARACTER SET UTF8,
     Cnote  VARCHAR(4096) CHARACTER SET UTF8,
-    CDELETE           SMALLINT DEFAULT 0,
+    CDELETE           SMALLINT DEFAULT 0 NOT NULL,
 PRIMARY KEY (CID),
 FOREIGN KEY (CAUTHORID) REFERENCES TAUTHORS(CID),
 FOREIGN KEY (COCCURRENCEID) REFERENCES TOCCURRENCES(CID));
@@ -184,10 +186,8 @@
 PRIMARY KEY (CID));
 
 CREATE TABLE THISTORYCHANGE (
-    CID            INTEGER NOT NULL auto_increment,
-    COCCURRENCEID  INTEGER  DEFAULT 0,
-    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,
-    COLDRECORDID   INTEGER,
+    CID            INTEGER NOT NULL auto_increment,    
+    CRECORDID      INTEGER  DEFAULT 0 NOT NULL,    
     COPERATION     SMALLINT  DEFAULT 0 NOT NULL,
     CWHEN          TIMESTAMP NOT NULL,
     CWHO           INTEGER NOT NULL,
@@ -200,6 +200,7 @@
         CCHANGEID INTEGER NOT NULL,
         COLDVALUE VARCHAR(4096) CHARACTER SET UTF8,
         CNEWVALUE VARCHAR(4096) CHARACTER SET UTF8,
+        COLDRECORDID   INTEGER,
 PRIMARY KEY (CID),
 FOREIGN KEY (CCOLUMNID) REFERENCES THISTORYCOLUMN(CID),
 FOREIGN KEY (CCHANGEID) REFERENCES THISTORYCHANGE(CID));
@@ -213,10 +214,10 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (7, 'TERRITORY', NULL);
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (8, 'VILLAGE', NULL);
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (9, 'PHYTOCHORION', NULL);
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (10, 'AUTHOROCCURRENCE', 'author');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (11, 'AUTHOROCCURRENCE', 'role');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (12, 'AUTHOROCCURRENCE', 'resultRevision');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (13, 'OCCURRENCE', 'plant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (10, 'AUTHOROCCURRENCE', 'role');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (11, 'AUTHOROCCURRENCE', 'note');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (12, 'OCCURRENCE', 'plant');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (13, 'OCCURRENCE', 'habitat');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (14, 'OCCURRENCE', 'yearCollected');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (15, 'OCCURRENCE', 'monthCollected');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (16, 'OCCURRENCE', 'dayCollected');
@@ -228,7 +229,7 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (22, 'OCCURRENCE', 'note');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (23, 'HABITAT', 'territory');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (24, 'HABITAT', 'phytochorion');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (25, 'HABITAT', 'nearestVillage');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (25, 'HABITAT', 'village');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (26, 'HABITAT', 'quadrant');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (27, 'HABITAT', 'description');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (28, 'HABITAT', 'country');
@@ -261,7 +262,7 @@
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (55, 'METADATA', 'biotopeText');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (56, 'METADATA', 'versionPlantsFile');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (57, 'PUBLICATION', 'collectionName');
-INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (58, 'PUBLICATION', 'collectionYearPublication');
+INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (58, 'PUBLICATION', 'collectionYearPUBLICATION');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (59, 'PUBLICATION', 'journalName');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (60, 'PUBLICATION', 'journalAuthorName');
 INSERT INTO thistorycolumn (cid, ctablename, ccolumnname) VALUES (61, 'PUBLICATION', 'referenceCitation');



From lada at mail.berlios.de  Sun Jul 23 20:41:10 2006
From: lada at mail.berlios.de (lada at mail.berlios.de)
Date: Sun, 23 Jul 2006 20:41:10 +0200
Subject: [Plantlore-dev] r470 - in trunk/src/net/sf/plantlore:
	client/history common
Message-ID: <200607231841.k6NIfAm6010361@sheep.berlios.de>

Author: lada
Date: 2006-07-23 20:41:04 +0200 (Sun, 23 Jul 2006)
New Revision: 470

Modified:
   trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.form
   trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.form
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryView.form
   trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
   trunk/src/net/sf/plantlore/common/ProgressBar.java
Log:
History - task, long transaction, rewrite view form - correct layout after expansion of dialog, tab, white background, ... (sometimes netbeans don`t save changes in form correctly - often old value is not rewrite in source).

Modified: trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.form	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.form	2006-07-23 18:41:04 UTC (rev 470)
@@ -23,7 +23,7 @@
                   <Component id="jPanel1" alignment="0" max="32767" attributes="0"/>
                   <Group type="102" alignment="1" attributes="0">
                       <Component id="helpButton" min="-2" pref="100" max="-2" attributes="0"/>
-                      <EmptySpace pref="189" max="32767" attributes="0"/>
+                      <EmptySpace pref="193" max="32767" attributes="0"/>
                       <Component id="closeButton" min="-2" pref="100" max="-2" attributes="0"/>
                   </Group>
               </Group>
@@ -34,13 +34,13 @@
     <DimensionLayout dim="1">
       <Group type="103" groupAlignment="0" attributes="0">
           <Group type="102" alignment="0" attributes="0">
-              <Component id="jPanel1" min="-2" max="-2" attributes="0"/>
+              <Component id="jPanel1" max="32767" attributes="0"/>
               <EmptySpace min="-2" pref="11" max="-2" attributes="0"/>
               <Group type="103" groupAlignment="3" attributes="0">
                   <Component id="closeButton" alignment="3" min="-2" max="-2" attributes="0"/>
                   <Component id="helpButton" alignment="3" min="-2" max="-2" attributes="0"/>
               </Group>
-              <EmptySpace max="32767" attributes="0"/>
+              <EmptySpace min="-2" max="-2" attributes="0"/>
           </Group>
       </Group>
     </DimensionLayout>

Modified: trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -80,7 +80,7 @@
         jPanel1.setLayout(jPanel1Layout);
         jPanel1Layout.setHorizontalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jScrollPane2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 373, Short.MAX_VALUE)
+            .add(jScrollPane2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 377, Short.MAX_VALUE)
         );
         jPanel1Layout.setVerticalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
@@ -101,19 +101,19 @@
                     .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                     .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                         .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 189, Short.MAX_VALUE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 193, Short.MAX_VALUE)
                         .add(closeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                 .addContainerGap())
         );
         layout.setVerticalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(layout.createSequentialGroup()
-                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                 .add(11, 11, 11)
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(closeButton)
                     .add(helpButton))
-                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+                .addContainerGap())
         );
         pack();
     }// </editor-fold>//GEN-END:initComponents

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -20,6 +20,7 @@
 import java.util.Hashtable;
 import java.util.Observable;
 import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.Task;
 import net.sf.plantlore.common.record.Author;
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Habitat;
@@ -74,7 +75,11 @@
     /** List of identifier of selected item */
     private HashSet markListId = new HashSet();
     /** List of pairs (Item, identifier of the oldest change of this Item) */
-    private ArrayList<Object[]> markItem = new ArrayList<Object[]>();
+    private ArrayList<Object[]> markItem = new ArrayList<Object[]>();    
+    /** Identifier of the oldest changes which will be restored */
+    private int toResult;
+    /** Containing information about type of history (false == whole history and true == history of record) */
+    private boolean typeHistory;
     /** Information about useing function Select All*/
     private boolean selectAll;
     /** Information about useing function Unselected All*/
@@ -213,7 +218,7 @@
      *  Creates a new instance of History - history of specific habitat 
      *  @param database Instance of a database management object
      *  @param idObj integer containing identifier of specific habitat
-     *  @param infoHabitat 
+     *  @param innfoHabitat 
      * */
     public History(DBLayer database, int idObj, String infoHabitat)
     {
@@ -1436,7 +1441,14 @@
             setChanged();
             notifyObservers();
         }     
-               
+          
+        if (objects == null) {
+        	logger.error("tAuthors doesn't contain required data");  
+ 		    setError(ERROR_SEARCH_AUTHOR);		    		   
+            setChanged();
+            notifyObservers();
+        }
+        
        return objects;
     }
     
@@ -1462,47 +1474,69 @@
     }
     
     /**
-     *  Update data in the database.
+     *  Update data in the database and delete selected data from history tables.
+     *  Operation is executed in a separate thread using Task class.
+     *  @param toResult identifier of the oldest changes which will be restored
+     *  @param typeHistory containing information about type of history (whole history or history of record)
+     *  @return instance of the Task with the long running operation (commitUpdate)
      */
-    public void commitUpdate() {    	                
+    public Task commitUpdate(int toResult, boolean typeHistory) {   
+    	this.toResult = toResult;
+    	this.typeHistory = typeHistory;
+    	
+    	final Task task = new Task() {    		    		
+    		public Object task() throws DBLayerException, RemoteException {
+    	
+		        ArrayList<Enum> editType = new ArrayList<Enum>();
+		        int count = editObjectList.size();
+		        boolean ok = false;
+		        String type;
+		        Enum key;
         
-        ArrayList<Enum> editType = new ArrayList<Enum>();
-        String type;
-        Enum key;
-        initEditTypeHash();
-        
-    	int count = editObjectList.size();
-              	
-    	for (int i=0; i< count; i++) {
-    		try {
-    			logger.debug("Object for update: "+ ((Record)editObjectList.get(i)).getId());                         
-                type = editObjectList.get(i).getClass().getSimpleName();
-                 if (editTypeHash.containsKey(type)) {
-                         key = (Enum)editTypeHash.get(type); 
-                         if(!editType.contains(key))
-                             editType.add(key);
-                }                                                     
-                database.executeUpdateHistory(editObjectList.get(i));
-	        } catch (RemoteException e) {
-	        	logger.error("Update data failed.Remote exception caught in History. Details: "+e.getMessage());
-	       	    setError(ERROR_UPDATE);
-	       	    //Tell observers to update
-	            setChanged();
-	            notifyObservers();
-	            return;
-	        } catch (DBLayerException e) {
-	        	logger.error("Update data failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-	            setError(ERROR_UPDATE); 
-	            //Tell observers to update
-	            setChanged();
-	            notifyObservers();
-	            return;
-	        } 
-       }    	
-    	//Create array of editing object and call notifyObservers
-        informMethod(editType);
+		        initEditTypeHash();
+            	    	
+		        ok = database.beginTransaction();
+		        if (!ok) {
+		            logger.debug("History.commitUpdate(): Can't create transaction. Another is probably already running.");
+		            throw new DBLayerException("Can't create transaction. Another already running.");
+		        }
+		        
+		        try {
+			    	for (int i=0; i< count; i++) {			    		
+			    			logger.debug("Object for update: "+ ((Record)editObjectList.get(i)).getId());                         
+			                type = editObjectList.get(i).getClass().getSimpleName();
+			                 if (editTypeHash.containsKey(type)) {
+			                         key = (Enum)editTypeHash.get(type); 
+			                         if(!editType.contains(key))
+			                             editType.add(key);
+			                }                                                     
+			                database.executeUpdateHistory(editObjectList.get(i));
+			    		}
+			    	//Delete selected data from history tables 
+			    	deleteHistory();
+		        } catch (RemoteException e) {
+		        	logger.error("Process UNDO failed. Remote exception caught in History. Details: "+e.getMessage());
+		        	database.rollbackTransaction();
+                    RemoteException remex = new RemoteException(ERROR_UPDATE + e);
+                    remex.setStackTrace(e.getStackTrace());
+                    throw remex; 		           
+		       	    
+		        } catch (DBLayerException e) {
+		        	logger.error("Process UNDO failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+		        	database.rollbackTransaction();
+                    DBLayerException dbex = new DBLayerException(ERROR_UPDATE + e);
+                    dbex.setStackTrace(e.getStackTrace());
+                    throw dbex; 		            
+		        } 
+		        database.commitTransaction();	    	
+		    	//Create array of editing object and call notifyObservers
+		        informMethod(editType);	    		    	        
+		        return null;
+    		}
+	    };
+	    return task;
     }
-    
+	    
     /**
      *  Create array of editing object and give this array to parrent
      *  @param editType containing list of type of editing object 
@@ -1526,11 +1560,11 @@
     }
        
     /**
-     * Delete selected data from history table. During delete data from table tHistoryChange verify foring key from table tHistory.
-     * @param toResult identifier of the oldest changes which will be restored
-     * @param typeHistory containing information about type of history (whole history or history of record)
+     * Delete selected data from history table. 
+     * During delete data from table tHistoryChange verify foring key from table tHistory. 
+     * Operation is executed in a separate thread using Task class.   
      */
-    public void deleteHistory(int toResult, boolean typeHistory) {
+    public void deleteHistory() throws DBLayerException, RemoteException {
    	
     	//take from younger record to older record
     	for( int i=0; i < toResult; i++) {
@@ -1544,18 +1578,17 @@
 	    	try {
 				database.executeDeleteHistory(historyRecord);
 				logger.debug("Deleting historyRecord successfully. Number of result: "+i);
-			} catch (RemoteException e) {				
-				logger.error("Deleting historyRecord failed.Remote exception caught in History. Details: "+e.getMessage());
-	       	    setError(ERROR_DELETE);
-	       	    //Tell observers to update
-	            setChanged();
-	            notifyObservers();
-			} catch (DBLayerException e) {				
-				logger.error("Deleting historyRecord failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-	            setError(ERROR_DELETE); 
-	            //Tell observers to update
-	            setChanged();
-	            notifyObservers();
+			} catch (RemoteException e) {								
+				logger.error("Process UNDO failed. Deleting historyRecord failed. Remote exception caught in History. Details: "+e.getMessage());	        	
+                RemoteException remex = new RemoteException(ERROR_DELETE + e);
+                remex.setStackTrace(e.getStackTrace());
+                throw remex; 		           
+			} catch (DBLayerException e) {								
+				logger.error("Process UNDO failed. Deleting historyRecord failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+	        	database.rollbackTransaction();
+                DBLayerException dbex = new DBLayerException(ERROR_DELETE + e);
+                dbex.setStackTrace(e.getStackTrace());
+                throw dbex; 		           	          
 			}
 			int countResult = getRelationshipHistoryChange(historyChange.getId());			
 			if (countResult == 0) {				
@@ -1563,17 +1596,16 @@
 					database.executeDeleteHistory(historyChange);
 					logger.debug("Deleting historyChange successfully.");
 				} catch (RemoteException e) {
-					logger.error("Deleting historyChange failed.Remote exception caught in History. Details: "+e.getMessage());
-		       	    setError(ERROR_DELETE);
-		       	    //Tell observers to update
-		            setChanged();
-		            notifyObservers();
+					logger.error("Process UNDO failed. Deleting historyChange failed. Remote exception caught in History. Details: "+e.getMessage());	        	
+	                RemoteException remex = new RemoteException(ERROR_DELETE + e);
+	                remex.setStackTrace(e.getStackTrace());
+	                throw remex; 		           
 				} catch (DBLayerException e) {
-					logger.error("Deleting historyChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-		            setError(ERROR_DELETE); 
-		            //Tell observers to update
-		            setChanged();
-		            notifyObservers();
+					logger.error("Process UNDO failed. Deleting historyChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+		        	database.rollbackTransaction();
+	                DBLayerException dbex = new DBLayerException(ERROR_DELETE + e);
+	                dbex.setStackTrace(e.getStackTrace());
+	                throw dbex; 		           
 				}
 			} else {
 				logger.debug("Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.");
@@ -1775,134 +1807,83 @@
     
     /**
      *  Delete all date from tables tHistory and tHistoryChange
+     *  Operation is executed in a separate thread using Task class.
      */
-    public void clearHistory() {        
-        
-    	//TODO uzavrit to do dlouhotrvajici transakce
+    public void clearHistory() throws RemoteException, DBLayerException {        
+            	
         try {
             //delete data from table tHistory
             database.conditionDelete(HistoryRecord.class, HistoryRecord.ID, ">", 0);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tHistory failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_HISTORY);       	   
-            setChanged();
-            notifyObservers();    
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tHistory failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_HISTORY);            
-            setChanged();
-            notifyObservers(); 
-            return;
-        }        
-        
-        try {            
             //delete data from  table tHistoryChange
             database.conditionDelete(HistoryChange.class, HistoryChange.ID, ">", 0);
         } catch (RemoteException e) {
-        	logger.error("Delete data from tHistoryChange failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_HISTORY);       	   
-            setChanged();
-            notifyObservers();  
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tHistoryChange failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_HISTORY);            
-            setChanged();
-            notifyObservers();
-            return;
-        }        
-        
+        	logger.error("Process cleare database failed. Remote exception caught in History. Details: "+e.getMessage());
+        	database.rollbackTransaction();
+            RemoteException remex = new RemoteException(ERROR_CLEAR_HISTORY + e);
+            remex.setStackTrace(e.getStackTrace());
+            throw remex; 		           
+       	    
+        } catch (DBLayerException e) {
+        	logger.error("Process cleare database failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+        	database.rollbackTransaction();
+            DBLayerException dbex = new DBLayerException(ERROR_CLEAR_HISTORY + e);
+            dbex.setStackTrace(e.getStackTrace());
+            throw dbex; 		            
+        }       
     }
     
     /**
-     * Delete records from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications with condition cdelete == 1 
+     * Delete records from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications with condition cdelete == 1
+     * and delete all date from tables tHistory and tHistoryChange
+     * Operation is executed in a separate thread using Task class. 
+     * @return instance of the Task with the long running operation (clearDatabase)
      */
-    public void clearDatabase() {
+    public Task clearDatabase() {
     	
     	//TODO - osetrit proti smazani zaznamu na ktery existuje FK
-    	//Uzavrit to do dlouho trvajici transakce, at se to provede bud vse nebo nic 
     	
-        try {
-            // delete data from table tAuthor with contidion cDelete == 1
-            database.conditionDelete(Author.class, Author.DELETED, "=", 1);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tAuthor failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_DATABASE);       	   
-            setChanged();
-            notifyObservers();   
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tAuthor failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_DATABASE);            
-            setChanged();
-            notifyObservers();  
-            return;
-        }        
-        try {
-        	//delete data from table tAuthorOccurrence with contidion cDelete > 0
-            database.conditionDelete(AuthorOccurrence.class, AuthorOccurrence.DELETED, ">", 0);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tAuthorOccurrence failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_DATABASE);       	   
-            setChanged();
-            notifyObservers();
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tAuthorOccurrence failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_DATABASE);            
-            setChanged();
-            notifyObservers();
-            return;
-        }        
-        try {
-        	// delete data from table tOccurrence with contidion cDelete == 1
-            database.conditionDelete(Occurrence.class, Occurrence.DELETED, "=", 1);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tOccurrence failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_DATABASE);       	   
-            setChanged();
-            notifyObservers();
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tOccurrence failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_DATABASE);            
-            setChanged();
-            notifyObservers();
-            return;
-        }        
-        try {
-        	// delete data from table tHabitat with contidion cDelete == 1
-            database.conditionDelete(Habitat.class, Habitat.DELETED, "=", 1);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tHabitat failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_DATABASE);       	   
-            setChanged();
-            notifyObservers();
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tHabitat failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_DATABASE);            
-            setChanged();
-            notifyObservers();
-            return;
-        }        
-        try {
-        	// delete data from table tPublication with contidion cDelete == 1
-            database.conditionDelete(Publication.class, Publication.DELETED, "=", 1);
-        } catch (RemoteException e) {
-        	logger.error("Delete data from tPublication failed.Remote exception caught in History. Details: "+e.getMessage());
-       	    setError(ERROR_CLEAR_DATABASE);       	   
-            setChanged();
-            notifyObservers();
-            return;
-        } catch(DBLayerException e) {
-        	logger.error("Delete data from tPublication failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
-            setError(ERROR_CLEAR_DATABASE);            
-            setChanged();
-            notifyObservers();
-            return;
-        }        
+    	final Task task = new Task() {    		    		
+    		public Object task() throws DBLayerException, RemoteException {
+    			boolean ok = false;
+    			
+    			ok = database.beginTransaction();
+		        if (!ok) {
+		            logger.debug("History.clearDatabase(): Can't create transaction. Another is probably already running.");
+		            throw new DBLayerException("Can't create transaction. Another already running.");
+		        }
+		        
+		        try {
+		        	// delete data from table tAuthor with contidion cDelete == 1
+		            database.conditionDelete(Author.class, Author.DELETED, "=", 1);
+		            // delete data from table tAuthorOccurrence with contidion cDelete > 0
+		            database.conditionDelete(AuthorOccurrence.class, AuthorOccurrence.DELETED, ">", 0);
+		            // delete data from table tOccurrence with contidion cDelete == 1
+		            database.conditionDelete(Occurrence.class, Occurrence.DELETED, "=", 1);
+		            // delete data from table tHabitat with contidion cDelete == 1
+		            database.conditionDelete(Habitat.class, Habitat.DELETED, "=", 1);
+		            // delete data from table tPublication with contidion cDelete == 1
+		            database.conditionDelete(Publication.class, Publication.DELETED, "=", 1);
+		            //Delete all date from tables tHistory and tHistoryChange
+		            clearHistory();
+		        } catch (RemoteException e) {
+		        	logger.error("Process cleare database failed. Remote exception caught in History. Details: "+e.getMessage());
+		        	database.rollbackTransaction();
+                    RemoteException remex = new RemoteException(ERROR_CLEAR_DATABASE + e);
+                    remex.setStackTrace(e.getStackTrace());
+                    throw remex; 		           
+		       	    
+		        } catch (DBLayerException e) {
+		        	logger.error("Process cleare database failed. DBLayer exception caught in History. Details: "+e.getMessage());       	                                                   
+		        	database.rollbackTransaction();
+                    DBLayerException dbex = new DBLayerException(ERROR_CLEAR_DATABASE + e);
+                    dbex.setStackTrace(e.getStackTrace());
+                    throw dbex; 		            
+		        } 
+		        database.commitTransaction(); 
+		        return null;
+    		}
+    	};
+    	return task;
     }
     
     /**

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -3,6 +3,15 @@
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
+import java.rmi.RemoteException;
+
+import javax.swing.JOptionPane;
+
+import net.sf.plantlore.common.ProgressBar;
+import net.sf.plantlore.common.Task;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.l10n.L10n;
+
 import org.apache.log4j.Logger;
 
 /**
@@ -202,23 +211,54 @@
                if (okCancle == 0){
             	   //Button OK was press
             	   logger.debug("Button OK was press.");
-            	   model.commitUpdate();
-            	   model.deleteHistory(model.getResultRows(), true);            	   
-            	   model.searchEditHistory(model.getData());
-            	   model.processResult(1,model.getDisplayRows());
-            	   view.getTable().setModel(new HistoryTableModel(model));
-            	   int resultRows = model.getResultRows();
-            	   if (resultRows == 0) {
-            		   view.setCurrentRowsInfo("0-0"); 
-            	   } else {
-            		   int from = model.getCurrentFirstRow();
-                       int to = from + view.getTable().getRowCount() - 1;               
-                       view.setCurrentRowsInfo(from + "-" + to);    
-            	   }               
-                       view.setCountResutl(resultRows);   
+            	   Task task = model.commitUpdate(model.getResultRows(), true);  
+            	   
+            	   ProgressBar progressBar = new ProgressBar(task, view, true) {		   				
+						private static final long serialVersionUID = -6065695152319199854L;
+							public void exceptionHandler(Exception e) {
+		   						if (e instanceof DBLayerException) {	   									   							
+		   							DBLayerException dbex = (DBLayerException) e;
+		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(dbex + ": " + dbex.getErrorInfo());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						if (e instanceof RemoteException) {	 
+		   							RemoteException remex = (RemoteException) e;
+		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+		   							JOptionPane.showMessageDialog(view, L10n.getString("Error.RemoteException")+ "\n" + remex.getMessage(),
+		 							   L10n.getString("Error.RemoteExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(remex + ": " + remex.getMessage());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						JOptionPane.showMessageDialog(view, L10n.getString("Delete.Message.UnknownException")+ "\n" + e.getMessage(),
+			 					    L10n.getString("Delete.Message.UnknownExceptionTitle"), JOptionPane.WARNING_MESSAGE);							
+		   						logger.error(e);
+		   					}
+	
+		   					public void afterStopping() {
+		   					   model.searchEditHistory(model.getData());
+		   	            	   model.processResult(1,model.getDisplayRows());
+		   	            	   view.getTable().setModel(new HistoryTableModel(model));
+		   	            	   int resultRows = model.getResultRows();
+		   	            	   if (resultRows == 0) {
+		   	            		   view.setCurrentRowsInfo("0-0"); 
+		   	            	   } else {
+		   	            		   int from = model.getCurrentFirstRow();
+		   	                       int to = from + view.getTable().getRowCount() - 1;               
+		   	                       view.setCurrentRowsInfo(from + "-" + to);    
+		   	            	   }               
+		   	                       view.setCountResutl(resultRows);   
+		   	               } 		   					
+		   				};
+		   				progressBar.setTitle(L10n.getString("History.Undo.ProgressTitle"));	                   	                   
+	                    task.start();            	               	   
                } else {            	  
             	   logger.debug("Button Cancle was press."); 
-               }
+               }  
            } else {
         	   model.setError(null);        	           	  
            }

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.form	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.form	2006-07-23 18:41:04 UTC (rev 470)
@@ -17,28 +17,24 @@
   <Layout>
     <DimensionLayout dim="0">
       <Group type="103" groupAlignment="0" attributes="0">
-          <Group type="102" attributes="0">
+          <Group type="102" alignment="0" attributes="0">
               <EmptySpace max="-2" attributes="0"/>
               <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" alignment="1" attributes="0">
-                      <Group type="103" groupAlignment="1" attributes="0">
-                          <Group type="102" alignment="1" attributes="0">
-                              <Component id="helpButton" min="-2" pref="100" max="-2" attributes="0"/>
-                              <EmptySpace pref="364" max="32767" attributes="0"/>
-                              <Component id="okButton" min="-2" pref="100" max="-2" attributes="0"/>
-                              <EmptySpace min="-2" pref="20" max="-2" attributes="0"/>
-                              <Component id="closeButton" min="-2" pref="100" max="-2" attributes="0"/>
-                          </Group>
-                          <Component id="jPanel3" alignment="1" pref="684" max="32767" attributes="1"/>
-                      </Group>
-                      <EmptySpace min="-2" max="-2" attributes="0"/>
+                  <Group type="102" alignment="0" attributes="0">
+                      <Component id="helpButton" min="-2" pref="60" max="-2" attributes="0"/>
+                      <EmptySpace pref="472" max="32767" attributes="0"/>
+                      <Component id="okButton" min="-2" pref="60" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Component id="closeButton" min="-2" pref="60" max="-2" attributes="0"/>
+                      <EmptySpace min="-2" pref="30" max="-2" attributes="0"/>
                   </Group>
                   <Group type="102" alignment="1" attributes="0">
                       <Group type="103" groupAlignment="1" attributes="0">
-                          <Component id="jPanel1" alignment="0" max="32767" attributes="1"/>
-                          <Component id="jPanel2" alignment="1" max="32767" attributes="1"/>
+                          <Component id="jPanel1" alignment="0" max="32767" attributes="0"/>
+                          <Component id="jPanel2" alignment="0" max="32767" attributes="0"/>
+                          <Component id="jPanel3" alignment="1" max="32767" attributes="0"/>
                       </Group>
-                      <EmptySpace min="-2" pref="20" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
                   </Group>
               </Group>
           </Group>
@@ -46,20 +42,20 @@
     </DimensionLayout>
     <DimensionLayout dim="1">
       <Group type="103" groupAlignment="0" attributes="0">
-          <Group type="102" alignment="0" max="-2" attributes="0">
+          <Group type="102" alignment="0" attributes="0">
               <EmptySpace max="-2" attributes="0"/>
               <Component id="jPanel1" min="-2" max="-2" attributes="0"/>
               <EmptySpace max="-2" attributes="0"/>
               <Component id="jPanel2" min="-2" max="-2" attributes="0"/>
               <EmptySpace max="-2" attributes="0"/>
-              <Component id="jPanel3" min="-2" max="-2" attributes="0"/>
-              <EmptySpace min="-2" pref="15" max="-2" attributes="0"/>
+              <Component id="jPanel3" max="32767" attributes="0"/>
+              <EmptySpace min="-2" pref="14" max="-2" attributes="0"/>
               <Group type="103" groupAlignment="3" attributes="0">
                   <Component id="helpButton" alignment="3" min="-2" max="-2" attributes="0"/>
-                  <Component id="okButton" alignment="3" min="-2" max="-2" attributes="0"/>
                   <Component id="closeButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="okButton" alignment="3" min="-2" max="-2" attributes="0"/>
               </Group>
-              <EmptySpace max="32767" attributes="0"/>
+              <EmptySpace min="-2" max="-2" attributes="0"/>
           </Group>
       </Group>
     </DimensionLayout>
@@ -79,27 +75,26 @@
       <Layout>
         <DimensionLayout dim="0">
           <Group type="103" groupAlignment="0" attributes="0">
-              <Group type="102" attributes="0">
-                  <EmptySpace max="-2" attributes="0"/>
+              <Group type="102" alignment="0" attributes="0">
+                  <EmptySpace min="-2" pref="19" max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="0" attributes="0">
-                      <Component id="taxonLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                       <Component id="authorLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                       <Component id="locationLabel" alignment="0" min="-2" max="-2" attributes="0"/>
+                      <Component id="taxonLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace min="-2" pref="83" max="-2" attributes="0"/>
+                  <EmptySpace pref="57" max="32767" attributes="0"/>
                   <Group type="103" groupAlignment="0" attributes="0">
-                      <Component id="locationValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
-                      <Component id="authorValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                       <Component id="taxonValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
+                      <Component id="authorValueLabel" min="-2" max="-2" attributes="0"/>
+                      <Component id="locationValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace pref="428" max="32767" attributes="0"/>
+                  <EmptySpace pref="445" max="32767" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
         <DimensionLayout dim="1">
           <Group type="103" groupAlignment="0" attributes="0">
               <Group type="102" alignment="0" attributes="0">
-                  <EmptySpace max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="3" attributes="0">
                       <Component id="taxonLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="taxonValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
@@ -114,7 +109,6 @@
                       <Component id="locationLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="locationValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace max="-2" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
@@ -187,18 +181,18 @@
       <Layout>
         <DimensionLayout dim="0">
           <Group type="103" groupAlignment="0" attributes="0">
-              <Group type="102" attributes="0">
-                  <EmptySpace max="-2" attributes="0"/>
+              <Group type="102" alignment="0" attributes="0">
+                  <EmptySpace min="-2" pref="20" max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="0" attributes="0">
-                      <Component id="whenInserLabel" alignment="0" min="-2" max="-2" attributes="0"/>
-                      <Component id="whoInsertLabel" alignment="0" min="-2" max="-2" attributes="0"/>
+                      <Component id="whenInsertLabel" min="-2" max="-2" attributes="0"/>
+                      <Component id="whoInsertLabel" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace min="-2" pref="80" max="-2" attributes="0"/>
+                  <EmptySpace min="-2" pref="39" max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="0" attributes="0">
-                      <Component id="whoInsertValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
-                      <Component id="whenInsertValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
+                      <Component id="whenInsertValueLabel" min="-2" max="-2" attributes="0"/>
+                      <Component id="whoInsertValueLabel" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace pref="431" max="32767" attributes="0"/>
+                  <EmptySpace pref="462" max="32767" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
@@ -206,21 +200,20 @@
           <Group type="103" groupAlignment="0" attributes="0">
               <Group type="102" alignment="0" attributes="0">
                   <Group type="103" groupAlignment="3" attributes="0">
-                      <Component id="whenInserLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="whenInsertValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="whenInsertLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
                   <EmptySpace max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="3" attributes="0">
-                      <Component id="whoInsertLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="whoInsertValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="whoInsertLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace pref="14" max="32767" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
       </Layout>
       <SubComponents>
-        <Component class="javax.swing.JLabel" name="whenInserLabel">
+        <Component class="javax.swing.JLabel" name="whenInsertLabel">
           <Properties>
             <Property name="font" type="java.awt.Font" editor="org.netbeans.beaninfo.editors.FontEditor">
               <Font name="Tahoma" size="11" style="1"/>
@@ -270,24 +263,34 @@
       <Layout>
         <DimensionLayout dim="0">
           <Group type="103" groupAlignment="0" attributes="0">
-              <Group type="102" attributes="0">
-                  <Group type="103" groupAlignment="0" attributes="0">
+              <Group type="102" alignment="1" attributes="0">
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="1" attributes="0">
+                      <Component id="jScrollPane1" alignment="0" pref="642" max="32767" attributes="0"/>
                       <Group type="102" alignment="1" attributes="0">
-                          <EmptySpace min="-2" pref="326" max="-2" attributes="0"/>
-                          <Component id="undoButton" min="-2" pref="110" max="-2" attributes="2"/>
-                          <EmptySpace min="-2" max="-2" attributes="0"/>
-                          <Component id="selectAllButton" min="-2" pref="110" max="-2" attributes="2"/>
-                          <EmptySpace min="-2" max="-2" attributes="0"/>
-                          <Component id="unselectAllButton" min="-2" pref="110" max="-2" attributes="1"/>
+                          <Component id="undoButton" min="-2" pref="90" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="selectAllButton" min="-2" pref="90" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="unselectAllButton" min="-2" pref="90" max="-2" attributes="0"/>
                       </Group>
-                      <Group type="102" alignment="0" attributes="0">
-                          <Component id="previousButton" min="-2" pref="100" max="-2" attributes="1"/>
-                          <EmptySpace pref="33" max="32767" attributes="0"/>
-                          <Component id="jPanel4" min="-2" max="-2" attributes="0"/>
+                      <Group type="102" alignment="1" attributes="0">
+                          <Component id="previousButton" min="-2" pref="60" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="68" max="-2" attributes="0"/>
+                          <Component id="totalResultLabel" min="-2" max="-2" attributes="0"/>
                           <EmptySpace max="-2" attributes="0"/>
-                          <Component id="nextButton" min="-2" pref="100" max="-2" attributes="1"/>
+                          <Component id="totalResultValueLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="33" max="-2" attributes="0"/>
+                          <Component id="toDisplayLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="toDisplayValueTextField" min="-2" pref="29" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="42" max="-2" attributes="0"/>
+                          <Component id="displayedLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="displayedValueLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="32767" attributes="0"/>
+                          <Component id="nextButton" min="-2" pref="60" max="-2" attributes="0"/>
                       </Group>
-                      <Component id="jScrollPane1" alignment="0" pref="668" max="32767" attributes="1"/>
                   </Group>
                   <EmptySpace max="-2" attributes="0"/>
               </Group>
@@ -295,27 +298,35 @@
         </DimensionLayout>
         <DimensionLayout dim="1">
           <Group type="103" groupAlignment="0" attributes="0">
-              <Group type="102" alignment="0" max="-2" attributes="0">
-                  <Component id="jScrollPane1" min="-2" pref="214" max="-2" attributes="0"/>
-                  <EmptySpace max="-2" attributes="0"/>
-                  <Group type="103" groupAlignment="1" attributes="0">
-                      <Component id="jPanel4" alignment="1" min="-2" pref="36" max="-2" attributes="0"/>
-                      <Component id="previousButton" min="-2" max="-2" attributes="0"/>
-                      <Component id="nextButton" min="-2" max="-2" attributes="0"/>
+              <Group type="102" alignment="1" attributes="0">
+                  <Component id="jScrollPane1" pref="224" max="32767" attributes="0"/>
+                  <EmptySpace min="-2" pref="14" max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="3" attributes="0">
+                      <Component id="nextButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="previousButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="totalResultValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="totalResultLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="toDisplayLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="toDisplayValueTextField" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="displayedLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="displayedValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace max="-2" attributes="0"/>
+                  <EmptySpace min="-2" max="-2" attributes="0"/>
                   <Group type="103" groupAlignment="3" attributes="0">
+                      <Component id="unselectAllButton" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="selectAllButton" alignment="3" min="-2" max="-2" attributes="0"/>
                       <Component id="undoButton" alignment="3" min="-2" max="-2" attributes="0"/>
-                      <Component id="unselectAllButton" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace max="-2" attributes="0"/>
+                  <EmptySpace min="-2" max="-2" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
       </Layout>
       <SubComponents>
         <Container class="javax.swing.JScrollPane" name="jScrollPane1">
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_InitCodePost" type="java.lang.String" value="jScrollPane1.getViewport().setBackground(Color.WHITE);"/>
+          </AuxValues>
 
           <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
           <SubComponents>
@@ -330,6 +341,9 @@
                   </Table>
                 </Property>
               </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_InitCodePost" type="java.lang.String" value="TransferFocus.patch(tableEditList);"/>
+              </AuxValues>
             </Component>
           </SubComponents>
         </Container>
@@ -353,20 +367,20 @@
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
-        <Component class="javax.swing.JButton" name="selectAllButton">
+        <Component class="javax.swing.JButton" name="unselectAllButton">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-              <Connection code="L10n.getString(&quot;History.ButtonSelectAll&quot;)" type="code"/>
+              <Connection code="L10n.getString(&quot;History.ButtonUnselectAll&quot;)" type="code"/>
             </Property>
           </Properties>
           <AuxValues>
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
-        <Component class="javax.swing.JButton" name="unselectAllButton">
+        <Component class="javax.swing.JButton" name="selectAllButton">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-              <Connection code="L10n.getString(&quot;History.ButtonUnselectAll&quot;)" type="code"/>
+              <Connection code="L10n.getString(&quot;History.ButtonSelectAll&quot;)" type="code"/>
             </Property>
           </Properties>
           <AuxValues>
@@ -383,103 +397,57 @@
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
-        <Container class="javax.swing.JPanel" name="jPanel4">
-
-          <Layout>
-            <DimensionLayout dim="0">
-              <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" alignment="0" attributes="0">
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="totalResultLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="totalResultValueLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace min="-2" pref="17" max="-2" attributes="0"/>
-                      <Component id="toDisplayLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="toDisplayValueTextField" min="-2" pref="25" max="-2" attributes="0"/>
-                      <EmptySpace pref="21" max="32767" attributes="0"/>
-                      <Component id="displayedLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="displayedValueLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                  </Group>
-              </Group>
-            </DimensionLayout>
-            <DimensionLayout dim="1">
-              <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" attributes="0">
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Group type="103" groupAlignment="3" attributes="0">
-                          <Component id="totalResultLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="totalResultValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="toDisplayLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="toDisplayValueTextField" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="displayedLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="displayedValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                      </Group>
-                      <EmptySpace max="32767" attributes="0"/>
-                  </Group>
-              </Group>
-            </DimensionLayout>
-          </Layout>
-          <SubComponents>
-            <Component class="javax.swing.JLabel" name="totalResultLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.TotalResult&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JLabel" name="totalResultValueLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="((Integer)model.getResultRows()).toString()" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JLabel" name="toDisplayLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.RowToDisplay&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JTextField" name="toDisplayValueTextField">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="((Integer)model.getDisplayRows()).toString()" type="code"/>
-                </Property>
-                <Property name="autoscrolls" type="boolean" value="false"/>
-                <Property name="minimumSize" type="java.awt.Dimension" editor="org.netbeans.beaninfo.editors.DimensionEditor">
-                  <Dimension value="[16, 19]"/>
-                </Property>
-              </Properties>
-              <AuxValues>
-                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
-              </AuxValues>
-            </Component>
-            <Component class="javax.swing.JLabel" name="displayedLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.Displayed&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JLabel" name="displayedValueLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="model.getCurrentDisplayRows()" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-          </SubComponents>
-        </Container>
+        <Component class="javax.swing.JLabel" name="totalResultLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.TotalResult&quot;)" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JLabel" name="totalResultValueLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="((Integer)model.getResultRows()).toString()" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JLabel" name="toDisplayLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.RowToDisplay&quot;)" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JTextField" name="toDisplayValueTextField">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="((Integer)model.getDisplayRows()).toString()" type="code"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
+        </Component>
+        <Component class="javax.swing.JLabel" name="displayedLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.Displayed&quot;)" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JLabel" name="displayedValueLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="model.getCurrentDisplayRows()" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
       </SubComponents>
     </Container>
-    <Component class="javax.swing.JButton" name="okButton">
+    <Component class="javax.swing.JButton" name="helpButton">
       <Properties>
         <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-          <Connection code="L10n.getString(&quot;History.ButtonOk&quot;)" type="code"/>
+          <Connection code="L10n.getString(&quot;History.ButtonHelp&quot;)" type="code"/>
         </Property>
       </Properties>
       <AuxValues>
@@ -496,10 +464,10 @@
         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
       </AuxValues>
     </Component>
-    <Component class="javax.swing.JButton" name="helpButton">
+    <Component class="javax.swing.JButton" name="okButton">
       <Properties>
         <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-          <Connection code="L10n.getString(&quot;History.ButtonHelp&quot;)" type="code"/>
+          <Connection code="L10n.getString(&quot;History.ButtonOk&quot;)" type="code"/>
         </Property>
       </Properties>
       <AuxValues>

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -14,6 +14,8 @@
 import javax.swing.JTable;
 import net.sf.plantlore.common.PlantloreHelp;
 import net.sf.plantlore.l10n.L10n;
+import java.awt.Color;
+import net.sf.plantlore.common.TransferFocus;
 
 /**
  * View for the main History dialog (part of the History MVC). Used for displaying the search results.
@@ -61,7 +63,7 @@
               return;
           } 
     } 
-      
+    
     /** This method is called from within the constructor to
      * initialize the form.
      * WARNING: Do NOT modify this code. The content of this method is
@@ -77,7 +79,7 @@
         authorValueLabel = new javax.swing.JLabel();
         locationValueLabel = new javax.swing.JLabel();
         jPanel2 = new javax.swing.JPanel();
-        whenInserLabel = new javax.swing.JLabel();
+        whenInsertLabel = new javax.swing.JLabel();
         whoInsertLabel = new javax.swing.JLabel();
         whenInsertValueLabel = new javax.swing.JLabel();
         whoInsertValueLabel = new javax.swing.JLabel();
@@ -86,19 +88,18 @@
         tableEditList = new javax.swing.JTable();
         previousButton = new javax.swing.JButton();
         nextButton = new javax.swing.JButton();
-        selectAllButton = new javax.swing.JButton();
         unselectAllButton = new javax.swing.JButton();
+        selectAllButton = new javax.swing.JButton();
         undoButton = new javax.swing.JButton();
-        jPanel4 = new javax.swing.JPanel();
         totalResultLabel = new javax.swing.JLabel();
         totalResultValueLabel = new javax.swing.JLabel();
         toDisplayLabel = new javax.swing.JLabel();
         toDisplayValueTextField = new javax.swing.JTextField();
         displayedLabel = new javax.swing.JLabel();
         displayedValueLabel = new javax.swing.JLabel();
-        okButton = new javax.swing.JButton();
-        closeButton = new javax.swing.JButton();
         helpButton = new javax.swing.JButton();
+        closeButton = new javax.swing.JButton();
+        okButton = new javax.swing.JButton();
 
         setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
         jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(L10n.getString("History.DetailsRecordPanel")));
@@ -122,22 +123,21 @@
         jPanel1Layout.setHorizontalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel1Layout.createSequentialGroup()
-                .addContainerGap()
+                .add(19, 19, 19)
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(taxonLabel)
                     .add(authorLabel)
-                    .add(locationLabel))
-                .add(83, 83, 83)
+                    .add(locationLabel)
+                    .add(taxonLabel))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 57, Short.MAX_VALUE)
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(locationValueLabel)
+                    .add(taxonValueLabel)
                     .add(authorValueLabel)
-                    .add(taxonValueLabel))
-                .addContainerGap(424, Short.MAX_VALUE))
+                    .add(locationValueLabel))
+                .addContainerGap(491, Short.MAX_VALUE))
         );
         jPanel1Layout.setVerticalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel1Layout.createSequentialGroup()
-                .addContainerGap()
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(taxonLabel)
                     .add(taxonValueLabel))
@@ -148,19 +148,17 @@
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(locationLabel)
-                    .add(locationValueLabel))
-                .addContainerGap())
+                    .add(locationValueLabel)))
         );
 
         jPanel2.setBorder(javax.swing.BorderFactory.createTitledBorder(L10n.getString("History.RecordCreatedPanel")));
-        whenInserLabel.setFont(new java.awt.Font("Tahoma", 1, 11));
-        whenInserLabel.setText(L10n.getString("History.WhenInsert"));
+        whenInsertLabel.setFont(new java.awt.Font("Tahoma", 1, 11));
+        whenInsertLabel.setText(L10n.getString("History.WhenInsert"));
 
         whoInsertLabel.setFont(new java.awt.Font("Tahoma", 1, 11));
         whoInsertLabel.setText(L10n.getString("History.WhoInsert"));
 
-        String whenInsert = (model.getWhen() == null) ? null : DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(model.getWhen());
-        whenInsertValueLabel.setText(whenInsert);
+        whenInsertValueLabel.setText(DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(model.getWhen()) );
 
         whoInsertValueLabel.setText(model.getNameUser());
 
@@ -169,30 +167,30 @@
         jPanel2Layout.setHorizontalGroup(
             jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel2Layout.createSequentialGroup()
-                .addContainerGap()
+                .add(20, 20, 20)
                 .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(whenInserLabel)
+                    .add(whenInsertLabel)
                     .add(whoInsertLabel))
-                .add(80, 80, 80)
+                .add(39, 39, 39)
                 .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(whoInsertValueLabel)
-                    .add(whenInsertValueLabel))
-                .addContainerGap(427, Short.MAX_VALUE))
+                    .add(whenInsertValueLabel)
+                    .add(whoInsertValueLabel))
+                .addContainerGap(508, Short.MAX_VALUE))
         );
         jPanel2Layout.setVerticalGroup(
             jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel2Layout.createSequentialGroup()
                 .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
-                    .add(whenInserLabel)
-                    .add(whenInsertValueLabel))
+                    .add(whenInsertValueLabel)
+                    .add(whenInsertLabel))
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                 .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
-                    .add(whoInsertLabel)
-                    .add(whoInsertValueLabel))
-                .addContainerGap(14, Short.MAX_VALUE))
+                    .add(whoInsertValueLabel)
+                    .add(whoInsertLabel)))
         );
 
         jPanel3.setBorder(javax.swing.BorderFactory.createTitledBorder(L10n.getString("History.ChangesRecordPanel")));
+        jScrollPane1.getViewport().setBackground(Color.WHITE);
         tableEditList.setModel(new javax.swing.table.DefaultTableModel(
             new Object [][] {
                 {null, null, null, null},
@@ -204,16 +202,17 @@
                 "Title 1", "Title 2", "Title 3", "Title 4"
             }
         ));
+        TransferFocus.patch(tableEditList);
         jScrollPane1.setViewportView(tableEditList);
 
         previousButton.setText(L10n.getString("History.ButtonPrev"));
 
         nextButton.setText(L10n.getString("History.ButtonNext"));
 
-        selectAllButton.setText(L10n.getString("History.ButtonSelectAll"));
-
         unselectAllButton.setText(L10n.getString("History.ButtonUnselectAll"));
 
+        selectAllButton.setText(L10n.getString("History.ButtonSelectAll"));
+
         undoButton.setText(L10n.getString("History.ButtonUndoSelected"));
 
         totalResultLabel.setText(L10n.getString("History.TotalResult"));
@@ -223,90 +222,70 @@
         toDisplayLabel.setText(L10n.getString("History.RowToDisplay"));
 
         toDisplayValueTextField.setText(((Integer)model.getDisplayRows()).toString());
-        toDisplayValueTextField.setAutoscrolls(false);
-        toDisplayValueTextField.setMinimumSize(new java.awt.Dimension(16, 19));
 
         displayedLabel.setText(L10n.getString("History.Displayed"));
 
         displayedValueLabel.setText(model.getCurrentDisplayRows());
 
-        org.jdesktop.layout.GroupLayout jPanel4Layout = new org.jdesktop.layout.GroupLayout(jPanel4);
-        jPanel4.setLayout(jPanel4Layout);
-        jPanel4Layout.setHorizontalGroup(
-            jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jPanel4Layout.createSequentialGroup()
-                .addContainerGap()
-                .add(totalResultLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(totalResultValueLabel)
-                .add(17, 17, 17)
-                .add(toDisplayLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 25, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 21, Short.MAX_VALUE)
-                .add(displayedLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(displayedValueLabel)
-                .addContainerGap())
-        );
-        jPanel4Layout.setVerticalGroup(
-            jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jPanel4Layout.createSequentialGroup()
-                .addContainerGap()
-                .add(jPanel4Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
-                    .add(totalResultLabel)
-                    .add(totalResultValueLabel)
-                    .add(toDisplayLabel)
-                    .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                    .add(displayedLabel)
-                    .add(displayedValueLabel))
-                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
-        );
-
         org.jdesktop.layout.GroupLayout jPanel3Layout = new org.jdesktop.layout.GroupLayout(jPanel3);
         jPanel3.setLayout(jPanel3Layout);
         jPanel3Layout.setHorizontalGroup(
             jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jPanel3Layout.createSequentialGroup()
-                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel3Layout.createSequentialGroup()
-                        .add(326, 326, 326)
-                        .add(undoButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel3Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
+                    .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 688, Short.MAX_VALUE)
+                    .add(jPanel3Layout.createSequentialGroup()
+                        .add(undoButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                         .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                        .add(selectAllButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(selectAllButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                         .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                        .add(unselectAllButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                        .add(unselectAllButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
                     .add(jPanel3Layout.createSequentialGroup()
-                        .add(previousButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 33, Short.MAX_VALUE)
-                        .add(jPanel4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(previousButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(68, 68, 68)
+                        .add(totalResultLabel)
                         .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                        .add(nextButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
-                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 668, Short.MAX_VALUE))
+                        .add(totalResultValueLabel)
+                        .add(33, 33, 33)
+                        .add(toDisplayLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 29, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(42, 42, 42)
+                        .add(displayedLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(displayedValueLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 50, Short.MAX_VALUE)
+                        .add(nextButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                 .addContainerGap())
         );
         jPanel3Layout.setVerticalGroup(
             jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jPanel3Layout.createSequentialGroup()
-                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 214, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
-                    .add(jPanel4, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 36, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel3Layout.createSequentialGroup()
+                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 224, Short.MAX_VALUE)
+                .add(14, 14, 14)
+                .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(nextButton)
                     .add(previousButton)
-                    .add(nextButton))
+                    .add(totalResultValueLabel)
+                    .add(totalResultLabel)
+                    .add(toDisplayLabel)
+                    .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                    .add(displayedLabel)
+                    .add(displayedValueLabel))
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                 .add(jPanel3Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(unselectAllButton)
                     .add(selectAllButton)
-                    .add(undoButton)
-                    .add(unselectAllButton))
+                    .add(undoButton))
                 .addContainerGap())
         );
 
-        okButton.setText(L10n.getString("History.ButtonOk"));
+        helpButton.setText(L10n.getString("History.ButtonHelp"));
 
         closeButton.setText(L10n.getString("History.ButtonClose"));
 
-        helpButton.setText(L10n.getString("History.ButtonHelp"));
+        okButton.setText(L10n.getString("History.ButtonOk"));
 
         org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
         getContentPane().setLayout(layout);
@@ -315,21 +294,19 @@
             .add(layout.createSequentialGroup()
                 .addContainerGap()
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(layout.createSequentialGroup()
+                        .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 518, Short.MAX_VALUE)
+                        .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(closeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(30, 30, 30))
                     .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                         .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
-                            .add(layout.createSequentialGroup()
-                                .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 364, Short.MAX_VALUE)
-                                .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                                .add(20, 20, 20)
-                                .add(closeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
-                            .add(jPanel3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 684, Short.MAX_VALUE))
-                        .addContainerGap())
-                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
-                        .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
                             .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
-                            .add(jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
-                        .add(20, 20, 20))))
+                            .add(org.jdesktop.layout.GroupLayout.LEADING, jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+                            .add(jPanel3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+                        .addContainerGap())))
         );
         layout.setVerticalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
@@ -339,18 +316,19 @@
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                 .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(jPanel3, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .add(15, 15, 15)
+                .add(jPanel3, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+                .add(14, 14, 14)
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(helpButton)
-                    .add(okButton)
-                    .add(closeButton))
-                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+                    .add(closeButton)
+                    .add(okButton))
+                .addContainerGap())
         );
         pack();
-    }// </editor-fold>//GEN-END:initComponents       
+    }// </editor-fold>//GEN-END:initComponents
     
-    /**
+       
+        /**
      *  Display generic error message.
      *  @param message Message we want to display
      */
@@ -429,7 +407,6 @@
         this.toDisplayValueTextField.setText(value.toString());
     }  
     
-    
     // Variables declaration - do not modify//GEN-BEGIN:variables
     private javax.swing.JLabel authorLabel;
     private javax.swing.JLabel authorValueLabel;
@@ -440,7 +417,6 @@
     private javax.swing.JPanel jPanel1;
     private javax.swing.JPanel jPanel2;
     private javax.swing.JPanel jPanel3;
-    private javax.swing.JPanel jPanel4;
     private javax.swing.JScrollPane jScrollPane1;
     private javax.swing.JLabel locationLabel;
     private javax.swing.JLabel locationValueLabel;
@@ -457,7 +433,7 @@
     private javax.swing.JLabel totalResultValueLabel;
     protected javax.swing.JButton undoButton;
     protected javax.swing.JButton unselectAllButton;
-    private javax.swing.JLabel whenInserLabel;
+    private javax.swing.JLabel whenInsertLabel;
     private javax.swing.JLabel whenInsertValueLabel;
     private javax.swing.JLabel whoInsertLabel;
     private javax.swing.JLabel whoInsertValueLabel;

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -11,6 +11,15 @@
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
+import java.rmi.RemoteException;
+
+import javax.swing.JOptionPane;
+
+import net.sf.plantlore.common.ProgressBar;
+import net.sf.plantlore.common.Task;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.l10n.L10n;
+
 import org.apache.log4j.Logger;
 
 /**
@@ -157,7 +166,7 @@
     class rowSetDisplayChangeListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent) {
     	   // Check whether an error flag is set
-    	   if (model.isError()) {
+    	   if (model.isError() && view.tableHistoryList.getRowCount() > 0) {
         	   view.showErrorMessage(model.getError());
         	   return;
            }
@@ -206,7 +215,7 @@
        public void actionPerformed(ActionEvent actionEvent)
        {
     	   // Check whether an error flag is set
-    	   if (model.isError()) {
+    	   if (model.isError() && view.tableHistoryList.getRowCount() > 0) {
         	   view.showErrorMessage(model.getError());
         	   return;
            }
@@ -225,20 +234,53 @@
 	               if (okCancle == 0){
 	                   //Button OK was press
 	                   logger.debug("Button OK was press.");    
-	                   model.commitUpdate();
-	                   model.deleteHistory(toResult, false);
-	                   model.searchWholeHistoryData();        	
-	                   model.processResult(1,model.getDisplayRows());
-	                   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
-	                   Integer resultRows = model.getResultRows();
-	                   if (resultRows == 0) {
-	                           view.displayedValueLabel.setText("0-0"); 
-	                   } else {
-	                           int from = model.getCurrentFirstRow();
-	                   int to = from + view.tableHistoryList.getRowCount() - 1;               
-	                   view.displayedValueLabel.setText(from + "-" + to);    
-	                   }               
-	                   view.totalResultValueLabel.setText(resultRows.toString());
+	                   Task task = model.commitUpdate(toResult, false);
+	                   
+	                   ProgressBar progressBar = new ProgressBar(task, view, true) {		   				
+						private static final long serialVersionUID = -6065695152319199854L;
+							public void exceptionHandler(Exception e) {
+		   						if (e instanceof DBLayerException) {	   									   							
+		   							DBLayerException dbex = (DBLayerException) e;
+		   							//TODO zobrazit vlastni message - nemusi byt vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(dbex + ": " + dbex.getErrorInfo());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						if (e instanceof RemoteException) {	 
+		   							RemoteException remex = (RemoteException) e;
+		   							//TODO zobrazit vlastni message - nemusi byt vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+		   							JOptionPane.showMessageDialog(view, L10n.getString("Error.RemoteException")+ "\n" + remex.getMessage(),
+		 							   L10n.getString("Error.RemoteExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(remex + ": " + remex.getMessage());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						JOptionPane.showMessageDialog(view, L10n.getString("Delete.Message.UnknownException")+ "\n" + e.getMessage(),
+			 					    L10n.getString("Delete.Message.UnknownExceptionTitle"), JOptionPane.WARNING_MESSAGE);							
+		   						logger.error(e);
+		   					}
+	
+		   					public void afterStopping() {
+		   						logger.debug("Load Data");	                   
+		 	                    model.searchWholeHistoryData();        	
+		 	                    model.processResult(1,model.getDisplayRows());
+		 	                    view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
+		 	                    Integer resultRows = model.getResultRows();
+		 	                    if (resultRows == 0) {
+		 	                            view.displayedValueLabel.setText("0-0"); 
+		 	                    } else {
+		 	                            int from = model.getCurrentFirstRow();
+		 	                    int to = from + view.tableHistoryList.getRowCount() - 1;               
+		 	                    view.displayedValueLabel.setText(from + "-" + to);    
+		 	                    }               
+		 	                    view.totalResultValueLabel.setText(resultRows.toString());
+		   					}
+		   				};
+		   				progressBar.setTitle(L10n.getString("History.Undo.ProgressTitle"));	                   	                   
+	                    task.start();
+	                   
 	               } else {	                       	                     
 	                       logger.debug("Button Cancle was press.");
 	               } 
@@ -257,7 +299,7 @@
        public void actionPerformed(ActionEvent actionEvent)
        {
     	   // Check whether an error flag is set
-    	   if (model.isError()) {
+    	   if (model.isError() && view.tableHistoryList.getRowCount() > 0) {
         	   view.showErrorMessage(model.getError());
         	   return;
            }        
@@ -284,26 +326,59 @@
        public void actionPerformed(ActionEvent actionEvent)
        {
     	   // Check whether an error flag is set
-    	   if (model.isError()) {
+    	   if (model.isError() && view.tableHistoryList.getRowCount() > 0) {
         	   view.showErrorMessage(model.getError());
         	   return;
-           }       
-           int okCancle = view.messageUndo("CH");
+           }     
+    	   if (view.tableHistoryList.getRowCount() == 0) {
+    		   view.messageUndo("clearHistory");
+    		   return;
+    	   }
+           int okCancle = view.messageUndo("clearHistory");
            if (okCancle == 0){
                    //Button OK was press
                    logger.debug("Button OK was press.");  
                    // delete records whit contition cdelete > 0
-                   model.clearDatabase();
-                   //deleta data from tables tHistoryChange and tHistory
-                   model.clearHistory();                   
-                   //load data
-                   model.searchWholeHistoryData();        	
-                   model.processResult(1,model.getDisplayRows());
-                   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
-                   view.displayedValueLabel.setText("0-0");
-                   view.displayedValueLabel.setText("0-0"); 
-                   view.totalResultValueLabel.setText("0");
+                   Task task = model.clearDatabase();
                    
+                   ProgressBar progressBar = new ProgressBar(task, view, true) {		   				
+						private static final long serialVersionUID = -6065695152319199854L;
+							public void exceptionHandler(Exception e) {
+		   						if (e instanceof DBLayerException) {	   									   							
+		   							DBLayerException dbex = (DBLayerException) e;
+		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(dbex + ": " + dbex.getErrorInfo());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						if (e instanceof RemoteException) {	 
+		   							RemoteException remex = (RemoteException) e;
+		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+		   							JOptionPane.showMessageDialog(view, L10n.getString("Error.RemoteException")+ "\n" + remex.getMessage(),
+		 							   L10n.getString("Error.RemoteExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									logger.error(remex + ": " + remex.getMessage());
+		   							getTask().stop();
+		   							return;
+		   						}
+		   						JOptionPane.showMessageDialog(view, L10n.getString("Delete.Message.UnknownException")+ "\n" + e.getMessage(),
+			 					    L10n.getString("Delete.Message.UnknownExceptionTitle"), JOptionPane.WARNING_MESSAGE);							
+		   						logger.error(e);
+		   					}
+	
+		   					public void afterStopping() {
+		   						//load data
+		   	                   model.searchWholeHistoryData();        	
+		   	                   model.processResult(1,model.getDisplayRows());
+		   	                   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
+		   	                   view.displayedValueLabel.setText("0-0");
+		   	                   view.displayedValueLabel.setText("0-0"); 
+		   	                   view.totalResultValueLabel.setText("0");
+		   					}
+		   				};
+		   				progressBar.setTitle(L10n.getString("History.Undo.ProgressTitle"));	                   	                   
+	                    task.start();	                                                         
            }
        }
     }

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryView.form	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryView.form	2006-07-23 18:41:04 UTC (rev 470)
@@ -19,32 +19,32 @@
       <Group type="103" groupAlignment="0" attributes="0">
           <Group type="102" attributes="0">
               <EmptySpace max="-2" attributes="0"/>
-              <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" alignment="0" attributes="0">
-                      <Component id="helpButton" min="-2" pref="100" max="-2" attributes="0"/>
-                      <EmptySpace pref="462" max="32767" attributes="0"/>
-                      <Component id="okButton" min="-2" pref="100" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="closeButton" min="-2" pref="100" max="-2" attributes="0"/>
-                  </Group>
-                  <Component id="jPanel1" alignment="1" min="-2" pref="768" max="-2" attributes="0"/>
-              </Group>
+              <Component id="jPanel1" max="32767" attributes="0"/>
               <EmptySpace max="-2" attributes="0"/>
           </Group>
+          <Group type="102" alignment="0" attributes="0">
+              <EmptySpace min="-2" pref="30" max="-2" attributes="0"/>
+              <Component id="helpButton" min="-2" pref="60" max="-2" attributes="0"/>
+              <EmptySpace pref="565" max="32767" attributes="0"/>
+              <Component id="okButton" min="-2" pref="60" max="-2" attributes="0"/>
+              <EmptySpace max="-2" attributes="0"/>
+              <Component id="closeButton" min="-2" pref="60" max="-2" attributes="0"/>
+              <EmptySpace min="-2" pref="27" max="-2" attributes="0"/>
+          </Group>
       </Group>
     </DimensionLayout>
     <DimensionLayout dim="1">
       <Group type="103" groupAlignment="0" attributes="0">
-          <Group type="102" alignment="1" attributes="0">
+          <Group type="102" alignment="0" attributes="0">
               <EmptySpace max="-2" attributes="0"/>
-              <Component id="jPanel1" min="-2" max="-2" attributes="0"/>
-              <EmptySpace pref="17" max="32767" attributes="0"/>
+              <Component id="jPanel1" max="32767" attributes="0"/>
+              <EmptySpace min="-2" pref="15" max="-2" attributes="0"/>
               <Group type="103" groupAlignment="3" attributes="0">
                   <Component id="helpButton" alignment="3" min="-2" max="-2" attributes="0"/>
                   <Component id="closeButton" alignment="3" min="-2" max="-2" attributes="0"/>
                   <Component id="okButton" alignment="3" min="-2" max="-2" attributes="0"/>
               </Group>
-              <EmptySpace max="-2" attributes="0"/>
+              <EmptySpace min="-2" pref="20" max="-2" attributes="0"/>
           </Group>
       </Group>
     </DimensionLayout>
@@ -64,29 +64,34 @@
       <Layout>
         <DimensionLayout dim="0">
           <Group type="103" groupAlignment="0" attributes="0">
-              <Group type="102" alignment="0" attributes="0">
-                  <Group type="103" groupAlignment="1" attributes="0">
+              <Group type="102" attributes="0">
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="0" attributes="0">
+                      <Component id="jScrollPane1" alignment="0" pref="752" max="32767" attributes="0"/>
+                      <Group type="102" alignment="0" attributes="0">
+                          <Component id="previousButton" min="-2" pref="60" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="50" max="-2" attributes="0"/>
+                          <Component id="totalResultLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="totalResultValueLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="41" max="-2" attributes="0"/>
+                          <Component id="toDisplayLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="toDisplayValueTextField" min="-2" pref="28" max="-2" attributes="0"/>
+                          <EmptySpace min="-2" pref="50" max="-2" attributes="0"/>
+                          <Component id="displayedLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="displayedValueLabel" min="-2" max="-2" attributes="0"/>
+                          <EmptySpace pref="117" max="32767" attributes="0"/>
+                          <Component id="nextButton" min="-2" pref="60" max="-2" attributes="0"/>
+                      </Group>
                       <Group type="102" alignment="1" attributes="0">
-                          <Group type="103" groupAlignment="0" attributes="0">
-                              <Group type="102" alignment="1" attributes="0">
-                                  <EmptySpace max="-2" attributes="0"/>
-                                  <Component id="detailsButton" min="-2" pref="110" max="-2" attributes="1"/>
-                                  <EmptySpace max="-2" attributes="0"/>
-                                  <Component id="undoToDateButton" min="-2" pref="110" max="-2" attributes="1"/>
-                              </Group>
-                              <Group type="102" alignment="0" attributes="0">
-                                  <Component id="previousButton" min="-2" pref="100" max="-2" attributes="1"/>
-                                  <EmptySpace pref="46" max="32767" attributes="0"/>
-                                  <Component id="jPanel2" min="-2" max="-2" attributes="0"/>
-                              </Group>
-                          </Group>
-                          <EmptySpace min="-2" pref="12" max="-2" attributes="0"/>
-                          <Group type="103" groupAlignment="1" attributes="0">
-                              <Component id="nextButton" min="-2" max="-2" attributes="1"/>
-                              <Component id="clearHistoryButton" min="-2" pref="110" max="-2" attributes="1"/>
-                          </Group>
+                          <Component id="detailsButton" min="-2" pref="90" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="undoToDateButton" min="-2" pref="90" max="-2" attributes="0"/>
+                          <EmptySpace max="-2" attributes="0"/>
+                          <Component id="clearHistoryButton" min="-2" pref="90" max="-2" attributes="0"/>
                       </Group>
-                      <Component id="jScrollPane1" alignment="0" min="-2" pref="747" max="-2" attributes="1"/>
                   </Group>
                   <EmptySpace max="-2" attributes="0"/>
               </Group>
@@ -95,31 +100,39 @@
         <DimensionLayout dim="1">
           <Group type="103" groupAlignment="0" attributes="0">
               <Group type="102" alignment="0" attributes="0">
-                  <Component id="jScrollPane1" min="-2" pref="222" max="-2" attributes="1"/>
-                  <EmptySpace max="-2" attributes="0"/>
-                  <Group type="103" groupAlignment="0" attributes="0">
-                      <Component id="previousButton" min="-2" max="-2" attributes="0"/>
-                      <Group type="102" alignment="1" attributes="0">
-                          <Group type="103" groupAlignment="0" attributes="0">
-                              <Component id="jPanel2" max="32767" attributes="0"/>
-                              <Component id="nextButton" min="-2" max="-2" attributes="0"/>
-                          </Group>
-                          <EmptySpace max="-2" attributes="0"/>
-                          <Group type="103" groupAlignment="3" attributes="0">
-                              <Component id="detailsButton" alignment="3" min="-2" max="-2" attributes="0"/>
-                              <Component id="undoToDateButton" alignment="3" min="-2" max="-2" attributes="0"/>
-                              <Component id="clearHistoryButton" alignment="3" min="-2" max="-2" attributes="0"/>
-                          </Group>
-                          <EmptySpace max="-2" attributes="0"/>
-                      </Group>
+                  <Component id="jScrollPane1" pref="240" max="32767" attributes="0"/>
+                  <EmptySpace min="-2" pref="15" max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="3" attributes="0">
+                      <Component id="previousButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="nextButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="totalResultLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="totalResultValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="toDisplayLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="toDisplayValueTextField" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="displayedValueLabel" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="displayedLabel" alignment="3" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace min="-2" max="-2" attributes="0"/>
+                  <EmptySpace min="-2" pref="13" max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="3" attributes="0">
+                      <Component id="clearHistoryButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="undoToDateButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                      <Component id="detailsButton" alignment="3" min="-2" max="-2" attributes="0"/>
+                  </Group>
+                  <EmptySpace max="-2" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
       </Layout>
       <SubComponents>
         <Container class="javax.swing.JScrollPane" name="jScrollPane1">
+          <Properties>
+            <Property name="background" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+              <Color blue="ff" green="ff" id="white" palette="1" red="ff" type="palette"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_InitCodePost" type="java.lang.String" value="jScrollPane1.getViewport().setBackground(Color.WHITE);"/>
+          </AuxValues>
 
           <Layout class="org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout"/>
           <SubComponents>
@@ -135,6 +148,7 @@
                 </Property>
               </Properties>
               <AuxValues>
+                <AuxValue name="JavaCodeGenerator_InitCodePost" type="java.lang.String" value="TransferFocus.patch(tableHistoryList);"/>
                 <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
               </AuxValues>
             </Component>
@@ -150,17 +164,36 @@
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
+        <Component class="javax.swing.JButton" name="nextButton">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.ButtonNext&quot;)" type="code"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
+        </Component>
         <Component class="javax.swing.JButton" name="clearHistoryButton">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
               <Connection code="L10n.getString(&quot;History.Whole.ButtonClearHistory&quot;)" type="code"/>
             </Property>
-            <Property name="inheritsPopupMenu" type="boolean" value="true"/>
           </Properties>
           <AuxValues>
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
+        <Component class="javax.swing.JButton" name="undoToDateButton">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.Whole.ButtonUndoToDate&quot;)" type="code"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
+        </Component>
         <Component class="javax.swing.JButton" name="detailsButton">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
@@ -171,125 +204,63 @@
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
-        <Component class="javax.swing.JButton" name="undoToDateButton">
+        <Component class="javax.swing.JLabel" name="totalResultLabel">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-              <Connection code="L10n.getString(&quot;History.Whole.ButtonUndoToDate&quot;)" type="code"/>
+              <Connection code="L10n.getString(&quot;History.TotalResult&quot;)" type="code"/>
             </Property>
           </Properties>
+        </Component>
+        <Component class="javax.swing.JLabel" name="totalResultValueLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="((Integer)model.getResultRows()).toString()" type="code"/>
+            </Property>
+          </Properties>
           <AuxValues>
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
-        <Container class="javax.swing.JPanel" name="jPanel2">
-
-          <Layout>
-            <DimensionLayout dim="0">
-              <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" alignment="0" attributes="0">
-                      <EmptySpace min="-2" pref="31" max="-2" attributes="0"/>
-                      <Component id="totalResultLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="totalResultValueLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace min="-2" pref="31" max="-2" attributes="0"/>
-                      <Component id="toDisplayLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                      <Component id="toDisplayValueTextField" min="-2" pref="31" max="-2" attributes="0"/>
-                      <EmptySpace min="-2" pref="30" max="-2" attributes="0"/>
-                      <Component id="displayedLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="32767" attributes="0"/>
-                      <Component id="displayedValueLabel" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace max="-2" attributes="0"/>
-                  </Group>
-              </Group>
-            </DimensionLayout>
-            <DimensionLayout dim="1">
-              <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" alignment="1" attributes="0">
-                      <Group type="103" groupAlignment="3" attributes="0">
-                          <Component id="totalResultLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="toDisplayLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="totalResultValueLabel" alignment="3" min="-2" pref="14" max="-2" attributes="0"/>
-                          <Component id="toDisplayValueTextField" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="displayedLabel" alignment="3" min="-2" max="-2" attributes="0"/>
-                          <Component id="displayedValueLabel" alignment="3" pref="25" max="32767" attributes="0"/>
-                      </Group>
-                      <EmptySpace min="-2" max="-2" attributes="0"/>
-                  </Group>
-              </Group>
-            </DimensionLayout>
-          </Layout>
-          <SubComponents>
-            <Component class="javax.swing.JLabel" name="totalResultLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.TotalResult&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JLabel" name="totalResultValueLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="((Integer)model.getResultRows()).toString()" type="code"/>
-                </Property>
-              </Properties>
-              <AuxValues>
-                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
-              </AuxValues>
-            </Component>
-            <Component class="javax.swing.JLabel" name="toDisplayLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.RowsToDisplay&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JTextField" name="toDisplayValueTextField">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="((Integer)model.getDisplayRows()).toString()" type="code"/>
-                </Property>
-                <Property name="autoscrolls" type="boolean" value="false"/>
-              </Properties>
-              <AuxValues>
-                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
-              </AuxValues>
-            </Component>
-            <Component class="javax.swing.JLabel" name="displayedLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="L10n.getString(&quot;History.Displayed&quot;)" type="code"/>
-                </Property>
-              </Properties>
-            </Component>
-            <Component class="javax.swing.JLabel" name="displayedValueLabel">
-              <Properties>
-                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-                  <Connection code="model.getCurrentDisplayRows()" type="code"/>
-                </Property>
-              </Properties>
-              <AuxValues>
-                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
-              </AuxValues>
-            </Component>
-          </SubComponents>
-        </Container>
-        <Component class="javax.swing.JButton" name="nextButton">
+        <Component class="javax.swing.JLabel" name="toDisplayLabel">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-              <Connection code="L10n.getString(&quot;History.ButtonNext&quot;)" type="code"/>
+              <Connection code="L10n.getString(&quot;History.RowsToDisplay&quot;)" type="code"/>
             </Property>
           </Properties>
+        </Component>
+        <Component class="javax.swing.JTextField" name="toDisplayValueTextField">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="((Integer)model.getDisplayRows()).toString()" type="code"/>
+            </Property>
+          </Properties>
           <AuxValues>
             <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
           </AuxValues>
         </Component>
+        <Component class="javax.swing.JLabel" name="displayedLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="L10n.getString(&quot;History.Displayed&quot;)" type="code"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JLabel" name="displayedValueLabel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
+              <Connection code="model.getCurrentDisplayRows()" type="code"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
+        </Component>
       </SubComponents>
     </Container>
-    <Component class="javax.swing.JButton" name="okButton">
+    <Component class="javax.swing.JButton" name="helpButton">
       <Properties>
         <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-          <Connection code="L10n.getString(&quot;History.ButtonOk&quot;)" type="code"/>
+          <Connection code="L10n.getString(&quot;History.ButtonHelp&quot;)" type="code"/>
         </Property>
       </Properties>
       <AuxValues>
@@ -306,10 +277,10 @@
         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
       </AuxValues>
     </Component>
-    <Component class="javax.swing.JButton" name="helpButton">
+    <Component class="javax.swing.JButton" name="okButton">
       <Properties>
         <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-          <Connection code="L10n.getString(&quot;History.ButtonHelp&quot;)" type="code"/>
+          <Connection code="L10n.getString(&quot;History.ButtonOk&quot;)" type="code"/>
         </Property>
       </Properties>
       <AuxValues>

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -1,11 +1,12 @@
 /*
  * WholeHistoryView.java
  *
- * Created on 14. duben 2006, 18:21
+ * Created on 23. ?ervenec 2006, 14:37
  */
 
 package net.sf.plantlore.client.history;
 
+import java.awt.Color;
 import java.util.Observable;
 import java.util.Observer;
 import javax.swing.DefaultListSelectionModel;
@@ -13,16 +14,14 @@
 import javax.swing.JOptionPane;
 import net.sf.plantlore.common.PlantloreHelp;
 import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.common.TransferFocus;
 
 /**
- * View for the main WholeHistory dialog (part of the WholeHistory MVC). Used for displaying the search results.
- * @author  Lada Oberreiterov?
- * @version 1.0
+ *
+ * @author  Lada
  */
-public class WholeHistoryView extends javax.swing.JDialog implements Observer{
-       
-	private static final long serialVersionUID = -3610428060548385487L;
-	/** Model of the History MVC*/
+public class WholeHistoryView extends javax.swing.JDialog implements Observer {
+    
     private History model;  
   
     /**
@@ -38,7 +37,9 @@
         // Register observer
         model.addObserver(this);
         setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
-        initComponents();
+        initComponents();        
+        getRootPane().setDefaultButton(okButton);    
+        //TODO doresit ENTER
         // Init Help
         PlantloreHelp.addKeyHelp(PlantloreHelp.HISTORY_MANAGER, this.getRootPane());
         PlantloreHelp.addButtonHelp(PlantloreHelp.HISTORY_MANAGER, this.helpButton);        
@@ -51,7 +52,7 @@
         }
     }
     
-    /**
+     /**
      * Reload the view dialog or display some kind of error.
      */
     public void update(Observable observable, Object object)
@@ -74,23 +75,24 @@
         jScrollPane1 = new javax.swing.JScrollPane();
         tableHistoryList = new javax.swing.JTable();
         previousButton = new javax.swing.JButton();
+        nextButton = new javax.swing.JButton();
         clearHistoryButton = new javax.swing.JButton();
-        detailsButton = new javax.swing.JButton();
         undoToDateButton = new javax.swing.JButton();
-        jPanel2 = new javax.swing.JPanel();
+        detailsButton = new javax.swing.JButton();
         totalResultLabel = new javax.swing.JLabel();
         totalResultValueLabel = new javax.swing.JLabel();
         toDisplayLabel = new javax.swing.JLabel();
         toDisplayValueTextField = new javax.swing.JTextField();
         displayedLabel = new javax.swing.JLabel();
         displayedValueLabel = new javax.swing.JLabel();
-        nextButton = new javax.swing.JButton();
-        okButton = new javax.swing.JButton();
-        closeButton = new javax.swing.JButton();
         helpButton = new javax.swing.JButton();
+        closeButton = new javax.swing.JButton();
+        okButton = new javax.swing.JButton();
 
         setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
         jPanel1.setBorder(javax.swing.BorderFactory.createTitledBorder(L10n.getString("History.Whole.Panel")));
+        jScrollPane1.setBackground(java.awt.Color.white);
+        jScrollPane1.getViewport().setBackground(Color.WHITE);
         tableHistoryList.setModel(new javax.swing.table.DefaultTableModel(
             new Object [][] {
                 {null, null, null, null},
@@ -102,17 +104,19 @@
                 "Title 1", "Title 2", "Title 3", "Title 4"
             }
         ));
+        TransferFocus.patch(tableHistoryList);
         jScrollPane1.setViewportView(tableHistoryList);
 
         previousButton.setText(L10n.getString("History.ButtonPrev"));
 
+        nextButton.setText(L10n.getString("History.ButtonNext"));
+
         clearHistoryButton.setText(L10n.getString("History.Whole.ButtonClearHistory"));
-        clearHistoryButton.setInheritsPopupMenu(true);
 
-        detailsButton.setText(L10n.getString("History.ButtonDetails"));
-
         undoToDateButton.setText(L10n.getString("History.Whole.ButtonUndoToDate"));
 
+        detailsButton.setText(L10n.getString("History.ButtonDetails"));
+
         totalResultLabel.setText(L10n.getString("History.TotalResult"));
 
         totalResultValueLabel.setText(((Integer)model.getResultRows()).toString());
@@ -120,95 +124,70 @@
         toDisplayLabel.setText(L10n.getString("History.RowsToDisplay"));
 
         toDisplayValueTextField.setText(((Integer)model.getDisplayRows()).toString());
-        toDisplayValueTextField.setAutoscrolls(false);
 
         displayedLabel.setText(L10n.getString("History.Displayed"));
 
         displayedValueLabel.setText(model.getCurrentDisplayRows());
 
-        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
-        jPanel2.setLayout(jPanel2Layout);
-        jPanel2Layout.setHorizontalGroup(
-            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(jPanel2Layout.createSequentialGroup()
-                .add(31, 31, 31)
-                .add(totalResultLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(totalResultValueLabel)
-                .add(31, 31, 31)
-                .add(toDisplayLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 31, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .add(30, 30, 30)
-                .add(displayedLabel)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
-                .add(displayedValueLabel)
-                .addContainerGap())
-        );
-        jPanel2Layout.setVerticalGroup(
-            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
-                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
-                    .add(totalResultLabel)
-                    .add(toDisplayLabel)
-                    .add(totalResultValueLabel, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 14, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                    .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                    .add(displayedLabel)
-                    .add(displayedValueLabel, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 25, Short.MAX_VALUE))
-                .addContainerGap())
-        );
-
-        nextButton.setText(L10n.getString("History.ButtonNext"));
-
         org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
         jPanel1.setLayout(jPanel1Layout);
         jPanel1Layout.setHorizontalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel1Layout.createSequentialGroup()
-                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
+                .addContainerGap()
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 752, Short.MAX_VALUE)
                     .add(jPanel1Layout.createSequentialGroup()
-                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                            .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
-                                .addContainerGap()
-                                .add(detailsButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                                .add(undoToDateButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
-                            .add(jPanel1Layout.createSequentialGroup()
-                                .add(previousButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 46, Short.MAX_VALUE)
-                                .add(jPanel2, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
-                        .add(12, 12, 12)
-                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.TRAILING)
-                            .add(nextButton)
-                            .add(clearHistoryButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 110, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
-                    .add(org.jdesktop.layout.GroupLayout.LEADING, jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 747, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                        .add(previousButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(50, 50, 50)
+                        .add(totalResultLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(totalResultValueLabel)
+                        .add(41, 41, 41)
+                        .add(toDisplayLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 28, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .add(50, 50, 50)
+                        .add(displayedLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(displayedValueLabel)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 117, Short.MAX_VALUE)
+                        .add(nextButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
+                        .add(detailsButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(undoToDateButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(clearHistoryButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 90, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)))
                 .addContainerGap())
         );
         jPanel1Layout.setVerticalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel1Layout.createSequentialGroup()
-                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 222, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 240, Short.MAX_VALUE)
+                .add(15, 15, 15)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(previousButton)
-                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
-                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                            .add(jPanel2, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
-                            .add(nextButton))
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                        .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
-                            .add(detailsButton)
-                            .add(undoToDateButton)
-                            .add(clearHistoryButton))
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)))
+                    .add(nextButton)
+                    .add(totalResultLabel)
+                    .add(totalResultValueLabel)
+                    .add(toDisplayLabel)
+                    .add(toDisplayValueTextField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                    .add(displayedValueLabel)
+                    .add(displayedLabel))
+                .add(13, 13, 13)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(clearHistoryButton)
+                    .add(undoToDateButton)
+                    .add(detailsButton))
                 .addContainerGap())
         );
 
-        okButton.setText(L10n.getString("History.ButtonOk"));
+        helpButton.setText(L10n.getString("History.ButtonHelp"));
 
         closeButton.setText(L10n.getString("History.ButtonClose"));
 
-        helpButton.setText(L10n.getString("History.ButtonHelp"));
+        okButton.setText(L10n.getString("History.ButtonOk"));
 
         org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
         getContentPane().setLayout(layout);
@@ -216,33 +195,44 @@
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(layout.createSequentialGroup()
                 .addContainerGap()
-                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(layout.createSequentialGroup()
-                        .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 462, Short.MAX_VALUE)
-                        .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                        .add(closeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 100, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
-                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 768, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                 .addContainerGap())
+            .add(layout.createSequentialGroup()
+                .add(30, 30, 30)
+                .add(helpButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 565, Short.MAX_VALUE)
+                .add(okButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(closeButton, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 60, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .add(27, 27, 27))
         );
         layout.setVerticalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
+            .add(layout.createSequentialGroup()
                 .addContainerGap()
-                .add(jPanel1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 17, Short.MAX_VALUE)
+                .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+                .add(15, 15, 15)
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(helpButton)
                     .add(closeButton)
                     .add(okButton))
-                .addContainerGap())
+                .add(20, 20, 20))
         );
         pack();
     }// </editor-fold>//GEN-END:initComponents
-      
     
     /**
+     * @param args the command line arguments
+     */
+    public static void main(String args[]) {
+        java.awt.EventQueue.invokeLater(new Runnable() {
+            public void run() {
+                new WholeHistoryView(null, new javax.swing.JFrame(), true).setVisible(true);
+            }
+        });
+    }
+    
+    /**
      * Close this dialog.
      */
     public void close() {
@@ -264,7 +254,7 @@
      */
     public int messageUndo(String message) {
     	int okCancle = 1;
-    	if (message.equals("cHistory")) {
+    	if (message.equals("clearHistory")) {
     		okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.ClearHistoryMessage"), L10n.getString("Question.ClearHistoryMessageTitle"), JOptionPane.OK_CANCEL_OPTION);
     	}else {
     		okCancle = JOptionPane.showConfirmDialog(this, L10n.getString("Question.Undo") + "  "+ message, L10n.getString("Question.UndoTitle"), JOptionPane.OK_CANCEL_OPTION);
@@ -300,7 +290,7 @@
      */
     public void setDisplayRows(Integer value) {
         this.toDisplayValueTextField.setText(value.toString());
-    }  
+    }      
     
     // Variables declaration - do not modify//GEN-BEGIN:variables
     protected javax.swing.JButton clearHistoryButton;
@@ -310,7 +300,6 @@
     protected javax.swing.JLabel displayedValueLabel;
     protected javax.swing.JButton helpButton;
     private javax.swing.JPanel jPanel1;
-    private javax.swing.JPanel jPanel2;
     private javax.swing.JScrollPane jScrollPane1;
     protected javax.swing.JButton nextButton;
     protected javax.swing.JButton okButton;

Modified: trunk/src/net/sf/plantlore/common/ProgressBar.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBar.java	2006-07-22 02:33:30 UTC (rev 469)
+++ trunk/src/net/sf/plantlore/common/ProgressBar.java	2006-07-23 18:41:04 UTC (rev 470)
@@ -219,6 +219,7 @@
                         setVisible(false);
                         dispose();                    
                         parent.setCursor(Cursor.getDefaultCursor());
+                        afterStopping();
                         break;
                     case STOPPED:
                         afterStopped(value);
@@ -247,6 +248,10 @@
         
     }
     
+    public void afterStopping() {
+    	
+    }
+    
     // Variables declaration - do not modify//GEN-BEGIN:variables
     private javax.swing.JPanel jPanel1;
     private javax.swing.JProgressBar progressBar;



From tkovarik at gmail.com  Mon Jul 24 13:11:04 2006
From: tkovarik at gmail.com (Tomas Kovarik)
Date: Mon, 24 Jul 2006 13:11:04 +0200
Subject: [Plantlore-dev] Fwd: Plantlore
In-Reply-To: <ea88f1620607240351p4ab08b8cx4338036e2e8de929@mail.gmail.com>
References: <ea88f1620607190806l10018c42ke4b5a69256b939f4@mail.gmail.com>
	<20060720072707.4dc3d2a7@ksint.ms.mff.cuni.cz>
	<ea88f1620607240351p4ab08b8cx4338036e2e8de929@mail.gmail.com>
Message-ID: <ea88f1620607240411x3e59b107oeee6dc19c0f7ac86@mail.gmail.com>

Sorry, zabudol som pridat CC tak forwardujem

K.

---------- Forwarded message ----------
From: Tomas Kovarik <tkovarik at gmail.com>
Date: Jul 24, 2006 12:51 PM
Subject: Re: Plantlore
To: Antonin Riha <riha at ksi.ms.mff.cuni.cz>

Dobry den,

opravedlnujem sa, ze pisem az teraz, bolo by to mozne zajtra (utorok) 15:00
na Malej Strane? Ak by vam to nevyhovovalo navrhnite kedy presne v stredu by
vam to vyhovovalo.

S pozdravom

Tomas Kovarik



On 7/20/06, Antonin Riha <riha at ksi.ms.mff.cuni.cz> wrote:
>
> Mily kolego,
> zrovna jsem na vas projektanty vzpominal. Na fakultu ted jezdim
> jen pokud se vyskytne nezbytnost, ale s vami se ovsem rad setkam.
> Mam dojednanou dovolenou 29.7.-4.8., takze skutecne bychom se
> mohli sejit pristi tyden nebo az cca od 8. srpna. Pristi tyden
> bych mohl prijet tradicne v utery nejdrive tak v 15 hod. anebo
> ve stredu celkem kdykoli.
> Zdravi  A.Riha
>
> P.S. Ptal se me zde dnes jeden kolega, zda bych nevedel o dvou
> informaticich, kteri by chteli pracovat ve firme, kde pracuje
> jeho manzelka a delaji tam zhruba receno databaze a warehousy
> pro Ceskou pojistovnu. Pozaduji predevsim Javu a Oracle. Sice
> by uvitali absolventy, ale to neni v teto chvili mozno dojednat,
> ale kdyby mel zajem nekdo z vas nebo byste vedeli o nekom
> spolehlivem, zkontaktoval bych ho s tim kolegou.
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060724/c552f2f4/attachment.html>

From tkovarik at gmail.com  Mon Jul 24 14:30:10 2006
From: tkovarik at gmail.com (Tomas Kovarik)
Date: Mon, 24 Jul 2006 14:30:10 +0200
Subject: [Plantlore-dev] Plantlore
In-Reply-To: <20060724122452.93e227e9@ksint.ms.mff.cuni.cz>
References: <20060724122452.93e227e9@ksint.ms.mff.cuni.cz>
Message-ID: <ea88f1620607240530u78293c91s5e786902e89a78c3@mail.gmail.com>

Dakujem, email som dostal, pocitame teda so zajtrajskom, 15:00 pred vasou
pracovnou

Tomas Kovarik

On 7/24/06, Antonin Riha <riha at ksi.ms.mff.cuni.cz> wrote:
>
> > opravedlnujem sa, ze pisem az teraz, bolo by to mozne zajtra (utorok)
> 15:00
> > na Malej Strane? Ak by vam to nevyhovovalo navrhnite kedy presne v
> stredu by
> > vam to vyhovovalo.
> > S pozdravom
> > Tomas Kovarik
>
> Zdravim,
> uterni termin mi vyhovuje; podle moznosti mi prosim
> jeste potvrdte, ze jste tento mail dostali.
> A. Riha
>
-------------- next part --------------
An HTML attachment was scrubbed...
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060724/011e136e/attachment.html>

From lada at mail.berlios.de  Mon Jul 24 18:56:32 2006
From: lada at mail.berlios.de (lada at mail.berlios.de)
Date: Mon, 24 Jul 2006 18:56:32 +0200
Subject: [Plantlore-dev] r471 - in trunk/src/net/sf/plantlore:
	client/history l10n
Message-ID: <200607241656.k6OGuWOb020172@sheep.berlios.de>

Author: lada
Date: 2006-07-24 18:56:27 +0200 (Mon, 24 Jul 2006)
New Revision: 471

Modified:
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.form
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
   trunk/src/net/sf/plantlore/l10n/Plantlore.properties
   trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
Log:
History - L10n, GUI.

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -124,19 +124,19 @@
     private Hashtable<String, Enum> editTypeHash;
     
     /** Constants used for description of errors */
-    public static final String ERROR_SEARCH_RECORD = L10n.getString("Error.historyRecordSearchFailed");
-    public static final String ERROR_SEARCH_DATA = L10n.getString("Error.historyDataSearchFailed");
-    public static final String ERROR_SEARCH_OBJECT = L10n.getString("Error.historyObjectSearchFailed");
-    public static final String ERROR_SEARCH_AUTHOR = L10n.getString("Error.historyAuthorSearchFailed");
-    public static final String ERROR_PROCESS = L10n.getString("Error.historyProcessResultsFailed");
-    public static final String ERROR_UPDATE = L10n.getString("Error.historyUpdateResultsFailed");
-    public static final String ERROR_DELETE = L10n.getString("Error.historyDeleteResultsFailed");  
-    public static final String ERROR_CLEAR_DATABASE = L10n.getString("Error.historyClearDatabase");
-    public static final String ERROR_CLEAR_HISTORY = L10n.getString("Error.historyClearHistory");
-    public static final String ERROR_PARSE_DATE = L10n.getString("Error.historyParseData");
-    public static final String ERROR_NUMBER_ROWS = L10n.getString("Error.historyGetNumberRows");
-    public static final String ERROR_NO_RIGHTS = L10n.getString("Error.historyNoRights"); 
-    
+    public static final String ERROR_SEARCH_RECORD = L10n.getString("Error.HistoryRecordSearchFailed");
+    public static final String ERROR_SEARCH_DATA = L10n.getString("Error.HistoryDataSearchFailed");
+    public static final String ERROR_SEARCH_OBJECT = L10n.getString("Error.HistoryObjectSearchFailed");
+    public static final String ERROR_SEARCH_AUTHOR = L10n.getString("Error.HistoryAuthorSearchFailed");
+    public static final String ERROR_PROCESS = L10n.getString("Error.HistoryProcessResultsFailed");
+    public static final String ERROR_UPDATE = L10n.getString("Error.HistoryUpdateResultsFailed");
+    public static final String ERROR_DELETE = L10n.getString("Error.HistoryDeleteResultsFailed");  
+    public static final String ERROR_CLEAR_DATABASE = L10n.getString("Error.HistoryClearDatabase");
+    public static final String ERROR_CLEAR_HISTORY = L10n.getString("Error.HistoryClearHistory");
+    public static final String ERROR_PARSE_DATE = L10n.getString("Error.HistoryParseData");
+    public static final String ERROR_NUMBER_ROWS = L10n.getString("Error.HistoryGetNumberRows");
+    public static final String ERROR_NO_RIGHTS = L10n.getString("Error.HistoryNoRights"); 
+    public static final String ERROR_TRANSACTION = L10n.getString("Error.TransactionRaceConditions");    
     /**
      * Creates a new instance of History - history of Occurrences, Habitats, Authors, 
      * Publications, Metadata, Territories, Phytochorions, Villages
@@ -477,7 +477,7 @@
      */
     public void undoInsertDelete(int isDelete) {
         if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)){        	
-        	Object[] object = searchObject("Occurrence",recordId);        	        	
+        	Object[] object = searchObject(PlantloreConstants.ENTITY_OCCURRENCE,recordId);        	        	
         	if (isError()) return; //tOccurrence doesn`t contain required data        	       		        		
         	Occurrence occurrence = (Occurrence)object[0];             
             occurrence.setDeleted(isDelete);                      	     	 
@@ -497,7 +497,7 @@
                     editObjectList.add((Record)authorOccurrence);                 
             }                                     
         } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {
-             Object[] object = searchObject("AuthorOccurrence",recordId);               
+             Object[] object = searchObject(PlantloreConstants.ENTITY_AUTHOROCCURRENCE,recordId);               
              if (isError()) return; //tAuthorOccurrence doesn`t contain required data
              AuthorOccurrence authorOccurrence = (AuthorOccurrence)object[0];
              authorOccurrence.setDeleted(isDelete);             
@@ -505,7 +505,7 @@
              if (!editObjectList.contains((Record)authorOccurrence))                 
                 editObjectList.add((Record)authorOccurrence);             
        } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {            
-               Object[] object = searchObject("Habitat",recordId);  
+               Object[] object = searchObject(PlantloreConstants.ENTITY_HABITAT,recordId);  
                if (isError()) return; //tHabitat doesn`t contain required data
                Habitat habitat = (Habitat)object[0];
                habitat.setDeleted(isDelete);
@@ -513,7 +513,7 @@
                if (!editObjectList.contains((Record)habitat))                 
                    editObjectList.add((Record)habitat);             
         } else if (tableName.equals(PlantloreConstants.ENTITY_METADATA)) {
-             Object[] object = searchObject("Metadata",recordId); 
+             Object[] object = searchObject(PlantloreConstants.ENTITY_METADATA,recordId); 
              if (isError()) return; //tMetadata doesn`t contain required data
              Metadata metadata = (Metadata)object[0];
              metadata.setDeleted(isDelete);
@@ -521,7 +521,7 @@
              if (!editObjectList.contains((Record)metadata))                 
                 editObjectList.add((Record)metadata);             
         } else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
-             Object[] object = searchObject("Publication",recordId);
+             Object[] object = searchObject(PlantloreConstants.ENTITY_PUBLICATION,recordId);
              if (isError()) return; //tPublication doesn`t contain required data
              Publication publication = (Publication)object[0];
              publication.setDeleted(isDelete);
@@ -529,7 +529,7 @@
              if (!editObjectList.contains((Record)publication))                 
                 editObjectList.add((Record)publication);             
         } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOR)) {             
-             Object[] object = searchObject("Author",recordId);  
+             Object[] object = searchObject(PlantloreConstants.ENTITY_AUTHOR,recordId);  
              if (isError()) return; //tAuthor doesn`t contain required data
              Author author = (Author)object[0];
              author.setDeleted(isDelete);
@@ -599,7 +599,7 @@
     	
     	if (!contain) {
         	// Select record AuthorOccurrence where id = authorOccurrenceId 
-    		Object[] object = searchObject("AuthorOccurrence", authorOccId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_AUTHOROCCURRENCE, authorOccId);
     		if (isError()) return; //tAuthorOccurrence doesn`t contain required data
             authorOccurrence = (AuthorOccurrence)object[0];
         }     	                 
@@ -673,7 +673,7 @@
                 
         if (!contain) {
         	// Select record Occurrence where id = occurrenceId 
-            Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+            Object[] objectOcc = searchObject(PlantloreConstants.ENTITY_OCCURRENCE,occurrenceId);
             if (isError()) return; //tOccurrence doesn`t contain required data
             occ = (Occurrence)objectOcc[0];                    	
         }    
@@ -693,7 +693,7 @@
         case 1: //Taxon  
             if (oldRecordId > 0 ) {
                 //Select record Plant where id = oldRocordId 
-                Object[] object = searchObject("Plant",oldRecordId);
+                Object[] object = searchObject(PlantloreConstants.ENTITY_PLANT,oldRecordId);
                 if (isError()) return; //tPlant doesn`t contain required data
                 Plant plant = (Plant)object[0];
                 //Set old value to attribute plantID
@@ -765,7 +765,7 @@
         case 9: //Publication  
                 //Select record Publication where id = oldRocordId 
                 if (oldRecordId > 0){
-                    Object[] objectPubl = searchObject("Publication",oldRecordId);
+                    Object[] objectPubl = searchObject(PlantloreConstants.ENTITY_PUBLICATION,oldRecordId);
                     if (isError()) return; //tPublication doesn`t contain required data
                     Publication publication = (Publication)objectPubl[0];
                     //Set old value to attribute publicationID
@@ -778,7 +778,7 @@
         case 10: //metadata
         		//Select record Publication where id = oldRocordId 
 	            if (oldRecordId > 0){
-	                Object[] objectMetadata = searchObject("Metadata",oldRecordId);
+	                Object[] objectMetadata = searchObject(PlantloreConstants.ENTITY_METADATA,oldRecordId);
 	                if (isError()) return; //tMetadata doesn`t contain required data
 	                Metadata metadata = (Metadata)objectMetadata[0];
 	                //Set old value to attribute metadataID
@@ -791,7 +791,7 @@
         case 11: //habitat
         		//Select record Publication where id = oldRocordId 
 	            if (oldRecordId > 0){
-	                Object[] objectHabitat = searchObject("Habitat",oldRecordId);
+	                Object[] objectHabitat = searchObject(PlantloreConstants.ENTITY_HABITAT,oldRecordId);
 	                if (isError()) return; //tHabitat doesn`t contain required data
 	                Habitat habitat = (Habitat)objectHabitat[0];
 	                //Set old value to attribute habitatID
@@ -837,7 +837,7 @@
     	
     	if (!contain) {
         	// Select record Habitat where id = habitatId 
-    		Object[] object = searchObject("Habitat",habitatId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_HABITAT,habitatId);
     		if (isError()) return; //tHabitat doesn`t contain required data
             hab = (Habitat)object[0];
         } 
@@ -879,7 +879,7 @@
         case 7: //Nearest bigger seat   	                	 	                			                		 
                 //Select record Village where id = oldRocordId 
                 if (oldRecordId != 0){
-                        Object[] objectVill = searchObject("Village",oldRecordId);
+                        Object[] objectVill = searchObject(PlantloreConstants.ENTITY_VILLAGE,oldRecordId);
                         if (isError()) return; //tVillage doesn`t contain required data
                         Village village = (Village)objectVill[0];
                 hab.setNearestVillage(village);
@@ -891,7 +891,7 @@
         case 8: //Phytochorion or phytochorion code 	                	             			                		 
                 // Select record Phytochoria where id = oldRocordId 
                 if (oldRecordId != 0){
-                        Object[] objectPhyt = searchObject("Phytochorion",oldRecordId);
+                        Object[] objectPhyt = searchObject(PlantloreConstants.ENTITY_PHYTOCHORION,oldRecordId);
                         if (isError()) return; //tPhytochorion doesn`t contain required data
                         Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
                         hab.setPhytochorion(phytochorion);
@@ -903,7 +903,7 @@
         case 9:  //Territory   	                	                			                		  
                 // Select record Territory where id = oldRocordId 
                 if (oldRecordId != 0){
-                        Object[] objectTerr = searchObject("Territory",oldRecordId);
+                        Object[] objectTerr = searchObject(PlantloreConstants.ENTITY_TERRITORY,oldRecordId);
                         if (isError()) return; //tTerritory doesn`t contain required data
                         Territory territory = (Territory)objectTerr[0];
                         hab.setTerritory(territory);                                                            
@@ -952,7 +952,7 @@
     	
     	if (!contain) {
         	// Select record Publication where id = publicationId 
-    		Object[] object = searchObject("Publication", publicationId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_PUBLICATION, publicationId);
     		if (isError()) return; //tPublication doesn`t contain required data
             publication = (Publication)object[0];
         } 
@@ -1031,7 +1031,7 @@
     	
     	if (!contain) {
         	// Select record Author where id = authorId 
-    		Object[] object = searchObject("Author", authorId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_AUTHOR, authorId);
     		if (isError()) return; //tAuthor doesn`t contain required data
             author = (Author)object[0];
         } 	
@@ -1114,7 +1114,7 @@
     	
     	if (!contain) {
         	// Select record Metadata where id = metadataId 
-    		Object[] object = searchObject("Metadata", metadataId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_METADATA, metadataId);
     		if (isError()) return; //tMetadata doesn`t contain required data
     	    metadata = (Metadata)object[0];
         }
@@ -1218,7 +1218,7 @@
     	
     	if (!contain) {
         	// Select record Phytochorion where id = phytochorionId 
-    		Object[] object = searchObject("Phytochorion", phytId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_PHYTOCHORION, phytId);
     		if (isError()) return; //tPhytochorion doesn`t contain required data
             phytochorion = (Phytochorion)object[0];     
         }
@@ -1265,7 +1265,7 @@
     	
     	if (!contain) {
         	// Select record Village where id = villageId 
-    		Object[] object = searchObject("Village", villageId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_VILLAGE, villageId);
     		if (isError()) return; //tVillage doesn`t contain required data
             village = (Village)object[0];     
         }
@@ -1310,7 +1310,7 @@
     	
     	if (!contain) {
         	// Select record Territory where id = territoryId 
-    		Object[] object = searchObject("Territory", territoryId);
+    		Object[] object = searchObject(PlantloreConstants.ENTITY_TERRITORY, territoryId);
     		if (isError()) return; //tTerritory doesn`t contain required data
     		territory = (Territory)object[0];     
         }
@@ -1341,36 +1341,36 @@
     	SelectQuery query = null;
     	int resultIdObject = 0;
     	Object[] object = null;
-    	
+    	  	
         try {
-            if (typeObject.equals("Occurrence")){
+            if (typeObject.equals(PlantloreConstants.ENTITY_OCCURRENCE)){
                 query = database.createQuery(Occurrence.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, id , null);
-            } else if (typeObject.equals("AuthorOccurrence")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)){
                 query = database.createQuery(AuthorOccurrence.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.ID, null, id , null);
-            } else if (typeObject.equals("Habitat")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_HABITAT)){
                 query = database.createQuery(Habitat.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, id , null);
-            } else if (typeObject.equals("Plant")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_PLANT)){
                 query = database.createQuery(Plant.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.ID, null, id , null);
-            } else if (typeObject.equals("Author")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_AUTHOR)){
                 query = database.createQuery(Author.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Author.ID, null, id , null);
-            } else if (typeObject.equals("Publication")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_PUBLICATION)){
                 query = database.createQuery(Publication.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Publication.ID, null, id , null);
-            } else if (typeObject.equals("Village")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_VILLAGE)){
                 query = database.createQuery(Village.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Village.ID, null, id, null);
-            }  else if  (typeObject.equals("Territory")){
+            }  else if  (typeObject.equals(PlantloreConstants.ENTITY_TERRITORY)){
                 query = database.createQuery(Territory.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.ID, null, id , null);
-            } else if (typeObject.equals("Phytochorion")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_PHYTOCHORION)){
                 query = database.createQuery(Phytochorion.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.ID, null, id , null);
-            } else if (typeObject.equals("Metadata")){
+            } else if (typeObject.equals(PlantloreConstants.ENTITY_METADATA)){
                 query = database.createQuery(Metadata.class);
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Metadata.ID, null, id , null);
             } else {
@@ -1498,7 +1498,7 @@
 		        ok = database.beginTransaction();
 		        if (!ok) {
 		            logger.debug("History.commitUpdate(): Can't create transaction. Another is probably already running.");
-		            throw new DBLayerException("Can't create transaction. Another already running.");
+		            throw new DBLayerException(ERROR_TRANSACTION);
 		        }
 		        
 		        try {
@@ -1664,16 +1664,6 @@
     }    
 
     /**
-     * Create message containinig information about operation which will be realised    
-     * @param toDate  Date to which all the changes will be turned back.
-     * @return message containinig information about operation which will be realised
-     */
-    public String getMessageUndoToDate(String toDate) {
-        String message = "V?echny zm?ny do " + toDate + " budou navr?ceny."; //All changes to 12.4.06 will be turned back.
-        return message;
-    }
-    
-    /**
      *  Create message containing details of record
      *  @param resultNumber identifier of selected record
      *  @return String containing details of record 
@@ -1689,11 +1679,19 @@
         tableName = historyRecord.getHistoryColumn().getTableName();
         recordId = historyChange.getRecordId();
                         
-        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
+        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
               //Get details for occurrence
-              int occurrenceId = historyChange.getRecordId();
+        	  int occurrenceId; 
+        	  int recordId = historyChange.getRecordId();
+        	  if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)) {
+        		  occurrenceId = recordId;
+        	  } else {
+        		  Object[] objectAutOcc = searchObject(PlantloreConstants.ENTITY_AUTHOROCCURRENCE,recordId);
+                  if (isError()) return ""; //tAuthorsOccurrences doesn`t contain required data                  
+                  occurrenceId = ((AuthorOccurrence)objectAutOcc[0]).getOccurrence().getId();
+        	  }
               //Select record Occurrence where id = occurrenceId 
-              Object[] objectOcc = searchObject("Occurrence",occurrenceId);
+              Object[] objectOcc = searchObject(PlantloreConstants.ENTITY_OCCURRENCE,occurrenceId);
               if (isError()) return ""; //tOccurrence doesn`t contain required data
               Occurrence occurrence = (Occurrence)objectOcc[0]; 
               detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
@@ -1713,7 +1711,7 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + occurrence.getHabitat().getNote() +"\n";
         }else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
         	  //Get details for Publication
-              Object[] object = searchObject("Habitat",recordId);
+              Object[] object = searchObject(PlantloreConstants.ENTITY_HABITAT,recordId);
               if (isError()) return ""; //tHabitat doesn`t contain required data
               Habitat habitat = (Habitat)object[0];
               detailsMessage = L10n.getString("History.DetailsOccurrence") + "\n\n";
@@ -1725,7 +1723,7 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +"."+ Habitat.NOTE) + ": " + habitat.getNote() +"\n";
     	}else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
               //Get details for Publication
-              Object[] object = searchObject("Publication",recordId);
+              Object[] object = searchObject(PlantloreConstants.ENTITY_PUBLICATION,recordId);
               if (isError()) return ""; //tPublication doesn`t contain required data
               Publication publication = (Publication)object[0];
               detailsMessage = L10n.getString("History.DetailsPublication") + "\n\n";
@@ -1737,7 +1735,7 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PUBLICATION +"."+ Publication.NOTE) + ": " + publication.getNote() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_AUTHOR)) {
               //Get details for Author
-              Object[] object = searchObject("Author",recordId); 
+              Object[] object = searchObject(PlantloreConstants.ENTITY_AUTHOR,recordId); 
               if (isError()) return ""; //tAuthor doesn`t contain required data
               Author author = (Author)object[0];
               detailsMessage = L10n.getString("History.DetailsAuthor") + "\n\n";
@@ -1751,7 +1749,7 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_AUTHOR +"."+ Author.NOTE)+ ": "  + author.getNote() + "\n";
         }  else if (tableName.equals(PlantloreConstants.ENTITY_METADATA)) {
              //Get details for Metadata
-              Object[] object = searchObject("Metadata",recordId); 
+              Object[] object = searchObject(PlantloreConstants.ENTITY_METADATA,recordId); 
               if (isError()) return ""; //tMetadata doesn`t contain required data
               Metadata metadata = (Metadata)object[0];
               detailsMessage = L10n.getString("History.DetailsMetadata") + "\n\n";
@@ -1776,7 +1774,7 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_METADATA +"."+ Metadata.BIOTOPETEXT) + ": " + metadata.getBiotopeText() + "\n";                      
         } else if (tableName.equals(PlantloreConstants.ENTITY_PHYTOCHORION)) {
               //Get details for Phytochorion
-              Object[] object = searchObject("Phytochorion",recordId); 
+              Object[] object = searchObject(PlantloreConstants.ENTITY_PHYTOCHORION,recordId); 
               if (isError()) return ""; //tPhytochorion doesn`t contain required data
               Phytochorion  phytochorion = (Phytochorion)object[0];
               detailsMessage = L10n.getString("History.DetailsPhytochorion") + "\n\n";
@@ -1784,14 +1782,14 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_PHYTOCHORION +"."+ Phytochorion.CODE) + ": " + phytochorion.getCode() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_TERRITORY)) {
               //Get details for Territory
-              Object[] object = searchObject("Territory",recordId);
+              Object[] object = searchObject(PlantloreConstants.ENTITY_TERRITORY,recordId);
               if (isError()) return ""; //tTerritory doesn`t contain required data
               Territory territory = (Territory)object[0];
               detailsMessage = L10n.getString("History.DetailsTerritory") + "\n\n";
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_TERRITORY +"."+ Territory.NAME) + ": " + territory.getName() + "\n";
         } else if (tableName.equals(PlantloreConstants.ENTITY_VILLAGE)) {
               //Get details for Village
-              Object[] object = searchObject("Village",recordId);
+              Object[] object = searchObject(PlantloreConstants.ENTITY_VILLAGE,recordId);
               if (isError()) return ""; //tVillage doesn`t contain required data
               Village village = (Village)object[0];
               detailsMessage = L10n.getString("History.detailsVillage") + "\n\n";
@@ -1849,7 +1847,7 @@
     			ok = database.beginTransaction();
 		        if (!ok) {
 		            logger.debug("History.clearDatabase(): Can't create transaction. Another is probably already running.");
-		            throw new DBLayerException("Can't create transaction. Another already running.");
+		            throw new DBLayerException(ERROR_TRANSACTION);
 		        }
 		        
 		        try {

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -217,17 +217,15 @@
 						private static final long serialVersionUID = -6065695152319199854L;
 							public void exceptionHandler(Exception e) {
 		   						if (e instanceof DBLayerException) {	   									   							
-		   							DBLayerException dbex = (DBLayerException) e;
-		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
-									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
-		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+		   							DBLayerException dbex = (DBLayerException) e;		   							
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.HistoryDBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.HistoryDBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
 									logger.error(dbex + ": " + dbex.getErrorInfo());
 		   							getTask().stop();
 		   							return;
 		   						}
 		   						if (e instanceof RemoteException) {	 
-		   							RemoteException remex = (RemoteException) e;
-		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
+		   							RemoteException remex = (RemoteException) e;		   							
 		   							JOptionPane.showMessageDialog(view, L10n.getString("Error.RemoteException")+ "\n" + remex.getMessage(),
 		 							   L10n.getString("Error.RemoteExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
 									logger.error(remex + ": " + remex.getMessage());

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.form	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.form	2006-07-24 16:56:27 UTC (rev 471)
@@ -85,10 +85,10 @@
                   <EmptySpace pref="57" max="32767" attributes="0"/>
                   <Group type="103" groupAlignment="0" attributes="0">
                       <Component id="taxonValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
-                      <Component id="authorValueLabel" min="-2" max="-2" attributes="0"/>
+                      <Component id="authorValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                       <Component id="locationValueLabel" alignment="0" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace pref="445" max="32767" attributes="0"/>
+                  <EmptySpace pref="10" max="32767" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
@@ -192,7 +192,7 @@
                       <Component id="whenInsertValueLabel" min="-2" max="-2" attributes="0"/>
                       <Component id="whoInsertValueLabel" min="-2" max="-2" attributes="0"/>
                   </Group>
-                  <EmptySpace pref="462" max="32767" attributes="0"/>
+                  <EmptySpace pref="10" max="32767" attributes="0"/>
               </Group>
           </Group>
         </DimensionLayout>
@@ -414,7 +414,7 @@
         <Component class="javax.swing.JLabel" name="toDisplayLabel">
           <Properties>
             <Property name="text" type="java.lang.String" editor="org.netbeans.modules.form.RADConnectionPropertyEditor">
-              <Connection code="L10n.getString(&quot;History.RowToDisplay&quot;)" type="code"/>
+              <Connection code="L10n.getString(&quot;History.RowsToDisplay&quot;)" type="code"/>
             </Property>
           </Properties>
         </Component>

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -123,17 +123,17 @@
         jPanel1Layout.setHorizontalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
             .add(jPanel1Layout.createSequentialGroup()
-                .add(19, 19, 19)
+                .add(20, 20, 20)
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(authorLabel)
                     .add(locationLabel)
                     .add(taxonLabel))
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 57, Short.MAX_VALUE)
+                .add(39, 39, 39)
                 .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(taxonValueLabel)
                     .add(authorValueLabel)
                     .add(locationValueLabel))
-                .addContainerGap(491, Short.MAX_VALUE))
+                .addContainerGap(10, Short.MAX_VALUE))
         );
         jPanel1Layout.setVerticalGroup(
             jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
@@ -175,7 +175,7 @@
                 .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                     .add(whenInsertValueLabel)
                     .add(whoInsertValueLabel))
-                .addContainerGap(508, Short.MAX_VALUE))
+                .addContainerGap(10, Short.MAX_VALUE))
         );
         jPanel2Layout.setVerticalGroup(
             jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
@@ -219,7 +219,7 @@
 
         totalResultValueLabel.setText(((Integer)model.getResultRows()).toString());
 
-        toDisplayLabel.setText(L10n.getString("History.RowToDisplay"));
+        toDisplayLabel.setText(L10n.getString("History.RowsToDisplay"));
 
         toDisplayValueTextField.setText(((Integer)model.getDisplayRows()).toString());
 

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -241,9 +241,8 @@
 							public void exceptionHandler(Exception e) {
 		   						if (e instanceof DBLayerException) {	   									   							
 		   							DBLayerException dbex = (DBLayerException) e;
-		   							//TODO zobrazit vlastni message - nemusi byt vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
-									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
-		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.HistoryDBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.HistoryDBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
 									logger.error(dbex + ": " + dbex.getErrorInfo());
 		   							getTask().stop();
 		   							return;
@@ -314,7 +313,8 @@
                DetailsHistoryCtrl detailsCtrl = new DetailsHistoryCtrl(detailsView);
                detailsView.setDetailsMessage(detailsMessage);
                detailsView.setVisible(true);               
-           }          
+           }    
+           model.setError(null);
        }
     }
     
@@ -345,10 +345,9 @@
 						private static final long serialVersionUID = -6065695152319199854L;
 							public void exceptionHandler(Exception e) {
 		   						if (e instanceof DBLayerException) {	   									   							
-		   							DBLayerException dbex = (DBLayerException) e;
-		   							//TODO zobrazit vlastni message - nemusi vzdy byt poskozene pripojeni k DB, nekdo mohl smazat data, atd..
-									JOptionPane.showMessageDialog(view, L10n.getString("Error.DBLayerException")+ "\n" + dbex.getErrorInfo(),
-		 							   L10n.getString("Error.DBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
+		   							DBLayerException dbex = (DBLayerException) e;		   							
+									JOptionPane.showMessageDialog(view, L10n.getString("Error.HistoryDBLayerException")+ "\n" + dbex.getErrorInfo(),
+		 							   L10n.getString("Error.HistoryDBLayerExceptionTitle"), JOptionPane.WARNING_MESSAGE);																						
 									logger.error(dbex + ": " + dbex.getErrorInfo());
 		   							getTask().stop();
 		   							return;

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -111,8 +111,7 @@
     	    editHistoryData[ii][0] = DateFormat.getDateTimeInstance(DateFormat.MEDIUM, DateFormat.SHORT,L10n.getCurrentLocale()).format(when);     	    
             editHistoryData[ii][1] = L10n.getString( "History.Operation"+((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getOperation());
     	    editHistoryData[ii][2] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWho().getWholeName();    	   
-    	    editHistoryData[ii][3] = item;
-    	    logger.debug("WWWWWWWWWW: "+ item);
+    	    editHistoryData[ii][3] = item;    	    
     	    editHistoryData[ii][4] = ((HistoryRecord)editHistoryDataList.get(i)).getOldValue();
     	    editHistoryData[ii][5] = ((HistoryRecord)editHistoryDataList.get(i)).getNewValue();
     	    ii++;

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-07-24 16:56:27 UTC (rev 471)
@@ -17,12 +17,14 @@
 import net.sf.plantlore.common.TransferFocus;
 
 /**
- *
- * @author  Lada
+ * View for the main WholeHistory dialog (part of the WholeHistory MVC). Used for displaying the search results.
+ * @author  Lada Oberreiterov?
+ * @version 1.0
  */
 public class WholeHistoryView extends javax.swing.JDialog implements Observer {
-    
-    private History model;  
+       
+	private static final long serialVersionUID = -8216564649155252124L;
+	private History model;  
   
     /**
      * Creates new form WholeHistoryView

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-07-24 16:56:27 UTC (rev 471)
@@ -132,7 +132,7 @@
 History.Whole.ButtonUndoToDate = Undo
 History.Whole.ButtonClearHistory = Clear history
 History.ButtonSelectAll = Select all
-History.ButtonUnselectAll = Unselect all
+History.ButtonUnselectAll = Unselected all
 History.ButtonUndoSelected = Undo selected
 
 History.Operation1 = insert
@@ -154,7 +154,7 @@
 History.Taxon = Taxon:
 History.Author = Author:
 History.Location = Location:
-History.WhenCreate = Date record creation:
+History.WhenInsert = Date record creation:
 History.WhoInsert = User who record created:
 
 History.DetailsOccurrence = Details of Occurrence
@@ -172,31 +172,37 @@
 # RECORDS - HISTORY ITEM
 #	net.sf.plantlore.client.history
 #=============================================================
-AUTHOROCCURRENCE.author = Author (occurrence)
-AUTHOROCCURRENCE.role = Role of author (occurrence)
-AUTHOROCCURRENCE.note = Note or result of revision
-OCCURRENCE.plant = Taxon (occurrence)
-OCCURRENCE.yearCollected = Year of collected
-OCCURRENCE.monthCollected = Month of collected
-OCCURRENCE.dayCollected = Day of collected
-OCCURRENCE.timeCollected = Time of collected
-OCCURRENCE.isoDateTime = Date and Time of collected
-OCCURRENCE.publication = Publication (occurrence)
-OCCURRENCE.dataSource = Data source
-OCCURRENCE.herbarium = Herbarium
-OCCURRENCE.note = Note of occurrence
-OCCURRENCE.metadata = Project (occurrence)
-HABITAT.territory = Territory (occurrence)
-HABITAT.phytochorion = Phytochorion (occurrence)
-HABITAT.nearestVillage = Village (occurrence)
-HABITAT.quadrant = Quadrant
-HABITAT.description = Place description
-HABITAT.country = Country
-HABITAT.altitude = Altitude
-HABITAT.latitude = Latitude
-HABITAT.longitude = Longitude
-HABITAT.note = Note of habitat
+AUTHOROCCURRENCE.author = Author (occ)
+AUTHOROCCURRENCE.role = Role of author (occ)
+AUTHOROCCURRENCE.note = Note or result of revision (occ)
+AUTHOROCCURRENCE.null = Occurrence/Author
+OCCURRENCE.null = Occurrence
+OCCURRENCE.plant = Taxon (occ)
+OCCURRENCE.yearCollected = Year of collected (occ)
+OCCURRENCE.monthCollected = Month of collected (occ)
+OCCURRENCE.dayCollected = Day of collected (occ)
+OCCURRENCE.timeCollected = Time of collected (occ)
+OCCURRENCE.isoDateTimeBegin = Date and Time of collected (occ)
+OCCURRENCE.publication = Publication (occ)
+OCCURRENCE.dataSource = Data source (occ)
+OCCURRENCE.herbarium = Herbarium (occ)
+OCCURRENCE.note = Note of occurrence (occ)
+OCCURRENCE.metadata = Project (occ)
 
+HABITAT.null = Habitat
+HABITAT.territory = Territory (hab)
+HABITAT.phytochorion = Phytochorion (hab)
+HABITAT.nearestVillage = Village (hab)
+HABITAT.village = Village (hab)
+HABITAT.quadrant = Quadrant 
+HABITAT.description = Place description 
+HABITAT.country = Country 
+HABITAT.altitude = Altitude 
+HABITAT.latitude = Latitude 
+HABITAT.longitude = Longitude 
+HABITAT.note = Note of habitat 
+
+PUBLICATION.null = Publication
 PUBLICATION.collectionName = Collection
 PUBLICATION.collectionYearPublication = Year of publication
 PUBLICATION.journalName = Journal
@@ -206,6 +212,7 @@
 PUBLICATION.url = URL of publication
 PUBLICATION.note = Note of publication
 
+METADATA.null = Metadata
 METADATA.technicalContactName = Technical contact name
 METADATA.technicalContactEmail = Technical contact email
 METADATA.technicalContactAddress = Technical contact address
@@ -222,6 +229,7 @@
 METADATA.recordbasis = Record basis
 METADATA.biotopetext = Biotopetext
 
+AUTHOR.null = Author
 AUTHOR.wholeName = Name of author
 AUTHOR.organization = Organization of author
 AUTHOR.role = Role of author
@@ -230,9 +238,15 @@
 AUTHOR.email = Email of author
 AUTHOR.ulr = Url of author
 AUTHOR.note = Note of 
+AUTHOR.role.revised = revisor
+AUTHOR.role.collected = collector
+AUTHOR.role.other = unspecified
 
+VILLAGE.null = Nearest bigger seat
 VILLAGE.name = Nearest bigger seat
+TERRITORY.null = Territory
 TERRITORY.name = Territory
+PHYTOCHORION.null = Phytochorion
 PHYTOCHORION.name = Phytochorion
 PHYTOCHORION.code = Phytochorion code 
 
@@ -247,36 +261,7 @@
 UserManager.ShowPanel = Show users
 UserManager.UserDataPanel = User`s data
 UserManager.UserRightPanel = User`s right
-#History a occurrence - details
-taxon = Taxon:
-author = Author:
-location = Location:
-#History - List of changes
-whenInsert = Date record creation:
-whoInsert = User who record created:
-#History - buttons
-selectAll = Select all
-unselectAll = Unselect all
-undoSelected = Undo selected
-undoToDate = Undo to Date
-detailsHistory = Details
-clearHistory = Clear history
-#History - information about result and displayed rows
-Author.TotalResults=Total results:
-Author.DisplayedRowsLabel=Displayed rows:
-toDisplay = Rows to display:
-#History - Title of table columns
-historyColX = X
-historyColDate = Date/Time
-historyColOperation = Operation
-historyColUser = User
-historyColItem = Item
-historyColOldValue = Old value
-historyColNewValue = New value
-#History - value of tHistoryChange.cOperation
-operation1 = insert
-operation2 = edit
-operation3 = delete
+
 UserManager.ButtonDrop = Drop User
 UserManager.ButtonAdd = Add User
 UserManager.ButtonEdit = Edit User
@@ -714,7 +699,36 @@
 Error.UnableToProcess = The record No. {0} cannot be processed; 
 Error.MissingUpdateRecord = The update is not defined! 
 
+Error.HistoryRecordSearchFailed = Connection to the database failed.\n The record was not found.\n Contact administrator.
+Error.HistoryDataSearchFailed = Connection to the database failed.\n The history data were not found.\n \n Contact administrator.
+Error.HistoryObjectSearchFailed = Work with data failed. \n Some data were not found in database.
+Error.HistoryAuthorSearchFailed = Work with data failed. \n Some data were not found in database.
+Error.HistoryProcessResultsFailed = Processing search results failed.
+Error.HistoryUpdateResultsFailed = Update data in the database failed.
+Error.HistoryDeleteResultsFailed = Update data in the database failed.  
+Error.HistoryClearDatabase = Delete history and inactive data in database failed.
+Error.HistoryClearHistory = Delete history and inactive data in database failed.
+Error.HistoryParseData = Work with data failed. \n Parse date failed.
+Error.HistoryGetNumberRows = Get the number of rows returned in the result failed.
+Error.HistoryNoRights =  You don't have sufficient rights to edit this record.
+Error.HistoryDBLayerException=Connection to the database failed.\n Data were not found.
+Error.HistoryDBLayerExceptionTitle=Database problem.
 
+Error.DBLayerException=Connection to the database failed\:
+Error.DBLayerExceptionTitle=Database connection problem
+Error.RemoteException=Please make sure the network connection is working.
+Error.RemoteExceptionTitle=Network problem
+Delete.Message.UnknownException=Some problem occurred during deletion\:
+authorSearchFailed=Searching authors failed
+authorSaveFailed=Saving author failed
+authorUpdateFailed=Updating author failed
+authorDeleteFailed=Deleting author failed
+authorProcessResultsFailed=Processing search results failed
+publicationSearchFailed=Searching publications failed
+publicationSaveFailed=Saving publication failed
+publicationUpdateFailed=Updating publication failed
+publicationDeleteFailed=Deleting publication failed
+publicationProcessResultsFailed=Processing search results failed
 
 #=============================================================
 # QUESTIONS
@@ -851,16 +865,6 @@
 
 searchPublicationsBtn=Search publications
 
-publicationSearchFailed=Searching publications failed
-
-publicationSaveFailed=Saving publication failed
-
-publicationUpdateFailed=Updating publication failed
-
-publicationDeleteFailed=Deleting publication failed
-
-publicationProcessResultsFailed=Processing search results failed
-
 addPublicationNoteLbl=Note\:
 
 addPublicationUrlLbl=URL\:
@@ -877,16 +881,6 @@
 
 addPublicationCollectionNameLbl=Collection name\:
 
-authorSearchFailed=Searching authors failed
-
-authorSaveFailed=Saving author failed
-
-authorUpdateFailed=Updating author failed
-
-authorDeleteFailed=Deleting author failed
-
-authorProcessResultsFailed=Processing search results failed
-
 savePublicationBtn=Save publication
 
 Overview.Warning.MaxRecordsPerPage=The maximum number of records per page is
@@ -1125,16 +1119,6 @@
 
 Message.DeleteRecordsTT=Warning
 
-Error.DBLayerException=Connection to the database failed\:
-
-Error.DBLayerExceptionTitle=Database connection problem
-
-Error.RemoteException=Please make sure the network connection is working.
-
-Error.RemoteExceptionTitle=Network problem
-
-Delete.Message.UnknownException=Some problem occurred during deletion\:
-
 Delete.Message.ProgressInfo={0} records out of {1} deleted.
 
 Message.DeleteRecordsTitle=Warning

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-07-23 18:41:04 UTC (rev 470)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-07-24 16:56:27 UTC (rev 471)
@@ -122,7 +122,149 @@
 #Whole history manager
 wholeHistory = Whole history - undo
 
-#User manager
+#=============================================================
+# HISTORY
+#	net.sf.plantlore.client.history
+#=============================================================
+History.Whole = Whole history
+History.Record= History 
+History.Whole.Panel = Whole history
+History.DetailsPanel = Details of selected record
+History.DetailsRecordPanel = Details of the record
+History.RecordCreatedPanel = Record created
+History.ChangesRecordPanel = List of changes
+
+History.ButtonPrev = Prev
+History.ButtonNext = Next
+History.ButtonDetails = Details
+History.ButtonHelp = Help
+History.ButtonClose = Close
+History.ButtonOk = Ok
+History.Whole.ButtonUndoToDate = Undo
+History.Whole.ButtonClearHistory = Clear history
+History.ButtonSelectAll = Select all
+History.ButtonUnselectAll = Unselected all
+History.ButtonUndoSelected = Undo selected
+
+History.Operation1 = insert
+History.Operation2 = edit
+History.Operation3 = delete
+
+History.TotalResult = Total results:
+History.RowsToDisplay = Rows to display:
+History.Displayed = Displayed rows:
+
+History.ColumnX = X
+History.ColumnDate = Date/Time
+History.ColumnOperation = Operation
+History.ColumnUser = User
+History.ColumnItem = Item
+History.ColumnOldValue = Old value
+History.ColumnNewValue = New value
+
+History.Taxon = Taxon:
+History.Author = Author:
+History.Location = Location:
+History.WhenInsert = Date record creation:
+History.WhoInsert = User who record created:
+
+History.DetailsOccurrence = Details of Occurrence
+History.DetailsPublication = Details of Publication
+History.DetailsAuthor = Details of Author
+History.DetailsTerritory = Details of Territory
+History.DetailsVillage = Details of Village
+History.DetailsPhytochorion = Details of Phytochorion
+History.DetailsMetadata.Project = PROJECT
+History.DetailsMetadata.Institution = INSTITUTION
+History.DetailsMetadata.TechnicalContact = TECHNICAL CONTACT
+History.DetailsMetadata.ContentContact = CONTENT CONTACT
+
+#=============================================================
+# RECORDS - HISTORY ITEM
+#	net.sf.plantlore.client.history
+#=============================================================
+AUTHOROCCURRENCE.author = Author (occ)
+AUTHOROCCURRENCE.role = Role of author (occ)
+AUTHOROCCURRENCE.note = Note or result of revision (occ)
+AUTHOROCCURRENCE.null = Occurrence/Author
+OCCURRENCE.null = Occurrence
+OCCURRENCE.plant = Taxon (occ)
+OCCURRENCE.yearCollected = Year of collected (occ)
+OCCURRENCE.monthCollected = Month of collected (occ)
+OCCURRENCE.dayCollected = Day of collected (occ)
+OCCURRENCE.timeCollected = Time of collected (occ)
+OCCURRENCE.isoDateTimeBegin = Date and Time of collected (occ)
+OCCURRENCE.publication = Publication (occ)
+OCCURRENCE.dataSource = Data source (occ)
+OCCURRENCE.herbarium = Herbarium (occ)
+OCCURRENCE.note = Note of occurrence (occ)
+OCCURRENCE.metadata = Project (occ)
+
+HABITAT.null = Habitat
+HABITAT.territory = Territory (hab)
+HABITAT.phytochorion = Phytochorion (hab)
+HABITAT.nearestVillage = Village (hab)
+HABITAT.village = Village (hab)
+HABITAT.quadrant = Quadrant 
+HABITAT.description = Place description 
+HABITAT.country = Country 
+HABITAT.altitude = Altitude 
+HABITAT.latitude = Latitude 
+HABITAT.longitude = Longitude 
+HABITAT.note = Note of habitat 
+
+PUBLICATION.null = Publication
+PUBLICATION.collectionName = Collection
+PUBLICATION.collectionYearPublication = Year of publication
+PUBLICATION.journalName = Journal
+PUBLICATION.journalAuthorName = Author of journal
+PUBLICATION.referenceCitation = Reference citation
+PUBLICATION.referenceDetail = Reference detail
+PUBLICATION.url = URL of publication
+PUBLICATION.note = Note of publication
+
+METADATA.null = Metadata
+METADATA.technicalContactName = Technical contact name
+METADATA.technicalContactEmail = Technical contact email
+METADATA.technicalContactAddress = Technical contact address
+METADATA.contentContactName = Content contact name
+METADATA.contentContactEmail = Content contact email
+METADATA.contentContactAddress = Content contact address
+METADATA.dataSetTitle = Project
+METADATA.dataSetDetails = Project description
+METADATA.sourceInstitutionId = Institution
+METADATA.sourceId = Source
+METADATA.ownerOrganizationAbbrev = Institution abbreviation
+METADATA.dateCreate = Created on
+METADATA.dateModified = Modified on
+METADATA.recordbasis = Record basis
+METADATA.biotopetext = Biotopetext
+
+AUTHOR.null = Author
+AUTHOR.wholeName = Name of author
+AUTHOR.organization = Organization of author
+AUTHOR.role = Role of author
+AUTHOR.address = Address of author
+AUTHOR.phoneNumber = Phone number of author
+AUTHOR.email = Email of author
+AUTHOR.ulr = Url of author
+AUTHOR.note = Note of 
+AUTHOR.role.revised = revisor
+AUTHOR.role.collected = collector
+AUTHOR.role.other = unspecified
+
+VILLAGE.null = Nearest bigger seat
+VILLAGE.name = Nearest bigger seat
+TERRITORY.null = Territory
+TERRITORY.name = Territory
+PHYTOCHORION.null = Phytochorion
+PHYTOCHORION.name = Phytochorion
+PHYTOCHORION.code = Phytochorion code 
+
+#=============================================================
+# USER MANAGER
+#	net.sf.plantlore.client.user
+#=============================================================
 UserManager = User manager
 UserManager.UserList = List of users
 UserManager.SearchPanel = Search users
@@ -169,113 +311,61 @@
 UserManager.Right.EditGroup = List of users whose occurrences the user can edit
 UserManager.Right.Add = Right add record
 
-#Publication - title of column  (used in History and Publication manager)
-PUBLICATION.null = Publication
-PUBLICATION.collectionName = Collection
-PUBLICATION.collectionYearPublication = Year of publication
-PUBLICATION.journalName = Journal
-PUBLICATION.journalAuthorName = Author of journal
-PUBLICATION.referenceCitation = Reference citation
-PUBLICATION.referenceDetail = Reference detail
-PUBLICATION.url = URL of publication
-PUBLICATION.note = Note of publication
+#=============================================================
+# METADATE MANAGER
+#	net.sf.plantlore.client.metadata
+#=============================================================
+MetadataManager.ListPanel = List of metadata
+MetadataManager.SearchPanel = Search users
+MetadataManager.SortPanel = Sorting
+MetadataManager.MetadataDetailsPanel = Metadata
+MetadataManager.InstitutionPanel = Institution
+MetadataManager.TechnicalContectPanel = Technical contact
+MetadataManager.ContentContactPanel = Content contact
+MetadataManager.ProjektDataPanel = Project - data
 
-#Metadata - title of column (use in History)
-METADATA.null = Metadata
-METADATA.technicalContactName = Technical contact name
-METADATA.technicalContactEmail = Technical contact email
-METADATA.technicalContactAddress = Technical contact address
-METADATA.contentContactName = Content contact name
-METADATA.contentContactEmail = Content contact email
-METADATA.contentContactAddress = Content contact address
-METADATA.dataSetTitle = Project
-METADATA.dataSetDetails = Project description
-METADATA.sourceInstitutionId = Institution name
-METADATA.sourceId = Code of source
-METADATA.ownerOrganizationAbbrev = Institution abbreviation
-METADATA.dateCreate = Date creating of project
-METADATA.dateModified = Last modified data in project
-METADATA.recordBasis = Recordbasis
-METADATA.biotopeText = Biotopetest
+MetadataManager = Metadata manager
+MetadataManager.TechnicalContactName = Technical contact name
+MetadataManager.TechnicalContactAddress = Technical contact address
+MetadataManager.TechnicalContactEmail = Technical contact email
+MetadataManager.ContentContactName = Content contact
+MetadataManager.ContentContactAddress = Content contact address
+MetadataManager.ContentContactEmail = Content contact email
+MetadataManager.DataSetTitle = Data set
+MetadataManager.DataSetDetails = Details
+MetadataManager.SourceInstitutionId = Institution
+MetadataManager.SourceId = Source
+MetadataManager.OwnerOrganizationAbbrev = Organization
+MetadataManager.DateCreate = Created on
+MetadataManager.DateModified = Modified on
+MetadataManager.RecordBasis = Basis
+MetadataManager.BiotopeText = BiotopeText
 
-#author - title of column (used in history)
-AUTHOR.null = Author
-AUTHOR.wholeName = Name of author
-AUTHOR.organization = Organization of author
-AUTHOR.role = Role of author
-AUTHOR.address = Address of author
-AUTHOR.phoneNumber = Phone number of author
-AUTHOR.email = Email of author
-AUTHOR.ulr = Url of author
-AUTHOR.note = Note of autho
-AUTHOR.role.collect = collector
+MetadataManager.ButtonDelete = Delete Metadata
+MetadataManager.ButtonAdd = Add Metadata
+MetadataManager.ButtonEdit = Edit Metadata
+MetadataManager.ButtonDetails = Details of Metadata
+MetadataManager.ButtonPrev = Previous
+MetadataManager.ButtonNext = Next
+MetadataManager.ButtonSearch = Search/Sort
+MetadataManager.ButtonHelp = Help
+MetadataManager.ButtonClose = Close
+MetadataManager.ButtonOk = Ok
 
-#village - title of column (used in history)
-VILLAGE.null = Nearest bigger seat
-VILLAGE.name = Nearest bigger seat
+MetadataManager.DisplayRows = Rows to display
+MetadataManager.TotalResult = Total results:
+MetadataManager.RowsToDisplay = Rows to display:
+MetadataManager.Displayed = Displayed rows:
+MetadataManager.DataSort = Sort by
+MetadataManager.SortAscending = Ascending
+MetadataManager.SortDescending = Descending
 
-#territory -  title of column (used in history)
-TERRITORY.null = Territory
-TERRITORY.name = Territory
-
-#phytochorion - title of column (used in history)
-PHYTOCHORION.null = Phytochorion
-PHYTOCHORION.name = Phytochorion
-PHYTOCHORION.code = Phytochorion code 
-
-#authorOccurrence, occurrence, habitat - title of column for history
-AUTHOROCCURRENCE.author = Author (occ)
-AUTHOROCCURRENCE.role = Role of author (occ)
-AUTHOROCCURRENCE.note = Note or result of revision (occ)
-AUTHOROCCURRENCE.null = Occurrence/Author
-OCCURRENCE.null = Occurrence
-OCCURRENCE.plant = Taxon (occ)
-OCCURRENCE.yearCollected = Year of collected (occ)
-OCCURRENCE.monthCollected = Month of collected (occ)
-OCCURRENCE.dayCollected = Day of collected (occ)
-OCCURRENCE.timeCollected = Time of collected (occ)
-OCCURRENCE.isoDateTimeBegin = Date and Time of collected (occ)
-OCCURRENCE.publication = Publication (occ)
-OCCURRENCE.dataSource = Data source (occ)
-OCCURRENCE.herbarium = Herbarium (occ)
-OCCURRENCE.note = Note of occurrence (occ)
-OCCURRENCE.metadata = Project (occ)
-HABITAT.null = Occurrence/Habitat
-HABITAT.territory = Territory (occ)
-HABITAT.phytochorion = Phytochorion (occ)
-HABITAT.nearestVillage = Village (occ)
-HABITAT.quadrant = Quadrant (occ)
-HABITAT.description = Place description (occ)
-HABITAT.country = Country (occ)
-HABITAT.altitude = Altitude (occ)
-HABITAT.latitude = Latitude (occ)
-HABITAT.longitude = Longitude (occ)
-HABITAT.note = Note of habitat (occ)
-
-
 record.Property = Property
 record.Value = Value
 record.ForeignKey = Foreign Key
 record.InDatabase = Value (In DB)
 record.FromFile = Value (In File)
 
-
-#Title of border and other titles 
-netadata.project = PROJECT
-metadata.institution = INSTITUTION
-metadata.technicalContact = TECHNICAL CONTACT
-metadata.contentContact = CONTENT CONTACT
-detailsOccurrence = Details of Occurrence
-detailsPublication = Details of Publication
-detailsAuthor = Details of Author
-detailsTerritory = Details of Territory
-detailsVillage = Details of Village
-detailsPhytochorion = Details of Phytochorion
-detailsRecordPanel = Details of the record
-recordCreatedPanel = Record created
-changesRecordPanel = List of changes
-wholeHistoryPanel = Whole history
-
 #version of data in table tPlants, ...
 versionPlantsFile = Last version of plants list
 



From admin at berlios.de  Wed Jul 26 15:57:59 2006
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 26 Jul 2006 15:57:59 +0200 (CEST)
Subject: [Plantlore-dev] [Bug #7748] Application freezes (Windows XP)
Message-ID: <200607261357.k6QDvxri021835@unicorn.berlios.de>

Bug #7748, was updated on 2006-Jun-04 17:04
Here is a current snapshot of the bug.

Project: Plantlore
Category: General
Status: Open
Resolution: None
Bug Group: Bug
Priority: 9
Submitted by: krater
Assigned to : none
Summary: Application freezes (Windows XP)

Details: Almost every time a JOptionPane.showMessage() is called and there is an opened modal dialog, the whole application freezes.

The cause of the problem is unknown, although it will probably have something to do with the threading model.

Follow-Ups:

Date: 2006-Jul-26 15:57
By: krater

Comment:
If you modify the VIEW's update() method accordingly, you actually CAN still call JOptionPane.showMessage() from the controller. I've found that recently. The application WILL NOT freeze.
-------------------------------------------------------

Date: 2006-Jun-04 17:41
By: krater

Comment:
In my experience if you convert your view's update() method in the following manner:

    public void update(Observable source, final Object arg) {
    	java.awt.EventQueue.invokeLater(new Runnable() {
    		public void run() {

    			if(arg instanceof Exception) {
    				
    				JOptionPane.showMessageDialog(
    						null, 
    						((Exception)arg).getMessage(), 
    						L10n.getString("Error.LoginFailed"), 
    						JOptionPane.ERROR_MESSAGE);
    			}
    			// The database layer has been created, we are no longer neccessary
    			else if(arg instanceof DBLayer)
    				setVisible(false); 
    			// Some update information - display them in the status bar.
    			else if(arg instanceof String) 
    				status.setText("  " + (String)arg);
    		}
    	});
	}



everything should be fine. However, the code in the controller must not call JOptionPane.showMessage(). Changes I do to the view from the controller doesn't seem to cause any problem. See the net.sf.plantlore.client.login package for the details.
-------------------------------------------------------

Date: 2006-Jun-04 17:19
By: krater

Comment:
Weird thing is that Login doesn't freeze now...
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7748&group_id=5975


From admin at berlios.de  Wed Jul 26 16:01:57 2006
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 26 Jul 2006 16:01:57 +0200 (CEST)
Subject: [Plantlore-dev] [Bug #7665] The items in the login triplet should
	be compulsory
Message-ID: <200607261401.k6QE1v5w024159@unicorn.berlios.de>

Bug #7665, was updated on 2006-May-30 19:37
Here is a current snapshot of the bug.

Project: Plantlore
Category: Login
Status: Closed
Resolution: Fixed
Bug Group: RFE
Priority: 5
Submitted by: tkovarik
Assigned to : krater
Summary: The items in the login triplet should be compulsory

Details: Currently when logging in, you can add triplet with all the items left blank. This should not be allowed. At least Alias and Database name should be compulsory (hostname can be set to default value ("localhost") when not provided by the user). The documentation needs to be updated as well

How to reproduce:
1. Open login
2. Add triplet, do not fill in any of the items
3. You have triplet without an alias (not very usefull since you cannot see it) and without a database (also not very usefull)

Encountered in revision: 395

Follow-Ups:

Date: 2006-Jul-26 16:01
By: krater

Comment:
The whole dialog was changed. It no longer works with so called "triplets" but with the DBInfo object. This allows the User to set much more things more precisely. Also the compulsory fields check has been added. 
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7665&group_id=5975


From admin at berlios.de  Wed Jul 26 16:04:03 2006
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 26 Jul 2006 16:04:03 +0200 (CEST)
Subject: [Plantlore-dev] [Bug #7693] The "Select automatically" checkbox
	should store its state
Message-ID: <200607261404.k6QE435A025127@unicorn.berlios.de>

Bug #7693, was updated on 2006-May-31 12:48
Here is a current snapshot of the bug.

Project: Plantlore
Category: Login
Status: Closed
Resolution: Fixed
Bug Group: RFE
Priority: 3
Submitted by: krater
Assigned to : krater
Summary: The "Select automatically" checkbox should store its state

Details: The checkbox labeled "Stored automatically" should store its state into the file containing preferences. The User must be able to change that state in Settings as well.

Follow-Ups:

Date: 2006-Jul-26 16:03
By: krater

Comment:
The label is invisible now. The functionality will not be implemented our release.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7693&group_id=5975


From admin at berlios.de  Wed Jul 26 16:07:08 2006
From: admin at berlios.de (admin at berlios.de)
Date: Wed, 26 Jul 2006 16:07:08 +0200 (CEST)
Subject: [Plantlore-dev] [Bug #7751] Simplify the Add triplet dialog
Message-ID: <200607261407.k6QE78te026924@unicorn.berlios.de>

Bug #7751, was updated on 2006-Jun-04 23:42
Here is a current snapshot of the bug.

Project: Plantlore
Category: Login
Status: Closed
Resolution: Works For Me
Bug Group: RFE
Priority: 3
Submitted by: tkovarik
Assigned to : krater
Summary: Simplify the Add triplet dialog

Details: The add triplet (now called DBInfo) dialog could be made more simple and user friendly. Since users connect either to a local database or a remote server, I suggest that the items in the dialog are divided into two groups - Local database and Remote database. This can be done for example by two tabs in the dialog. Each of the two options would have only those fields neccessary for that type of login (for example masterlogin and masterpassword are not neccessary for remote connection).
This feature could be implemented in the 2.0 version.

Follow-Ups:

Date: 2006-Jul-26 16:07
By: krater

Comment:
The problem was fixed together with Bug #7665.
-------------------------------------------------------

For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=7751&group_id=5975


From admin at berlios.de  Fri Jul 28 15:19:24 2006
From: admin at berlios.de (admin at berlios.de)
Date: Fri, 28 Jul 2006 15:19:24 +0200 (CEST)
Subject: [Plantlore-dev] [Bug #8231] Distorted buttons
Message-ID: <200607281319.k6SDJObB027130@unicorn.berlios.de>

Bug #8231, was updated on 2006-Jul-28 15:19
Here is a current snapshot of the bug.

Project: Plantlore
Category: None
Status: Open
Resolution: None
Bug Group: RFE
Priority: 1
Submitted by: krater
Assigned to : none
Summary: Distorted buttons

Details: It sometimes happens that buttons get distorted (the size is incorrect and the text is missing) although everything seems to be set ok. 

The cause of the problem is simple. It seems that the call button.setAction( myAction ) causes that problem IF `myAction` doesn't have a constructor whith the following line: putValue(NAME, L10n.getString("Common.Cancel"));



For detailed info, follow this link:
http://developer.berlios.de/bugs/?func=detailbug&bug_id=8231&group_id=5975


From krater at mail.berlios.de  Mon Jul 31 10:38:30 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 10:38:30 +0200
Subject: [Plantlore-dev] r472 - trunk/src/net/sf/plantlore/common
Message-ID: <200607310838.k6V8cUWI024357@sheep.berlios.de>

Author: krater
Date: 2006-07-31 10:38:27 +0200 (Mon, 31 Jul 2006)
New Revision: 472

Modified:
   trunk/src/net/sf/plantlore/common/Task.java
Log:
A simple extension: a kill() method. If the task thread is blocked (wait(), sleep(), join(), blocking IO operation), then stop() will have not an instant effect. Therefore another method - kill() - was introduced. This method can interrupt that blocking operation and the thread could react more swiftly. This is very useful when a network operation is in progress and may take a very long time (such as login etc.). The User can cancel the operation immediately.

Modified: trunk/src/net/sf/plantlore/common/Task.java
===================================================================
--- trunk/src/net/sf/plantlore/common/Task.java	2006-07-24 16:56:27 UTC (rev 471)
+++ trunk/src/net/sf/plantlore/common/Task.java	2006-07-31 08:38:27 UTC (rev 472)
@@ -235,6 +235,22 @@
         notifyObservers(new Pair<Message,Object>(Message.STOPPING,null));
     }
     
+    
+    /**
+     * Forcibly stops (cancels) the task.
+     * <br/>
+     * This call will interrupt any blocking IO operation, wait(), sleep(), and join() 
+     * that might be blocking the current task. 
+     * This should stop the task immediately. 
+     */
+    public void kill() {
+    	canceled = true;
+    	
+    	worker.interrupt();
+    	
+    	setChanged();
+        notifyObservers(new Pair<Message,Object>(Message.STOPPING,null));
+    }
 }
 
 



From krater at mail.berlios.de  Mon Jul 31 10:42:37 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 10:42:37 +0200
Subject: [Plantlore-dev] r473 - trunk/src/net/sf/plantlore/common
Message-ID: <200607310842.k6V8gbpG026735@sheep.berlios.de>

Author: krater
Date: 2006-07-31 10:42:37 +0200 (Mon, 31 Jul 2006)
New Revision: 473

Modified:
   trunk/src/net/sf/plantlore/common/ProgressBar.form
   trunk/src/net/sf/plantlore/common/ProgressBar.java
Log:
ProgressBar slightly modified to make it easier to create descendants (subclasses) = several `private` modifiers changed to `protected`.

Modified: trunk/src/net/sf/plantlore/common/ProgressBar.form
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBar.form	2006-07-31 08:38:27 UTC (rev 472)
+++ trunk/src/net/sf/plantlore/common/ProgressBar.form	2006-07-31 08:42:37 UTC (rev 473)
@@ -77,6 +77,9 @@
               <Color blue="0" green="ff" id="green" palette="1" red="0" type="palette"/>
             </Property>
           </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
         </Component>
         <Component class="javax.swing.JTextField" name="statusField">
           <Properties>
@@ -94,6 +97,9 @@
           <Events>
             <EventHandler event="actionPerformed" listener="java.awt.event.ActionListener" parameters="java.awt.event.ActionEvent" handler="statusFieldActionPerformed"/>
           </Events>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
         </Component>
       </SubComponents>
     </Container>

Modified: trunk/src/net/sf/plantlore/common/ProgressBar.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBar.java	2006-07-31 08:38:27 UTC (rev 472)
+++ trunk/src/net/sf/plantlore/common/ProgressBar.java	2006-07-31 08:42:37 UTC (rev 473)
@@ -29,11 +29,11 @@
  * @author  fraktalek
  */
 public abstract class ProgressBar extends javax.swing.JDialog implements Observer {
-    private Logger logger;
-    private Task task;
+    protected Logger logger;
+    protected Task task;
     private int statusFieldWidth;
     private double charSizeApprox = 180/27; //in 180 pixel wide JTextField first 27 characters are visible in Matisse
-    private Window parent;
+    protected Window parent;
     
     /** Creates a new progress bar, initially invisible. It becomes visible after it receives
      * a STARTING Message from the Task.
@@ -59,7 +59,8 @@
         initialize();        
     }    
    
-    private void initialize() {
+    
+    protected void initialize() {
         logger = Logger.getLogger(this.getClass().getPackage().getName());
         initComponents();
         
@@ -245,7 +246,7 @@
     }
     
     public void afterStopped(Object value) {
-        
+    	// Empty implementation = do nothing.        
     }
     
     public void afterStopping() {
@@ -254,8 +255,8 @@
     
     // Variables declaration - do not modify//GEN-BEGIN:variables
     private javax.swing.JPanel jPanel1;
-    private javax.swing.JProgressBar progressBar;
-    private javax.swing.JTextField statusField;
+    protected javax.swing.JProgressBar progressBar;
+    protected javax.swing.JTextField statusField;
     // End of variables declaration//GEN-END:variables
     
 }



From krater at mail.berlios.de  Mon Jul 31 10:51:39 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 10:51:39 +0200
Subject: [Plantlore-dev] r474 - trunk/src/net/sf/plantlore/common
Message-ID: <200607310851.k6V8pd55028143@sheep.berlios.de>

Author: krater
Date: 2006-07-31 10:51:38 +0200 (Mon, 31 Jul 2006)
New Revision: 474

Added:
   trunk/src/net/sf/plantlore/common/DefaultCancelAction.java
   trunk/src/net/sf/plantlore/common/DefaultProgressBar.java
   trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java
   trunk/src/net/sf/plantlore/common/ProgressBarEx.form
   trunk/src/net/sf/plantlore/common/ProgressBarEx.java
Log:
DefaultCancelAction.java contains a default implementation of the Cancel Action (closing the form). In most forms there is a cancel button. You don't have to specify this Action over and over again anymore. Just type (in the controller): view.myCancelButton.setAction( new DefaultCancelAction(view) );

The ProgressBar is an abstract class. The DefaultProgressBar is a simple subclass that announces the exception and ends the task (because the only abstract method is the exceptionHandler().

There is also another ProgressBar, ProgressBarEx (as in extended), which is a subclass of the ProgressBar and has the "Cancel" button. This is useful when the User is to be presented with a task that may be canceled (such as export or login procedure). The use is extremely simple:

Task t = new MyTask(...);
new DefaultProgressBar( t, view, true );
t.start()

or

Task t = new MyTask(...);
new DefaultProgressBarEx( t, view, true ); // with the "Cancel" button
t.start;

Added: trunk/src/net/sf/plantlore/common/DefaultCancelAction.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultCancelAction.java	2006-07-31 08:42:37 UTC (rev 473)
+++ trunk/src/net/sf/plantlore/common/DefaultCancelAction.java	2006-07-31 08:51:38 UTC (rev 474)
@@ -0,0 +1,65 @@
+package net.sf.plantlore.common;
+
+import java.awt.event.ActionEvent;
+import javax.swing.AbstractAction;
+import javax.swing.JDialog;
+import javax.swing.JFrame;
+
+import net.sf.plantlore.l10n.L10n;
+
+
+/**
+ * Most dialogs have a Cancel or a Discard button which always does the same action:
+ * closes the dialog without doing anything else. So as not to have to write this action
+ * over and over again, this DefaultCancelAction came into existence.
+ * <br/>
+ * The use is very simple (in the controller):
+ * <br/>
+ * <code>myView.myCancelButton.setAction( new DefaultCancelAction( myView ) ); </code>
+ * <br/>
+ * Both JFrames and JDialogs may be used with the DefaultCancelAction.
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-07-26
+ */
+public class DefaultCancelAction extends AbstractAction {
+	
+	protected JDialog dialog;
+	protected JFrame frame;
+	
+	
+	public DefaultCancelAction(JFrame frame, String name, String tooltip) {
+		putValue(SHORT_DESCRIPTION, tooltip);
+		putValue(NAME, name);
+		this.frame = frame;
+	}
+	
+	public DefaultCancelAction(JDialog dialog, String name, String tooltip) {
+		putValue(SHORT_DESCRIPTION, tooltip);
+		putValue(NAME, name);
+		this.dialog = dialog;
+	}
+	
+	
+	public DefaultCancelAction(JFrame frame) {
+		putValue(NAME, L10n.getString("Common.Cancel"));
+		this.frame = frame;
+	}
+	
+	
+	public DefaultCancelAction(JDialog dialog) {
+		putValue(NAME, L10n.getString("Common.Cancel"));
+		this.dialog = dialog;
+	}
+
+	
+	
+	public void actionPerformed(ActionEvent e) {
+		if(frame != null)
+			frame.setVisible(false);
+		else if(dialog != null)
+			dialog.setVisible(false);
+	}
+	
+
+}

Added: trunk/src/net/sf/plantlore/common/DefaultProgressBar.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultProgressBar.java	2006-07-31 08:42:37 UTC (rev 473)
+++ trunk/src/net/sf/plantlore/common/DefaultProgressBar.java	2006-07-31 08:51:38 UTC (rev 474)
@@ -0,0 +1,59 @@
+package net.sf.plantlore.common;
+
+import java.awt.Component;
+
+import javax.swing.JDialog;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ * A simple and convenient
+ * implementation of the abstract ProgressBar.
+ * <br/>
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-07-26
+ *
+ */
+public class DefaultProgressBar extends ProgressBar {
+	
+	private Component[] components;
+	
+	
+	public DefaultProgressBar(Task task, JFrame parent, boolean modal) {
+		super(task, parent, modal);
+	}
+	
+	public DefaultProgressBar(Task task, JDialog parent, boolean modal) {
+		super(task, parent, modal);
+	}
+	
+	
+	public DefaultProgressBar unlockComponents(Component...c) {
+		this.components = c;
+		return this;
+	}
+	
+	
+	@Override
+	public void afterStopped(Object value) {
+		super.afterStopped(value);
+		if(components != null)
+			for(Component c : components)
+				c.setEnabled(true);
+	}
+	
+	
+	@Override
+	public void exceptionHandler(Exception ex) {
+		JOptionPane.showMessageDialog( 
+				parent, 
+				ex.getMessage(), 
+				L10n.getString("Error.General"), 
+				JOptionPane.ERROR_MESSAGE );
+		getTask().stop();
+		getTask().fireStopped(null); // So that the afterStopped() method is called! (BUG OR FEATURE in Task?)
+	}
+	
+}

Added: trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java	2006-07-31 08:42:37 UTC (rev 473)
+++ trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java	2006-07-31 08:51:38 UTC (rev 474)
@@ -0,0 +1,41 @@
+package net.sf.plantlore.common;
+
+import javax.swing.JDialog;
+import javax.swing.JFrame;
+import javax.swing.JOptionPane;
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ * A simple and convenient
+ * implementation of the abstract ProgressBar.
+ * <br/>
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-07-26
+ *
+ */
+public class DefaultProgressBarEx extends ProgressBarEx {
+	
+	
+	public DefaultProgressBarEx(Task task, JFrame parent, boolean modal) {
+		super(task, parent, modal);
+	}
+	
+	public DefaultProgressBarEx(Task task, JDialog parent, boolean modal) {
+		super(task, parent, modal);
+	}
+	
+	
+	
+	@Override
+	public void exceptionHandler(Exception ex) {
+		JOptionPane.showMessageDialog( 
+				parent, 
+				ex.getMessage(), 
+				L10n.getString("Error.General"), 
+				JOptionPane.ERROR_MESSAGE );
+		getTask().stop();
+		getTask().fireStopped(null); // So that the afterStopped() method is called! (BUG OR FEATURE in Task?)
+	}
+	
+}

Added: trunk/src/net/sf/plantlore/common/ProgressBarEx.form
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBarEx.form	2006-07-31 08:42:37 UTC (rev 473)
+++ trunk/src/net/sf/plantlore/common/ProgressBarEx.form	2006-07-31 08:51:38 UTC (rev 474)
@@ -0,0 +1,111 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<Form version="1.3" type="org.netbeans.modules.form.forminfo.JDialogFormInfo">
+  <Properties>
+    <Property name="defaultCloseOperation" type="int" value="0"/>
+    <Property name="resizable" type="boolean" value="false"/>
+    <Property name="undecorated" type="boolean" value="true"/>
+  </Properties>
+  <SyntheticProperties>
+    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
+  </SyntheticProperties>
+  <AuxValues>
+    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
+    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
+  </AuxValues>
+
+  <Layout>
+    <DimensionLayout dim="0">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Component id="jPanel1" alignment="0" max="32767" attributes="0"/>
+      </Group>
+    </DimensionLayout>
+    <DimensionLayout dim="1">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Component id="jPanel1" alignment="0" max="32767" attributes="0"/>
+      </Group>
+    </DimensionLayout>
+  </Layout>
+  <SubComponents>
+    <Container class="javax.swing.JPanel" name="jPanel1">
+      <Properties>
+        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
+          <Border info="org.netbeans.modules.form.compat2.border.CompoundBorderInfo">
+            <CompundBorder>
+              <Border PropertyName="outside" info="org.netbeans.modules.form.compat2.border.SoftBevelBorderInfo">
+                <BevelBorder/>
+              </Border>
+              <Border PropertyName="inside" info="org.netbeans.modules.form.compat2.border.EtchedBorderInfo">
+                <EtchetBorder/>
+              </Border>
+            </CompundBorder>
+          </Border>
+        </Property>
+      </Properties>
+
+      <Layout>
+        <DimensionLayout dim="0">
+          <Group type="103" groupAlignment="0" attributes="0">
+              <Group type="102" attributes="0">
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Group type="103" groupAlignment="0" attributes="0">
+                      <Component id="statusField" alignment="1" pref="294" max="32767" attributes="0"/>
+                      <Component id="cancel" alignment="1" min="-2" max="-2" attributes="0"/>
+                      <Component id="progressBar" alignment="0" pref="294" max="32767" attributes="2"/>
+                  </Group>
+                  <EmptySpace max="-2" attributes="0"/>
+              </Group>
+          </Group>
+        </DimensionLayout>
+        <DimensionLayout dim="1">
+          <Group type="103" groupAlignment="0" attributes="0">
+              <Group type="102" alignment="0" attributes="0">
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Component id="progressBar" min="-2" max="-2" attributes="0"/>
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Component id="statusField" min="-2" max="-2" attributes="0"/>
+                  <EmptySpace max="-2" attributes="0"/>
+                  <Component id="cancel" min="-2" max="-2" attributes="0"/>
+                  <EmptySpace max="32767" attributes="0"/>
+              </Group>
+          </Group>
+        </DimensionLayout>
+      </Layout>
+      <SubComponents>
+        <Component class="javax.swing.JProgressBar" name="progressBar">
+          <Properties>
+            <Property name="foreground" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+              <Color blue="0" green="ff" id="green" palette="1" red="0" type="palette"/>
+            </Property>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JTextField" name="statusField">
+          <Properties>
+            <Property name="background" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+              <Color blue="ee" green="ee" id="Panel.background" palette="3" red="ee" type="palette"/>
+            </Property>
+            <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
+              <Border info="null"/>
+            </Property>
+            <Property name="disabledTextColor" type="java.awt.Color" editor="org.netbeans.beaninfo.editors.ColorEditor">
+              <Color blue="33" green="33" id="Button.foreground" palette="3" red="33" type="palette"/>
+            </Property>
+            <Property name="enabled" type="boolean" value="false"/>
+          </Properties>
+        </Component>
+        <Component class="javax.swing.JButton" name="cancel">
+          <Properties>
+            <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+              <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Common.Cancel" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+            </Property>
+          </Properties>
+          <AuxValues>
+            <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+          </AuxValues>
+        </Component>
+      </SubComponents>
+    </Container>
+  </SubComponents>
+</Form>

Added: trunk/src/net/sf/plantlore/common/ProgressBarEx.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBarEx.java	2006-07-31 08:42:37 UTC (rev 473)
+++ trunk/src/net/sf/plantlore/common/ProgressBarEx.java	2006-07-31 08:51:38 UTC (rev 474)
@@ -0,0 +1,160 @@
+/*
+ * ProgressBar.java
+ *
+ * Created on 28. kv?ten 2006, 23:31
+ */
+
+package net.sf.plantlore.common;
+
+import java.awt.Cursor;
+import java.awt.event.ActionEvent;
+import javax.swing.AbstractAction;
+
+import org.apache.log4j.Logger;
+
+import net.sf.plantlore.l10n.L10n;
+
+
+/** ProgressBar dialog that works as an observer of a given Task.
+ *
+ * The dialog sets itself visible after it receives a STARTING Message, disposes
+ * itself after getting a STOPPED Message and in the time between it updates it's
+ * state according to POSITION_CHANGED, MESSAGE_CHANGED and LENGHT_CHANGED messages.
+ *
+ * If constructed with an indeterminate Task works in indeterminate mode until it
+ * receives a LENGHT_CHANGED message from the Task. Then it switches to determinate mode.
+ *
+ * Exceptions trhown by the task are processed by the abstract exceptionHandler() method.
+ *
+ * @author  Erik Kratochv?l
+ */
+public abstract class ProgressBarEx extends ProgressBar {
+    
+    /** Creates a new progress bar, initially invisible. It becomes visible after it receives
+     * a STARTING Message from the Task.
+     *
+     * @param task the task to be monitored
+     * @param parent the parent frame of this dialog
+     * @modal whether to open in modal mode
+     *
+     */
+    public ProgressBarEx(Task task, java.awt.Frame parent, boolean modal) {
+        super(task, parent, modal);
+        
+    }
+    
+    public ProgressBarEx(Task task, javax.swing.JDialog parent, boolean modal) {
+        super(task, parent, modal);
+    }    
+ 
+    @Override
+    protected void initialize() {
+    	logger = Logger.getLogger(this.getClass().getPackage().getName());
+    	
+         initComponents();
+         
+         cancel.setAction(new CancelTaskAction());
+         
+         if (task.isDeterminate()) {
+             progressBar.setIndeterminate(false);
+             progressBar.setMinimum(0);
+             progressBar.setMaximum(task.getLength());
+         } else {
+             progressBar.setIndeterminate(true);
+         }
+
+         statusField.setBackground(javax.swing.UIManager.getDefaults().getColor("Panel.background"));
+         
+         setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
+         parent.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
+         
+         task.addObserver(this);    
+    }
+ 
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
+    private void initComponents() {
+        jPanel1 = new javax.swing.JPanel();
+        progressBar = new javax.swing.JProgressBar();
+        statusField = new javax.swing.JTextField();
+        cancel = new javax.swing.JButton();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.DO_NOTHING_ON_CLOSE);
+        setResizable(false);
+        setUndecorated(true);
+        jPanel1.setBorder(javax.swing.BorderFactory.createCompoundBorder(new javax.swing.border.SoftBevelBorder(javax.swing.border.BevelBorder.RAISED), javax.swing.BorderFactory.createEtchedBorder()));
+        progressBar.setForeground(java.awt.Color.green);
+
+        statusField.setBackground(javax.swing.UIManager.getDefaults().getColor("Panel.background"));
+        statusField.setBorder(null);
+        statusField.setDisabledTextColor(javax.swing.UIManager.getDefaults().getColor("Button.foreground"));
+        statusField.setEnabled(false);
+
+        cancel.setText(L10n.getString("Common.Cancel"));
+
+        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
+        jPanel1.setLayout(jPanel1Layout);
+        jPanel1Layout.setHorizontalGroup(
+            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, statusField, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 294, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, cancel)
+                    .add(progressBar, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 294, Short.MAX_VALUE))
+                .addContainerGap())
+        );
+        jPanel1Layout.setVerticalGroup(
+            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(progressBar, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(statusField, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(cancel)
+                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+        );
+
+        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
+        getContentPane().setLayout(layout);
+        layout.setHorizontalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+        );
+        layout.setVerticalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+        );
+        pack();
+    }// </editor-fold>//GEN-END:initComponents
+    
+
+    private class CancelTaskAction extends AbstractAction {
+    	public CancelTaskAction() {
+    		putValue(NAME, L10n.getString("Common.Cancel"));
+		}
+		public void actionPerformed(ActionEvent e) {
+			task.kill();
+		}
+    }
+    
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    protected javax.swing.JButton cancel;
+    private javax.swing.JPanel jPanel1;
+    //--------------------------------------------------------------
+    // Progress bar and Status field are updated by the
+    // super class - we must use its variables!
+    // (Otherwise they wouldn't be initialized and the
+    //  program would crash instantly.)
+    //--------------------------------------------------------------
+    //private javax.swing.JProgressBar progressBar;
+    //private javax.swing.JTextField statusField;
+    //--------------------------------------------------------------
+    // End of variables declaration//GEN-END:variables
+    
+}



From krater at mail.berlios.de  Mon Jul 31 10:54:20 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 10:54:20 +0200
Subject: [Plantlore-dev] r475 - trunk/src/net/sf/plantlore/client
Message-ID: <200607310854.k6V8sK6a028579@sheep.berlios.de>

Author: krater
Date: 2006-07-31 10:54:20 +0200 (Mon, 31 Jul 2006)
New Revision: 475

Modified:
   trunk/src/net/sf/plantlore/client/MainConfig.java
Log:
An error-prone code fixed. If there were no Users in the stored DBInfo, the program would crash later (Null-pointer Exception).

Modified: trunk/src/net/sf/plantlore/client/MainConfig.java
===================================================================
--- trunk/src/net/sf/plantlore/client/MainConfig.java	2006-07-31 08:51:38 UTC (rev 474)
+++ trunk/src/net/sf/plantlore/client/MainConfig.java	2006-07-31 08:54:20 UTC (rev 475)
@@ -17,6 +17,7 @@
 import java.util.Iterator;
 import java.util.List;
 import net.sf.plantlore.client.login.DBInfo;
+import net.sf.plantlore.client.login.Login;
 import net.sf.plantlore.server.RMIServer;
 
 import org.apache.log4j.Logger;
@@ -157,10 +158,11 @@
     		
     		// The list of stored users. 
     		List userList = n.selectNodes("user");
-    		users = new String[userList.size()];
+    		users = new String[ Login.MAX_NAMES /*userList.size()*/ ];
     		Node user = null;
-    		Iterator it2 = userList.iterator(); int i = 0;
-    		while (it2.hasNext()) {
+    		Iterator it2 = userList.iterator(); 
+    		int i = 0;
+    		while (it2.hasNext() && i < Login.MAX_NAMES) {
     			user = (Node) it2.next();
     			users[i] = user.getText();
     			i++;



From krater at mail.berlios.de  Mon Jul 31 10:59:57 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 10:59:57 +0200
Subject: [Plantlore-dev] r476 - in trunk/src/net/sf/plantlore/client/export:
	. builders component
Message-ID: <200607310859.k6V8xvnX029887@sheep.berlios.de>

Author: krater
Date: 2006-07-31 10:59:55 +0200 (Mon, 31 Jul 2006)
New Revision: 476

Added:
   trunk/src/net/sf/plantlore/client/export/ExportMng2.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
   trunk/src/net/sf/plantlore/client/export/ExportTask2.java
   trunk/src/net/sf/plantlore/client/export/Projection.java
   trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
   trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
   trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
   trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
Modified:
   trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
   trunk/src/net/sf/plantlore/client/export/Builder.java
   trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
   trunk/src/net/sf/plantlore/client/export/ExportMng.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
   trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
   trunk/src/net/sf/plantlore/client/export/ExportTask.java
   trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java
   trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
Log:
The Export uses the Task/ProgressBar classes now (which lead to a simplification of the code).

The XMLBuilder can handle files of any size now. The other builders are to be refined yet.

The class Template was renamed to Projection (because the name adheres better with the purpose of this class). And so were the XFilter renamed to FileFormat, XTree to ExtendedTree, and XNode to UserTreeNode.

Modified: trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -23,7 +23,7 @@
 	/** For an invocation of parameterless methods. */
 	protected static final Object[] NO_PARAMETERS = new Object[0];
 	
-	protected Template template;
+	protected Projection template;
 	
 	
 	/**
@@ -31,7 +31,7 @@
 	 * 
 	 * @param template The template describing which columns are selected.
 	 */
-	public AbstractBuilder(Template template) {
+	public AbstractBuilder(Projection template) {
 		setTemplate(template);
 	}
 	
@@ -41,14 +41,14 @@
 	 *  
 	 * @param template The new template. <b>Mustn't be <i>null</i></b>.
 	 */
-	public void setTemplate(Template template) {
+	public void setTemplate(Projection template) {
 		this.template = (template == null) ? null : template.clone();
 	}
 	
 	/**
 	 * @return A clone of the template this Builder currently uses.
 	 */
-	public Template getTemplate() {
+	public Projection getTemplate() {
 		return (template == null) ? null : template.clone();
 	}
 	

Modified: trunk/src/net/sf/plantlore/client/export/Builder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Builder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/Builder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -13,7 +13,6 @@
  * @author Erik Kratochv?l (discontinuum at gmail.com)
  * @since 2006-04-21
  * @version 1.0
- * @see net.sf.plantlore.client.export.DefaultDirector
  */
 public interface Builder {
 		

Modified: trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -47,6 +47,7 @@
  * @see net.sf.plantlore.client.export.Builder
  * @see net.sf.plantlore.middleware.DBLayer
  */
+ at Deprecated
 public class DefaultDirector extends Observable implements Runnable {
 	
 	private Logger logger = Logger.getLogger(getClass().getPackage().getName());

Modified: trunk/src/net/sf/plantlore/client/export/ExportMng.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -12,7 +12,7 @@
 import java.util.Set;
 
 import net.sf.plantlore.client.export.builders.*;
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.common.Selection;
 import net.sf.plantlore.common.exception.ExportException;
 import net.sf.plantlore.l10n.L10n;
@@ -38,7 +38,7 @@
  * <li><b>Selection</b> stores the list of all selected records 
  * 					(<i>restriction</i> in the database terminology).</li>
  * <li><b>SelectQuery</b> identifies the result set as well (in fact the resultId is derived from it).</li>
- * <li><b>Template</b> stores the list of all selected columns that should be 
+ * <li><b>Projection</b> stores the list of all selected columns that should be 
  * 					exported (<i>projection</i> in the database terminology).</li>
  * <li><b>File</b> stores the name of file as the user has suggested it.</li>
  * <li><b>XFilter</b> suggests the final name of the <i>file</i>
@@ -52,6 +52,7 @@
  * @see net.sf.plantlore.client.export.DefaultDirector
  * @see net.sf.plantlore.client.export.Builder
  */
+ at Deprecated
 public class ExportMng implements Observer {
 	
 	
@@ -61,21 +62,21 @@
 	/**
 	 * List of all filters the Export Manager is capable to handle.
 	 */
-	protected XFilter[] filters = new XFilter[] {
-			new XFilter(L10n.getString("Format.PlantloreNative"), false, false, ".xml", ".pln"),
-			new XFilter(L10n.getString("Format.XML"), true, true, ".xml"),
-			new XFilter(L10n.getString("Format.CSV"), true, true, ".txt", ".csv"),	
-			new XFilter(L10n.getString("Format.ABCD"), ".xml"),	
-			new XFilter(L10n.getString("Format.DC"), ".xml"),
-			new XFilter(L10n.getString("Format.StdOut"), true, false, ".out")
+	protected FileFormat[] filters = new FileFormat[] {
+			new FileFormat(L10n.getString("Format.PlantloreNative"), false, false, ".xml", ".pln"),
+			new FileFormat(L10n.getString("Format.XML"), true, true, ".xml"),
+			new FileFormat(L10n.getString("Format.CSV"), true, true, ".txt", ".csv"),	
+			new FileFormat(L10n.getString("Format.ABCD"), ".xml"),	
+			new FileFormat(L10n.getString("Format.DC"), ".xml"),
+			new FileFormat(L10n.getString("Format.StdOut"), true, false, ".out")
 	};
 	
 	
 	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
 	private DBLayer db ;
-	private Template template;
+	private Projection template;
 	private Selection selection;
-	private XFilter filter;
+	private FileFormat filter;
 	private String filename;
 	private SelectQuery query = null;
 	private boolean useProjections = false;
@@ -90,7 +91,7 @@
 	 * @param selection	The list of selected records. 
 	 * @param template	The list of selected columns. <b>Null means everything is selected.</b>
 	 */
-	public ExportMng(DBLayer dblayer, SelectQuery query, Selection selection, Template template) 
+	public ExportMng(DBLayer dblayer, SelectQuery query, Selection selection, Projection template) 
 	throws ExportException, DBLayerException, RemoteException {
 		this(dblayer, query, selection, template, null, null, false, null);
 	}
@@ -138,8 +139,8 @@
 			DBLayer dblayer, 
 			SelectQuery query, 
 			Selection selection, 
-			Template template, 
-			XFilter filter, 
+			Projection template, 
+			FileFormat filter, 
 			String filename,
 			boolean useProjections,
 			Class rootTable) 
@@ -188,7 +189,7 @@
 	 * Store a copy of the <code>template</code>. 
 	 * Null means all columns are selected.
 	 */
-	synchronized public void setTemplate(Template template) {
+	synchronized public void setTemplate(Projection template) {
 		if(template == null)
 			this.template = null;
 		else 
@@ -212,7 +213,7 @@
 	 * and to create a correct Builder (for the format this
 	 * filter represents). 
 	 */
-	synchronized public void setActiveFileFilter(XFilter filter) {
+	synchronized public void setActiveFileFilter(FileFormat filter) {
 		this.filter = filter; 
 	}
 	
@@ -234,7 +235,7 @@
 	synchronized public void setSelectQuery(SelectQuery query) { 
 		// Close the previous query!
 		if(this.query != null) try {
-			db.closeQuery(this.query); 
+			db.closeQuery(this.query);  // This must go here because of the RMI!
 		} catch (RemoteException e) {
 			// Never mind.
 		}
@@ -270,7 +271,7 @@
 		if( useProjections && rootTable == null)
 			throw new ExportException(L10n.getString("Error.InvalidRootTable"));
 		if(template == null || template.isEmpty())
-			template = new Template().setEverything();
+			template = new Projection().setEverything();
 		if(selection == null || selection.isEmpty())
 			selection = new Selection().all();
 			
@@ -311,8 +312,8 @@
 		else if(filter.getDescription().equals(L10n.getString("Format.ABCD"))) 
 			builder = new ABCDBuilder(writer);
 		else if(filter.getDescription().equals(L10n.getString("Format.XML")))                        
-			builder = new XMLBuilder(template, writer);                       
-                else if(filter.getDescription().equals(L10n.getString("Format.PlantloreNative")))                        
+			builder = new XMLBuilder2(template, writer);                       
+		else if(filter.getDescription().equals(L10n.getString("Format.PlantloreNative")))                        
 			builder = new XMLBuilder(writer);                       
 		else {
 			builder = new TrainingBuilder(template);
@@ -364,7 +365,7 @@
 	/**
 	 * @return The list of filters describing formats this Export Manager can handle.
 	 */
-	public XFilter[] getFilters() {
+	public FileFormat[] getFilters() {
 		return filters.clone();
 	}
 

Added: trunk/src/net/sf/plantlore/client/export/ExportMng2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,368 @@
+package net.sf.plantlore.client.export;
+
+import java.io.BufferedWriter;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.rmi.RemoteException;
+import java.util.HashSet;
+import java.util.Observable;
+import java.util.Observer;
+import java.util.Set;
+
+import net.sf.plantlore.client.export.builders.*;
+import net.sf.plantlore.client.export.component.FileFormat;
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.exception.ExportException;
+import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.middleware.SelectQuery;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.common.record.*;
+
+import org.apache.log4j.Logger;
+
+/**
+ * The Export Manager. This class controls the whole process of export -
+ * starting with creation of all necessary participants
+ * and ending with the final cleanup. 
+ * <br/>
+ * There are several entities involved in the export:
+ * <ul>
+ * <li><b>DBLayer</b> the database layer that will carry out the requests.
+ * 					Mustn't be null!</li>
+ * <li><b>Director</b> iterates over the <i>result set</i> 
+ * 					and <i>selected records</i> passes to the <i>builder</i>,</li>
+ * <li><b>Builder</b> writes the records to the <i>output</i>.</li>
+ * <li><b>Selection</b> stores the list of all selected records 
+ * 					(<i>restriction</i> in the database terminology).</li>
+ * <li><b>SelectQuery</b> identifies the result set as well (in fact the resultId is derived from it).</li>
+ * <li><b>Projection</b> stores the list of all selected columns that should be 
+ * 					exported (<i>projection</i> in the database terminology).</li>
+ * <li><b>File</b> stores the name of file as the user has suggested it.</li>
+ * <li><b>XFilter</b> suggests the final name of the <i>file</i>
+ * 					and is used to determine which <i>builder</i> will be used
+ * 					to produce the output.</li>
+ * </ul>
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-04-29 
+ * @version 2.0
+ * @see net.sf.plantlore.client.export.Builder
+ */
+public class ExportMng2 implements Observer {
+	
+	
+	public static final String ENCODING = "UTF-8";
+	
+	
+	/**
+	 * List of all filters the Export Manager is capable to handle.
+	 */
+	protected FileFormat[] filters = new FileFormat[] {
+			new FileFormat(L10n.getString("Format.PlantloreNative"), false, false, ".xml", ".pln"),
+			new FileFormat(L10n.getString("Format.XML"), true, true, ".xml"),
+			new FileFormat(L10n.getString("Format.CSV"), true, true, ".txt", ".csv"),	
+			new FileFormat(L10n.getString("Format.ABCD"), ".xml"),	
+			new FileFormat(L10n.getString("Format.DC"), ".xml"),
+			new FileFormat(L10n.getString("Format.StdOut"), true, false, ".out")
+	};
+	
+	
+	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
+	private DBLayer db ;
+	private Projection template;
+	private Selection selection;
+	private FileFormat filter;
+	private String filename;
+	private SelectQuery query = null;
+	private boolean useProjections = false;
+	private Class rootTable = Occurrence.class;
+	
+	
+	/**
+	 * Create a new Export Manager.
+	 * 
+	 * @param dblayer The database layer mediating the access to the database.
+	 * @param query	The query defining the result set which is to be iterated over.
+	 * @param selection	The list of selected records. 
+	 * @param template	The list of selected columns. <b>Null means everything is selected.</b>
+	 */
+	public ExportMng2(DBLayer dblayer, SelectQuery query, Selection selection, Projection template) 
+	throws ExportException, DBLayerException, RemoteException {
+		this(dblayer, query, selection, template, null, null, false, null);
+	}
+
+	
+	/**
+	 * Create a new Export manager.
+	 * <b>Mark all records AND columns as selected</b>.
+	 * <b>You will have to specify the SelectQuery</b>
+	 * before you call <code>start()</code>. 
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database.
+	 */
+	public ExportMng2(DBLayer dblayer) 
+	throws ExportException {
+		setDBLayer(dblayer);
+		setSelection(null);
+	}
+	
+	/**
+	 * Create a new Export manager and <b>mark all records AND columns as selected</b>.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database.
+	 * @param query	The query defining the result set which is to be iterated over.
+	 */
+	public ExportMng2(DBLayer dblayer, SelectQuery query) 
+	throws ExportException, DBLayerException, RemoteException {
+		this(dblayer, query, null, null, null, null, false, null);
+	}
+	
+	
+	/**
+	 * Create a new Export manager.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database. Shouldn't be empty.
+	 * @param query	The query defining the result set which is to be iterated over. Shouldn't be empty.
+	 * @param selection	The list of selected records. Shouldn't be empty.
+	 * @param template	The list of selected columns. <b>Null means everything is selected.</b>
+	 * @param filter	The filter which will be used to determine the appropriate builder of the output.
+	 * @param file	The name of the file where the output will be written.
+	 * @param useProjections	Should projections be used.
+	 * @param rootTable	The root table (only if projections are used).
+	 */
+	public ExportMng2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Selection selection, 
+			Projection template, 
+			FileFormat filter, 
+			String filename,
+			boolean useProjections,
+			Class rootTable) 
+	throws ExportException, DBLayerException, RemoteException  {
+		useProjections( useProjections );
+		setRootTable( rootTable );
+		setDBLayer(dblayer);
+		setSelectQuery(query);
+		setSelection(selection);
+		setTemplate(template);
+		setSelectedFile(filename);
+		setActiveFileFilter(filter);
+	}
+	
+	
+	/**
+	 * @param useProjections	True if the Export manager shall use projections instead of regular records.
+	 */
+	synchronized public void useProjections(boolean useProjections) {
+		this.useProjections = useProjections;
+	}
+	
+	/**
+	 * If projections are used, the root table must be specified explicitely.
+	 * The default root table is the Occurrence table.
+	 * 
+	 * @param rootTable	The root table (the table the query started with). 
+	 */
+	synchronized public void setRootTable(Class rootTable) {
+		this.rootTable = rootTable;
+	}
+	
+	/**
+	 * Set a new DBLayer.
+	 */
+	synchronized public void setDBLayer(DBLayer dblayer) {
+		if(query != null) try {
+			db.closeQuery(query);
+		} catch(RemoteException e) {
+			// Never mind.
+		}
+		db = dblayer;
+	}
+	
+	/**
+	 * Store a copy of the <code>template</code>. 
+	 * Null means all columns are selected.
+	 */
+	synchronized public void setTemplate(Projection template) {
+		if(template == null)
+			this.template = null;
+		else 
+			this.template = template.clone();
+	}
+	
+	/**
+	 * Store a copy of the <code>selection</code>.
+	 * Null means all rows are selected.
+	 */
+	synchronized public void setSelection(Selection selection) {
+		if(selection == null)
+			this.selection = null;
+		else 
+			this.selection = selection.clone();
+	}
+	
+	/**
+	 * Set the active filter. The type of the filter will be used 
+	 * to determine the appropriate extension of the file
+	 * and to create a correct Builder (for the format this
+	 * filter represents). 
+	 */
+	synchronized public void setActiveFileFilter(FileFormat filter) {
+		this.filter = filter; 
+	}
+	
+	/**
+	 * Set the selected file. Into this file the builder will 
+	 * spit its output. 
+	 */
+	synchronized public void setSelectedFile(String filename) { 
+		this.filename = filename; 
+	}
+	
+	
+	/**
+	 * Set a particular select query. The manager will execute this select query
+	 * and update the <code>resultId</code> if Projections are not used.
+	 * On the other hand, if Projections are used, it is the <code>setTemplate()</code>
+	 * that executes the query after it adds desired projections.
+	 */
+	synchronized public void setSelectQuery(SelectQuery query) { 
+		// Close the previous query!
+		if(this.query != null) try {
+			db.closeQuery(this.query);  // This must go here because of the RMI!
+		} catch (RemoteException e) {
+			// Never mind.
+		}
+		this.query = query;
+	}
+	
+	
+	
+	
+	
+	private Set<ExportTask2> exportTasks = new HashSet<ExportTask2>(8);
+	
+	
+	/**
+	 * Start the export procedure. The export will run in its own thread.
+	 * 
+	 * @throws ExportException	If information provided is not complete.
+	 * @throws IOException	If anything with the file goes wrong (insufficient disk space, insufficient permissions).
+	 */
+	synchronized public ExportTask2 createExportTask() 
+	throws ExportException, IOException, DBLayerException {
+		if( exportTasks.size() > 4 )
+			throw new ExportException(L10n.getString("Error.TooManyTasks"));
+		// Check if all necessary components are valid.
+		if( db == null )
+			throw new ExportException(L10n.getString("Error.InvalidDBLayer"));
+		if( query == null)
+			throw new ExportException(L10n.getString("Error.InvalidQuery"));
+		if( filter == null ) 
+			throw new ExportException(L10n.getString("Error.InvalidFilter"));
+		if( filename == null || filename.length() == 0 ) 
+			throw new ExportException(L10n.getString("Error.MissingFileName"));
+		if( useProjections && rootTable == null)
+			throw new ExportException(L10n.getString("Error.InvalidRootTable"));
+		if(template == null || template.isEmpty())
+			template = new Projection().setEverything();
+		if(selection == null || selection.isEmpty())
+			selection = new Selection().all();
+			
+		
+		logger.debug("Initializing the export environment.");
+		
+		// Prepare the query for projections.
+		if(useProjections) {
+			if( rootTable == AuthorOccurrence.class || rootTable == Author.class )
+				template.addProjections( query, AuthorOccurrence.class, Author.class );
+			else
+				template.addProjections( query, 
+					Occurrence.class, Plant.class, Metadata.class, Publication.class, 
+					Habitat.class, Territory.class, Village.class, Phytochorion.class );
+		}
+		
+		// Create a new file and writer (wrapper).
+		Writer writer = new BufferedWriter(
+					new OutputStreamWriter(new FileOutputStream(filter.suggestName(filename)),
+					ENCODING));
+		if(writer == null) {
+			logger.fatal("Unable to create a new Writer.");
+			throw new ExportException(L10n.getString("Error.WriterNotCreated"));
+		}
+		
+		logger.debug("Filename: "+ filename);
+		
+		// Create a new builder according to the selected format. 
+		Builder builder;
+		if(filter.getDescription().equals(L10n.getString("Format.CSV")))
+			builder = new CSVBuilder(writer, template);
+		else if(filter.getDescription().equals(L10n.getString("Format.DC")))                        
+			builder = new DarwinCoreBuilder(writer);
+		else if(filter.getDescription().equals(L10n.getString("Format.ABCD"))) 
+			builder = new ABCDBuilder(writer);
+		else if(filter.getDescription().equals(L10n.getString("Format.XML")))                        
+			builder = new XMLBuilder2(template, writer);                       
+		else if(filter.getDescription().equals(L10n.getString("Format.PlantloreNative")))                        
+			builder = new XMLBuilder2(writer);                       
+		else {
+			builder = new TrainingBuilder(template);
+		}
+
+		
+		// Start a new task.
+		ExportTask2 t = new ExportTask2(db, query, writer, builder, selection);
+		t.ignoreDead( filter.ignoreDead() );
+		/*exportTasks.add(t);
+		t.addObserver(this);*/
+		
+		// Reset variables.
+		query = null;
+		template = null;
+		selection = null;
+		filter = null;
+		filename = null;
+		useProjections = false;
+		rootTable = Occurrence.class;
+		
+		return t;
+	}
+	
+	
+		
+	/**
+	 * Abort every running Export. 
+	 */
+	synchronized public void abortAllTasks() {
+		for(ExportTask2 task : exportTasks) {
+			task.kill();
+			task.deleteObserver(this);
+		}
+		exportTasks.clear();
+	}
+	
+	
+	synchronized public boolean isAnExportInProgress() {
+		return exportTasks.size() != 0;
+	}
+	
+	/**
+	 * @return The list of filters describing formats this Export Manager can handle.
+	 */
+	public FileFormat[] getFileFormats() {
+		return filters.clone();
+	}
+
+
+	synchronized public void update(Observable source, Object arg) {
+		if( !((ExportTask)source).isExportInProgress() ) {
+			exportTasks.remove( source );
+			source.deleteObserver(this);
+		}
+	}
+	
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,84 @@
+package net.sf.plantlore.client.export;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.filechooser.FileFilter;
+
+import net.sf.plantlore.client.AppCoreView;
+import net.sf.plantlore.client.export.component.FileFormat;
+import net.sf.plantlore.common.DefaultProgressBarEx;
+import net.sf.plantlore.l10n.L10n;
+
+public class ExportMngCtrl2 {
+	
+	
+	private ExportMng2 model;
+	private AppCoreView parentView;
+	private JFileChooser choice;
+	
+	private ExportMngViewB viewB;
+
+	
+	public ExportMngCtrl2(ExportMng2 model, AppCoreView view) {
+		this.model = model; 
+		this.parentView = view;
+		
+		viewB = new ExportMngViewB(view);
+		viewB.next.setAction( new NextAction() );
+		choice = new JFileChooser();
+		choice.setAcceptAllFileFilterUsed(false);
+		for( FileFilter filter: model.getFileFormats() )
+			choice.addChoosableFileFilter(filter);
+	}
+	
+	
+	public void setVisible(boolean visible) {
+		if(visible) {
+			// The dialog must have a parent so that it is displayed correctly after ALT+TAB is pressed.
+			int result = choice.showDialog(parentView, L10n.getString("Export.Title"));
+			if( result == JFileChooser.APPROVE_OPTION ) {
+				model.setSelectedFile( choice.getSelectedFile().getAbsolutePath() );
+				FileFormat filter = (FileFormat) choice.getFileFilter();
+				model.setActiveFileFilter( filter );
+				
+				if( filter.isColumnSelectionEnabled() )
+					viewB.setVisible(true);
+				else 
+					performExport();
+			}
+		}
+	}
+	
+	
+	private class NextAction extends AbstractAction {
+		public NextAction() {
+			putValue(NAME, L10n.getString("Export.Title"));
+		}
+		public void actionPerformed(ActionEvent arg0) {
+			Projection t = viewB.tsm.getTemplate();
+			viewB.setVisible(false);
+			model.setTemplate( t ); // Set the new template.
+			viewB.tsm.clearSelection();
+			
+			performExport();
+		}
+	}
+
+	
+	private void performExport() {
+		try {
+			ExportTask2 export = model.createExportTask();
+			new DefaultProgressBarEx(export, parentView, false);
+			export.start();
+		} catch(Exception e) {
+			JOptionPane.showMessageDialog(null,
+					e.getMessage(),
+					L10n.getString("Export.Failed"),
+					JOptionPane.WARNING_MESSAGE);
+		}
+	}
+
+}

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -5,9 +5,10 @@
 import javax.swing.filechooser.FileFilter;
 
 import net.sf.plantlore.client.AppCoreView;
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.l10n.L10n;
 
+ at Deprecated
 public class ExportMngCtrlA {
 	
 	
@@ -49,7 +50,7 @@
 				}
 				
 				model.setSelectedFile( choice.getSelectedFile().getAbsolutePath() );
-				XFilter filter = (XFilter) choice.getFileFilter();
+				FileFormat filter = (FileFormat) choice.getFileFilter();
 				model.setActiveFileFilter( filter );
 				
 				if( filter.isColumnSelectionEnabled() )

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 
 
 //import net.sf.plantlore.l10n.L10n;
-
+ at Deprecated
 public class ExportMngCtrlB {
 	
 	private ExportMng model;
@@ -27,7 +27,7 @@
 	
 	class Next extends AbstractAction {
 		public void actionPerformed(ActionEvent arg0) {
-			Template t = view.tsm.getTemplate();
+			Projection t = view.tsm.getTemplate();
 			view.setVisible(false);
 			
 			

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 import java.awt.Frame;
 
 import net.sf.plantlore.client.export.component.TemplateSelectionModel;
-import net.sf.plantlore.client.export.component.XTree;
+import net.sf.plantlore.client.export.component.ExtendedTree;
 import net.sf.plantlore.l10n.L10n;
 
 /**
@@ -24,7 +24,7 @@
     public ExportMngViewB(Frame parent) {
     	super(parent, true);
     	
-    	tsm = new TemplateSelectionModel();
+    	tsm = new TemplateSelectionModel( new Projection() );
     	
         initComponents();
         getRootPane().setDefaultButton(next);
@@ -39,7 +39,7 @@
     // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
     private void initComponents() {
         jScrollPane1 = new javax.swing.JScrollPane();
-        tree = new XTree();
+        tree = new ExtendedTree();
         next = new javax.swing.JButton();
 
         setTitle(L10n.getString("Export.SelectColumns"));

Modified: trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,6 +9,7 @@
 
 //import net.sf.plantlore.l10n.L10n;
 
+ at Deprecated
 public class ExportProgressCtrl {
 	
 	private ExportTask model;

Modified: trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -16,6 +16,7 @@
  *
  * @author  Erik Kratochv?l
  */
+ at Deprecated
 public class ExportProgressView extends javax.swing.JFrame implements Observer {
 	
 	private ExportTask model;

Modified: trunk/src/net/sf/plantlore/client/export/ExportTask.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportTask.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportTask.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
 
-
+ at Deprecated
 public class ExportTask extends Observable implements Observer {
 	
 	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());

Added: trunk/src/net/sf/plantlore/client/export/ExportTask2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,215 @@
+package net.sf.plantlore.client.export;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.rmi.RemoteException;
+import java.util.List;
+
+import org.apache.log4j.Logger;
+
+import net.sf.plantlore.common.Pair;
+import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.Task;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.common.exception.ExportException;
+import net.sf.plantlore.common.record.AuthorOccurrence;
+import net.sf.plantlore.common.record.Occurrence;
+import net.sf.plantlore.common.record.Record;
+import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.middleware.SelectQuery;
+
+public class ExportTask2 extends Task {
+	
+private Logger logger = Logger.getLogger(getClass().getPackage().getName());
+	
+	private Builder build;
+	private Selection selection;
+	private DBLayer database;
+	private Integer resultId;
+	private boolean ignoreDead = true;
+	private boolean useProjections = false;
+	private List<Pair<Class, String>> description;
+	private SelectQuery query;
+	private Writer writer;
+	private Record torso;
+	
+	
+	
+	public ExportTask2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Writer writer, 
+			Builder builder, 
+			Selection selection) {
+		
+		this.database = dblayer;
+		this.query = query;
+		this.writer = writer;
+		this.selection = selection;
+		this.build = builder;
+	}
+	
+	// Pro pouziti s projekcema
+	public ExportTask2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Writer writer, 
+			Builder builder, 
+			Selection selection,
+			List<Pair<Class, String>> description, 
+			Class rootTable) 
+	throws ExportException {
+		
+		this(dblayer, query, writer, builder, selection);
+		this.useProjections = true;
+		this.description = description;
+		try { 
+			torso = (Record)rootTable.newInstance();
+			torso.createTorso();
+		} catch (Exception e) {
+			throw new ExportException(L10n.getString("Error.InternalError"));
+		}
+	}
+	
+	public ExportTask2 ignoreDead(boolean ignore) {
+		this.ignoreDead = ignore;
+		return this;
+	}
+
+	@Override
+	public Object task() throws Exception {
+		try {
+			logger.info("Export begins...");
+			setStatusMessage(L10n.getString("Export.Initializing"));
+			
+			resultId = database.executeQuery( query );
+			
+			build.header();
+			
+			// Iterate over the result of the query.
+			int rows = database.getNumRows( resultId ),
+			expectedNumberOfRecords = selection.size( rows ),
+			count = 0;
+			
+			if(expectedNumberOfRecords > 0)
+				setLength(expectedNumberOfRecords);
+			
+			for(int i = 0; i < rows && !isCanceled() && count < expectedNumberOfRecords; i++) {
+				
+				logger.debug("Fetching a new record from the database.");
+				
+				Record record;
+				if(useProjections) 
+					record = reconstruct( (Object[])database.more( resultId, i, i )[0] );
+				else
+					record = (Record)((Object[])database.more( resultId, i, i )[0])[0];
+				
+				
+				logger.debug("New record No. "+i+" fetched: "+record);
+				if( !selection.contains( record ) || (ignoreDead && record.isDead()) ) 
+					continue; // Is the record selected?
+				
+				logger.debug("The record is in the selection. It will be exported.");
+				count++;
+				setStatusMessage(count + " " + L10n.getString("Export.RecordsExported"));
+				setLength(count);
+				
+				build.startRecord();
+				
+				// Build this part of the record.
+				build.part( record );
+				
+				/* -----------------------------------------------------------
+				 * Deal with the one-to-many relationship
+				 * of Occurence -> AuthorOccurence ~ Author
+				 * ----------------------------------------------------------- */
+				if( record instanceof Occurrence ) 
+					loadAssociatedAuthors( (Occurrence)record );
+				
+				build.finishRecord();
+				
+			}
+
+			build.footer();
+			logger.info("Export completed. " + count + " records sent to output. ");
+			cleanup();
+		}
+		catch(Exception e) {
+			logger.error("Export ended prematurely: "+e.getMessage());
+			cleanup();
+			throw e;
+		}
+		
+		return null;
+	}
+	
+	
+	
+	private void cleanup() {
+		try {
+			writer.close();
+		} catch(Exception e) { /* Never mind. */ }
+		try {
+			database.closeQuery( query );
+		} catch(Exception e) {/* Never mind. */}
+	}
+	
+	
+	
+	/**
+	 * Find all AuthorOccurrences associated with the <code>Occurrence</code>
+	 * and send them to the Builder, too.
+	 * 
+	 * @param occurrence	The currently processed occurrence data.
+	 */
+	private void loadAssociatedAuthors(Occurrence occurrence) 
+	throws RemoteException, IOException, DBLayerException {
+		
+		logger.debug("Processing the associated information about Authors.");
+		
+		SelectQuery query = database.createQuery(AuthorOccurrence.class);
+		query.createAlias(AuthorOccurrence.OCCURRENCE, "OCC");
+
+		// AuthorOccurrence.OCCURRENCE = Occurrence.ID  &&  Occurrence.ID = occ.getId()
+		query.addRestriction(PlantloreConstants.RESTR_EQ_PROPERTY, AuthorOccurrence.OCCURRENCE, "OCC."+Occurrence.ID, null, null);
+		query.addRestriction(PlantloreConstants.RESTR_EQ, "OCC."+Occurrence.ID, null, occurrence.getId(), null);
+		int resultId = database.executeQuery( query );
+		
+		// Take all results and spit'em out.
+		int rows = database.getNumRows( resultId );
+		for(int i = 0; i < rows; i++) {
+			logger.debug("Fetching associated data (Author, AuthorOccurrence).");
+			
+			Object[] pulp = database.more( resultId, i, i );
+			AuthorOccurrence ao = (AuthorOccurrence) ((Object[])pulp[0])[0];
+			ao.setOccurrence( null ); // cut off the way back to the occurrence
+			if(ao.isDead() && ignoreDead) continue;
+			
+			logger.debug("New author-occurence record: " + ao);
+			
+			build.part( ao );
+		}
+		database.closeQuery( query );
+		
+		logger.debug("Author-occurence processed.");
+	}
+	
+	
+	
+	/**
+	 * Reconstruct the record from the given values. 
+	 * 
+	 * @param values	Values of columns (in the same order as in the Description).
+	 * @return	The reconstructed record.
+	 */
+	private Record reconstruct(Object[] values) {
+		for(int i = 0; i < description.size(); i++ ) {
+			Pair<Class, String> d = description.get(i);
+			torso.setValue(d.getFirst(), d.getSecond(), values[i]);
+		}
+		return torso;
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/Projection.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Projection.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/Projection.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,172 @@
+package net.sf.plantlore.client.export;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import net.sf.plantlore.common.Pair;
+import net.sf.plantlore.common.record.*;
+import net.sf.plantlore.middleware.SelectQuery;
+import static net.sf.plantlore.common.PlantloreConstants.PROJ_PROPERTY;
+
+
+/**
+ * The template holds information about the selected columns and tables.
+ * This information may used by builders and access rights managers
+ * to decide, whether or not the currently
+ * considered column should be exported / is accessible.
+ * <br/>
+ * Note: The template doesn't know anything about the structure
+ * (mapping) of the database.  
+ * <br/>
+ * A little dictionary:
+ * <ul>
+ * <li><i>foreign key</i> a column of a table that refers to another table,</li>
+ * <li><i>property</i> a column of a table that contains a (possibly null) value,
+ * but doesn't refer to another table</li>
+ * <li><i>nn</i> a property that cannot be null (defined in the db model)</li>
+ * </ul>
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-04-22
+ * @version 1.1
+ */
+public class Projection {
+	
+	/** The list of all pairs Table.Column that are set. */
+	private Collection<String> columns = new HashSet<String>(100);
+	
+	
+
+	
+	/** Create a new template. */
+	public Projection() {/* Nothing to be done. Just to have a default constructor. */}
+	
+	/** A copy constructor. */
+	public Projection(Projection template) {
+		columns = new HashSet<String>( template.columns );
+	}
+	
+	
+	@Override
+	public Projection clone() {
+		return new Projection(this);
+	}
+	
+	
+	/** Select the <code>table.column</code>. */
+	public Projection set(Class table, String column) { 
+		System.out.println("+ "+table.getSimpleName()+"."+column);
+		columns.add(table.getSimpleName()+ (column == null ? "" : "."+column));
+		return this;
+	}
+	
+	/** Unselect the <code>table.column</code>. */
+	public Projection unset(Class table, String column) { 
+		System.out.println("- "+table.getSimpleName()+"."+column);
+		columns.remove(table.getSimpleName()+ (column == null ? "" : "."+column));
+		return this;
+	}
+	
+	/** @return true if the <code>table.column</code> is set.*/
+	public boolean isSet(Class table, String column) {
+		return columns.contains(table.getSimpleName()+ (column == null ? "" : "."+column));
+	}
+	
+	/** Unselect all columns of all tables. */
+	public Projection unsetEverything() { 
+		columns.clear();
+		return this;
+	}
+	
+	/** Select all columns (properties) of all tables. */
+	public Projection setEverything() {
+		for(Class table : Record.BASIC_TABLES)
+			setAllProperties(table);
+		return this;
+	}
+	
+	/** Select all not null columns (properties). */
+	public void setEverythingNN() {
+		// Implementation missing!
+	}
+	
+	/** Select all properties of this <code>table</code>. */
+	public Projection setAllProperties(Class table) {
+		try {
+			for( String column : ((Record)table.newInstance()).getProperties() )
+				set(table, column);
+		} catch(Exception e) {/* Not good :/. */}
+		return this;
+	}
+	
+	/** Select all not-null properties of the specified <code>table</code>. */
+	public Projection setAllNN(Class table) {
+		try {
+			Record record = ((Record)table.newInstance());
+			List<String> nnProperties = record.getNN();
+			nnProperties.removeAll(record.getForeignKeys());
+			for( String column :  nnProperties )
+				set(table, column);
+		} catch(Exception e) {/* Not good. */}
+		return this;
+	}
+	
+	/**
+	 * @return true if nothing is selected.
+	 */
+	public boolean isEmpty() {
+		return columns.isEmpty();
+	}
+	
+		
+	/**
+	 * Match this template against another one.
+	 * 
+	 * @param t	The template against which the matching will be done.
+	 * @return	True if this template is a superset of the other template.
+	 */ 
+	public boolean match(Projection t) { 
+		return columns.containsAll(t.columns); 
+	}
+	
+	
+	private List<Pair<Class, String>> plan;
+	
+	public List<Pair<Class, String>> getDescription() {
+		return plan;
+	}
+	
+	/**
+	 * Add projections to the query according to the selected columns.
+	 * 
+	 * @param q	The query to be modified.
+	 * @param tables	The important tables. The first table is considered the root table.
+	 * @return The column description.
+	 */
+	public List<Pair<Class, String>> addProjections(SelectQuery q, Class...tables) {
+		plan = new ArrayList<Pair<Class,String>>(20);
+		for(int i = 0; i < tables.length; i++)
+			addProjections(q, tables[i], i == 0);
+		return plan;
+	}
+	
+	
+	private void addProjections(SelectQuery q, Class table, boolean omitAlias) {
+		try {
+			Record r = (Record)table.newInstance();
+			for(String property : r.getProperties())
+				if( isSet(table, property) ) {
+					q.addProjection(PROJ_PROPERTY, (omitAlias ? property : Record.alias(table)+"."+property));
+					plan.add(new Pair<Class, String>(table, property));
+				}
+		} catch(Exception e) {/* Not good. */}
+	}
+	
+	@Override
+	public String toString() {
+		return columns.toString();
+	}
+	
+}

Modified: trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,7 +4,7 @@
 import java.io.Writer;
 import net.sf.plantlore.client.export.AbstractBuilder;
 import net.sf.plantlore.client.export.Builder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Metadata;
 import net.sf.plantlore.common.record.Occurrence;

Modified: trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -7,7 +7,7 @@
 import net.sf.plantlore.client.export.AbstractBuilder;
 import net.sf.plantlore.client.export.Builder;
 import net.sf.plantlore.common.record.*;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 
 /**
@@ -22,7 +22,7 @@
 public class CSVBuilder implements Builder {
 	
 	private Writer stream;
-	private Template template;
+	private Projection template;
 	
 	/** Is this the first column on this line? */
 	private boolean firstColumnOnThisLine;
@@ -52,7 +52,7 @@
 	 * @param output	The writer where the output will be sent.
 	 * @param tmp	The template that describes the selected columns and tables.
 	 */
-	public CSVBuilder(Writer output, Template tmp) {
+	public CSVBuilder(Writer output, Projection tmp) {
 		this.stream = output;
 		this.template = tmp;
 	}

Modified: trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -3,7 +3,7 @@
 import java.io.IOException;
 
 import net.sf.plantlore.client.export.AbstractBuilder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 /**
  * A training extension of the AbstractBuilder.
@@ -27,7 +27,7 @@
 	
 	private int i = 0;
 	
-	public TrainingBuilder(Template template) {
+	public TrainingBuilder(Projection template) {
 		super(template);
 	}
  

Modified: trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,7 +4,7 @@
 import java.io.Writer;
 
 import net.sf.plantlore.client.export.AbstractBuilder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 import net.sf.plantlore.common.record.*;
 import org.dom4j.Document;
 import org.dom4j.DocumentHelper;
@@ -36,9 +36,9 @@
      * 
      * @param template	Description of important attributes of  the whole record. 
      * @param writer	The writer that will create the file.
-     * @see net.sf.plantlore.client.export.Template
+     * @see net.sf.plantlore.client.export.Projection
      */
-    public XMLBuilder(Template template, Writer writer) {
+    public XMLBuilder(Projection template, Writer writer) {
     	super(template);
         document = DocumentHelper.createDocument();
         document.addElement("occurrences");
@@ -55,10 +55,10 @@
      * Every attribute (column) of the whole record will be exported.
      * 
      * @param writer	The writer that will create the file.
-     * @see net.sf.plantlore.client.export.Template
+     * @see net.sf.plantlore.client.export.Projection
      */
     public XMLBuilder(Writer writer) {
-    	this(new Template().setEverything(), writer);
+    	this(new Projection().setEverything(), writer);
     }
     
     /**

Added: trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,158 @@
+package net.sf.plantlore.client.export.builders;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.dom4j.DocumentHelper;
+import org.dom4j.Element;
+import org.dom4j.io.OutputFormat;
+import org.dom4j.io.XMLWriter;
+
+import net.sf.plantlore.client.export.Builder;
+import net.sf.plantlore.client.export.Projection;
+import net.sf.plantlore.common.record.*;
+
+/**
+ * An improved version of the previous XMLBuilder. 
+ * This XMLBuilder is capable of creating files of virtually any size.
+ * The builder uses the Dom4j to create just one Occurrence element
+ * at a time; that element is written down when another Occurrence
+ * record arrives to be processed. 
+ * <br/>
+ * This way, the creation of an element is handled by the Dom4j 
+ * (all those necessary conversions 
+ * of <code>&gt;</code> to <code>&amp;gt;</code> etc.)
+ * <br/>
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-07-21
+ *
+ */
+public class XMLBuilder2 implements Builder {
+	
+    private Writer outputWriter;
+    private XMLWriter xmlWriter;
+    private Element element;
+    protected Projection template;
+    
+    /**
+     * Create a new XML Builder.
+     * The builder receives records (holder objects from the database)
+     * decomposes them, creates an XML node, and stores it in the specified
+     * file.
+     * <br/>
+     * The template holds the set of important attributes (columns) of the record
+     * that will be exported.
+     * 
+     * @param template	Description of important attributes of  the whole record. 
+     * @param writer	The writer that will create the file.
+     * @see net.sf.plantlore.client.export.Projection
+     */
+    public XMLBuilder2(Projection template, Writer writer) {
+        this.outputWriter = writer;
+        this.template = template;
+    }
+    
+    /**
+     * Create a new XML Builder.
+     * The builder receives records (holder objects from the database)
+     * decomposes them, creates an XML node, and stores it in the specified
+     * file.
+     * <br/>
+     * Every attribute (column) of the whole record will be exported.
+     * 
+     * @param writer	The writer that will create the file.
+     * @see net.sf.plantlore.client.export.Projection
+     */
+    public XMLBuilder2(Writer writer) {
+    	this(new Projection().setEverything(), writer);
+    }
+    
+       
+    /**
+     * Generate the header of this format.
+     */
+    public void header() 
+    throws IOException {
+    	outputWriter.write("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
+    	outputWriter.write("\n<occurrences>\n");
+    	
+    	OutputFormat format = OutputFormat.createPrettyPrint();
+        xmlWriter = new XMLWriter( outputWriter, format );
+    }
+    
+    /**
+     * Generate the footer of this format.
+     */
+    public void footer() 
+    throws IOException {
+    	outputWriter.write("</occurrences>\n");
+        xmlWriter.close();
+    }
+    
+    /**
+     * Begin a new record.
+     */
+    public void startRecord() 
+    throws IOException {
+    	element = null;
+    }
+    
+    /**
+     * Finish processing of the record.
+     */
+    public void finishRecord() 
+    throws IOException {
+    	xmlWriter.write( element );
+    }
+    
+
+    /**
+     * Build part of the whole record.
+     */
+    public void part(Record record) 
+    throws IOException {
+    	decompose( element, record);
+    }
+    
+    /**
+     * Decompose the given <code>record</code> and build the XML tree appropriately.
+     *  
+     * @param father	Father element of the currently processed <code>record</code>.
+     * @param record	Part of the whole record corresponding to a certain table in the database.
+     */
+    protected boolean decompose(Element father, Record record) 
+    throws IOException {
+    	if(record == null) 
+    		return false;
+    	
+    	Class table = record.getClass();
+    	
+    	Element current;
+    	if( father == null )
+    		current = element = DocumentHelper.createElement(table.getSimpleName().toLowerCase());
+    	else
+    		current = father.addElement(table.getSimpleName().toLowerCase());
+    	
+    	boolean hasAtLeastOneProperty = false;
+    	
+    	for( String property : record.getProperties() )
+    		if( template.isSet(table, property) ) {
+    			Object value = record.getValue(property);
+    			if( value != null && value.toString().length() > 0 ) {
+    				current.addElement(property.toLowerCase()).setText(value.toString());
+    				hasAtLeastOneProperty = true;
+    			}
+    		}
+    	
+    	// Decompose all subrecords of this record.
+    	for(String key : record.getForeignKeys())
+    		hasAtLeastOneProperty =  decompose( current, (Record) record.getValue(key) ) || hasAtLeastOneProperty;
+    	
+    	if( !hasAtLeastOneProperty )
+    		current.detach();
+    	
+    	return hasAtLeastOneProperty;
+    }
+
+}

Added: trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,435 @@
+package net.sf.plantlore.client.export.component;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.event.KeyListener;
+import java.util.LinkedList;
+
+
+import javax.swing.JLabel;
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeExpansionListener;
+import javax.swing.tree.*;
+
+import net.sf.plantlore.common.record.*;
+
+/**
+ * The extension of a JTree that allows the User to see the database model
+ * in a compact form. The tree expects the database hierarchy when it's created.
+ * Two default hierarchies are already present - the <code>DefaultHierarchy</code>
+ * which is loaded when no other hierarchy is specified and displays the database
+ * model in the hierarchy, 
+ * and the <code>SimpleHierarchy</code> which is a simplified version with
+ * all tables as sub-root nodes.
+ * Both hierarchies are hard-wired and must be updated if the database
+ * model changes!
+ * <br/>
+ * The selected nodes are visualized to the User in another colour.
+ * Collapsing a node <b>will cause</b> deselection of all of its selected
+ * sub-nodes. This is a feature that will prevent the User from selecting
+ * a group of columns and forgeting about them. 
+ * <br/>
+ * The XTree uses instances of XNode class - that is, the label of the
+ * node is derived from the XNode.toString(). Should you have a desire
+ * to implement the L10N, modify that method appropriatelly.
+ * <br/>
+ * The XTree cannot produce a Projection - in order to create and update 
+ * the Projection "automatically" create your own TreeSelectionModel
+ * that is capable of such an action. 
+ * <pre>
+ * XTree tree = new XTree( );
+ * tree.setSelectionModel( new YSelectionModel() );
+ * </pre>
+ * where
+ * <pre>
+ * class TemplateSelectionModel extends DefaultTreeSelectionModel {
+ * 		private Projection template;
+ * 
+ *		// Use this to achieve compatibility with the default XTree selection model.
+ *		@Override 
+ *		public void setSelectionPath(TreePath path) {
+ *			if( isPathSelected(path) )
+ *				removeSelectionPath(path);
+ *			else
+ *				addSelectionPath(path);
+ *		}
+ *		@Override 
+ *		public void removeSelectionPaths(TreePath[] paths) {
+ *			for(TreePath path : paths) {
+ *				XNode x  = (XNode) 
+ *					((DefaultMutableTreeNode)path.getLastPathComponent())
+ *					.getUserObject();
+ *				template.unset(x.table, x.column);    // update the Projection 
+ *			} 
+ *			super.removeSelectionPaths( paths ); 
+ *		}
+ *		@Override 
+ *		public void addSelectionPaths(TreePath[] paths) {
+ *			// ...similar...
+ *		}
+ * }
+ * </pre>
+ *   
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-04-29
+ * @version 1.0
+ * @see net.sf.plantlore.client.export.Projection
+ * @see net.sf.plantlore.client.export.ExportMng.XSelectionModel
+ */
+public class ExtendedTree extends javax.swing.JTree {
+	
+	private static Color NotNullColor = new Color(220, 50, 20);
+	private static Color SelectedColor = new Color(20, 150, 20);
+	private static Color DefaultColor = Color.BLACK;
+	
+	
+	/**
+	 * The Default Hierarchy Model of the Database Model.
+	 */
+	public static Object[] DefaultHierarchy = {
+		new UserTreeNode(ExtendedTree.class, "Plantlore"),
+		new Object[] { // OCCURENCE
+			new UserTreeNode(Occurrence.class, null),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new Object[] { // HABITAT
+				new UserTreeNode(Habitat.class, null),
+				new Object[] { // TERRITORY
+					new UserTreeNode(Territory.class, null),
+					new UserTreeNode(Territory.class, Territory.NAME, true)
+				},
+				new Object[] { // PHYTOCHORION
+					new UserTreeNode(Phytochorion.class, null),
+					new UserTreeNode(Phytochorion.class, Phytochorion.CODE, true),
+					new UserTreeNode(Phytochorion.class, Phytochorion.NAME, true),
+				},
+				new UserTreeNode(Habitat.class, Habitat.QUADRANT),
+				new UserTreeNode(Habitat.class, Habitat.DESCRIPTION),
+				new Object[] { // NEAREST VILLAGE
+					new UserTreeNode(Village.class, null),
+					new UserTreeNode(Village.class, Village.NAME, true)
+				},
+				new UserTreeNode(Habitat.class, Habitat.COUNTRY),
+				new UserTreeNode(Habitat.class, Habitat.ALTITUDE),
+				new UserTreeNode(Habitat.class, Habitat.LATITUDE),
+				new UserTreeNode(Habitat.class, Habitat.LONGITUDE),
+				new UserTreeNode(Habitat.class, Habitat.NOTE),
+			},
+			new Object[] { // PLANT
+				new UserTreeNode(Plant.class, null),
+				new UserTreeNode(Plant.class, Plant.SURVEYTAXID, true),
+				new UserTreeNode(Plant.class, Plant.TAXON, true),
+				new UserTreeNode(Plant.class, Plant.GENUS),
+				new UserTreeNode(Plant.class, Plant.SPECIES),
+				new UserTreeNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
+				new UserTreeNode(Plant.class, Plant.CZECHNAME),
+				new UserTreeNode(Plant.class, Plant.SYNONYMS),
+				new UserTreeNode(Plant.class, Plant.NOTE)
+			},
+			new UserTreeNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new UserTreeNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DATASOURCE),
+			new Object[] { // PUBLICATION
+				new UserTreeNode(Publication.class, null),
+				new UserTreeNode(Publication.class, Publication.COLLECTIONNAME),
+				new UserTreeNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+				new UserTreeNode(Publication.class, Publication.JOURNALNAME),
+				new UserTreeNode(Publication.class, Publication.JOURNALAUTHORNAME),
+				new UserTreeNode(Publication.class, Publication.REFERENCECITATION, true),
+				new UserTreeNode(Publication.class, Publication.REFERENCEDETAIL),
+				new UserTreeNode(Publication.class, Publication.URL),
+				new UserTreeNode(Publication.class, Publication.NOTE)
+			},
+			new UserTreeNode(Occurrence.class, Occurrence.HERBARIUM),
+			new UserTreeNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new UserTreeNode(Occurrence.class, Occurrence.NOTE),
+			new Object[] { // METADATA
+				new UserTreeNode(Metadata.class, null),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+				new UserTreeNode(Metadata.class, Metadata.DATASETTITLE, true),
+				new UserTreeNode(Metadata.class, Metadata.DATASETDETAILS),
+				new UserTreeNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+				new UserTreeNode(Metadata.class, Metadata.SOURCEID, true),
+				new UserTreeNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+				new UserTreeNode(Metadata.class, Metadata.DATECREATE, true),
+				new UserTreeNode(Metadata.class, Metadata.DATEMODIFIED, true),
+				new UserTreeNode(Metadata.class, Metadata.RECORDBASIS),
+				new UserTreeNode(Metadata.class, Metadata.BIOTOPETEXT),				
+			}
+		},
+		new Object[] { // AUTHOR
+			new UserTreeNode(Author.class, null),
+			new UserTreeNode(Author.class, Author.WHOLENAME),
+			new UserTreeNode(Author.class, Author.ORGANIZATION),
+			new UserTreeNode(Author.class, Author.PHONENUMBER),
+			new UserTreeNode(Author.class, Author.ROLE),
+			new UserTreeNode(Author.class, Author.ADDRESS),
+			new UserTreeNode(Author.class, Author.EMAIL),
+			new UserTreeNode(Author.class, Author.URL),
+			new UserTreeNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new UserTreeNode(AuthorOccurrence.class, null),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
+		}
+	};
+	
+	/**
+	 * A simplified Hierarchy Model of the Database Model. 
+	 */
+	public static Object[] SimpleHierarchy = new Object[] {
+		new UserTreeNode(ExtendedTree.class, "Plantlore DB"),
+		new Object[] { // OCCURENCE
+			new UserTreeNode(Occurrence.class, null),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new UserTreeNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new UserTreeNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DATASOURCE),
+			new UserTreeNode(Occurrence.class, Occurrence.HERBARIUM),
+			new UserTreeNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new UserTreeNode(Occurrence.class, Occurrence.NOTE)
+		},
+		new Object[] { // TERRITORY
+			new UserTreeNode(Territory.class, null),
+			new UserTreeNode(Territory.class, Territory.NAME, true)
+		},
+		new Object[] { // PHYTOCHORION
+			new UserTreeNode(Phytochorion.class, null),
+			new UserTreeNode(Phytochorion.class, Phytochorion.CODE, true),
+			new UserTreeNode(Phytochorion.class, Phytochorion.NAME, true),
+		},
+		new Object[] { // NEAREST VILLAGE
+			new UserTreeNode(Village.class, null),
+			new UserTreeNode(Village.class, Village.NAME, true)
+		},
+		new Object[] { // HABITAT
+			new UserTreeNode(Habitat.class, null),
+			new UserTreeNode(Habitat.class, Habitat.QUADRANT),
+			new UserTreeNode(Habitat.class, Habitat.DESCRIPTION),
+			new UserTreeNode(Habitat.class, Habitat.COUNTRY),
+			new UserTreeNode(Habitat.class, Habitat.ALTITUDE),
+			new UserTreeNode(Habitat.class, Habitat.LATITUDE),
+			new UserTreeNode(Habitat.class, Habitat.LONGITUDE),
+			new UserTreeNode(Habitat.class, Habitat.NOTE)
+		},
+		new Object[] { // PLANT
+			new UserTreeNode(Plant.class, null),
+			new UserTreeNode(Plant.class, Plant.SURVEYTAXID, true),
+			new UserTreeNode(Plant.class, Plant.TAXON, true),
+			new UserTreeNode(Plant.class, Plant.GENUS),
+			new UserTreeNode(Plant.class, Plant.SPECIES),
+			new UserTreeNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
+			new UserTreeNode(Plant.class, Plant.CZECHNAME),
+			new UserTreeNode(Plant.class, Plant.SYNONYMS),
+			new UserTreeNode(Plant.class, Plant.NOTE)
+		},
+		new Object[] { // PUBLICATION
+			new UserTreeNode(Publication.class, null),
+			new UserTreeNode(Publication.class, Publication.COLLECTIONNAME),
+			new UserTreeNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+			new UserTreeNode(Publication.class, Publication.JOURNALNAME),
+			new UserTreeNode(Publication.class, Publication.JOURNALAUTHORNAME),
+			new UserTreeNode(Publication.class, Publication.REFERENCECITATION, true),
+			new UserTreeNode(Publication.class, Publication.REFERENCEDETAIL),
+			new UserTreeNode(Publication.class, Publication.URL),
+			new UserTreeNode(Publication.class, Publication.NOTE)
+		},
+		new Object[] { // METADATA
+			new UserTreeNode(Metadata.class, null),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+			new UserTreeNode(Metadata.class, Metadata.DATASETTITLE, true),
+			new UserTreeNode(Metadata.class, Metadata.DATASETDETAILS),
+			new UserTreeNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+			new UserTreeNode(Metadata.class, Metadata.SOURCEID, true),
+			new UserTreeNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+			new UserTreeNode(Metadata.class, Metadata.DATECREATE, true),
+			new UserTreeNode(Metadata.class, Metadata.DATEMODIFIED, true),
+			new UserTreeNode(Metadata.class, Metadata.RECORDBASIS),
+			new UserTreeNode(Metadata.class, Metadata.BIOTOPETEXT),			
+		},
+		new Object[] { // AUTHOR
+			new UserTreeNode(Author.class, null),
+			new UserTreeNode(Author.class, Author.WHOLENAME),
+			new UserTreeNode(Author.class, Author.ORGANIZATION),
+			new UserTreeNode(Author.class, Author.PHONENUMBER),
+			new UserTreeNode(Author.class, Author.ROLE),
+			new UserTreeNode(Author.class, Author.ADDRESS),
+			new UserTreeNode(Author.class, Author.EMAIL),
+			new UserTreeNode(Author.class, Author.URL),
+			new UserTreeNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new UserTreeNode(AuthorOccurrence.class, null),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
+		}
+	};
+	
+	/**
+	 * Create a new XTree with the Default Hierarchy Model.
+	 */
+	public ExtendedTree( ) {
+		this( DefaultHierarchy );
+	}
+	
+		
+	/**
+	 * Create a new XTree with a specified Hierarchy Model.
+	 * @param hierarchy The hierarchy to be processed.
+	 */
+	public ExtendedTree( Object[] hierarchy ) {
+		super( processHierarchy(hierarchy) );
+		
+	    setCellRenderer( new XCellRenderer() );
+	    setToggleClickCount(1);
+	    setSelectionModel( new XSelectionModel() );
+	    addTreeExpansionListener( te = new XTreeExpansionListener() );
+	    
+	    for( KeyListener listener : getKeyListeners() ) 
+	    	removeKeyListener(listener);
+	}
+	
+	private XTreeExpansionListener te;
+	
+	
+	/**
+	 * Collapse all nodes.
+	 *
+	 */
+	public void collapseAll() {
+		te.collapseAll();
+	}
+			
+	
+	/**
+	 * Store all expanded nodes; capable of collapsing them all into the
+	 * original state.
+	 * 
+	 * @author Erik Kratochv?l (discontinuum at gmail.com)
+	 * @since 2006-07-30
+	 *
+	 */
+	protected class XTreeExpansionListener implements TreeExpansionListener {
+		
+		private LinkedList<TreePath> paths = new LinkedList<TreePath>();
+
+		public void treeExpanded(TreeExpansionEvent e) {
+			if( !paths.contains(e.getPath()) )
+				paths.addFirst( e.getPath() );
+		}
+
+		public void treeCollapsed(TreeExpansionEvent e) {
+			// Not important
+		}
+		
+		public void collapseAll() {
+			for( TreePath path : paths )
+				collapsePath( path );
+			
+			paths.clear();
+		}
+		
+	}
+	
+	
+	/**
+	 * A modified selection model. A single click will 
+	 * add a leaf to the current selection.
+	 * 
+	 * @author Erik Kratochv?l (discontinuum at gmail.com)
+	 * @since 2006-04-29
+	 */	
+	public class XSelectionModel extends DefaultTreeSelectionModel {
+		
+		@Override 
+		public void setSelectionPath(TreePath path) {
+			if( isPathSelected(path) )
+				removeSelectionPath(path);
+			else
+				addSelectionPath(path);
+		}
+		
+	}
+	
+	
+	/**
+	 * SPecialized Cell Renderer that shows no icons and
+	 * displayes mandatory columns with a different coulour.
+	 * 
+	 * @author Erik Kratochv?l (discontinuum at gmail.com)
+	 * @since 2006-04-29
+	 */
+	protected class XCellRenderer extends DefaultTreeCellRenderer {
+		
+		public XCellRenderer() {
+			setOpenIcon(null); 
+		    setClosedIcon(null); 
+		    setLeafIcon(null);
+		}
+		
+		@Override
+		public Component getTreeCellRendererComponent(
+				javax.swing.JTree tree, 
+				Object value, 
+				boolean selected, 
+				boolean expanded, 
+				boolean leaf, 
+				int row, 
+				boolean hasFocus) {
+			// Let the default implementation handle the drawing.
+			JLabel label =  (JLabel) 
+				super.getTreeCellRendererComponent(tree, value, false, expanded, leaf, row, false);
+			// Modify the result of the predecessor.
+			if( selected && leaf ) 
+				label.setForeground( SelectedColor );
+			else
+				if( ((UserTreeNode)((DefaultMutableTreeNode)value).getUserObject()).nn )
+					label.setForeground( NotNullColor );
+				else 
+					label.setForeground( DefaultColor );
+			return label;
+		}
+	}
+	
+	
+	
+	/**
+	 * Transform the simple Object[] hierarchy into an internal representation 
+	 * of the JTree.
+	 * @param hierarchy The hierarchy to be converted.
+	 * @return The root of the transformed hierarchy.
+	 */
+	private static DefaultMutableTreeNode processHierarchy(Object[] hierarchy) {
+		DefaultMutableTreeNode node = new DefaultMutableTreeNode(hierarchy[0]);
+		DefaultMutableTreeNode child;
+		for (int i = 1; i < hierarchy.length; i++) {
+			Object nodeSpecifier = hierarchy[i];
+			if (nodeSpecifier instanceof Object[]) // Ie node with children
+				child = processHierarchy((Object[]) nodeSpecifier);
+			else
+				child = new DefaultMutableTreeNode(nodeSpecifier); // Ie Leaf
+			node.add(child);
+		}
+		return (node);
+	}
+	
+
+}

Added: trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,121 @@
+package net.sf.plantlore.client.export.component;
+
+import java.io.File;
+import java.util.ArrayList;
+
+import javax.swing.filechooser.FileFilter;
+
+/**
+ * An implementation of a FileFilter.
+ * The XFilter stores a list of extensions
+ * that are related to a particular format.
+ * <br/>
+ * For example: 
+ * <code>Comma Separated Values (*.txt, *.csv)</code>
+ * will store <code>".txt", ".csv"</code>.
+ *  
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-04-29
+ * @version 1.0
+ */
+public class FileFormat extends FileFilter {
+	
+	private String description;
+	private ArrayList<String> extensions;
+	private boolean columnSelection = false;
+	private boolean ignoreDead = true;
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description The description of the filter.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public FileFormat(String description, String... extensions) {
+		this.description = description;
+		this.extensions = new ArrayList<String>( extensions.length );
+		for(String ext : extensions) this.extensions.add(ext);
+	}
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description	The description of the filter.
+	 * @param columnSelectionEnabled	The format allows further modifications.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public FileFormat(String description, boolean columnSelectionEnabled, boolean ignoreDead, String... extensions) {
+		this(description, extensions);
+		this.columnSelection = columnSelectionEnabled;
+		this.ignoreDead = ignoreDead;
+	}
+
+	/**
+	 * @return True if the column selection is available for this format.
+	 */
+	public boolean isColumnSelectionEnabled() {
+		return this.columnSelection;
+	}
+	
+	/**
+	 *	@return True if dead records should be omited.
+	 */
+	public boolean ignoreDead() {
+		return ignoreDead;
+	}
+
+	/**
+	 * Decide whether the file meets the requierements - has the correct extension
+	 * or it is in fact a directory.
+	 */
+	@Override
+	public boolean accept(File file) {
+		if( file != null) {
+			if(file.isDirectory()) return true;
+			String name = file.getName() ;
+			int dot = name.lastIndexOf(".");
+			if(dot < 0) return false;
+			if(extensions.contains( name.substring(dot) )) return true;
+		}
+		return false;
+	}
+
+	/**
+	 * @return The description of the format.
+	 */
+	@Override
+	public String getDescription() {
+		return description;
+	}
+	
+	/**
+	 * Decide whether the file already has a valid extension.
+	 * A valid extension is an extension that belongs to
+	 * the list of extensions of this format.
+	 * 
+	 * @param filename	The file to be tested.
+	 * @return	True if the file has a valid extension of this format.
+	 */
+	public boolean hasExtension(String filename) {
+		int dot = filename.lastIndexOf(".");
+		if(dot < 0) return false;
+		if(extensions.contains( filename.substring(dot) )) return true;
+		return false;
+	}
+	
+	/**
+	 * Suggest the name for a file based on the list of extensions.
+	 * If the file already has an extension, the name is not changed.
+	 * An extension is added, if the file has not a valid extension. 
+	 * 
+	 * @param filename	The name of the file.
+	 * @return The suggested name for this file.
+	 * @see net.sf.plantlore.client.export.component.FileFormat#hasExtension(String)
+	 */
+	public String suggestName(String filename) {
+		if(hasExtension(filename)) 
+			return filename;
+		return filename + extensions.get(0);
+	}
+	
+}
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,20 +4,26 @@
 import javax.swing.tree.DefaultTreeSelectionModel;
 import javax.swing.tree.TreePath;
 
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 /**
- * A TreeSelectionModel modified to update its Template. 
+ * A TreeSelectionModel modified to update a Projection. 
  * 
  * @author Erik Kratochv?l (discontinuum at gmail.com)
  * @since 29.4.2006
- * @see net.sf.plantlore.client.export.component.XTree
- * @see net.sf.plantlore.client.export.component.XNode
+ * @see net.sf.plantlore.client.export.component.ExtendedTree
+ * @see net.sf.plantlore.client.export.component.UserTreeNode
  */
 public class TemplateSelectionModel extends DefaultTreeSelectionModel {
 	
-	private Template xtemplate = new Template();
+	private Projection template;
 	
+	
+	
+	public TemplateSelectionModel(Projection template) {
+		this.template = template;
+	}
+	
 	/**
 	 * Setting a selection path
 	 * adds the selection path if it is not selected
@@ -32,7 +38,7 @@
 	}
 	
 	/**
-	 * Update the Template appropriately.
+	 * Update the Projection appropriately.
 	 */
 	@Override 
 	public void removeSelectionPaths(TreePath[] paths) {
@@ -40,24 +46,24 @@
 			if(path == null) continue;
 			Object node = path.getLastPathComponent();
 			if(node instanceof DefaultMutableTreeNode) {
-				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
-				xtemplate.unset(x.table, x.column);  
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
+				template.unset(x.table, x.column);  
 			}
 		}
 		super.removeSelectionPaths( paths );
 	}
 	
 	/**
-	 * Update the Template appropriately.
+	 * Update the Projection appropriately.
 	 */
 	@Override 
 	public void addSelectionPaths(TreePath[] paths) {
 		for(TreePath path : paths) {
 			Object node = path.getLastPathComponent();
 			if(node instanceof DefaultMutableTreeNode) {
-				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
 				// Select table.column records (not the table only). 
-				if(x.column != null) xtemplate.set(x.table, x.column);
+				if(x.column != null) template.set(x.table, x.column);
 			}
 		}
 		super.addSelectionPaths( paths );
@@ -66,15 +72,15 @@
 	@Override
 	public void clearSelection() {
 		super.clearSelection();
-		xtemplate.unsetEverything();
+		template.unsetEverything();
 	}
 			
 	/**
 	 * 
 	 * @return A copy of the inner template that stores the list of selected columns.
 	 */
-	public Template getTemplate() {
-		return xtemplate.clone();
+	public Projection getTemplate() {
+		return template;
 	}
 	
 }

Added: trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,45 @@
+package net.sf.plantlore.client.export.component;
+
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ * A representation of a node in an XTree.
+ * Every node corresponds to a <code>column</code> of a <code>table</code>.
+ *  
+ * 
+ * @author Erik Kratochv?l (discontinuum at gmail.com)
+ * @since 2006-04-29
+ * @see net.sf.plantlore.client.export.component.ExtendedTree
+ */
+public class UserTreeNode {
+	/** The table whose columns this node represents. */
+	public Class table;
+	/** The column of the table this node represents. */
+	public String column;
+	/** Is it a not-null property in the database? */
+	public boolean nn;
+	
+	/**
+	 * Create a new XNode. The node represents 
+	 * a (possibly mandatory) column of a table.
+	 */
+	public UserTreeNode(Class table, String column, boolean notNullProperty) {
+		this.table = table; nn = notNullProperty; this.column = column;
+	}
+	
+	/**
+	 * Create a new XNode. The node represents a column of a table.
+	 */
+	public UserTreeNode(Class table, String column) {
+		this(table, column, false);
+	}
+	
+	/**
+	 * Get the name of the column.
+	 * TODO: L10n may be useful here!
+	 */
+	@Override
+	public String toString() {
+		return L10n.getString(table.getSimpleName() + ((column != null) ? "." +  column : ""));
+	}
+}
\ No newline at end of file



From krater at mail.berlios.de  Mon Jul 31 11:02:45 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 11:02:45 +0200
Subject: [Plantlore-dev] r477 - in trunk/src/net/sf/plantlore/client/export:
	. component
Message-ID: <200607310902.k6V92jhS030260@sheep.berlios.de>

Author: krater
Date: 2006-07-31 11:02:45 +0200 (Mon, 31 Jul 2006)
New Revision: 477

Removed:
   trunk/src/net/sf/plantlore/client/export/Template.java
   trunk/src/net/sf/plantlore/client/export/component/XFilter.java
   trunk/src/net/sf/plantlore/client/export/component/XNode.java
   trunk/src/net/sf/plantlore/client/export/component/XTree.java
Log:
Removal of unnecessary classes (those previously renamed).

Deleted: trunk/src/net/sf/plantlore/client/export/Template.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Template.java	2006-07-31 08:59:55 UTC (rev 476)
+++ trunk/src/net/sf/plantlore/client/export/Template.java	2006-07-31 09:02:45 UTC (rev 477)
@@ -1,165 +0,0 @@
-package net.sf.plantlore.client.export;
-
-import java.util.ArrayList;
-import java.util.Collection;
-import java.util.HashSet;
-import java.util.List;
-
-import net.sf.plantlore.common.Pair;
-import net.sf.plantlore.common.record.*;
-import net.sf.plantlore.middleware.SelectQuery;
-import static net.sf.plantlore.common.PlantloreConstants.PROJ_PROPERTY;
-
-
-/**
- * The template holds information about the selected columns and tables.
- * This information may used by builders and access rights managers
- * to decide, whether or not the currently
- * considered column should be exported / is accessible.
- * <br/>
- * Note: The template doesn't know anything about the structure
- * (mapping) of the database.  
- * <br/>
- * A little dictionary:
- * <ul>
- * <li><i>foreign key</i> a column of a table that refers to another table,</li>
- * <li><i>property</i> a column of a table that contains a (possibly null) value,
- * but doesn't refer to another table</li>
- * <li><i>nn</i> a property that cannot be null (defined in the db model)</li>
- * </ul>
- * 
- * @author Erik Kratochv?l (discontinuum at gmail.com)
- * @since 2006-04-22
- * @version 1.1
- */
-public class Template {
-	
-	/** The list of all pairs Table.Column that are set. */
-	private Collection<String> columns = new HashSet<String>(100);
-	
-	
-
-	
-	/** Create a new template. */
-	public Template() {/* Nothing to be done. Just to have a default constructor. */}
-	
-	/** A copy constructor. */
-	public Template(Template template) {
-		columns = new HashSet<String>( template.columns );
-	}
-	
-	
-	@Override
-	public Template clone() {
-		return new Template(this);
-	}
-	
-	
-	/** Select the <code>table.column</code>. */
-	public Template set(Class table, String column) { 
-		columns.add(table.getSimpleName()+ (column == null ? "" : "."+column));
-		return this;
-	}
-	
-	/** Unselect the <code>table.column</code>. */
-	public Template unset(Class table, String column) { 
-		columns.remove(table.getSimpleName()+ (column == null ? "" : "."+column));
-		return this;
-	}
-	
-	/** @return true if the <code>table.column</code> is set.*/
-	public boolean isSet(Class table, String column) {
-		return columns.contains(table.getSimpleName()+ (column == null ? "" : "."+column));
-	}
-	
-	/** Unselect all columns of all tables. */
-	public Template unsetEverything() { 
-		columns.clear();
-		return this;
-	}
-	
-	/** Select all columns (properties) of all tables. */
-	public Template setEverything() {
-		for(Class table : Record.BASIC_TABLES)
-			setAllProperties(table);
-		return this;
-	}
-	
-	/** Select all not null columns (properties). */
-	public void setEverythingNN() {
-		// Implementation missing!
-	}
-	
-	/** Select all properties of this <code>table</code>. */
-	public Template setAllProperties(Class table) {
-		try {
-			for( String column : ((Record)table.newInstance()).getProperties() )
-				set(table, column);
-		} catch(Exception e) {/* Not good :/. */}
-		return this;
-	}
-	
-	/** Select all not-null properties of the specified <code>table</code>. */
-	public Template setAllNN(Class table) {
-		try {
-			Record record = ((Record)table.newInstance());
-			List<String> nnProperties = record.getNN();
-			nnProperties.removeAll(record.getForeignKeys());
-			for( String column :  nnProperties )
-				set(table, column);
-		} catch(Exception e) {/* Not good. */}
-		return this;
-	}
-	
-	/**
-	 * @return true if nothing is selected.
-	 */
-	public boolean isEmpty() {
-		return columns.isEmpty();
-	}
-	
-		
-	/**
-	 * Match this template against another one.
-	 * 
-	 * @param t	The template against which the matching will be done.
-	 * @return	True if this template is a superset of the other template.
-	 */ 
-	public boolean match(Template t) { 
-		return columns.containsAll(t.columns); 
-	}
-	
-	
-	private List<Pair<Class, String>> plan;
-	
-	public List<Pair<Class, String>> getDescription() {
-		return plan;
-	}
-	
-	/**
-	 * Add projections to the query according to the selected columns.
-	 * 
-	 * @param q	The query to be modified.
-	 * @param tables	The important tables. The first table is considered the root table.
-	 * @return The column description.
-	 */
-	public List<Pair<Class, String>> addProjections(SelectQuery q, Class...tables) {
-		plan = new ArrayList<Pair<Class,String>>(20);
-		for(int i = 0; i < tables.length; i++)
-			addProjections(q, tables[i], i == 0);
-		return plan;
-	}
-	
-	
-	private void addProjections(SelectQuery q, Class table, boolean omitAlias) {
-		try {
-			Record r = (Record)table.newInstance();
-			for(String property : r.getProperties())
-				if( isSet(table, property) ) {
-					q.addProjection(PROJ_PROPERTY, (omitAlias ? property : Record.alias(table)+"."+property));
-					plan.add(new Pair<Class, String>(table, property));
-				}
-		} catch(Exception e) {/* Not good. */}
-	}
-	
-}

Deleted: trunk/src/net/sf/plantlore/client/export/component/XFilter.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XFilter.java	2006-07-31 08:59:55 UTC (rev 476)
+++ trunk/src/net/sf/plantlore/client/export/component/XFilter.java	2006-07-31 09:02:45 UTC (rev 477)
@@ -1,121 +0,0 @@
-package net.sf.plantlore.client.export.component;
-
-import java.io.File;
-import java.util.ArrayList;
-
-import javax.swing.filechooser.FileFilter;
-
-/**
- * An implementation of a FileFilter.
- * The XFilter stores a list of extensions
- * that are related to a particular format.
- * <br/>
- * For example: 
- * <code>Comma Separated Values (*.txt, *.csv)</code>
- * will store <code>".txt", ".csv"</code>.
- *  
- * @author Erik Kratochv?l (discontinuum at gmail.com)
- * @since 2006-04-29
- * @version 1.0
- */
-public class XFilter extends FileFilter {
-	
-	private String description;
-	private ArrayList<String> extensions;
-	private boolean columnSelection = false;
-	private boolean ignoreDead = true;
-	
-	/**
-	 * Create a new XFilter.
-	 * 
-	 * @param description The description of the filter.
-	 * @param extensions	The list of extensions that are related to this filter.
-	 */
-	public XFilter(String description, String... extensions) {
-		this.description = description;
-		this.extensions = new ArrayList<String>( extensions.length );
-		for(String ext : extensions) this.extensions.add(ext);
-	}
-	
-	/**
-	 * Create a new XFilter.
-	 * 
-	 * @param description	The description of the filter.
-	 * @param columnSelectionEnabled	The format allows further modifications.
-	 * @param extensions	The list of extensions that are related to this filter.
-	 */
-	public XFilter(String description, boolean columnSelectionEnabled, boolean ignoreDead, String... extensions) {
-		this(description, extensions);
-		this.columnSelection = columnSelectionEnabled;
-		this.ignoreDead = ignoreDead;
-	}
-
-	/**
-	 * @return True if the column selection is available for this format.
-	 */
-	public boolean isColumnSelectionEnabled() {
-		return this.columnSelection;
-	}
-	
-	/**
-	 *	@return True if dead records should be omited.
-	 */
-	public boolean ignoreDead() {
-		return ignoreDead;
-	}
-
-	/**
-	 * Decide whether the file meets the requierements - has the correct extension
-	 * or it is in fact a directory.
-	 */
-	@Override
-	public boolean accept(File file) {
-		if( file != null) {
-			if(file.isDirectory()) return true;
-			String name = file.getName() ;
-			int dot = name.lastIndexOf(".");
-			if(dot < 0) return false;
-			if(extensions.contains( name.substring(dot) )) return true;
-		}
-		return false;
-	}
-
-	/**
-	 * @return The description of the format.
-	 */
-	@Override
-	public String getDescription() {
-		return description;
-	}
-	
-	/**
-	 * Decide whether the file already has a valid extension.
-	 * A valid extension is an extension that belongs to
-	 * the list of extensions of this format.
-	 * 
-	 * @param filename	The file to be tested.
-	 * @return	True if the file has a valid extension of this format.
-	 */
-	public boolean hasExtension(String filename) {
-		int dot = filename.lastIndexOf(".");
-		if(dot < 0) return false;
-		if(extensions.contains( filename.substring(dot) )) return true;
-		return false;
-	}
-	
-	/**
-	 * Suggest the name for a file based on the list of extensions.
-	 * If the file already has an extension, the name is not changed.
-	 * An extension is added, if the file has not a valid extension. 
-	 * 
-	 * @param filename	The name of the file.
-	 * @return The suggested name for this file.
-	 * @see net.sf.plantlore.client.export.component.XFilter#hasExtension(String)
-	 */
-	public String suggestName(String filename) {
-		if(hasExtension(filename)) 
-			return filename;
-		return filename + extensions.get(0);
-	}
-	
-}
\ No newline at end of file

Deleted: trunk/src/net/sf/plantlore/client/export/component/XNode.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XNode.java	2006-07-31 08:59:55 UTC (rev 476)
+++ trunk/src/net/sf/plantlore/client/export/component/XNode.java	2006-07-31 09:02:45 UTC (rev 477)
@@ -1,45 +0,0 @@
-package net.sf.plantlore.client.export.component;
-
-import net.sf.plantlore.l10n.L10n;
-
-/**
- * A representation of a node in an XTree.
- * Every node corresponds to a <code>column</code> of a <code>table</code>.
- *  
- * 
- * @author Erik Kratochv?l (discontinuum at gmail.com)
- * @since 2006-04-29
- * @see net.sf.plantlore.client.export.component.XTree
- */
-public class XNode {
-	/** The table whose columns this node represents. */
-	public Class table;
-	/** The column of the table this node represents. */
-	public String column;
-	/** Is it a not-null property in the database? */
-	public boolean nn;
-	
-	/**
-	 * Create a new XNode. The node represents 
-	 * a (possibly mandatory) column of a table.
-	 */
-	public XNode(Class table, String column, boolean notNullProperty) {
-		this.table = table; nn = notNullProperty; this.column = column;
-	}
-	
-	/**
-	 * Create a new XNode. The node represents a column of a table.
-	 */
-	public XNode(Class table, String column) {
-		this(table, column, false);
-	}
-	
-	/**
-	 * Get the name of the column.
-	 * TODO: L10n may be useful here!
-	 */
-	@Override
-	public String toString() {
-		return L10n.getString(table.getSimpleName() + ((column != null) ? "." +  column : ""));
-	}
-}
\ No newline at end of file

Deleted: trunk/src/net/sf/plantlore/client/export/component/XTree.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XTree.java	2006-07-31 08:59:55 UTC (rev 476)
+++ trunk/src/net/sf/plantlore/client/export/component/XTree.java	2006-07-31 09:02:45 UTC (rev 477)
@@ -1,385 +0,0 @@
-package net.sf.plantlore.client.export.component;
-
-import java.awt.Color;
-import java.awt.Component;
-
-
-import javax.swing.JLabel;
-import javax.swing.tree.*;
-
-import net.sf.plantlore.common.record.*;
-
-/**
- * The extension of a JTree that allows the User to see the database model
- * in a compact form. The tree expects the database hierarchy when it's created.
- * Two default hierarchies are already present - the <code>DefaultHierarchy</code>
- * which is loaded when no other hierarchy is specified and displays the database
- * model in the hierarchy, 
- * and the <code>SimpleHierarchy</code> which is a simplified version with
- * all tables as sub-root nodes.
- * Both hierarchies are hard-wired and must be updated if the database
- * model changes!
- * <br/>
- * The selected nodes are visualized to the User in another colour.
- * Collapsing a node <b>will cause</b> deselection of all of its selected
- * sub-nodes. This is a feature that will prevent the User from selecting
- * a group of columns and forgeting about them. 
- * <br/>
- * The XTree uses instances of XNode class - that is, the label of the
- * node is derived from the XNode.toString(). Should you have a desire
- * to implement the L10N, modify that method appropriatelly.
- * <br/>
- * The XTree cannot produce a Template - in order to create and update 
- * the Template "automatically" create your own TreeSelectionModel
- * that is capable of such an action. 
- * <pre>
- * XTree tree = new XTree( );
- * tree.setSelectionModel( new YSelectionModel() );
- * </pre>
- * where
- * <pre>
- * class TemplateSelectionModel extends DefaultTreeSelectionModel {
- * 		private Template template;
- * 
- *		// Use this to achieve compatibility with the default XTree selection model.
- *		@Override 
- *		public void setSelectionPath(TreePath path) {
- *			if( isPathSelected(path) )
- *				removeSelectionPath(path);
- *			else
- *				addSelectionPath(path);
- *		}
- *		@Override 
- *		public void removeSelectionPaths(TreePath[] paths) {
- *			for(TreePath path : paths) {
- *				XNode x  = (XNode) 
- *					((DefaultMutableTreeNode)path.getLastPathComponent())
- *					.getUserObject();
- *				template.unset(x.table, x.column);    // update the Template 
- *			} 
- *			super.removeSelectionPaths( paths ); 
- *		}
- *		@Override 
- *		public void addSelectionPaths(TreePath[] paths) {
- *			// ...similar...
- *		}
- * }
- * </pre>
- *   
- * @author Erik Kratochv?l (discontinuum at gmail.com)
- * @since 2006-04-29
- * @version 1.0
- * @see net.sf.plantlore.client.export.Template
- * @see net.sf.plantlore.client.export.ExportMng.XSelectionModel
- */
-public class XTree extends javax.swing.JTree {
-	
-	private static Color NotNullColor = new Color(220, 50, 20);
-	private static Color SelectedColor = new Color(20, 150, 20);
-	private static Color DefaultColor = Color.BLACK;
-	
-	
-	/**
-	 * The Default Hierarchy Model of the Database Model.
-	 */
-	public static Object[] DefaultHierarchy = {
-		new XNode(XTree.class, "Plantlore"),
-		new Object[] { // OCCURENCE
-			new XNode(Occurrence.class, null),
-			new XNode(Occurrence.class, Occurrence.UNITIDDB, true),
-			new XNode(Occurrence.class, Occurrence.UNITVALUE, true),
-			new Object[] { // HABITAT
-				new XNode(Habitat.class, null),
-				new Object[] { // TERRITORY
-					new XNode(Territory.class, null),
-					new XNode(Territory.class, Territory.NAME, true)
-				},
-				new Object[] { // PHYTOCHORION
-					new XNode(Phytochorion.class, null),
-					new XNode(Phytochorion.class, Phytochorion.CODE, true),
-					new XNode(Phytochorion.class, Phytochorion.NAME, true),
-				},
-				new XNode(Habitat.class, Habitat.QUADRANT),
-				new XNode(Habitat.class, Habitat.DESCRIPTION),
-				new Object[] { // NEAREST VILLAGE
-					new XNode(Village.class, null),
-					new XNode(Village.class, Village.NAME, true)
-				},
-				new XNode(Habitat.class, Habitat.COUNTRY),
-				new XNode(Habitat.class, Habitat.ALTITUDE),
-				new XNode(Habitat.class, Habitat.LATITUDE),
-				new XNode(Habitat.class, Habitat.LONGITUDE),
-				new XNode(Habitat.class, Habitat.NOTE),
-			},
-			new Object[] { // PLANT
-				new XNode(Plant.class, null),
-				new XNode(Plant.class, Plant.SURVEYTAXID, true),
-				new XNode(Plant.class, Plant.TAXON, true),
-				new XNode(Plant.class, Plant.GENUS),
-				new XNode(Plant.class, Plant.SPECIES),
-				new XNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
-				new XNode(Plant.class, Plant.CZECHNAME),
-				new XNode(Plant.class, Plant.SYNONYMS),
-				new XNode(Plant.class, Plant.NOTE)
-			},
-			new XNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
-			new XNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
-			new XNode(Occurrence.class, Occurrence.DAYCOLLECTED),
-			new XNode(Occurrence.class, Occurrence.TIMECOLLECTED),
-			new XNode(Occurrence.class, Occurrence.DATASOURCE),
-			new Object[] { // PUBLICATION
-				new XNode(Publication.class, null),
-				new XNode(Publication.class, Publication.COLLECTIONNAME),
-				new XNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
-				new XNode(Publication.class, Publication.JOURNALNAME),
-				new XNode(Publication.class, Publication.JOURNALAUTHORNAME),
-				new XNode(Publication.class, Publication.REFERENCECITATION, true),
-				new XNode(Publication.class, Publication.REFERENCEDETAIL),
-				new XNode(Publication.class, Publication.URL),
-				new XNode(Publication.class, Publication.NOTE)
-			},
-			new XNode(Occurrence.class, Occurrence.HERBARIUM),
-			new XNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
-			new XNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
-			new XNode(Occurrence.class, Occurrence.NOTE),
-			new Object[] { // METADATA
-				new XNode(Metadata.class, null),
-				new XNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
-				new XNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
-				new XNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
-				new XNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
-				new XNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
-				new XNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
-				new XNode(Metadata.class, Metadata.DATASETTITLE, true),
-				new XNode(Metadata.class, Metadata.DATASETDETAILS),
-				new XNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
-				new XNode(Metadata.class, Metadata.SOURCEID, true),
-				new XNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
-				new XNode(Metadata.class, Metadata.DATECREATE, true),
-				new XNode(Metadata.class, Metadata.DATEMODIFIED, true),
-				new XNode(Metadata.class, Metadata.RECORDBASIS),
-				new XNode(Metadata.class, Metadata.BIOTOPETEXT),				
-			}
-		},
-		new Object[] { // AUTHOR
-			new XNode(Author.class, null),
-			new XNode(Author.class, Author.WHOLENAME),
-			new XNode(Author.class, Author.ORGANIZATION),
-			new XNode(Author.class, Author.PHONENUMBER),
-			new XNode(Author.class, Author.ROLE),
-			new XNode(Author.class, Author.ADDRESS),
-			new XNode(Author.class, Author.EMAIL),
-			new XNode(Author.class, Author.URL),
-			new XNode(Author.class, Author.NOTE)
-		},
-		new Object[] { // AUTHOR-OCCURENCE
-			new XNode(AuthorOccurrence.class, null),
-			new XNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
-			new XNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
-		}
-	};
-	
-	/**
-	 * A simplified Hierarchy Model of the Database Model. 
-	 */
-	public static Object[] SimpleHierarchy = new Object[] {
-		new XNode(XTree.class, "Plantlore DB"),
-		new Object[] { // OCCURENCE
-			new XNode(Occurrence.class, null),
-			new XNode(Occurrence.class, Occurrence.UNITIDDB, true),
-			new XNode(Occurrence.class, Occurrence.UNITVALUE, true),
-			new XNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
-			new XNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
-			new XNode(Occurrence.class, Occurrence.DAYCOLLECTED),
-			new XNode(Occurrence.class, Occurrence.TIMECOLLECTED),
-			new XNode(Occurrence.class, Occurrence.DATASOURCE),
-			new XNode(Occurrence.class, Occurrence.HERBARIUM),
-			new XNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
-			new XNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
-			new XNode(Occurrence.class, Occurrence.NOTE)
-		},
-		new Object[] { // TERRITORY
-			new XNode(Territory.class, null),
-			new XNode(Territory.class, Territory.NAME, true)
-		},
-		new Object[] { // PHYTOCHORION
-			new XNode(Phytochorion.class, null),
-			new XNode(Phytochorion.class, Phytochorion.CODE, true),
-			new XNode(Phytochorion.class, Phytochorion.NAME, true),
-		},
-		new Object[] { // NEAREST VILLAGE
-			new XNode(Village.class, null),
-			new XNode(Village.class, Village.NAME, true)
-		},
-		new Object[] { // HABITAT
-			new XNode(Habitat.class, null),
-			new XNode(Habitat.class, Habitat.QUADRANT),
-			new XNode(Habitat.class, Habitat.DESCRIPTION),
-			new XNode(Habitat.class, Habitat.COUNTRY),
-			new XNode(Habitat.class, Habitat.ALTITUDE),
-			new XNode(Habitat.class, Habitat.LATITUDE),
-			new XNode(Habitat.class, Habitat.LONGITUDE),
-			new XNode(Habitat.class, Habitat.NOTE)
-		},
-		new Object[] { // PLANT
-			new XNode(Plant.class, null),
-			new XNode(Plant.class, Plant.SURVEYTAXID, true),
-			new XNode(Plant.class, Plant.TAXON, true),
-			new XNode(Plant.class, Plant.GENUS),
-			new XNode(Plant.class, Plant.SPECIES),
-			new XNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
-			new XNode(Plant.class, Plant.CZECHNAME),
-			new XNode(Plant.class, Plant.SYNONYMS),
-			new XNode(Plant.class, Plant.NOTE)
-		},
-		new Object[] { // PUBLICATION
-			new XNode(Publication.class, null),
-			new XNode(Publication.class, Publication.COLLECTIONNAME),
-			new XNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
-			new XNode(Publication.class, Publication.JOURNALNAME),
-			new XNode(Publication.class, Publication.JOURNALAUTHORNAME),
-			new XNode(Publication.class, Publication.REFERENCECITATION, true),
-			new XNode(Publication.class, Publication.REFERENCEDETAIL),
-			new XNode(Publication.class, Publication.URL),
-			new XNode(Publication.class, Publication.NOTE)
-		},
-		new Object[] { // METADATA
-			new XNode(Metadata.class, null),
-			new XNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
-			new XNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
-			new XNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
-			new XNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
-			new XNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
-			new XNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
-			new XNode(Metadata.class, Metadata.DATASETTITLE, true),
-			new XNode(Metadata.class, Metadata.DATASETDETAILS),
-			new XNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
-			new XNode(Metadata.class, Metadata.SOURCEID, true),
-			new XNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
-			new XNode(Metadata.class, Metadata.DATECREATE, true),
-			new XNode(Metadata.class, Metadata.DATEMODIFIED, true),
-			new XNode(Metadata.class, Metadata.RECORDBASIS),
-			new XNode(Metadata.class, Metadata.BIOTOPETEXT),			
-		},
-		new Object[] { // AUTHOR
-			new XNode(Author.class, null),
-			new XNode(Author.class, Author.WHOLENAME),
-			new XNode(Author.class, Author.ORGANIZATION),
-			new XNode(Author.class, Author.PHONENUMBER),
-			new XNode(Author.class, Author.ROLE),
-			new XNode(Author.class, Author.ADDRESS),
-			new XNode(Author.class, Author.EMAIL),
-			new XNode(Author.class, Author.URL),
-			new XNode(Author.class, Author.NOTE)
-		},
-		new Object[] { // AUTHOR-OCCURENCE
-			new XNode(AuthorOccurrence.class, null),
-			new XNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
-			new XNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
-		}
-	};
-	
-	/**
-	 * Create a new XTree with the Default Hierarchy Model.
-	 */
-	public XTree( ) {
-		this( DefaultHierarchy );
-	}
-	
-		
-	/**
-	 * Create a new XTree with a specified Hierarchy Model.
-	 * @param hierarchy The hierarchy to be processed.
-	 */
-	public XTree( Object[] hierarchy ) {
-		super( processHierarchy(hierarchy) );
-		
-	    setCellRenderer( new XCellRenderer() );
-	    setToggleClickCount(1);
-	    setSelectionModel( new XSelectionModel() );
-	}
-	
-	
-	/**
-	 * A modified selection model. A single click will 
-	 * add a leaf to the current selection.
-	 * 
-	 * @author Erik Kratochv?l (discontinuum at gmail.com)
-	 * @since 2006-04-29
-	 */	
-	public class XSelectionModel extends DefaultTreeSelectionModel {
-		
-		@Override 
-		public void setSelectionPath(TreePath path) {
-			if( isPathSelected(path) )
-				removeSelectionPath(path);
-			else
-				addSelectionPath(path);
-		}
-		
-	}
-	
-	
-	/**
-	 * SPecialized Cell Renderer that shows no icons and
-	 * displayes mandatory columns with a different coulour.
-	 * 
-	 * @author Erik Kratochv?l (discontinuum at gmail.com)
-	 * @since 2006-04-29
-	 */
-	protected class XCellRenderer extends DefaultTreeCellRenderer {
-		
-		public XCellRenderer() {
-			setOpenIcon(null); 
-		    setClosedIcon(null); 
-		    setLeafIcon(null);
-		}
-		
-		@Override
-		public Component getTreeCellRendererComponent(
-				javax.swing.JTree tree, 
-				Object value, 
-				boolean selected, 
-				boolean expanded, 
-				boolean leaf, 
-				int row, 
-				boolean hasFocus) {
-			// Let the default implementation handle the drawing.
-			JLabel label =  (JLabel) 
-				super.getTreeCellRendererComponent(tree, value, false, expanded, leaf, row, false);
-			// Modify the result of the predecessor.
-			if( selected && leaf ) 
-				label.setForeground( SelectedColor );
-			else
-				if( ((XNode)((DefaultMutableTreeNode)value).getUserObject()).nn )
-					label.setForeground( NotNullColor );
-				else 
-					label.setForeground( DefaultColor );
-			return label;
-		}
-	}
-	
-	
-	
-	/**
-	 * Transform the simple Object[] hierarchy into an internal representation 
-	 * of the JTree.
-	 * @param hierarchy The hierarchy to be converted.
-	 * @return The root of the transformed hierarchy.
-	 */
-	private static DefaultMutableTreeNode processHierarchy(Object[] hierarchy) {
-		DefaultMutableTreeNode node = new DefaultMutableTreeNode(hierarchy[0]);
-		DefaultMutableTreeNode child;
-		for (int i = 1; i < hierarchy.length; i++) {
-			Object nodeSpecifier = hierarchy[i];
-			if (nodeSpecifier instanceof Object[]) // Ie node with children
-				child = processHierarchy((Object[]) nodeSpecifier);
-			else
-				child = new DefaultMutableTreeNode(nodeSpecifier); // Ie Leaf
-			node.add(child);
-		}
-		return (node);
-	}
-	
-
-}



From krater at mail.berlios.de  Mon Jul 31 11:07:37 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 11:07:37 +0200
Subject: [Plantlore-dev] r478 - trunk/src/net/sf/plantlore/client/login
Message-ID: <200607310907.k6V97b0S030566@sheep.berlios.de>

Author: krater
Date: 2006-07-31 11:07:36 +0200 (Mon, 31 Jul 2006)
New Revision: 478

Added:
   trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java
   trunk/src/net/sf/plantlore/client/login/ItemView2.form
   trunk/src/net/sf/plantlore/client/login/ItemView2.java
Modified:
   trunk/src/net/sf/plantlore/client/login/AuthCtrl.java
   trunk/src/net/sf/plantlore/client/login/AuthView.form
   trunk/src/net/sf/plantlore/client/login/AuthView.java
   trunk/src/net/sf/plantlore/client/login/ItemCtrl.java
   trunk/src/net/sf/plantlore/client/login/ItemView.java
   trunk/src/net/sf/plantlore/client/login/Login.java
   trunk/src/net/sf/plantlore/client/login/LoginCtrl.java
   trunk/src/net/sf/plantlore/client/login/LoginView.form
   trunk/src/net/sf/plantlore/client/login/LoginView.java
Log:
The Login rewritten to conform several RFEs and to use the Task/ProgressBar.
Files ending with '2' are meant to replace their counterparts (those are meant to be deleted).

Modified: trunk/src/net/sf/plantlore/client/login/AuthCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/AuthCtrl.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/AuthCtrl.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -5,6 +5,10 @@
 
 import javax.swing.AbstractAction;
 
+import net.sf.plantlore.common.DefaultCancelAction;
+import net.sf.plantlore.common.DefaultProgressBar;
+import net.sf.plantlore.common.DefaultProgressBarEx;
+import net.sf.plantlore.common.Task;
 import net.sf.plantlore.l10n.L10n;
 
 
@@ -15,11 +19,11 @@
 	
 	public AuthCtrl(Login login, AuthView authview) {
 		this.model = login; this.view = authview;
-		view.next.setAction(new NextAction());
-		view.discard.setAction(new CancelAction());
+		view.next.setAction(new NextAction2());
+		view.discard.setAction( new DefaultCancelAction(view) );
 	}
 
-	
+	@Deprecated
 	class NextAction extends AbstractAction {
 		public NextAction() {
 			putValue(SHORT_DESCRIPTION, L10n.getString("Login.AuthorizeTT"));
@@ -35,6 +39,26 @@
 		}
 	}
 	
+	
+	class NextAction2 extends AbstractAction {
+		public NextAction2() {
+			putValue(SHORT_DESCRIPTION, L10n.getString("Login.AuthorizeTT"));
+			putValue(NAME, L10n.getString("Login.Authorize"));
+		}
+		public void actionPerformed(ActionEvent arg0) {
+			//view.next.setEnabled(false);
+			//view.setCursor(Cursor.getPredefinedCursor(Cursor.WAIT_CURSOR));
+			//view.discard.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
+			String user = ((javax.swing.JTextField)view.user.getEditor().getEditorComponent()).getText();
+
+			Task connect = model.createConnectionTask(user, new String(view.password.getPassword()));
+			/*DefaultProgressBar bar = */new DefaultProgressBarEx(connect, view, true);
+			//bar.unlockComponents(view.next);
+			connect.start();
+		}
+	}
+	
+	@Deprecated
 	class CancelAction extends AbstractAction {
 		public CancelAction() {
 			//putValue(SHORT_DESCRIPTION, L10n.getString("Login.DiscardTT"));

Modified: trunk/src/net/sf/plantlore/client/login/AuthView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/login/AuthView.form	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/AuthView.form	2006-07-31 09:07:36 UTC (rev 478)
@@ -21,10 +21,10 @@
   <Layout>
     <DimensionLayout dim="0">
       <Group type="103" groupAlignment="0" attributes="0">
-          <Group type="102" alignment="1" attributes="0">
+          <Group type="102" attributes="0">
               <EmptySpace max="-2" attributes="0"/>
               <Group type="103" groupAlignment="0" attributes="0">
-                  <Group type="102" attributes="0">
+                  <Group type="102" alignment="1" attributes="0">
                       <Group type="103" groupAlignment="0" attributes="0">
                           <Component id="jLabel1" alignment="0" min="-2" max="-2" attributes="0"/>
                           <Component id="jLabel2" alignment="0" min="-2" max="-2" attributes="0"/>
@@ -43,7 +43,6 @@
               </Group>
               <EmptySpace max="-2" attributes="0"/>
           </Group>
-          <Component id="status" alignment="0" pref="298" max="32767" attributes="0"/>
       </Group>
     </DimensionLayout>
     <DimensionLayout dim="1">
@@ -65,7 +64,6 @@
                   <Component id="discard" alignment="3" min="-2" max="-2" attributes="0"/>
               </Group>
               <EmptySpace max="-2" attributes="0"/>
-              <Component id="status" min="-2" pref="22" max="-2" attributes="0"/>
           </Group>
       </Group>
     </DimensionLayout>
@@ -112,19 +110,6 @@
         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
       </AuxValues>
     </Component>
-    <Component class="javax.swing.JLabel" name="status">
-      <Properties>
-        <Property name="text" type="java.lang.String" value=" ..."/>
-        <Property name="border" type="javax.swing.border.Border" editor="org.netbeans.modules.form.editors2.BorderEditor">
-          <Border info="org.netbeans.modules.form.compat2.border.BevelBorderInfo">
-            <BevelBorder bevelType="1"/>
-          </Border>
-        </Property>
-      </Properties>
-      <AuxValues>
-        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
-      </AuxValues>
-    </Component>
     <Component class="javax.swing.JButton" name="discard">
       <Properties>
         <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">

Modified: trunk/src/net/sf/plantlore/client/login/AuthView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/AuthView.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/AuthView.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -11,8 +11,6 @@
 import java.util.Observable;
 import java.util.Observer;
 
-import javax.swing.JOptionPane;
-
 import net.sf.plantlore.common.AutoComboBox;
 import net.sf.plantlore.l10n.L10n;
 import net.sf.plantlore.middleware.DBLayer;
@@ -46,7 +44,6 @@
         ((AutoComboBox)user).setStrict(false);
         password = new javax.swing.JPasswordField();
         next = new javax.swing.JButton();
-        status = new javax.swing.JLabel();
         discard = new javax.swing.JButton();
 
         setTitle(L10n.getString("Login.Authentication"));
@@ -61,19 +58,16 @@
 
         next.setText(L10n.getString("Login.Authorize"));
 
-        status.setText(" ...");
-        status.setBorder(javax.swing.BorderFactory.createBevelBorder(javax.swing.border.BevelBorder.LOWERED));
-
         discard.setText(L10n.getString("Common.Cancel"));
 
         org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
         getContentPane().setLayout(layout);
         layout.setHorizontalGroup(
             layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
+            .add(layout.createSequentialGroup()
                 .addContainerGap()
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
-                    .add(layout.createSequentialGroup()
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                         .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
                             .add(jLabel1)
                             .add(jLabel2))
@@ -86,7 +80,6 @@
                         .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                         .add(next)))
                 .addContainerGap())
-            .add(status, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 298, Short.MAX_VALUE)
         );
 
         layout.linkSize(new java.awt.Component[] {discard, next}, org.jdesktop.layout.GroupLayout.HORIZONTAL);
@@ -106,8 +99,7 @@
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(next)
                     .add(discard))
-                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
-                .add(status, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 22, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addContainerGap())
         );
         pack();
     }// </editor-fold>//GEN-END:initComponents
@@ -136,22 +128,18 @@
     				setTitle(L10n.getString("Login.ConnectingTo") + " " + selected.toString());
     			}
     			// Exception! We must display the exception to the user.
-    			else if(arg instanceof Exception) {
-    				status.setText(L10n.getString("Login.Failed"));
-    				next.setEnabled(true);
-    				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
-    				JOptionPane.showMessageDialog(
-    						null, 
-    						((Exception)arg).getMessage(), 
-    						L10n.getString("Error.LoginFailed"), 
-    						JOptionPane.ERROR_MESSAGE);
-    			}
+//    			else if(arg instanceof Exception) {
+//    				next.setEnabled(true);
+//    				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
+//    				JOptionPane.showMessageDialog(
+//    						null, 
+//    						((Exception)arg).getMessage(), 
+//    						L10n.getString("Error.LoginFailed"), 
+//    						JOptionPane.ERROR_MESSAGE);
+//    			}
     			// The database layer has been created, we are no longer neccessary
     			else if(arg instanceof DBLayer)
     				setVisible(false); 
-    			// Some update information - display them in the status bar.
-    			else if(arg instanceof String) 
-    				status.setText("  " + (String)arg);
     		}
     	});
 	}
@@ -163,7 +151,6 @@
     private javax.swing.JLabel jLabel2;
     protected javax.swing.JButton next;
     protected javax.swing.JPasswordField password;
-    protected javax.swing.JLabel status;
     protected javax.swing.JComboBox user;
     // End of variables declaration//GEN-END:variables
 

Modified: trunk/src/net/sf/plantlore/client/login/ItemCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemCtrl.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/ItemCtrl.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -7,6 +7,7 @@
 
 import net.sf.plantlore.l10n.L10n;
 
+ at Deprecated
 public class ItemCtrl {
 	
 	private Login model;

Added: trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -0,0 +1,189 @@
+package net.sf.plantlore.client.login;
+
+import java.awt.event.ActionEvent;
+import javax.swing.AbstractAction;
+import javax.swing.JOptionPane;
+
+import net.sf.plantlore.common.DefaultCancelAction;
+import net.sf.plantlore.l10n.L10n;
+
+public class ItemCtrl2 {
+	
+	private Login model;
+	private ItemView2 view;
+	
+	public enum Mode { ADD, EDIT };
+	
+	private Mode mode = Mode.ADD;
+	
+	
+	// Switch between the ADD/EDIT behaviour
+	public void setMode(Mode m) {
+		this.mode = m;
+		switch(m) {
+		case ADD:
+			view.aliasLocal.setText("");
+			view.aliasRemote.setText("");
+			view.host.setText("");
+			view.port.setText("");
+			((javax.swing.JTextField)view.databaseEngine.getEditor().getEditorComponent()).setText("");
+			view.databaseIdentifier.setText("");
+			view.databasePort.setText("");
+			view.databaseParameter.setText("");
+			view.databaseMasterUser.setText("");
+			view.databaseMasterPassword.setText("");
+			
+			view.setTitle(L10n.getString("Login.AddTitle"));
+			view.next.setText(L10n.getString("Login.Add"));
+			view.next.setToolTipText(L10n.getString("Login.AddTT"));
+			break;
+		case EDIT:
+			view.setTitle(L10n.getString("Login.EditTitle"));
+			view.next.setText(L10n.getString("Login.Change"));
+			view.next.setToolTipText(L10n.getString("Login.ChangeTT"));
+			view.next.setEnabled(true);
+			break;
+		}
+	}
+	
+	
+	public ItemCtrl2(Login login, ItemView2 itemview) {
+		this.model = login; this.view = itemview;
+		view.next.setAction(new NextAction());
+		view.discard.setAction(
+				new DefaultCancelAction(
+						itemview, 
+						L10n.getString("Login.Discard"), 
+						L10n.getString("Login.DiscardTT")));
+	}
+	
+	
+	
+
+	
+	
+	class NextAction extends AbstractAction {
+		
+		public NextAction() {
+			putValue(SHORT_DESCRIPTION, L10n.getString("Login.ChangeTT"));
+			putValue(NAME, L10n.getString("Login.Change"));
+		}
+		
+		public void actionPerformed(ActionEvent arg0) {
+			
+			switch( view.jTabbedPane1.getSelectedIndex() ) {
+			//-------------------------------------------------
+			// Direct Connection (local database only)
+			//-------------------------------------------------
+			case 0:
+				// Validity check...
+				String dbEngine = ((javax.swing.JTextField)view.databaseEngine.getEditor().getEditorComponent()).getText(),
+				masterPassword = new String(view.databaseMasterPassword.getPassword());
+				int dbPort = -1;
+				try {
+					dbPort = Integer.parseInt(view.databasePort.getText());
+				} catch(NumberFormatException e) {
+					// Nothing we can do.
+				}
+				
+				if( dbEngine.length() == 0 || 
+						view.databaseIdentifier.getText().length() == 0 ||
+						dbPort < 0 ||
+						view.databaseMasterUser.getText().length() == 0 ||
+						masterPassword.length() == 0 ||
+						view.aliasLocal.getText().length() == 0 ) {
+					// Announce the problem.
+					JOptionPane.showMessageDialog(
+    						view, 
+    						L10n.getString("Error.MissingSeveralCompulsoryFields"), 
+    						L10n.getString("Error.MissingCompulsoryFieldTitle"), 
+    						JOptionPane.ERROR_MESSAGE);
+					return;
+				}
+					
+				// The values appear to be sufficient.
+				switch(mode) {
+				case ADD:
+					model.createRecord(
+							view.aliasLocal.getText(),
+							null,
+							0,
+							dbEngine,
+							dbPort,
+							view.databaseIdentifier.getText(),
+							view.databaseParameter.getText(),
+							view.databaseMasterUser.getText(),
+							masterPassword
+					);
+					break;
+				case EDIT:
+					model.updateSelectedRecord(
+							view.aliasLocal.getText(),
+							null,
+							0,
+							dbEngine,
+							dbPort,
+							view.databaseIdentifier.getText(),
+							view.databaseParameter.getText(),
+							view.databaseMasterUser.getText(),
+							masterPassword
+					);
+					break;
+				}
+				
+				
+				break;
+				
+			//-------------------------------------------------
+			// Connection to a remote server
+			//-------------------------------------------------
+			case 1:
+				int port = 1099;
+				try {
+					port = Integer.parseInt(view.port.getText());
+				} catch(NumberFormatException e) {
+					// Never mind, use the default port.
+				}
+				
+				// Validity check...
+				if( port < 0 || view.aliasRemote.getText().length() == 0 || 
+						view.host.getText().length() == 0 ) {
+					// Announce the problem.
+					JOptionPane.showMessageDialog(
+    						view, 
+    						L10n.getString("Error.MissingSeveralCompulsoryFields"), 
+    						L10n.getString("Error.MissingCompulsoryFieldTitle"), 
+    						JOptionPane.ERROR_MESSAGE);
+					return;
+				}
+				
+				// The values appear to be sufficient.
+				switch(mode) {
+				case ADD:
+					model.createRecord(
+							view.aliasRemote.getText(),
+							view.host.getText(),
+							port,
+							null, 0, null, null, null, null
+					);
+					break;
+				case EDIT:
+					model.updateSelectedRecord(
+							view.aliasRemote.getText(),
+							view.host.getText(),
+							port,
+							null, 0, null, null, null, null
+					);
+					break;
+				}
+				
+				break;
+			}
+			
+			view.setVisible(false);
+			setMode(Mode.EDIT);
+		}
+	}
+	
+
+}

Modified: trunk/src/net/sf/plantlore/client/login/ItemView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemView.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/ItemView.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -17,6 +17,7 @@
  *
  * @author  yaa
  */
+ at Deprecated
 public class ItemView extends javax.swing.JDialog implements Observer {
 	
 	private Login model;

Added: trunk/src/net/sf/plantlore/client/login/ItemView2.form
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemView2.form	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/ItemView2.form	2006-07-31 09:07:36 UTC (rev 478)
@@ -0,0 +1,420 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<Form version="1.3" type="org.netbeans.modules.form.forminfo.JDialogFormInfo">
+  <Properties>
+    <Property name="defaultCloseOperation" type="int" value="3"/>
+  </Properties>
+  <SyntheticProperties>
+    <SyntheticProperty name="formSizePolicy" type="int" value="1"/>
+  </SyntheticProperties>
+  <AuxValues>
+    <AuxValue name="FormSettings_generateMnemonicsCode" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_listenerGenerationStyle" type="java.lang.Integer" value="0"/>
+    <AuxValue name="FormSettings_variablesLocal" type="java.lang.Boolean" value="false"/>
+    <AuxValue name="FormSettings_variablesModifier" type="java.lang.Integer" value="2"/>
+  </AuxValues>
+
+  <Layout>
+    <DimensionLayout dim="0">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Group type="102" alignment="0" attributes="0">
+              <EmptySpace max="-2" attributes="0"/>
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Component id="jTabbedPane1" alignment="1" pref="380" max="32767" attributes="0"/>
+                  <Group type="102" alignment="0" attributes="0">
+                      <Component id="help" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace pref="175" max="32767" attributes="0"/>
+                      <Component id="discard" linkSize="3" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Component id="next" linkSize="3" min="-2" max="-2" attributes="0"/>
+                  </Group>
+              </Group>
+              <EmptySpace min="-2" max="-2" attributes="0"/>
+          </Group>
+      </Group>
+    </DimensionLayout>
+    <DimensionLayout dim="1">
+      <Group type="103" groupAlignment="0" attributes="0">
+          <Group type="102" alignment="1" attributes="0">
+              <EmptySpace max="-2" attributes="0"/>
+              <Component id="jTabbedPane1" min="-2" max="-2" attributes="0"/>
+              <EmptySpace max="32767" attributes="0"/>
+              <Group type="103" groupAlignment="3" attributes="0">
+                  <Component id="next" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="discard" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="help" alignment="3" min="-2" max="-2" attributes="0"/>
+              </Group>
+              <EmptySpace max="-2" attributes="0"/>
+          </Group>
+      </Group>
+    </DimensionLayout>
+  </Layout>
+  <SubComponents>
+    <Container class="javax.swing.JTabbedPane" name="jTabbedPane1">
+      <AuxValues>
+        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+      </AuxValues>
+
+      <Layout class="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout"/>
+      <SubComponents>
+        <Container class="javax.swing.JPanel" name="jPanel1">
+          <Constraints>
+            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
+              <JTabbedPaneConstraints tabName="Direct connection (local)">
+                <Property name="tabTitle" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.LocalDatabase" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </JTabbedPaneConstraints>
+            </Constraint>
+          </Constraints>
+
+          <Layout>
+            <DimensionLayout dim="0">
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Group type="102" attributes="0">
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="0" attributes="0">
+                          <Component id="jLabel1" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel3" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel4" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel5" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel6" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel7" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel2" alignment="0" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="0" attributes="0">
+                          <Component id="databaseMasterUser" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Component id="databaseParameter" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Component id="databasePort" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Component id="databaseIdentifier" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Component id="databaseEngine" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Component id="aliasLocal" alignment="0" pref="270" max="32767" attributes="0"/>
+                          <Group type="102" alignment="1" attributes="0">
+                              <EmptySpace min="-2" max="-2" attributes="1"/>
+                              <Component id="databaseMasterPassword" pref="270" max="32767" attributes="0"/>
+                          </Group>
+                      </Group>
+                      <EmptySpace min="-2" max="-2" attributes="0"/>
+                  </Group>
+              </Group>
+            </DimensionLayout>
+            <DimensionLayout dim="1">
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Group type="102" attributes="0">
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel1" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="aliasLocal" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="databaseEngine" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel2" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel3" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="databaseIdentifier" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel4" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="databasePort" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel5" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="databaseParameter" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel6" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="databaseMasterUser" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel7" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="databaseMasterPassword" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="32767" attributes="0"/>
+                  </Group>
+              </Group>
+            </DimensionLayout>
+          </Layout>
+          <SubComponents>
+            <Component class="javax.swing.JLabel" name="jLabel1">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.Alias" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel2">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseEngine" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel3">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseIdentifier" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel4">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabasePort" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel5">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseParameter" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel6">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.MasterUser" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel7">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.MasterPassword" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JTextField" name="aliasLocal">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.AliasTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="databaseIdentifier">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseIdentifierTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="databasePort">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabasePortTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="databaseParameter">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseParameterTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="databaseMasterUser">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.MasterUserTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JComboBox" name="databaseEngine">
+              <Properties>
+                <Property name="editable" type="boolean" value="true"/>
+                <Property name="model" type="javax.swing.ComboBoxModel" editor="org.netbeans.modules.form.editors2.ComboBoxModelEditor">
+                  <StringArray count="4">
+                    <StringItem index="0" value="postgresql"/>
+                    <StringItem index="1" value="firebirdsql"/>
+                    <StringItem index="2" value="mysql"/>
+                    <StringItem index="3" value="oraclesql"/>
+                  </StringArray>
+                </Property>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.DatabaseEngineTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JPasswordField" name="databaseMasterPassword">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.MasterPasswordTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+          </SubComponents>
+        </Container>
+        <Container class="javax.swing.JPanel" name="jPanel2">
+          <Constraints>
+            <Constraint layoutClass="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout" value="org.netbeans.modules.form.compat2.layouts.support.JTabbedPaneSupportLayout$JTabbedPaneConstraintsDescription">
+              <JTabbedPaneConstraints tabName="Remote connection">
+                <Property name="tabTitle" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.RemoteDabatase" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </JTabbedPaneConstraints>
+            </Constraint>
+          </Constraints>
+
+          <Layout>
+            <DimensionLayout dim="0">
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Group type="102" attributes="0">
+                      <EmptySpace min="-2" max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="0" attributes="0">
+                          <Component id="jLabel8" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel9" alignment="0" min="-2" max="-2" attributes="0"/>
+                          <Component id="jLabel10" alignment="0" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace min="-2" max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="0" attributes="0">
+                          <Component id="port" alignment="0" pref="303" max="32767" attributes="0"/>
+                          <Component id="aliasRemote" alignment="1" pref="303" max="32767" attributes="0"/>
+                          <Group type="102" alignment="1" attributes="0">
+                              <EmptySpace min="-2" max="-2" attributes="1"/>
+                              <Component id="host" pref="303" max="32767" attributes="0"/>
+                          </Group>
+                      </Group>
+                      <EmptySpace min="-2" max="-2" attributes="0"/>
+                  </Group>
+              </Group>
+            </DimensionLayout>
+            <DimensionLayout dim="1">
+              <Group type="103" groupAlignment="0" attributes="0">
+                  <Group type="102" alignment="0" attributes="0">
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel8" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="aliasRemote" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel9" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="host" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace max="-2" attributes="0"/>
+                      <Group type="103" groupAlignment="3" attributes="0">
+                          <Component id="jLabel10" alignment="3" min="-2" max="-2" attributes="0"/>
+                          <Component id="port" alignment="3" min="-2" max="-2" attributes="0"/>
+                      </Group>
+                      <EmptySpace pref="112" max="32767" attributes="0"/>
+                  </Group>
+              </Group>
+            </DimensionLayout>
+          </Layout>
+          <SubComponents>
+            <Component class="javax.swing.JLabel" name="jLabel8">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.Alias" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel9">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.HostName" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JLabel" name="jLabel10">
+              <Properties>
+                <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.Port" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+            </Component>
+            <Component class="javax.swing.JTextField" name="aliasRemote">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.AliasTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="host">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.HostNameTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+            <Component class="javax.swing.JTextField" name="port">
+              <Properties>
+                <Property name="toolTipText" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+                  <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.PortTT" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+                </Property>
+              </Properties>
+              <AuxValues>
+                <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+              </AuxValues>
+            </Component>
+          </SubComponents>
+        </Container>
+      </SubComponents>
+    </Container>
+    <Component class="javax.swing.JButton" name="next">
+      <Properties>
+        <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+          <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.Change" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+        </Property>
+      </Properties>
+      <AuxValues>
+        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+      </AuxValues>
+    </Component>
+    <Component class="javax.swing.JButton" name="discard">
+      <Properties>
+        <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+          <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Login.Discard" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+        </Property>
+      </Properties>
+      <AuxValues>
+        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+      </AuxValues>
+    </Component>
+    <Component class="javax.swing.JButton" name="help">
+      <Properties>
+        <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+          <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Common.Help" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+        </Property>
+      </Properties>
+      <AuxValues>
+        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+      </AuxValues>
+    </Component>
+  </SubComponents>
+</Form>

Added: trunk/src/net/sf/plantlore/client/login/ItemView2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemView2.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/ItemView2.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -0,0 +1,315 @@
+/*
+ * ItemView2.java
+ *
+ * Created on 25. ?ervenec 2006, 16:25
+ */
+
+package net.sf.plantlore.client.login;
+
+import java.awt.Dialog;
+import java.util.Observable;
+import java.util.Observer;
+
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ *
+ * @author  yaa
+ */
+public class ItemView2 extends javax.swing.JDialog implements Observer {
+    
+	private Login model;
+	
+    /** Creates new form ItemView2 */
+    public ItemView2(Dialog parent, Login model) {
+    	super(parent, true);
+    	
+		this.model = model;
+		model.addObserver(this);
+		initComponents();
+		getRootPane().setDefaultButton(next);
+		setLocationRelativeTo(null);
+    }
+    
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
+    private void initComponents() {
+        jTabbedPane1 = new javax.swing.JTabbedPane();
+        jPanel1 = new javax.swing.JPanel();
+        jLabel1 = new javax.swing.JLabel();
+        jLabel2 = new javax.swing.JLabel();
+        jLabel3 = new javax.swing.JLabel();
+        jLabel4 = new javax.swing.JLabel();
+        jLabel5 = new javax.swing.JLabel();
+        jLabel6 = new javax.swing.JLabel();
+        jLabel7 = new javax.swing.JLabel();
+        aliasLocal = new javax.swing.JTextField();
+        databaseIdentifier = new javax.swing.JTextField();
+        databasePort = new javax.swing.JTextField();
+        databaseParameter = new javax.swing.JTextField();
+        databaseMasterUser = new javax.swing.JTextField();
+        databaseEngine = new javax.swing.JComboBox();
+        databaseMasterPassword = new javax.swing.JPasswordField();
+        jPanel2 = new javax.swing.JPanel();
+        jLabel8 = new javax.swing.JLabel();
+        jLabel9 = new javax.swing.JLabel();
+        jLabel10 = new javax.swing.JLabel();
+        aliasRemote = new javax.swing.JTextField();
+        host = new javax.swing.JTextField();
+        port = new javax.swing.JTextField();
+        next = new javax.swing.JButton();
+        discard = new javax.swing.JButton();
+        help = new javax.swing.JButton();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
+        jLabel1.setText(L10n.getString("Login.Alias"));
+
+        jLabel2.setText(L10n.getString("Login.DatabaseEngine"));
+
+        jLabel3.setText(L10n.getString("Login.DatabaseIdentifier"));
+
+        jLabel4.setText(L10n.getString("Login.DatabasePort"));
+
+        jLabel5.setText(L10n.getString("Login.DatabaseParameter"));
+
+        jLabel6.setText(L10n.getString("Login.MasterUser"));
+
+        jLabel7.setText(L10n.getString("Login.MasterPassword"));
+
+        aliasLocal.setToolTipText(L10n.getString("Login.AliasTT"));
+
+        databaseIdentifier.setToolTipText(L10n.getString("Login.DatabaseIdentifierTT"));
+
+        databasePort.setToolTipText(L10n.getString("Login.DatabasePortTT"));
+
+        databaseParameter.setToolTipText(L10n.getString("Login.DatabaseParameterTT"));
+
+        databaseMasterUser.setToolTipText(L10n.getString("Login.MasterUserTT"));
+
+        databaseEngine.setEditable(true);
+        databaseEngine.setModel(new javax.swing.DefaultComboBoxModel(new String[] { "postgresql", "firebirdsql", "mysql", "oraclesql" }));
+        databaseEngine.setToolTipText(L10n.getString("Login.DatabaseEngineTT"));
+
+        databaseMasterPassword.setToolTipText(L10n.getString("Login.MasterPasswordTT"));
+
+        org.jdesktop.layout.GroupLayout jPanel1Layout = new org.jdesktop.layout.GroupLayout(jPanel1);
+        jPanel1.setLayout(jPanel1Layout);
+        jPanel1Layout.setHorizontalGroup(
+            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(jLabel1)
+                    .add(jLabel3)
+                    .add(jLabel4)
+                    .add(jLabel5)
+                    .add(jLabel6)
+                    .add(jLabel7)
+                    .add(jLabel2))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(databaseMasterUser, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
+                    .add(databaseParameter, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
+                    .add(databasePort, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
+                    .add(databaseIdentifier, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
+                    .add(databaseEngine, 0, 270, Short.MAX_VALUE)
+                    .add(aliasLocal, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel1Layout.createSequentialGroup()
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(databaseMasterPassword, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 270, Short.MAX_VALUE)))
+                .addContainerGap())
+        );
+        jPanel1Layout.setVerticalGroup(
+            jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel1Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel1)
+                    .add(aliasLocal, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(databaseEngine, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                    .add(jLabel2))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel3)
+                    .add(databaseIdentifier, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel4)
+                    .add(databasePort, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel5)
+                    .add(databaseParameter, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel6)
+                    .add(databaseMasterUser, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel1Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel7)
+                    .add(databaseMasterPassword, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addContainerGap(org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
+        );
+        jTabbedPane1.addTab(L10n.getString("Login.LocalDatabase"), jPanel1);
+
+        jLabel8.setText(L10n.getString("Login.Alias"));
+
+        jLabel9.setText(L10n.getString("Login.HostName"));
+
+        jLabel10.setText(L10n.getString("Login.Port"));
+
+        aliasRemote.setToolTipText(L10n.getString("Login.AliasTT"));
+
+        host.setToolTipText(L10n.getString("Login.HostNameTT"));
+
+        port.setToolTipText(L10n.getString("Login.PortTT"));
+
+        org.jdesktop.layout.GroupLayout jPanel2Layout = new org.jdesktop.layout.GroupLayout(jPanel2);
+        jPanel2.setLayout(jPanel2Layout);
+        jPanel2Layout.setHorizontalGroup(
+            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel2Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(jLabel8)
+                    .add(jLabel9)
+                    .add(jLabel10))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(port, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 303, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, aliasRemote, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 303, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jPanel2Layout.createSequentialGroup()
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(host, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 303, Short.MAX_VALUE)))
+                .addContainerGap())
+        );
+        jPanel2Layout.setVerticalGroup(
+            jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(jPanel2Layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel8)
+                    .add(aliasRemote, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel9)
+                    .add(host, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(jPanel2Layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(jLabel10)
+                    .add(port, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE))
+                .addContainerGap(112, Short.MAX_VALUE))
+        );
+        jTabbedPane1.addTab(L10n.getString("Login.RemoteDabatase"), jPanel2);
+
+        next.setText(L10n.getString("Login.Change"));
+
+        discard.setText(L10n.getString("Login.Discard"));
+
+        help.setText(L10n.getString("Common.Help"));
+
+        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
+        getContentPane().setLayout(layout);
+        layout.setHorizontalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(layout.createSequentialGroup()
+                .addContainerGap()
+                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, jTabbedPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
+                    .add(layout.createSequentialGroup()
+                        .add(help)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 175, Short.MAX_VALUE)
+                        .add(discard)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                        .add(next)))
+                .addContainerGap())
+        );
+
+        layout.linkSize(new java.awt.Component[] {discard, next}, org.jdesktop.layout.GroupLayout.HORIZONTAL);
+
+        layout.setVerticalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jTabbedPane1, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
+                    .add(next)
+                    .add(discard)
+                    .add(help))
+                .addContainerGap())
+        );
+        pack();
+    }// </editor-fold>//GEN-END:initComponents
+    
+    
+    /**
+     * Fill all fields with information obtained from the currently selected record.
+     */
+    public void update(Observable arg0, Object arg1) {
+		java.awt.EventQueue.invokeLater(new Runnable() {
+			public void run() {
+				DBInfo info = model.getSelected();
+				if(info != null) {
+					// Remote connection (via the Plantlore Server)
+					aliasRemote.setText(info.alias);
+					host.setText(info.host);
+					if(info.port > 0) 
+						port.setText( Integer.toString(info.port) );
+					// Direct connection (without any contact with a server)
+					aliasLocal.setText(info.alias);
+					((javax.swing.JTextField)databaseEngine.getEditor().getEditorComponent()).setText(info.databaseType);
+					databaseIdentifier.setText(info.getDatabaseIdentifier());
+					if(info.databasePort > 0)
+						databasePort.setText( Integer.toString(info.getDatabasePort()) );
+					databaseParameter.setText(info.getDatabaseParameter());
+					databaseMasterUser.setText(info.getMasterUser());
+					databaseMasterPassword.setText(info.getMasterPassword());
+					
+					if(info.host == null || info.host.length() == 0)
+						jTabbedPane1.setSelectedIndex(0);
+					else
+						jTabbedPane1.setSelectedIndex(1);
+						
+				}
+			}
+		});
+	}
+    
+        
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    protected javax.swing.JTextField aliasLocal;
+    protected javax.swing.JTextField aliasRemote;
+    protected javax.swing.JComboBox databaseEngine;
+    protected javax.swing.JTextField databaseIdentifier;
+    protected javax.swing.JPasswordField databaseMasterPassword;
+    protected javax.swing.JTextField databaseMasterUser;
+    protected javax.swing.JTextField databaseParameter;
+    protected javax.swing.JTextField databasePort;
+    protected javax.swing.JButton discard;
+    protected javax.swing.JButton help;
+    protected javax.swing.JTextField host;
+    private javax.swing.JLabel jLabel1;
+    private javax.swing.JLabel jLabel10;
+    private javax.swing.JLabel jLabel2;
+    private javax.swing.JLabel jLabel3;
+    private javax.swing.JLabel jLabel4;
+    private javax.swing.JLabel jLabel5;
+    private javax.swing.JLabel jLabel6;
+    private javax.swing.JLabel jLabel7;
+    private javax.swing.JLabel jLabel8;
+    private javax.swing.JLabel jLabel9;
+    private javax.swing.JPanel jPanel1;
+    private javax.swing.JPanel jPanel2;
+    protected javax.swing.JTabbedPane jTabbedPane1;
+    protected javax.swing.JButton next;
+    protected javax.swing.JTextField port;
+    // End of variables declaration//GEN-END:variables
+    
+}

Modified: trunk/src/net/sf/plantlore/client/login/Login.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/Login.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/Login.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -6,6 +6,7 @@
 import java.util.Observable;
 import net.sf.plantlore.client.MainConfig;
 import net.sf.plantlore.common.SwingWorker;
+import net.sf.plantlore.common.Task;
 import net.sf.plantlore.common.record.User;
 
 import org.apache.log4j.Logger;
@@ -228,15 +229,18 @@
 	 * @param name The account name (used to access the database).  
 	 * @param password The password to the account.
 	 */
+	@Deprecated
 	synchronized public void connectToSelected(final String name, final String password) {
 		
-		if(selected == null) {
+		final DBInfo selectedClone = selected.clone();
+		
+		if(selectedClone == null) {
 			logger.debug("The System cannot create a connection when nothing was selected!");
 			return;
 		}
 		
-		final DBInfo selectedClone = selected.clone();
 		
+		
 		worker = new SwingWorker() {
 			public Object construct() {
 				
@@ -293,9 +297,101 @@
 	
 	
 	/**
+	 * Once the connection is established and the database layer is
+	 * initialized, Login must inform its observers so that they can
+	 * update their database layers.
+	 */
+	private void announceConnection() {
+		setChanged(); 
+		notifyObservers(dblayer);
+	}
+	
+	
+	/**
+	 * Create a task that will try to forge the connection to the selected database. 
+	 * First, a new database layer is created,
+	 * and second, that database layer is initialized.
+	 * <br/>
+	 * <b>Warning:</b>If there is a previously created DBLayer, 
+	 * it will be destroyed using the <code>logout()</code> method. 
+	 * 	  
+	 * @param name The account name (used to access the database).  
+	 * @param password The password to the account.
+	 */
+	synchronized public Task createConnectionTask(final String name, final String password) {
+		if(selected == null) {
+			logger.debug("The System cannot create a connection when nothing was selected!");
+			return null;
+		}
+		
+		logout();
+		
+		final DBInfo selectedClone = selected.clone();
+
+		// The current username is moved to the top of the list of names :) Nice feature.
+		selectedClone.promoteUser(name);
+		// Save the current state.
+		save();
+		
+		return new Task() {
+
+			@Override
+			public Object task() throws Exception {
+				
+				try {				
+					// Create a new database layer.
+					logger.debug("Asking the DBLayerFactory for a new DBLayer @ " + selectedClone.host + ":" + selectedClone.port);
+					setStatusMessage( L10n.getString("Login.Connecting") );
+					dblayer = factory.create( selectedClone );
+					if(isCanceled())
+						throw new Exception(L10n.getString("Common.Canceled"));
+					
+					logger.debug("Connection successful.");
+					setStatusMessage( L10n.getString("Login.Connected") );
+					
+					// Initialize the database layer.
+					setStatusMessage( L10n.getString("Login.InitializingDBLayer") );
+					logger.debug("Initializing that DBLayer (" + selectedClone.databaseType + ", " + name + ", " + password + "...");
+					
+					Object[] init = dblayer.initialize(selectedClone.getDatabaseIdentifier(), name, password);
+					if(isCanceled())
+						throw new Exception(L10n.getString("Common.Canceled"));
+					plantloreUser = (User)init[0];
+					accessRights = (Right)init[1];
+				} 
+				catch (Exception e) {
+					logger.error("The initialization of the DBLayer failed! " + e.getMessage());
+					// If the initialization of the DBLayer failed, the uninitialized DBLayer must be destroyed!
+					// Otherwise, the server's policy may not allow another connection from this client!
+					if(dblayer != null)
+						try {
+							factory.destroy(dblayer);
+						} catch(RemoteException re) {
+							// Nothing we can do; the server is probably in trouble, or the network connection failed. 
+						}
+					// Re-throw the exception so that the view is updated as well.
+					throw e;
+				}
+				
+				setStatusMessage( L10n.getString("Login.DBLayerInitialized") );
+				logger.debug("DBLayer initialized.");
+				
+				fireStopped(null);
+				
+				// Everything went fine - 
+				// there is a new DBLayer which is to be announced to the observers of Login.
+				announceConnection();
+				return null;
+			}
+		};
+	
+	}
+	
+	/**
 	 * Cancel the login proces.
 	 *
 	 */
+	@Deprecated
 	synchronized public void interrupt() {
 		if(worker != null) {
 			worker.interrupt();
@@ -303,15 +399,13 @@
 		}
 		logout();
 		setChanged(); notifyObservers(L10n.getString("Login.Interrupted"));
-	}
+	} //NO LONGER AVAILABLE (it didn't work anyway).
 	
 	
 	
 	/**
 	 * Disconnect from the current database. 
 	 * The database connection is lost, any operation in progress will cause an exception.
-	 * 
-	 * @throws RemoteException if the RMI encounters an error.
 	 */
 	public void logout() {
 		if(dblayer != null) 

Modified: trunk/src/net/sf/plantlore/client/login/LoginCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/LoginCtrl.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/LoginCtrl.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -7,6 +7,7 @@
 import javax.swing.event.ListSelectionEvent;
 import javax.swing.event.ListSelectionListener;
 
+import net.sf.plantlore.common.DefaultCancelAction;
 import net.sf.plantlore.l10n.L10n;
 
 
@@ -15,8 +16,8 @@
 	private Login model;
 	private LoginView view;
 	
-	private ItemView itemView;
-	private ItemCtrl itemCtrl;
+	private ItemView2 itemView;
+	private ItemCtrl2 itemCtrl;
 	private AuthView authView;
 	
 	
@@ -25,8 +26,8 @@
 		this.view = loginview; this.model = login;
 		
 		// Create Item Add/Edit dialog.
-		itemView = new ItemView(view, model);
-		itemCtrl = new ItemCtrl(model, itemView);
+		itemView = new ItemView2(view, model);
+		itemCtrl = new ItemCtrl2(model, itemView);
 		// Create Authorization dialog.
 		authView = new AuthView(view, model);
 		new AuthCtrl(model, authView);
@@ -36,6 +37,7 @@
 		view.edit.setAction(new EditRecordAction());
 		view.remove.setAction(new RemoveRecordAction());
 		view.next.setAction(new NextAction());
+		view.discard.setAction(new DefaultCancelAction(view));
 		
 		// Select something.
 		view.choice.setSelectedIndex(0);
@@ -62,7 +64,7 @@
 			putValue(NAME, L10n.getString("Login.AddRecord"));
 		}
 		public void actionPerformed(ActionEvent arg0) {
-			itemCtrl.setMode(ItemCtrl.Mode.ADD);
+			itemCtrl.setMode(ItemCtrl2.Mode.ADD);
 			itemView.setVisible(true);
 		}
 	}
@@ -84,7 +86,7 @@
 		}
 		public void actionPerformed(ActionEvent arg0) {
 			if(model.getSelected() != null) {
-				itemCtrl.setMode(ItemCtrl.Mode.EDIT);
+				itemCtrl.setMode(ItemCtrl2.Mode.EDIT);
 				itemView.setVisible(true);
 			}
 		}

Modified: trunk/src/net/sf/plantlore/client/login/LoginView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/login/LoginView.form	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/LoginView.form	2006-07-31 09:07:36 UTC (rev 478)
@@ -65,7 +65,9 @@
                   <Component id="jScrollPane1" alignment="1" pref="343" max="32767" attributes="0"/>
                   <Group type="102" alignment="1" attributes="0">
                       <Component id="remember" min="-2" max="-2" attributes="0"/>
-                      <EmptySpace pref="151" max="32767" attributes="0"/>
+                      <EmptySpace pref="74" max="32767" attributes="0"/>
+                      <Component id="discard" min="-2" max="-2" attributes="0"/>
+                      <EmptySpace max="-2" attributes="0"/>
                       <Component id="next" min="-2" max="-2" attributes="0"/>
                   </Group>
               </Group>
@@ -82,6 +84,7 @@
               <Group type="103" groupAlignment="3" attributes="0">
                   <Component id="next" alignment="3" min="-2" max="-2" attributes="0"/>
                   <Component id="remember" alignment="3" min="-2" max="-2" attributes="0"/>
+                  <Component id="discard" alignment="3" min="-2" max="-2" attributes="0"/>
               </Group>
               <EmptySpace min="-2" max="-2" attributes="0"/>
           </Group>
@@ -141,5 +144,15 @@
         <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
       </AuxValues>
     </Component>
+    <Component class="javax.swing.JButton" name="discard">
+      <Properties>
+        <Property name="text" type="java.lang.String" editor="org.netbeans.modules.i18n.form.FormI18nStringEditor">
+          <ResourceString bundle="net/sf/plantlore/l10n/Plantlore.properties" key="Common.Cancel" replaceFormat="L10n.getString(&quot;{key}&quot;)"/>
+        </Property>
+      </Properties>
+      <AuxValues>
+        <AuxValue name="JavaCodeGenerator_VariableModifier" type="java.lang.Integer" value="4"/>
+      </AuxValues>
+    </Component>
   </SubComponents>
 </Form>

Modified: trunk/src/net/sf/plantlore/client/login/LoginView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/LoginView.java	2006-07-31 09:02:45 UTC (rev 477)
+++ trunk/src/net/sf/plantlore/client/login/LoginView.java	2006-07-31 09:07:36 UTC (rev 478)
@@ -50,6 +50,7 @@
         jScrollPane1 = new javax.swing.JScrollPane();
         choice = new javax.swing.JList();
         remember = new javax.swing.JCheckBox();
+        discard = new javax.swing.JButton();
 
         popup.setName("popup");
         add.setText(L10n.getString("Login.AddRecord"));
@@ -75,6 +76,8 @@
         remember.setBorder(javax.swing.BorderFactory.createEmptyBorder(0, 0, 0, 0));
         remember.setMargin(new java.awt.Insets(0, 0, 0, 0));
 
+        discard.setText(L10n.getString("Common.Cancel"));
+
         org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
         getContentPane().setLayout(layout);
         layout.setHorizontalGroup(
@@ -85,7 +88,9 @@
                     .add(org.jdesktop.layout.GroupLayout.TRAILING, jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 343, Short.MAX_VALUE)
                     .add(org.jdesktop.layout.GroupLayout.TRAILING, layout.createSequentialGroup()
                         .add(remember)
-                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 151, Short.MAX_VALUE)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, 74, Short.MAX_VALUE)
+                        .add(discard)
+                        .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                         .add(next)))
                 .addContainerGap())
         );
@@ -97,7 +102,8 @@
                 .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
                 .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.BASELINE)
                     .add(next)
-                    .add(remember))
+                    .add(remember)
+                    .add(discard))
                 .addContainerGap())
         );
         pack();
@@ -137,6 +143,7 @@
     // Variables declaration - do not modify//GEN-BEGIN:variables
     protected javax.swing.JMenuItem add;
     protected javax.swing.JList choice;
+    protected javax.swing.JButton discard;
     protected javax.swing.JMenuItem edit;
     private javax.swing.JScrollPane jScrollPane1;
     protected javax.swing.JButton next;



From krater at mail.berlios.de  Mon Jul 31 11:09:40 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 11:09:40 +0200
Subject: [Plantlore-dev] r479 - in
	trunk/src/net/sf/plantlore/client/imports: . table
Message-ID: <200607310909.k6V99eVp030717@sheep.berlios.de>

Author: krater
Date: 2006-07-31 11:09:36 +0200 (Mon, 31 Jul 2006)
New Revision: 479

Modified:
   trunk/src/net/sf/plantlore/client/imports/ImportMng.java
   trunk/src/net/sf/plantlore/client/imports/table/TableImportMngCtrl.java
Log:
Minor changes of files affected by the change of the name (XFilter to FileFormat).

Modified: trunk/src/net/sf/plantlore/client/imports/ImportMng.java
===================================================================
--- trunk/src/net/sf/plantlore/client/imports/ImportMng.java	2006-07-31 09:07:36 UTC (rev 478)
+++ trunk/src/net/sf/plantlore/client/imports/ImportMng.java	2006-07-31 09:09:36 UTC (rev 479)
@@ -15,7 +15,7 @@
 
 import org.apache.log4j.Logger;
 
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.client.imports.Parser.Action;
 import net.sf.plantlore.client.imports.parsers.*;
 import net.sf.plantlore.common.exception.ImportException;
@@ -50,9 +50,9 @@
 	/**
 	 * List of all filters the Export Manager is capable to handle.
 	 */
-	protected XFilter[] formats = new XFilter[] {
-			new XFilter(L10n.getString("Format.XML"), true, true, ".xml"),
-			new XFilter(L10n.getString("Format.PlantloreNative"), false, false, ".xml", ".pln"),
+	protected FileFormat[] formats = new FileFormat[] {
+			new FileFormat(L10n.getString("Format.XML"), true, true, ".xml"),
+			new FileFormat(L10n.getString("Format.PlantloreNative"), false, false, ".xml", ".pln"),
 	};
 	
 	
@@ -207,8 +207,8 @@
 		
 		// Create a new parser according to the format.
 		// The format is guessed based on the extension.
-		XFilter format = null;
-		for(XFilter f : formats)
+		FileFormat format = null;
+		for(FileFormat f : formats)
 			if( f.accept(file) ) {
 				format = f;
 				break;
@@ -520,7 +520,7 @@
 	/**
 	 * @return The list of filters describing formats this Import Manager can handle.
 	 */
-	public XFilter[] getFilters() {
+	public FileFormat[] getFilters() {
 		return formats.clone();
 	}
 

Modified: trunk/src/net/sf/plantlore/client/imports/table/TableImportMngCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/imports/table/TableImportMngCtrl.java	2006-07-31 09:07:36 UTC (rev 478)
+++ trunk/src/net/sf/plantlore/client/imports/table/TableImportMngCtrl.java	2006-07-31 09:09:36 UTC (rev 479)
@@ -4,7 +4,7 @@
 import javax.swing.JOptionPane;
 
 import net.sf.plantlore.client.AppCoreView;
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.common.Task;
 import net.sf.plantlore.l10n.L10n;
 
@@ -20,7 +20,7 @@
 		this.view = view;
 		choice = new JFileChooser();
 		choice.setAcceptAllFileFilterUsed(false);
-		choice.addChoosableFileFilter( new XFilter("Table update files (*.xml)", ".xml") );
+		choice.addChoosableFileFilter( new FileFormat("Table update files (*.xml)", ".xml") );
 	}
 	
 	public void setVisible(boolean visible) {



From krater at mail.berlios.de  Mon Jul 31 11:24:24 2006
From: krater at mail.berlios.de (krater at mail.berlios.de)
Date: Mon, 31 Jul 2006 11:24:24 +0200
Subject: [Plantlore-dev] r480 - trunk/src/net/sf/plantlore/l10n
Message-ID: <200607310924.k6V9OOYG001418@sheep.berlios.de>

Author: krater
Date: 2006-07-31 11:24:23 +0200 (Mon, 31 Jul 2006)
New Revision: 480

Modified:
   trunk/src/net/sf/plantlore/l10n/Plantlore.properties
Log:
Updated (language) strings.

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-07-31 09:09:36 UTC (rev 479)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-07-31 09:24:23 UTC (rev 480)
@@ -57,6 +57,7 @@
 Continue = C&ontinue
 ContinueTT = Continue with the operation 
 Common.Cancel=&Cancel
+Common.Canceled=The operation was canceled by the User.
 Close = Close
 Common.Help=&Help
 defaultLang = Default system language
@@ -364,20 +365,20 @@
 Login.RemoveRecordTT = Remove the selected record (the database won't be deleted!).
 
 Login.Alias = Alias
-Login.AliasTT = The string that will be displayed to you.
+Login.AliasTT = The string that will be displayed to you in the Login dialog. Makes it easier to distinguish among all your database connections.
 Login.HostName = Hostname
 Login.HostNameTT = The name of the computer where the server dwells.
 Login.Database = Database
 Login.DatabaseTT = The database engine that contains the data.
 Login.DatabaseIdentifier = DB Id.
-Login.DatabaseIdentifierTT = The identifier of the database that is stored within the database engine.
+Login.DatabaseIdentifierTT = The identifier (name) of the database that is stored within the database engine.
 Login.DatabasePort = DB Port
 Login.DatabasePortTT = The port where the database engine listens.
 Login.Port = Port
 Login.PortTT = The port where the server listens.
 Login.Parameter = Parameter
 Login.ParameterTT = Additional information required for the connection (such as encoding).
-Login.MasterUser = User
+Login.MasterUser = Master User
 Login.MasterUserTT = The database account this connection shall use.
 Login.MasterPassword = Password
 Login.MasterPasswordTT = The password to the database account.
@@ -406,9 +407,9 @@
 Login.SelectAutomatically = Select automatically.
 
 Login.Connecting = Connecting to the server...
-Login.Connected = Connection successful.
-Login.InitializingDBLayer = Initializing database connection...
-Login.DBLayerInitialized = Database connection successful.
+Login.Connected = Connected!
+Login.InitializingDBLayer = Forging db connection...
+Login.DBLayerInitialized = Connected!
 Login.Failed = Login failed!
 
 
@@ -679,6 +680,7 @@
 Error.MissingFileName = The file name was not specified.
 Error.MissingUserName = You forget to enter the account name.
 Error.MissingCompulsoryFieldTitle = Missing compulsory field
+Error.MissingSeveralCompulsoryFields = Some compulsory fields are missing.\nIn order to proceed, you must fill them.
 Error.MissingCompulsoryField = is a compulsory field. Please fill in it.
 Error.WriterNotCreated = Unable to create the output file writer.
 Error.NothingSelected = Nothing is selected.
@@ -1279,3 +1281,12 @@
 Settings.General.OverviewPanel=Overview
 
 Settings.General.DynamicPageLoading=Determine number of records per page dynamically
+Login.LocalDatabase=Direct connection (local)
+Login.RemoteDabatase=Remote connection
+
+Login.DatabaseEngine=Database Engine
+
+Login.DatabaseParameter=DB Parameter
+
+Login.DatabaseEngineTT=The database engine that holds the database. 
+Login.DatabaseParameterTT=Additional information you may wish to use for the connection (such as encoding).



