<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r476 - in trunk/src/net/sf/plantlore/client/export:	. builders component
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r476%20-%20in%20trunk/src/net/sf/plantlore/client/export%3A%0A%09.%20builders%20component&In-Reply-To=%3C200607310859.k6V8xvnX029887%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000620.html">
   <LINK REL="Next"  HREF="000622.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r476 - in trunk/src/net/sf/plantlore/client/export:	. builders component</H1>
    <B>krater at mail.berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r476%20-%20in%20trunk/src/net/sf/plantlore/client/export%3A%0A%09.%20builders%20component&In-Reply-To=%3C200607310859.k6V8xvnX029887%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r476 - in trunk/src/net/sf/plantlore/client/export:	. builders component">krater at mail.berlios.de
       </A><BR>
    <I>Mon Jul 31 10:59:57 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000620.html">[Plantlore-dev] r475 - trunk/src/net/sf/plantlore/client
</A></li>
        <LI>Next message: <A HREF="000622.html">[Plantlore-dev] r477 - in trunk/src/net/sf/plantlore/client/export:	. component
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#621">[ date ]</a>
              <a href="thread.html#621">[ thread ]</a>
              <a href="subject.html#621">[ subject ]</a>
              <a href="author.html#621">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: krater
Date: 2006-07-31 10:59:55 +0200 (Mon, 31 Jul 2006)
New Revision: 476

Added:
   trunk/src/net/sf/plantlore/client/export/ExportMng2.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
   trunk/src/net/sf/plantlore/client/export/ExportTask2.java
   trunk/src/net/sf/plantlore/client/export/Projection.java
   trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
   trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
   trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
   trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
Modified:
   trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
   trunk/src/net/sf/plantlore/client/export/Builder.java
   trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
   trunk/src/net/sf/plantlore/client/export/ExportMng.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
   trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
   trunk/src/net/sf/plantlore/client/export/ExportTask.java
   trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java
   trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
Log:
The Export uses the Task/ProgressBar classes now (which lead to a simplification of the code).

The XMLBuilder can handle files of any size now. The other builders are to be refined yet.

The class Template was renamed to Projection (because the name adheres better with the purpose of this class). And so were the XFilter renamed to FileFormat, XTree to ExtendedTree, and XNode to UserTreeNode.

Modified: trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -23,7 +23,7 @@
 	/** For an invocation of parameterless methods. */
 	protected static final Object[] NO_PARAMETERS = new Object[0];
 	
-	protected Template template;
+	protected Projection template;
 	
 	
 	/**
@@ -31,7 +31,7 @@
 	 * 
 	 * @param template The template describing which columns are selected.
 	 */
-	public AbstractBuilder(Template template) {
+	public AbstractBuilder(Projection template) {
 		setTemplate(template);
 	}
 	
@@ -41,14 +41,14 @@
 	 *  
 	 * @param template The new template. &lt;b&gt;Mustn't be &lt;i&gt;null&lt;/i&gt;&lt;/b&gt;.
 	 */
-	public void setTemplate(Template template) {
+	public void setTemplate(Projection template) {
 		this.template = (template == null) ? null : template.clone();
 	}
 	
 	/**
 	 * @return A clone of the template this Builder currently uses.
 	 */
-	public Template getTemplate() {
+	public Projection getTemplate() {
 		return (template == null) ? null : template.clone();
 	}
 	

Modified: trunk/src/net/sf/plantlore/client/export/Builder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Builder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/Builder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -13,7 +13,6 @@
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-21
  * @version 1.0
- * @see net.sf.plantlore.client.export.DefaultDirector
  */
 public interface Builder {
 		

Modified: trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -47,6 +47,7 @@
  * @see net.sf.plantlore.client.export.Builder
  * @see net.sf.plantlore.middleware.DBLayer
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class DefaultDirector extends Observable implements Runnable {
 	
 	private Logger logger = Logger.getLogger(getClass().getPackage().getName());

Modified: trunk/src/net/sf/plantlore/client/export/ExportMng.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -12,7 +12,7 @@
 import java.util.Set;
 
 import net.sf.plantlore.client.export.builders.*;
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.common.Selection;
 import net.sf.plantlore.common.exception.ExportException;
 import net.sf.plantlore.l10n.L10n;
@@ -38,7 +38,7 @@
  * &lt;li&gt;&lt;b&gt;Selection&lt;/b&gt; stores the list of all selected records 
  * 					(&lt;i&gt;restriction&lt;/i&gt; in the database terminology).&lt;/li&gt;
  * &lt;li&gt;&lt;b&gt;SelectQuery&lt;/b&gt; identifies the result set as well (in fact the resultId is derived from it).&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;Template&lt;/b&gt; stores the list of all selected columns that should be 
+ * &lt;li&gt;&lt;b&gt;Projection&lt;/b&gt; stores the list of all selected columns that should be 
  * 					exported (&lt;i&gt;projection&lt;/i&gt; in the database terminology).&lt;/li&gt;
  * &lt;li&gt;&lt;b&gt;File&lt;/b&gt; stores the name of file as the user has suggested it.&lt;/li&gt;
  * &lt;li&gt;&lt;b&gt;XFilter&lt;/b&gt; suggests the final name of the &lt;i&gt;file&lt;/i&gt;
@@ -52,6 +52,7 @@
  * @see net.sf.plantlore.client.export.DefaultDirector
  * @see net.sf.plantlore.client.export.Builder
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportMng implements Observer {
 	
 	
@@ -61,21 +62,21 @@
 	/**
 	 * List of all filters the Export Manager is capable to handle.
 	 */
-	protected XFilter[] filters = new XFilter[] {
-			new XFilter(L10n.getString(&quot;Format.PlantloreNative&quot;), false, false, &quot;.xml&quot;, &quot;.pln&quot;),
-			new XFilter(L10n.getString(&quot;Format.XML&quot;), true, true, &quot;.xml&quot;),
-			new XFilter(L10n.getString(&quot;Format.CSV&quot;), true, true, &quot;.txt&quot;, &quot;.csv&quot;),	
-			new XFilter(L10n.getString(&quot;Format.ABCD&quot;), &quot;.xml&quot;),	
-			new XFilter(L10n.getString(&quot;Format.DC&quot;), &quot;.xml&quot;),
-			new XFilter(L10n.getString(&quot;Format.StdOut&quot;), true, false, &quot;.out&quot;)
+	protected FileFormat[] filters = new FileFormat[] {
+			new FileFormat(L10n.getString(&quot;Format.PlantloreNative&quot;), false, false, &quot;.xml&quot;, &quot;.pln&quot;),
+			new FileFormat(L10n.getString(&quot;Format.XML&quot;), true, true, &quot;.xml&quot;),
+			new FileFormat(L10n.getString(&quot;Format.CSV&quot;), true, true, &quot;.txt&quot;, &quot;.csv&quot;),	
+			new FileFormat(L10n.getString(&quot;Format.ABCD&quot;), &quot;.xml&quot;),	
+			new FileFormat(L10n.getString(&quot;Format.DC&quot;), &quot;.xml&quot;),
+			new FileFormat(L10n.getString(&quot;Format.StdOut&quot;), true, false, &quot;.out&quot;)
 	};
 	
 	
 	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
 	private DBLayer db ;
-	private Template template;
+	private Projection template;
 	private Selection selection;
-	private XFilter filter;
+	private FileFormat filter;
 	private String filename;
 	private SelectQuery query = null;
 	private boolean useProjections = false;
@@ -90,7 +91,7 @@
 	 * @param selection	The list of selected records. 
 	 * @param template	The list of selected columns. &lt;b&gt;Null means everything is selected.&lt;/b&gt;
 	 */
-	public ExportMng(DBLayer dblayer, SelectQuery query, Selection selection, Template template) 
+	public ExportMng(DBLayer dblayer, SelectQuery query, Selection selection, Projection template) 
 	throws ExportException, DBLayerException, RemoteException {
 		this(dblayer, query, selection, template, null, null, false, null);
 	}
@@ -138,8 +139,8 @@
 			DBLayer dblayer, 
 			SelectQuery query, 
 			Selection selection, 
-			Template template, 
-			XFilter filter, 
+			Projection template, 
+			FileFormat filter, 
 			String filename,
 			boolean useProjections,
 			Class rootTable) 
@@ -188,7 +189,7 @@
 	 * Store a copy of the &lt;code&gt;template&lt;/code&gt;. 
 	 * Null means all columns are selected.
 	 */
-	synchronized public void setTemplate(Template template) {
+	synchronized public void setTemplate(Projection template) {
 		if(template == null)
 			this.template = null;
 		else 
@@ -212,7 +213,7 @@
 	 * and to create a correct Builder (for the format this
 	 * filter represents). 
 	 */
-	synchronized public void setActiveFileFilter(XFilter filter) {
+	synchronized public void setActiveFileFilter(FileFormat filter) {
 		this.filter = filter; 
 	}
 	
@@ -234,7 +235,7 @@
 	synchronized public void setSelectQuery(SelectQuery query) { 
 		// Close the previous query!
 		if(this.query != null) try {
-			db.closeQuery(this.query); 
+			db.closeQuery(this.query);  // This must go here because of the RMI!
 		} catch (RemoteException e) {
 			// Never mind.
 		}
@@ -270,7 +271,7 @@
 		if( useProjections &amp;&amp; rootTable == null)
 			throw new ExportException(L10n.getString(&quot;Error.InvalidRootTable&quot;));
 		if(template == null || template.isEmpty())
-			template = new Template().setEverything();
+			template = new Projection().setEverything();
 		if(selection == null || selection.isEmpty())
 			selection = new Selection().all();
 			
@@ -311,8 +312,8 @@
 		else if(filter.getDescription().equals(L10n.getString(&quot;Format.ABCD&quot;))) 
 			builder = new ABCDBuilder(writer);
 		else if(filter.getDescription().equals(L10n.getString(&quot;Format.XML&quot;)))                        
-			builder = new XMLBuilder(template, writer);                       
-                else if(filter.getDescription().equals(L10n.getString(&quot;Format.PlantloreNative&quot;)))                        
+			builder = new XMLBuilder2(template, writer);                       
+		else if(filter.getDescription().equals(L10n.getString(&quot;Format.PlantloreNative&quot;)))                        
 			builder = new XMLBuilder(writer);                       
 		else {
 			builder = new TrainingBuilder(template);
@@ -364,7 +365,7 @@
 	/**
 	 * @return The list of filters describing formats this Export Manager can handle.
 	 */
-	public XFilter[] getFilters() {
+	public FileFormat[] getFilters() {
 		return filters.clone();
 	}
 

Added: trunk/src/net/sf/plantlore/client/export/ExportMng2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,368 @@
+package net.sf.plantlore.client.export;
+
+import java.io.BufferedWriter;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.OutputStreamWriter;
+import java.io.Writer;
+import java.rmi.RemoteException;
+import java.util.HashSet;
+import java.util.Observable;
+import java.util.Observer;
+import java.util.Set;
+
+import net.sf.plantlore.client.export.builders.*;
+import net.sf.plantlore.client.export.component.FileFormat;
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.exception.ExportException;
+import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.middleware.SelectQuery;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.common.record.*;
+
+import org.apache.log4j.Logger;
+
+/**
+ * The Export Manager. This class controls the whole process of export -
+ * starting with creation of all necessary participants
+ * and ending with the final cleanup. 
+ * &lt;br/&gt;
+ * There are several entities involved in the export:
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;b&gt;DBLayer&lt;/b&gt; the database layer that will carry out the requests.
+ * 					Mustn't be null!&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Director&lt;/b&gt; iterates over the &lt;i&gt;result set&lt;/i&gt; 
+ * 					and &lt;i&gt;selected records&lt;/i&gt; passes to the &lt;i&gt;builder&lt;/i&gt;,&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Builder&lt;/b&gt; writes the records to the &lt;i&gt;output&lt;/i&gt;.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Selection&lt;/b&gt; stores the list of all selected records 
+ * 					(&lt;i&gt;restriction&lt;/i&gt; in the database terminology).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;SelectQuery&lt;/b&gt; identifies the result set as well (in fact the resultId is derived from it).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Projection&lt;/b&gt; stores the list of all selected columns that should be 
+ * 					exported (&lt;i&gt;projection&lt;/i&gt; in the database terminology).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;File&lt;/b&gt; stores the name of file as the user has suggested it.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;XFilter&lt;/b&gt; suggests the final name of the &lt;i&gt;file&lt;/i&gt;
+ * 					and is used to determine which &lt;i&gt;builder&lt;/i&gt; will be used
+ * 					to produce the output.&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29 
+ * @version 2.0
+ * @see net.sf.plantlore.client.export.Builder
+ */
+public class ExportMng2 implements Observer {
+	
+	
+	public static final String ENCODING = &quot;UTF-8&quot;;
+	
+	
+	/**
+	 * List of all filters the Export Manager is capable to handle.
+	 */
+	protected FileFormat[] filters = new FileFormat[] {
+			new FileFormat(L10n.getString(&quot;Format.PlantloreNative&quot;), false, false, &quot;.xml&quot;, &quot;.pln&quot;),
+			new FileFormat(L10n.getString(&quot;Format.XML&quot;), true, true, &quot;.xml&quot;),
+			new FileFormat(L10n.getString(&quot;Format.CSV&quot;), true, true, &quot;.txt&quot;, &quot;.csv&quot;),	
+			new FileFormat(L10n.getString(&quot;Format.ABCD&quot;), &quot;.xml&quot;),	
+			new FileFormat(L10n.getString(&quot;Format.DC&quot;), &quot;.xml&quot;),
+			new FileFormat(L10n.getString(&quot;Format.StdOut&quot;), true, false, &quot;.out&quot;)
+	};
+	
+	
+	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
+	private DBLayer db ;
+	private Projection template;
+	private Selection selection;
+	private FileFormat filter;
+	private String filename;
+	private SelectQuery query = null;
+	private boolean useProjections = false;
+	private Class rootTable = Occurrence.class;
+	
+	
+	/**
+	 * Create a new Export Manager.
+	 * 
+	 * @param dblayer The database layer mediating the access to the database.
+	 * @param query	The query defining the result set which is to be iterated over.
+	 * @param selection	The list of selected records. 
+	 * @param template	The list of selected columns. &lt;b&gt;Null means everything is selected.&lt;/b&gt;
+	 */
+	public ExportMng2(DBLayer dblayer, SelectQuery query, Selection selection, Projection template) 
+	throws ExportException, DBLayerException, RemoteException {
+		this(dblayer, query, selection, template, null, null, false, null);
+	}
+
+	
+	/**
+	 * Create a new Export manager.
+	 * &lt;b&gt;Mark all records AND columns as selected&lt;/b&gt;.
+	 * &lt;b&gt;You will have to specify the SelectQuery&lt;/b&gt;
+	 * before you call &lt;code&gt;start()&lt;/code&gt;. 
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database.
+	 */
+	public ExportMng2(DBLayer dblayer) 
+	throws ExportException {
+		setDBLayer(dblayer);
+		setSelection(null);
+	}
+	
+	/**
+	 * Create a new Export manager and &lt;b&gt;mark all records AND columns as selected&lt;/b&gt;.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database.
+	 * @param query	The query defining the result set which is to be iterated over.
+	 */
+	public ExportMng2(DBLayer dblayer, SelectQuery query) 
+	throws ExportException, DBLayerException, RemoteException {
+		this(dblayer, query, null, null, null, null, false, null);
+	}
+	
+	
+	/**
+	 * Create a new Export manager.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database. Shouldn't be empty.
+	 * @param query	The query defining the result set which is to be iterated over. Shouldn't be empty.
+	 * @param selection	The list of selected records. Shouldn't be empty.
+	 * @param template	The list of selected columns. &lt;b&gt;Null means everything is selected.&lt;/b&gt;
+	 * @param filter	The filter which will be used to determine the appropriate builder of the output.
+	 * @param file	The name of the file where the output will be written.
+	 * @param useProjections	Should projections be used.
+	 * @param rootTable	The root table (only if projections are used).
+	 */
+	public ExportMng2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Selection selection, 
+			Projection template, 
+			FileFormat filter, 
+			String filename,
+			boolean useProjections,
+			Class rootTable) 
+	throws ExportException, DBLayerException, RemoteException  {
+		useProjections( useProjections );
+		setRootTable( rootTable );
+		setDBLayer(dblayer);
+		setSelectQuery(query);
+		setSelection(selection);
+		setTemplate(template);
+		setSelectedFile(filename);
+		setActiveFileFilter(filter);
+	}
+	
+	
+	/**
+	 * @param useProjections	True if the Export manager shall use projections instead of regular records.
+	 */
+	synchronized public void useProjections(boolean useProjections) {
+		this.useProjections = useProjections;
+	}
+	
+	/**
+	 * If projections are used, the root table must be specified explicitely.
+	 * The default root table is the Occurrence table.
+	 * 
+	 * @param rootTable	The root table (the table the query started with). 
+	 */
+	synchronized public void setRootTable(Class rootTable) {
+		this.rootTable = rootTable;
+	}
+	
+	/**
+	 * Set a new DBLayer.
+	 */
+	synchronized public void setDBLayer(DBLayer dblayer) {
+		if(query != null) try {
+			db.closeQuery(query);
+		} catch(RemoteException e) {
+			// Never mind.
+		}
+		db = dblayer;
+	}
+	
+	/**
+	 * Store a copy of the &lt;code&gt;template&lt;/code&gt;. 
+	 * Null means all columns are selected.
+	 */
+	synchronized public void setTemplate(Projection template) {
+		if(template == null)
+			this.template = null;
+		else 
+			this.template = template.clone();
+	}
+	
+	/**
+	 * Store a copy of the &lt;code&gt;selection&lt;/code&gt;.
+	 * Null means all rows are selected.
+	 */
+	synchronized public void setSelection(Selection selection) {
+		if(selection == null)
+			this.selection = null;
+		else 
+			this.selection = selection.clone();
+	}
+	
+	/**
+	 * Set the active filter. The type of the filter will be used 
+	 * to determine the appropriate extension of the file
+	 * and to create a correct Builder (for the format this
+	 * filter represents). 
+	 */
+	synchronized public void setActiveFileFilter(FileFormat filter) {
+		this.filter = filter; 
+	}
+	
+	/**
+	 * Set the selected file. Into this file the builder will 
+	 * spit its output. 
+	 */
+	synchronized public void setSelectedFile(String filename) { 
+		this.filename = filename; 
+	}
+	
+	
+	/**
+	 * Set a particular select query. The manager will execute this select query
+	 * and update the &lt;code&gt;resultId&lt;/code&gt; if Projections are not used.
+	 * On the other hand, if Projections are used, it is the &lt;code&gt;setTemplate()&lt;/code&gt;
+	 * that executes the query after it adds desired projections.
+	 */
+	synchronized public void setSelectQuery(SelectQuery query) { 
+		// Close the previous query!
+		if(this.query != null) try {
+			db.closeQuery(this.query);  // This must go here because of the RMI!
+		} catch (RemoteException e) {
+			// Never mind.
+		}
+		this.query = query;
+	}
+	
+	
+	
+	
+	
+	private Set&lt;ExportTask2&gt; exportTasks = new HashSet&lt;ExportTask2&gt;(8);
+	
+	
+	/**
+	 * Start the export procedure. The export will run in its own thread.
+	 * 
+	 * @throws ExportException	If information provided is not complete.
+	 * @throws IOException	If anything with the file goes wrong (insufficient disk space, insufficient permissions).
+	 */
+	synchronized public ExportTask2 createExportTask() 
+	throws ExportException, IOException, DBLayerException {
+		if( exportTasks.size() &gt; 4 )
+			throw new ExportException(L10n.getString(&quot;Error.TooManyTasks&quot;));
+		// Check if all necessary components are valid.
+		if( db == null )
+			throw new ExportException(L10n.getString(&quot;Error.InvalidDBLayer&quot;));
+		if( query == null)
+			throw new ExportException(L10n.getString(&quot;Error.InvalidQuery&quot;));
+		if( filter == null ) 
+			throw new ExportException(L10n.getString(&quot;Error.InvalidFilter&quot;));
+		if( filename == null || filename.length() == 0 ) 
+			throw new ExportException(L10n.getString(&quot;Error.MissingFileName&quot;));
+		if( useProjections &amp;&amp; rootTable == null)
+			throw new ExportException(L10n.getString(&quot;Error.InvalidRootTable&quot;));
+		if(template == null || template.isEmpty())
+			template = new Projection().setEverything();
+		if(selection == null || selection.isEmpty())
+			selection = new Selection().all();
+			
+		
+		logger.debug(&quot;Initializing the export environment.&quot;);
+		
+		// Prepare the query for projections.
+		if(useProjections) {
+			if( rootTable == AuthorOccurrence.class || rootTable == Author.class )
+				template.addProjections( query, AuthorOccurrence.class, Author.class );
+			else
+				template.addProjections( query, 
+					Occurrence.class, Plant.class, Metadata.class, Publication.class, 
+					Habitat.class, Territory.class, Village.class, Phytochorion.class );
+		}
+		
+		// Create a new file and writer (wrapper).
+		Writer writer = new BufferedWriter(
+					new OutputStreamWriter(new FileOutputStream(filter.suggestName(filename)),
+					ENCODING));
+		if(writer == null) {
+			logger.fatal(&quot;Unable to create a new Writer.&quot;);
+			throw new ExportException(L10n.getString(&quot;Error.WriterNotCreated&quot;));
+		}
+		
+		logger.debug(&quot;Filename: &quot;+ filename);
+		
+		// Create a new builder according to the selected format. 
+		Builder builder;
+		if(filter.getDescription().equals(L10n.getString(&quot;Format.CSV&quot;)))
+			builder = new CSVBuilder(writer, template);
+		else if(filter.getDescription().equals(L10n.getString(&quot;Format.DC&quot;)))                        
+			builder = new DarwinCoreBuilder(writer);
+		else if(filter.getDescription().equals(L10n.getString(&quot;Format.ABCD&quot;))) 
+			builder = new ABCDBuilder(writer);
+		else if(filter.getDescription().equals(L10n.getString(&quot;Format.XML&quot;)))                        
+			builder = new XMLBuilder2(template, writer);                       
+		else if(filter.getDescription().equals(L10n.getString(&quot;Format.PlantloreNative&quot;)))                        
+			builder = new XMLBuilder2(writer);                       
+		else {
+			builder = new TrainingBuilder(template);
+		}
+
+		
+		// Start a new task.
+		ExportTask2 t = new ExportTask2(db, query, writer, builder, selection);
+		t.ignoreDead( filter.ignoreDead() );
+		/*exportTasks.add(t);
+		t.addObserver(this);*/
+		
+		// Reset variables.
+		query = null;
+		template = null;
+		selection = null;
+		filter = null;
+		filename = null;
+		useProjections = false;
+		rootTable = Occurrence.class;
+		
+		return t;
+	}
+	
+	
+		
+	/**
+	 * Abort every running Export. 
+	 */
+	synchronized public void abortAllTasks() {
+		for(ExportTask2 task : exportTasks) {
+			task.kill();
+			task.deleteObserver(this);
+		}
+		exportTasks.clear();
+	}
+	
+	
+	synchronized public boolean isAnExportInProgress() {
+		return exportTasks.size() != 0;
+	}
+	
+	/**
+	 * @return The list of filters describing formats this Export Manager can handle.
+	 */
+	public FileFormat[] getFileFormats() {
+		return filters.clone();
+	}
+
+
+	synchronized public void update(Observable source, Object arg) {
+		if( !((ExportTask)source).isExportInProgress() ) {
+			exportTasks.remove( source );
+			source.deleteObserver(this);
+		}
+	}
+	
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,84 @@
+package net.sf.plantlore.client.export;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+import javax.swing.JFileChooser;
+import javax.swing.JOptionPane;
+import javax.swing.filechooser.FileFilter;
+
+import net.sf.plantlore.client.AppCoreView;
+import net.sf.plantlore.client.export.component.FileFormat;
+import net.sf.plantlore.common.DefaultProgressBarEx;
+import net.sf.plantlore.l10n.L10n;
+
+public class ExportMngCtrl2 {
+	
+	
+	private ExportMng2 model;
+	private AppCoreView parentView;
+	private JFileChooser choice;
+	
+	private ExportMngViewB viewB;
+
+	
+	public ExportMngCtrl2(ExportMng2 model, AppCoreView view) {
+		this.model = model; 
+		this.parentView = view;
+		
+		viewB = new ExportMngViewB(view);
+		viewB.next.setAction( new NextAction() );
+		choice = new JFileChooser();
+		choice.setAcceptAllFileFilterUsed(false);
+		for( FileFilter filter: model.getFileFormats() )
+			choice.addChoosableFileFilter(filter);
+	}
+	
+	
+	public void setVisible(boolean visible) {
+		if(visible) {
+			// The dialog must have a parent so that it is displayed correctly after ALT+TAB is pressed.
+			int result = choice.showDialog(parentView, L10n.getString(&quot;Export.Title&quot;));
+			if( result == JFileChooser.APPROVE_OPTION ) {
+				model.setSelectedFile( choice.getSelectedFile().getAbsolutePath() );
+				FileFormat filter = (FileFormat) choice.getFileFilter();
+				model.setActiveFileFilter( filter );
+				
+				if( filter.isColumnSelectionEnabled() )
+					viewB.setVisible(true);
+				else 
+					performExport();
+			}
+		}
+	}
+	
+	
+	private class NextAction extends AbstractAction {
+		public NextAction() {
+			putValue(NAME, L10n.getString(&quot;Export.Title&quot;));
+		}
+		public void actionPerformed(ActionEvent arg0) {
+			Projection t = viewB.tsm.getTemplate();
+			viewB.setVisible(false);
+			model.setTemplate( t ); // Set the new template.
+			viewB.tsm.clearSelection();
+			
+			performExport();
+		}
+	}
+
+	
+	private void performExport() {
+		try {
+			ExportTask2 export = model.createExportTask();
+			new DefaultProgressBarEx(export, parentView, false);
+			export.start();
+		} catch(Exception e) {
+			JOptionPane.showMessageDialog(null,
+					e.getMessage(),
+					L10n.getString(&quot;Export.Failed&quot;),
+					JOptionPane.WARNING_MESSAGE);
+		}
+	}
+
+}

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -5,9 +5,10 @@
 import javax.swing.filechooser.FileFilter;
 
 import net.sf.plantlore.client.AppCoreView;
-import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.client.export.component.FileFormat;
 import net.sf.plantlore.l10n.L10n;
 
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportMngCtrlA {
 	
 	
@@ -49,7 +50,7 @@
 				}
 				
 				model.setSelectedFile( choice.getSelectedFile().getAbsolutePath() );
-				XFilter filter = (XFilter) choice.getFileFilter();
+				FileFormat filter = (FileFormat) choice.getFileFilter();
 				model.setActiveFileFilter( filter );
 				
 				if( filter.isColumnSelectionEnabled() )

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 
 
 //import net.sf.plantlore.l10n.L10n;
-
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportMngCtrlB {
 	
 	private ExportMng model;
@@ -27,7 +27,7 @@
 	
 	class Next extends AbstractAction {
 		public void actionPerformed(ActionEvent arg0) {
-			Template t = view.tsm.getTemplate();
+			Projection t = view.tsm.getTemplate();
 			view.setVisible(false);
 			
 			

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 import java.awt.Frame;
 
 import net.sf.plantlore.client.export.component.TemplateSelectionModel;
-import net.sf.plantlore.client.export.component.XTree;
+import net.sf.plantlore.client.export.component.ExtendedTree;
 import net.sf.plantlore.l10n.L10n;
 
 /**
@@ -24,7 +24,7 @@
     public ExportMngViewB(Frame parent) {
     	super(parent, true);
     	
-    	tsm = new TemplateSelectionModel();
+    	tsm = new TemplateSelectionModel( new Projection() );
     	
         initComponents();
         getRootPane().setDefaultButton(next);
@@ -39,7 +39,7 @@
     // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot; Generated Code &quot;&gt;//GEN-BEGIN:initComponents
     private void initComponents() {
         jScrollPane1 = new javax.swing.JScrollPane();
-        tree = new XTree();
+        tree = new ExtendedTree();
         next = new javax.swing.JButton();
 
         setTitle(L10n.getString(&quot;Export.SelectColumns&quot;));

Modified: trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,6 +9,7 @@
 
 //import net.sf.plantlore.l10n.L10n;
 
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportProgressCtrl {
 	
 	private ExportTask model;

Modified: trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -16,6 +16,7 @@
  *
  * @author  Erik Kratochv&#237;l
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportProgressView extends javax.swing.JFrame implements Observer {
 	
 	private ExportTask model;

Modified: trunk/src/net/sf/plantlore/client/export/ExportTask.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportTask.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportTask.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -9,7 +9,7 @@
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
 
-
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ExportTask extends Observable implements Observer {
 	
 	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());

Added: trunk/src/net/sf/plantlore/client/export/ExportTask2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,215 @@
+package net.sf.plantlore.client.export;
+
+import java.io.IOException;
+import java.io.Writer;
+import java.rmi.RemoteException;
+import java.util.List;
+
+import org.apache.log4j.Logger;
+
+import net.sf.plantlore.common.Pair;
+import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.Task;
+import net.sf.plantlore.common.exception.DBLayerException;
+import net.sf.plantlore.common.exception.ExportException;
+import net.sf.plantlore.common.record.AuthorOccurrence;
+import net.sf.plantlore.common.record.Occurrence;
+import net.sf.plantlore.common.record.Record;
+import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.middleware.SelectQuery;
+
+public class ExportTask2 extends Task {
+	
+private Logger logger = Logger.getLogger(getClass().getPackage().getName());
+	
+	private Builder build;
+	private Selection selection;
+	private DBLayer database;
+	private Integer resultId;
+	private boolean ignoreDead = true;
+	private boolean useProjections = false;
+	private List&lt;Pair&lt;Class, String&gt;&gt; description;
+	private SelectQuery query;
+	private Writer writer;
+	private Record torso;
+	
+	
+	
+	public ExportTask2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Writer writer, 
+			Builder builder, 
+			Selection selection) {
+		
+		this.database = dblayer;
+		this.query = query;
+		this.writer = writer;
+		this.selection = selection;
+		this.build = builder;
+	}
+	
+	// Pro pouziti s projekcema
+	public ExportTask2(
+			DBLayer dblayer, 
+			SelectQuery query, 
+			Writer writer, 
+			Builder builder, 
+			Selection selection,
+			List&lt;Pair&lt;Class, String&gt;&gt; description, 
+			Class rootTable) 
+	throws ExportException {
+		
+		this(dblayer, query, writer, builder, selection);
+		this.useProjections = true;
+		this.description = description;
+		try { 
+			torso = (Record)rootTable.newInstance();
+			torso.createTorso();
+		} catch (Exception e) {
+			throw new ExportException(L10n.getString(&quot;Error.InternalError&quot;));
+		}
+	}
+	
+	public ExportTask2 ignoreDead(boolean ignore) {
+		this.ignoreDead = ignore;
+		return this;
+	}
+
+	@Override
+	public Object task() throws Exception {
+		try {
+			logger.info(&quot;Export begins...&quot;);
+			setStatusMessage(L10n.getString(&quot;Export.Initializing&quot;));
+			
+			resultId = database.executeQuery( query );
+			
+			build.header();
+			
+			// Iterate over the result of the query.
+			int rows = database.getNumRows( resultId ),
+			expectedNumberOfRecords = selection.size( rows ),
+			count = 0;
+			
+			if(expectedNumberOfRecords &gt; 0)
+				setLength(expectedNumberOfRecords);
+			
+			for(int i = 0; i &lt; rows &amp;&amp; !isCanceled() &amp;&amp; count &lt; expectedNumberOfRecords; i++) {
+				
+				logger.debug(&quot;Fetching a new record from the database.&quot;);
+				
+				Record record;
+				if(useProjections) 
+					record = reconstruct( (Object[])database.more( resultId, i, i )[0] );
+				else
+					record = (Record)((Object[])database.more( resultId, i, i )[0])[0];
+				
+				
+				logger.debug(&quot;New record No. &quot;+i+&quot; fetched: &quot;+record);
+				if( !selection.contains( record ) || (ignoreDead &amp;&amp; record.isDead()) ) 
+					continue; // Is the record selected?
+				
+				logger.debug(&quot;The record is in the selection. It will be exported.&quot;);
+				count++;
+				setStatusMessage(count + &quot; &quot; + L10n.getString(&quot;Export.RecordsExported&quot;));
+				setLength(count);
+				
+				build.startRecord();
+				
+				// Build this part of the record.
+				build.part( record );
+				
+				/* -----------------------------------------------------------
+				 * Deal with the one-to-many relationship
+				 * of Occurence -&gt; AuthorOccurence ~ Author
+				 * ----------------------------------------------------------- */
+				if( record instanceof Occurrence ) 
+					loadAssociatedAuthors( (Occurrence)record );
+				
+				build.finishRecord();
+				
+			}
+
+			build.footer();
+			logger.info(&quot;Export completed. &quot; + count + &quot; records sent to output. &quot;);
+			cleanup();
+		}
+		catch(Exception e) {
+			logger.error(&quot;Export ended prematurely: &quot;+e.getMessage());
+			cleanup();
+			throw e;
+		}
+		
+		return null;
+	}
+	
+	
+	
+	private void cleanup() {
+		try {
+			writer.close();
+		} catch(Exception e) { /* Never mind. */ }
+		try {
+			database.closeQuery( query );
+		} catch(Exception e) {/* Never mind. */}
+	}
+	
+	
+	
+	/**
+	 * Find all AuthorOccurrences associated with the &lt;code&gt;Occurrence&lt;/code&gt;
+	 * and send them to the Builder, too.
+	 * 
+	 * @param occurrence	The currently processed occurrence data.
+	 */
+	private void loadAssociatedAuthors(Occurrence occurrence) 
+	throws RemoteException, IOException, DBLayerException {
+		
+		logger.debug(&quot;Processing the associated information about Authors.&quot;);
+		
+		SelectQuery query = database.createQuery(AuthorOccurrence.class);
+		query.createAlias(AuthorOccurrence.OCCURRENCE, &quot;OCC&quot;);
+
+		// AuthorOccurrence.OCCURRENCE = Occurrence.ID  &amp;&amp;  Occurrence.ID = occ.getId()
+		query.addRestriction(PlantloreConstants.RESTR_EQ_PROPERTY, AuthorOccurrence.OCCURRENCE, &quot;OCC.&quot;+Occurrence.ID, null, null);
+		query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;OCC.&quot;+Occurrence.ID, null, occurrence.getId(), null);
+		int resultId = database.executeQuery( query );
+		
+		// Take all results and spit'em out.
+		int rows = database.getNumRows( resultId );
+		for(int i = 0; i &lt; rows; i++) {
+			logger.debug(&quot;Fetching associated data (Author, AuthorOccurrence).&quot;);
+			
+			Object[] pulp = database.more( resultId, i, i );
+			AuthorOccurrence ao = (AuthorOccurrence) ((Object[])pulp[0])[0];
+			ao.setOccurrence( null ); // cut off the way back to the occurrence
+			if(ao.isDead() &amp;&amp; ignoreDead) continue;
+			
+			logger.debug(&quot;New author-occurence record: &quot; + ao);
+			
+			build.part( ao );
+		}
+		database.closeQuery( query );
+		
+		logger.debug(&quot;Author-occurence processed.&quot;);
+	}
+	
+	
+	
+	/**
+	 * Reconstruct the record from the given values. 
+	 * 
+	 * @param values	Values of columns (in the same order as in the Description).
+	 * @return	The reconstructed record.
+	 */
+	private Record reconstruct(Object[] values) {
+		for(int i = 0; i &lt; description.size(); i++ ) {
+			Pair&lt;Class, String&gt; d = description.get(i);
+			torso.setValue(d.getFirst(), d.getSecond(), values[i]);
+		}
+		return torso;
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/Projection.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Projection.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/Projection.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,172 @@
+package net.sf.plantlore.client.export;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.List;
+
+import net.sf.plantlore.common.Pair;
+import net.sf.plantlore.common.record.*;
+import net.sf.plantlore.middleware.SelectQuery;
+import static net.sf.plantlore.common.PlantloreConstants.PROJ_PROPERTY;
+
+
+/**
+ * The template holds information about the selected columns and tables.
+ * This information may used by builders and access rights managers
+ * to decide, whether or not the currently
+ * considered column should be exported / is accessible.
+ * &lt;br/&gt;
+ * Note: The template doesn't know anything about the structure
+ * (mapping) of the database.  
+ * &lt;br/&gt;
+ * A little dictionary:
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;i&gt;foreign key&lt;/i&gt; a column of a table that refers to another table,&lt;/li&gt;
+ * &lt;li&gt;&lt;i&gt;property&lt;/i&gt; a column of a table that contains a (possibly null) value,
+ * but doesn't refer to another table&lt;/li&gt;
+ * &lt;li&gt;&lt;i&gt;nn&lt;/i&gt; a property that cannot be null (defined in the db model)&lt;/li&gt;
+ * &lt;/ul&gt;
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-22
+ * @version 1.1
+ */
+public class Projection {
+	
+	/** The list of all pairs Table.Column that are set. */
+	private Collection&lt;String&gt; columns = new HashSet&lt;String&gt;(100);
+	
+	
+
+	
+	/** Create a new template. */
+	public Projection() {/* Nothing to be done. Just to have a default constructor. */}
+	
+	/** A copy constructor. */
+	public Projection(Projection template) {
+		columns = new HashSet&lt;String&gt;( template.columns );
+	}
+	
+	
+	@Override
+	public Projection clone() {
+		return new Projection(this);
+	}
+	
+	
+	/** Select the &lt;code&gt;table.column&lt;/code&gt;. */
+	public Projection set(Class table, String column) { 
+		System.out.println(&quot;+ &quot;+table.getSimpleName()+&quot;.&quot;+column);
+		columns.add(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
+		return this;
+	}
+	
+	/** Unselect the &lt;code&gt;table.column&lt;/code&gt;. */
+	public Projection unset(Class table, String column) { 
+		System.out.println(&quot;- &quot;+table.getSimpleName()+&quot;.&quot;+column);
+		columns.remove(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
+		return this;
+	}
+	
+	/** @return true if the &lt;code&gt;table.column&lt;/code&gt; is set.*/
+	public boolean isSet(Class table, String column) {
+		return columns.contains(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
+	}
+	
+	/** Unselect all columns of all tables. */
+	public Projection unsetEverything() { 
+		columns.clear();
+		return this;
+	}
+	
+	/** Select all columns (properties) of all tables. */
+	public Projection setEverything() {
+		for(Class table : Record.BASIC_TABLES)
+			setAllProperties(table);
+		return this;
+	}
+	
+	/** Select all not null columns (properties). */
+	public void setEverythingNN() {
+		// Implementation missing!
+	}
+	
+	/** Select all properties of this &lt;code&gt;table&lt;/code&gt;. */
+	public Projection setAllProperties(Class table) {
+		try {
+			for( String column : ((Record)table.newInstance()).getProperties() )
+				set(table, column);
+		} catch(Exception e) {/* Not good :/. */}
+		return this;
+	}
+	
+	/** Select all not-null properties of the specified &lt;code&gt;table&lt;/code&gt;. */
+	public Projection setAllNN(Class table) {
+		try {
+			Record record = ((Record)table.newInstance());
+			List&lt;String&gt; nnProperties = record.getNN();
+			nnProperties.removeAll(record.getForeignKeys());
+			for( String column :  nnProperties )
+				set(table, column);
+		} catch(Exception e) {/* Not good. */}
+		return this;
+	}
+	
+	/**
+	 * @return true if nothing is selected.
+	 */
+	public boolean isEmpty() {
+		return columns.isEmpty();
+	}
+	
+		
+	/**
+	 * Match this template against another one.
+	 * 
+	 * @param t	The template against which the matching will be done.
+	 * @return	True if this template is a superset of the other template.
+	 */ 
+	public boolean match(Projection t) { 
+		return columns.containsAll(t.columns); 
+	}
+	
+	
+	private List&lt;Pair&lt;Class, String&gt;&gt; plan;
+	
+	public List&lt;Pair&lt;Class, String&gt;&gt; getDescription() {
+		return plan;
+	}
+	
+	/**
+	 * Add projections to the query according to the selected columns.
+	 * 
+	 * @param q	The query to be modified.
+	 * @param tables	The important tables. The first table is considered the root table.
+	 * @return The column description.
+	 */
+	public List&lt;Pair&lt;Class, String&gt;&gt; addProjections(SelectQuery q, Class...tables) {
+		plan = new ArrayList&lt;Pair&lt;Class,String&gt;&gt;(20);
+		for(int i = 0; i &lt; tables.length; i++)
+			addProjections(q, tables[i], i == 0);
+		return plan;
+	}
+	
+	
+	private void addProjections(SelectQuery q, Class table, boolean omitAlias) {
+		try {
+			Record r = (Record)table.newInstance();
+			for(String property : r.getProperties())
+				if( isSet(table, property) ) {
+					q.addProjection(PROJ_PROPERTY, (omitAlias ? property : Record.alias(table)+&quot;.&quot;+property));
+					plan.add(new Pair&lt;Class, String&gt;(table, property));
+				}
+		} catch(Exception e) {/* Not good. */}
+	}
+	
+	@Override
+	public String toString() {
+		return columns.toString();
+	}
+	
+}

Modified: trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/ABCDBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,7 +4,7 @@
 import java.io.Writer;
 import net.sf.plantlore.client.export.AbstractBuilder;
 import net.sf.plantlore.client.export.Builder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Metadata;
 import net.sf.plantlore.common.record.Occurrence;

Modified: trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -7,7 +7,7 @@
 import net.sf.plantlore.client.export.AbstractBuilder;
 import net.sf.plantlore.client.export.Builder;
 import net.sf.plantlore.common.record.*;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 
 /**
@@ -22,7 +22,7 @@
 public class CSVBuilder implements Builder {
 	
 	private Writer stream;
-	private Template template;
+	private Projection template;
 	
 	/** Is this the first column on this line? */
 	private boolean firstColumnOnThisLine;
@@ -52,7 +52,7 @@
 	 * @param output	The writer where the output will be sent.
 	 * @param tmp	The template that describes the selected columns and tables.
 	 */
-	public CSVBuilder(Writer output, Template tmp) {
+	public CSVBuilder(Writer output, Projection tmp) {
 		this.stream = output;
 		this.template = tmp;
 	}

Modified: trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -3,7 +3,7 @@
 import java.io.IOException;
 
 import net.sf.plantlore.client.export.AbstractBuilder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 /**
  * A training extension of the AbstractBuilder.
@@ -27,7 +27,7 @@
 	
 	private int i = 0;
 	
-	public TrainingBuilder(Template template) {
+	public TrainingBuilder(Projection template) {
 		super(template);
 	}
  

Modified: trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,7 +4,7 @@
 import java.io.Writer;
 
 import net.sf.plantlore.client.export.AbstractBuilder;
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 import net.sf.plantlore.common.record.*;
 import org.dom4j.Document;
 import org.dom4j.DocumentHelper;
@@ -36,9 +36,9 @@
      * 
      * @param template	Description of important attributes of  the whole record. 
      * @param writer	The writer that will create the file.
-     * @see net.sf.plantlore.client.export.Template
+     * @see net.sf.plantlore.client.export.Projection
      */
-    public XMLBuilder(Template template, Writer writer) {
+    public XMLBuilder(Projection template, Writer writer) {
     	super(template);
         document = DocumentHelper.createDocument();
         document.addElement(&quot;occurrences&quot;);
@@ -55,10 +55,10 @@
      * Every attribute (column) of the whole record will be exported.
      * 
      * @param writer	The writer that will create the file.
-     * @see net.sf.plantlore.client.export.Template
+     * @see net.sf.plantlore.client.export.Projection
      */
     public XMLBuilder(Writer writer) {
-    	this(new Template().setEverything(), writer);
+    	this(new Projection().setEverything(), writer);
     }
     
     /**

Added: trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,158 @@
+package net.sf.plantlore.client.export.builders;
+
+import java.io.IOException;
+import java.io.Writer;
+
+import org.dom4j.DocumentHelper;
+import org.dom4j.Element;
+import org.dom4j.io.OutputFormat;
+import org.dom4j.io.XMLWriter;
+
+import net.sf.plantlore.client.export.Builder;
+import net.sf.plantlore.client.export.Projection;
+import net.sf.plantlore.common.record.*;
+
+/**
+ * An improved version of the previous XMLBuilder. 
+ * This XMLBuilder is capable of creating files of virtually any size.
+ * The builder uses the Dom4j to create just one Occurrence element
+ * at a time; that element is written down when another Occurrence
+ * record arrives to be processed. 
+ * &lt;br/&gt;
+ * This way, the creation of an element is handled by the Dom4j 
+ * (all those necessary conversions 
+ * of &lt;code&gt;&gt;&lt;/code&gt; to &lt;code&gt;&amp;gt;&lt;/code&gt; etc.)
+ * &lt;br/&gt;
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-07-21
+ *
+ */
+public class XMLBuilder2 implements Builder {
+	
+    private Writer outputWriter;
+    private XMLWriter xmlWriter;
+    private Element element;
+    protected Projection template;
+    
+    /**
+     * Create a new XML Builder.
+     * The builder receives records (holder objects from the database)
+     * decomposes them, creates an XML node, and stores it in the specified
+     * file.
+     * &lt;br/&gt;
+     * The template holds the set of important attributes (columns) of the record
+     * that will be exported.
+     * 
+     * @param template	Description of important attributes of  the whole record. 
+     * @param writer	The writer that will create the file.
+     * @see net.sf.plantlore.client.export.Projection
+     */
+    public XMLBuilder2(Projection template, Writer writer) {
+        this.outputWriter = writer;
+        this.template = template;
+    }
+    
+    /**
+     * Create a new XML Builder.
+     * The builder receives records (holder objects from the database)
+     * decomposes them, creates an XML node, and stores it in the specified
+     * file.
+     * &lt;br/&gt;
+     * Every attribute (column) of the whole record will be exported.
+     * 
+     * @param writer	The writer that will create the file.
+     * @see net.sf.plantlore.client.export.Projection
+     */
+    public XMLBuilder2(Writer writer) {
+    	this(new Projection().setEverything(), writer);
+    }
+    
+       
+    /**
+     * Generate the header of this format.
+     */
+    public void header() 
+    throws IOException {
+    	outputWriter.write(&quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;);
+    	outputWriter.write(&quot;\n&lt;occurrences&gt;\n&quot;);
+    	
+    	OutputFormat format = OutputFormat.createPrettyPrint();
+        xmlWriter = new XMLWriter( outputWriter, format );
+    }
+    
+    /**
+     * Generate the footer of this format.
+     */
+    public void footer() 
+    throws IOException {
+    	outputWriter.write(&quot;&lt;/occurrences&gt;\n&quot;);
+        xmlWriter.close();
+    }
+    
+    /**
+     * Begin a new record.
+     */
+    public void startRecord() 
+    throws IOException {
+    	element = null;
+    }
+    
+    /**
+     * Finish processing of the record.
+     */
+    public void finishRecord() 
+    throws IOException {
+    	xmlWriter.write( element );
+    }
+    
+
+    /**
+     * Build part of the whole record.
+     */
+    public void part(Record record) 
+    throws IOException {
+    	decompose( element, record);
+    }
+    
+    /**
+     * Decompose the given &lt;code&gt;record&lt;/code&gt; and build the XML tree appropriately.
+     *  
+     * @param father	Father element of the currently processed &lt;code&gt;record&lt;/code&gt;.
+     * @param record	Part of the whole record corresponding to a certain table in the database.
+     */
+    protected boolean decompose(Element father, Record record) 
+    throws IOException {
+    	if(record == null) 
+    		return false;
+    	
+    	Class table = record.getClass();
+    	
+    	Element current;
+    	if( father == null )
+    		current = element = DocumentHelper.createElement(table.getSimpleName().toLowerCase());
+    	else
+    		current = father.addElement(table.getSimpleName().toLowerCase());
+    	
+    	boolean hasAtLeastOneProperty = false;
+    	
+    	for( String property : record.getProperties() )
+    		if( template.isSet(table, property) ) {
+    			Object value = record.getValue(property);
+    			if( value != null &amp;&amp; value.toString().length() &gt; 0 ) {
+    				current.addElement(property.toLowerCase()).setText(value.toString());
+    				hasAtLeastOneProperty = true;
+    			}
+    		}
+    	
+    	// Decompose all subrecords of this record.
+    	for(String key : record.getForeignKeys())
+    		hasAtLeastOneProperty =  decompose( current, (Record) record.getValue(key) ) || hasAtLeastOneProperty;
+    	
+    	if( !hasAtLeastOneProperty )
+    		current.detach();
+    	
+    	return hasAtLeastOneProperty;
+    }
+
+}

Added: trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,435 @@
+package net.sf.plantlore.client.export.component;
+
+import java.awt.Color;
+import java.awt.Component;
+import java.awt.event.KeyListener;
+import java.util.LinkedList;
+
+
+import javax.swing.JLabel;
+import javax.swing.event.TreeExpansionEvent;
+import javax.swing.event.TreeExpansionListener;
+import javax.swing.tree.*;
+
+import net.sf.plantlore.common.record.*;
+
+/**
+ * The extension of a JTree that allows the User to see the database model
+ * in a compact form. The tree expects the database hierarchy when it's created.
+ * Two default hierarchies are already present - the &lt;code&gt;DefaultHierarchy&lt;/code&gt;
+ * which is loaded when no other hierarchy is specified and displays the database
+ * model in the hierarchy, 
+ * and the &lt;code&gt;SimpleHierarchy&lt;/code&gt; which is a simplified version with
+ * all tables as sub-root nodes.
+ * Both hierarchies are hard-wired and must be updated if the database
+ * model changes!
+ * &lt;br/&gt;
+ * The selected nodes are visualized to the User in another colour.
+ * Collapsing a node &lt;b&gt;will cause&lt;/b&gt; deselection of all of its selected
+ * sub-nodes. This is a feature that will prevent the User from selecting
+ * a group of columns and forgeting about them. 
+ * &lt;br/&gt;
+ * The XTree uses instances of XNode class - that is, the label of the
+ * node is derived from the XNode.toString(). Should you have a desire
+ * to implement the L10N, modify that method appropriatelly.
+ * &lt;br/&gt;
+ * The XTree cannot produce a Projection - in order to create and update 
+ * the Projection &quot;automatically&quot; create your own TreeSelectionModel
+ * that is capable of such an action. 
+ * &lt;pre&gt;
+ * XTree tree = new XTree( );
+ * tree.setSelectionModel( new YSelectionModel() );
+ * &lt;/pre&gt;
+ * where
+ * &lt;pre&gt;
+ * class TemplateSelectionModel extends DefaultTreeSelectionModel {
+ * 		private Projection template;
+ * 
+ *		// Use this to achieve compatibility with the default XTree selection model.
+ *		@Override 
+ *		public void setSelectionPath(TreePath path) {
+ *			if( isPathSelected(path) )
+ *				removeSelectionPath(path);
+ *			else
+ *				addSelectionPath(path);
+ *		}
+ *		@Override 
+ *		public void removeSelectionPaths(TreePath[] paths) {
+ *			for(TreePath path : paths) {
+ *				XNode x  = (XNode) 
+ *					((DefaultMutableTreeNode)path.getLastPathComponent())
+ *					.getUserObject();
+ *				template.unset(x.table, x.column);    // update the Projection 
+ *			} 
+ *			super.removeSelectionPaths( paths ); 
+ *		}
+ *		@Override 
+ *		public void addSelectionPaths(TreePath[] paths) {
+ *			// ...similar...
+ *		}
+ * }
+ * &lt;/pre&gt;
+ *   
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @version 1.0
+ * @see net.sf.plantlore.client.export.Projection
+ * @see net.sf.plantlore.client.export.ExportMng.XSelectionModel
+ */
+public class ExtendedTree extends javax.swing.JTree {
+	
+	private static Color NotNullColor = new Color(220, 50, 20);
+	private static Color SelectedColor = new Color(20, 150, 20);
+	private static Color DefaultColor = Color.BLACK;
+	
+	
+	/**
+	 * The Default Hierarchy Model of the Database Model.
+	 */
+	public static Object[] DefaultHierarchy = {
+		new UserTreeNode(ExtendedTree.class, &quot;Plantlore&quot;),
+		new Object[] { // OCCURENCE
+			new UserTreeNode(Occurrence.class, null),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new Object[] { // HABITAT
+				new UserTreeNode(Habitat.class, null),
+				new Object[] { // TERRITORY
+					new UserTreeNode(Territory.class, null),
+					new UserTreeNode(Territory.class, Territory.NAME, true)
+				},
+				new Object[] { // PHYTOCHORION
+					new UserTreeNode(Phytochorion.class, null),
+					new UserTreeNode(Phytochorion.class, Phytochorion.CODE, true),
+					new UserTreeNode(Phytochorion.class, Phytochorion.NAME, true),
+				},
+				new UserTreeNode(Habitat.class, Habitat.QUADRANT),
+				new UserTreeNode(Habitat.class, Habitat.DESCRIPTION),
+				new Object[] { // NEAREST VILLAGE
+					new UserTreeNode(Village.class, null),
+					new UserTreeNode(Village.class, Village.NAME, true)
+				},
+				new UserTreeNode(Habitat.class, Habitat.COUNTRY),
+				new UserTreeNode(Habitat.class, Habitat.ALTITUDE),
+				new UserTreeNode(Habitat.class, Habitat.LATITUDE),
+				new UserTreeNode(Habitat.class, Habitat.LONGITUDE),
+				new UserTreeNode(Habitat.class, Habitat.NOTE),
+			},
+			new Object[] { // PLANT
+				new UserTreeNode(Plant.class, null),
+				new UserTreeNode(Plant.class, Plant.SURVEYTAXID, true),
+				new UserTreeNode(Plant.class, Plant.TAXON, true),
+				new UserTreeNode(Plant.class, Plant.GENUS),
+				new UserTreeNode(Plant.class, Plant.SPECIES),
+				new UserTreeNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
+				new UserTreeNode(Plant.class, Plant.CZECHNAME),
+				new UserTreeNode(Plant.class, Plant.SYNONYMS),
+				new UserTreeNode(Plant.class, Plant.NOTE)
+			},
+			new UserTreeNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new UserTreeNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DATASOURCE),
+			new Object[] { // PUBLICATION
+				new UserTreeNode(Publication.class, null),
+				new UserTreeNode(Publication.class, Publication.COLLECTIONNAME),
+				new UserTreeNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+				new UserTreeNode(Publication.class, Publication.JOURNALNAME),
+				new UserTreeNode(Publication.class, Publication.JOURNALAUTHORNAME),
+				new UserTreeNode(Publication.class, Publication.REFERENCECITATION, true),
+				new UserTreeNode(Publication.class, Publication.REFERENCEDETAIL),
+				new UserTreeNode(Publication.class, Publication.URL),
+				new UserTreeNode(Publication.class, Publication.NOTE)
+			},
+			new UserTreeNode(Occurrence.class, Occurrence.HERBARIUM),
+			new UserTreeNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new UserTreeNode(Occurrence.class, Occurrence.NOTE),
+			new Object[] { // METADATA
+				new UserTreeNode(Metadata.class, null),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+				new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+				new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+				new UserTreeNode(Metadata.class, Metadata.DATASETTITLE, true),
+				new UserTreeNode(Metadata.class, Metadata.DATASETDETAILS),
+				new UserTreeNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+				new UserTreeNode(Metadata.class, Metadata.SOURCEID, true),
+				new UserTreeNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+				new UserTreeNode(Metadata.class, Metadata.DATECREATE, true),
+				new UserTreeNode(Metadata.class, Metadata.DATEMODIFIED, true),
+				new UserTreeNode(Metadata.class, Metadata.RECORDBASIS),
+				new UserTreeNode(Metadata.class, Metadata.BIOTOPETEXT),				
+			}
+		},
+		new Object[] { // AUTHOR
+			new UserTreeNode(Author.class, null),
+			new UserTreeNode(Author.class, Author.WHOLENAME),
+			new UserTreeNode(Author.class, Author.ORGANIZATION),
+			new UserTreeNode(Author.class, Author.PHONENUMBER),
+			new UserTreeNode(Author.class, Author.ROLE),
+			new UserTreeNode(Author.class, Author.ADDRESS),
+			new UserTreeNode(Author.class, Author.EMAIL),
+			new UserTreeNode(Author.class, Author.URL),
+			new UserTreeNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new UserTreeNode(AuthorOccurrence.class, null),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
+		}
+	};
+	
+	/**
+	 * A simplified Hierarchy Model of the Database Model. 
+	 */
+	public static Object[] SimpleHierarchy = new Object[] {
+		new UserTreeNode(ExtendedTree.class, &quot;Plantlore DB&quot;),
+		new Object[] { // OCCURENCE
+			new UserTreeNode(Occurrence.class, null),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new UserTreeNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new UserTreeNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new UserTreeNode(Occurrence.class, Occurrence.DATASOURCE),
+			new UserTreeNode(Occurrence.class, Occurrence.HERBARIUM),
+			new UserTreeNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new UserTreeNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new UserTreeNode(Occurrence.class, Occurrence.NOTE)
+		},
+		new Object[] { // TERRITORY
+			new UserTreeNode(Territory.class, null),
+			new UserTreeNode(Territory.class, Territory.NAME, true)
+		},
+		new Object[] { // PHYTOCHORION
+			new UserTreeNode(Phytochorion.class, null),
+			new UserTreeNode(Phytochorion.class, Phytochorion.CODE, true),
+			new UserTreeNode(Phytochorion.class, Phytochorion.NAME, true),
+		},
+		new Object[] { // NEAREST VILLAGE
+			new UserTreeNode(Village.class, null),
+			new UserTreeNode(Village.class, Village.NAME, true)
+		},
+		new Object[] { // HABITAT
+			new UserTreeNode(Habitat.class, null),
+			new UserTreeNode(Habitat.class, Habitat.QUADRANT),
+			new UserTreeNode(Habitat.class, Habitat.DESCRIPTION),
+			new UserTreeNode(Habitat.class, Habitat.COUNTRY),
+			new UserTreeNode(Habitat.class, Habitat.ALTITUDE),
+			new UserTreeNode(Habitat.class, Habitat.LATITUDE),
+			new UserTreeNode(Habitat.class, Habitat.LONGITUDE),
+			new UserTreeNode(Habitat.class, Habitat.NOTE)
+		},
+		new Object[] { // PLANT
+			new UserTreeNode(Plant.class, null),
+			new UserTreeNode(Plant.class, Plant.SURVEYTAXID, true),
+			new UserTreeNode(Plant.class, Plant.TAXON, true),
+			new UserTreeNode(Plant.class, Plant.GENUS),
+			new UserTreeNode(Plant.class, Plant.SPECIES),
+			new UserTreeNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR),
+			new UserTreeNode(Plant.class, Plant.CZECHNAME),
+			new UserTreeNode(Plant.class, Plant.SYNONYMS),
+			new UserTreeNode(Plant.class, Plant.NOTE)
+		},
+		new Object[] { // PUBLICATION
+			new UserTreeNode(Publication.class, null),
+			new UserTreeNode(Publication.class, Publication.COLLECTIONNAME),
+			new UserTreeNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+			new UserTreeNode(Publication.class, Publication.JOURNALNAME),
+			new UserTreeNode(Publication.class, Publication.JOURNALAUTHORNAME),
+			new UserTreeNode(Publication.class, Publication.REFERENCECITATION, true),
+			new UserTreeNode(Publication.class, Publication.REFERENCEDETAIL),
+			new UserTreeNode(Publication.class, Publication.URL),
+			new UserTreeNode(Publication.class, Publication.NOTE)
+		},
+		new Object[] { // METADATA
+			new UserTreeNode(Metadata.class, null),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+			new UserTreeNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+			new UserTreeNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+			new UserTreeNode(Metadata.class, Metadata.DATASETTITLE, true),
+			new UserTreeNode(Metadata.class, Metadata.DATASETDETAILS),
+			new UserTreeNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+			new UserTreeNode(Metadata.class, Metadata.SOURCEID, true),
+			new UserTreeNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+			new UserTreeNode(Metadata.class, Metadata.DATECREATE, true),
+			new UserTreeNode(Metadata.class, Metadata.DATEMODIFIED, true),
+			new UserTreeNode(Metadata.class, Metadata.RECORDBASIS),
+			new UserTreeNode(Metadata.class, Metadata.BIOTOPETEXT),			
+		},
+		new Object[] { // AUTHOR
+			new UserTreeNode(Author.class, null),
+			new UserTreeNode(Author.class, Author.WHOLENAME),
+			new UserTreeNode(Author.class, Author.ORGANIZATION),
+			new UserTreeNode(Author.class, Author.PHONENUMBER),
+			new UserTreeNode(Author.class, Author.ROLE),
+			new UserTreeNode(Author.class, Author.ADDRESS),
+			new UserTreeNode(Author.class, Author.EMAIL),
+			new UserTreeNode(Author.class, Author.URL),
+			new UserTreeNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new UserTreeNode(AuthorOccurrence.class, null),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new UserTreeNode(AuthorOccurrence.class, AuthorOccurrence.NOTE)
+		}
+	};
+	
+	/**
+	 * Create a new XTree with the Default Hierarchy Model.
+	 */
+	public ExtendedTree( ) {
+		this( DefaultHierarchy );
+	}
+	
+		
+	/**
+	 * Create a new XTree with a specified Hierarchy Model.
+	 * @param hierarchy The hierarchy to be processed.
+	 */
+	public ExtendedTree( Object[] hierarchy ) {
+		super( processHierarchy(hierarchy) );
+		
+	    setCellRenderer( new XCellRenderer() );
+	    setToggleClickCount(1);
+	    setSelectionModel( new XSelectionModel() );
+	    addTreeExpansionListener( te = new XTreeExpansionListener() );
+	    
+	    for( KeyListener listener : getKeyListeners() ) 
+	    	removeKeyListener(listener);
+	}
+	
+	private XTreeExpansionListener te;
+	
+	
+	/**
+	 * Collapse all nodes.
+	 *
+	 */
+	public void collapseAll() {
+		te.collapseAll();
+	}
+			
+	
+	/**
+	 * Store all expanded nodes; capable of collapsing them all into the
+	 * original state.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-07-30
+	 *
+	 */
+	protected class XTreeExpansionListener implements TreeExpansionListener {
+		
+		private LinkedList&lt;TreePath&gt; paths = new LinkedList&lt;TreePath&gt;();
+
+		public void treeExpanded(TreeExpansionEvent e) {
+			if( !paths.contains(e.getPath()) )
+				paths.addFirst( e.getPath() );
+		}
+
+		public void treeCollapsed(TreeExpansionEvent e) {
+			// Not important
+		}
+		
+		public void collapseAll() {
+			for( TreePath path : paths )
+				collapsePath( path );
+			
+			paths.clear();
+		}
+		
+	}
+	
+	
+	/**
+	 * A modified selection model. A single click will 
+	 * add a leaf to the current selection.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-04-29
+	 */	
+	public class XSelectionModel extends DefaultTreeSelectionModel {
+		
+		@Override 
+		public void setSelectionPath(TreePath path) {
+			if( isPathSelected(path) )
+				removeSelectionPath(path);
+			else
+				addSelectionPath(path);
+		}
+		
+	}
+	
+	
+	/**
+	 * SPecialized Cell Renderer that shows no icons and
+	 * displayes mandatory columns with a different coulour.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-04-29
+	 */
+	protected class XCellRenderer extends DefaultTreeCellRenderer {
+		
+		public XCellRenderer() {
+			setOpenIcon(null); 
+		    setClosedIcon(null); 
+		    setLeafIcon(null);
+		}
+		
+		@Override
+		public Component getTreeCellRendererComponent(
+				javax.swing.JTree tree, 
+				Object value, 
+				boolean selected, 
+				boolean expanded, 
+				boolean leaf, 
+				int row, 
+				boolean hasFocus) {
+			// Let the default implementation handle the drawing.
+			JLabel label =  (JLabel) 
+				super.getTreeCellRendererComponent(tree, value, false, expanded, leaf, row, false);
+			// Modify the result of the predecessor.
+			if( selected &amp;&amp; leaf ) 
+				label.setForeground( SelectedColor );
+			else
+				if( ((UserTreeNode)((DefaultMutableTreeNode)value).getUserObject()).nn )
+					label.setForeground( NotNullColor );
+				else 
+					label.setForeground( DefaultColor );
+			return label;
+		}
+	}
+	
+	
+	
+	/**
+	 * Transform the simple Object[] hierarchy into an internal representation 
+	 * of the JTree.
+	 * @param hierarchy The hierarchy to be converted.
+	 * @return The root of the transformed hierarchy.
+	 */
+	private static DefaultMutableTreeNode processHierarchy(Object[] hierarchy) {
+		DefaultMutableTreeNode node = new DefaultMutableTreeNode(hierarchy[0]);
+		DefaultMutableTreeNode child;
+		for (int i = 1; i &lt; hierarchy.length; i++) {
+			Object nodeSpecifier = hierarchy[i];
+			if (nodeSpecifier instanceof Object[]) // Ie node with children
+				child = processHierarchy((Object[]) nodeSpecifier);
+			else
+				child = new DefaultMutableTreeNode(nodeSpecifier); // Ie Leaf
+			node.add(child);
+		}
+		return (node);
+	}
+	
+
+}

Added: trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,121 @@
+package net.sf.plantlore.client.export.component;
+
+import java.io.File;
+import java.util.ArrayList;
+
+import javax.swing.filechooser.FileFilter;
+
+/**
+ * An implementation of a FileFilter.
+ * The XFilter stores a list of extensions
+ * that are related to a particular format.
+ * &lt;br/&gt;
+ * For example: 
+ * &lt;code&gt;Comma Separated Values (*.txt, *.csv)&lt;/code&gt;
+ * will store &lt;code&gt;&quot;.txt&quot;, &quot;.csv&quot;&lt;/code&gt;.
+ *  
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @version 1.0
+ */
+public class FileFormat extends FileFilter {
+	
+	private String description;
+	private ArrayList&lt;String&gt; extensions;
+	private boolean columnSelection = false;
+	private boolean ignoreDead = true;
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description The description of the filter.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public FileFormat(String description, String... extensions) {
+		this.description = description;
+		this.extensions = new ArrayList&lt;String&gt;( extensions.length );
+		for(String ext : extensions) this.extensions.add(ext);
+	}
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description	The description of the filter.
+	 * @param columnSelectionEnabled	The format allows further modifications.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public FileFormat(String description, boolean columnSelectionEnabled, boolean ignoreDead, String... extensions) {
+		this(description, extensions);
+		this.columnSelection = columnSelectionEnabled;
+		this.ignoreDead = ignoreDead;
+	}
+
+	/**
+	 * @return True if the column selection is available for this format.
+	 */
+	public boolean isColumnSelectionEnabled() {
+		return this.columnSelection;
+	}
+	
+	/**
+	 *	@return True if dead records should be omited.
+	 */
+	public boolean ignoreDead() {
+		return ignoreDead;
+	}
+
+	/**
+	 * Decide whether the file meets the requierements - has the correct extension
+	 * or it is in fact a directory.
+	 */
+	@Override
+	public boolean accept(File file) {
+		if( file != null) {
+			if(file.isDirectory()) return true;
+			String name = file.getName() ;
+			int dot = name.lastIndexOf(&quot;.&quot;);
+			if(dot &lt; 0) return false;
+			if(extensions.contains( name.substring(dot) )) return true;
+		}
+		return false;
+	}
+
+	/**
+	 * @return The description of the format.
+	 */
+	@Override
+	public String getDescription() {
+		return description;
+	}
+	
+	/**
+	 * Decide whether the file already has a valid extension.
+	 * A valid extension is an extension that belongs to
+	 * the list of extensions of this format.
+	 * 
+	 * @param filename	The file to be tested.
+	 * @return	True if the file has a valid extension of this format.
+	 */
+	public boolean hasExtension(String filename) {
+		int dot = filename.lastIndexOf(&quot;.&quot;);
+		if(dot &lt; 0) return false;
+		if(extensions.contains( filename.substring(dot) )) return true;
+		return false;
+	}
+	
+	/**
+	 * Suggest the name for a file based on the list of extensions.
+	 * If the file already has an extension, the name is not changed.
+	 * An extension is added, if the file has not a valid extension. 
+	 * 
+	 * @param filename	The name of the file.
+	 * @return The suggested name for this file.
+	 * @see net.sf.plantlore.client.export.component.FileFormat#hasExtension(String)
+	 */
+	public String suggestName(String filename) {
+		if(hasExtension(filename)) 
+			return filename;
+		return filename + extensions.get(0);
+	}
+	
+}
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -4,20 +4,26 @@
 import javax.swing.tree.DefaultTreeSelectionModel;
 import javax.swing.tree.TreePath;
 
-import net.sf.plantlore.client.export.Template;
+import net.sf.plantlore.client.export.Projection;
 
 /**
- * A TreeSelectionModel modified to update its Template. 
+ * A TreeSelectionModel modified to update a Projection. 
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 29.4.2006
- * @see net.sf.plantlore.client.export.component.XTree
- * @see net.sf.plantlore.client.export.component.XNode
+ * @see net.sf.plantlore.client.export.component.ExtendedTree
+ * @see net.sf.plantlore.client.export.component.UserTreeNode
  */
 public class TemplateSelectionModel extends DefaultTreeSelectionModel {
 	
-	private Template xtemplate = new Template();
+	private Projection template;
 	
+	
+	
+	public TemplateSelectionModel(Projection template) {
+		this.template = template;
+	}
+	
 	/**
 	 * Setting a selection path
 	 * adds the selection path if it is not selected
@@ -32,7 +38,7 @@
 	}
 	
 	/**
-	 * Update the Template appropriately.
+	 * Update the Projection appropriately.
 	 */
 	@Override 
 	public void removeSelectionPaths(TreePath[] paths) {
@@ -40,24 +46,24 @@
 			if(path == null) continue;
 			Object node = path.getLastPathComponent();
 			if(node instanceof DefaultMutableTreeNode) {
-				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
-				xtemplate.unset(x.table, x.column);  
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
+				template.unset(x.table, x.column);  
 			}
 		}
 		super.removeSelectionPaths( paths );
 	}
 	
 	/**
-	 * Update the Template appropriately.
+	 * Update the Projection appropriately.
 	 */
 	@Override 
 	public void addSelectionPaths(TreePath[] paths) {
 		for(TreePath path : paths) {
 			Object node = path.getLastPathComponent();
 			if(node instanceof DefaultMutableTreeNode) {
-				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
 				// Select table.column records (not the table only). 
-				if(x.column != null) xtemplate.set(x.table, x.column);
+				if(x.column != null) template.set(x.table, x.column);
 			}
 		}
 		super.addSelectionPaths( paths );
@@ -66,15 +72,15 @@
 	@Override
 	public void clearSelection() {
 		super.clearSelection();
-		xtemplate.unsetEverything();
+		template.unsetEverything();
 	}
 			
 	/**
 	 * 
 	 * @return A copy of the inner template that stores the list of selected columns.
 	 */
-	public Template getTemplate() {
-		return xtemplate.clone();
+	public Projection getTemplate() {
+		return template;
 	}
 	
 }

Added: trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-07-31 08:54:20 UTC (rev 475)
+++ trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-07-31 08:59:55 UTC (rev 476)
@@ -0,0 +1,45 @@
+package net.sf.plantlore.client.export.component;
+
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ * A representation of a node in an XTree.
+ * Every node corresponds to a &lt;code&gt;column&lt;/code&gt; of a &lt;code&gt;table&lt;/code&gt;.
+ *  
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @see net.sf.plantlore.client.export.component.ExtendedTree
+ */
+public class UserTreeNode {
+	/** The table whose columns this node represents. */
+	public Class table;
+	/** The column of the table this node represents. */
+	public String column;
+	/** Is it a not-null property in the database? */
+	public boolean nn;
+	
+	/**
+	 * Create a new XNode. The node represents 
+	 * a (possibly mandatory) column of a table.
+	 */
+	public UserTreeNode(Class table, String column, boolean notNullProperty) {
+		this.table = table; nn = notNullProperty; this.column = column;
+	}
+	
+	/**
+	 * Create a new XNode. The node represents a column of a table.
+	 */
+	public UserTreeNode(Class table, String column) {
+		this(table, column, false);
+	}
+	
+	/**
+	 * Get the name of the column.
+	 * TODO: L10n may be useful here!
+	 */
+	@Override
+	public String toString() {
+		return L10n.getString(table.getSimpleName() + ((column != null) ? &quot;.&quot; +  column : &quot;&quot;));
+	}
+}
\ No newline at end of file


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000620.html">[Plantlore-dev] r475 - trunk/src/net/sf/plantlore/client
</A></li>
	<LI>Next message: <A HREF="000622.html">[Plantlore-dev] r477 - in trunk/src/net/sf/plantlore/client/export:	. component
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#621">[ date ]</a>
              <a href="thread.html#621">[ thread ]</a>
              <a href="subject.html#621">[ subject ]</a>
              <a href="author.html#621">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
