<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r467 - in trunk/src/net/sf/plantlore:	client/history server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r467%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09client/history%20server&In-Reply-To=%3C200607171711.k6HHBWVr029355%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000601.html">
   <LINK REL="Next"  HREF="000603.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r467 - in trunk/src/net/sf/plantlore:	client/history server</H1>
    <B>lada at mail.berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r467%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09client/history%20server&In-Reply-To=%3C200607171711.k6HHBWVr029355%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r467 - in trunk/src/net/sf/plantlore:	client/history server">lada at mail.berlios.de
       </A><BR>
    <I>Mon Jul 17 19:11:32 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000601.html">[Plantlore-dev] r466 - in trunk: analysis/database	src/net/sf/plantlore/client/history	src/net/sf/plantlore/common/record	src/net/sf/plantlore/config/hibernate src/net/sf/plantlore/server
</A></li>
        <LI>Next message: <A HREF="000603.html">[Plantlore-dev] Plantlore
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#602">[ date ]</a>
              <a href="thread.html#602">[ thread ]</a>
              <a href="subject.html#602">[ subject ]</a>
              <a href="author.html#602">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lada
Date: 2006-07-17 19:11:29 +0200 (Mon, 17 Jul 2006)
New Revision: 467

Modified:
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
Log:
Others changes in history - test and repair bugs, comment...

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -24,6 +24,7 @@
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Habitat;
 import net.sf.plantlore.common.record.HistoryChange;
+import net.sf.plantlore.common.record.HistoryColumn;
 import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.common.record.Metadata;
 import net.sf.plantlore.common.record.Occurrence;
@@ -45,10 +46,12 @@
  */
 public class History extends Observable {
     
-      /** Instance of a logger */
+    /** Instance of a logger */
     private Logger logger;      
     /** Instance of a database management object */
     private DBLayer database;   
+    /** Exception with details about an error */
+    private String error = null;
     /** Constant with default number of rows to display */
     private static final int DEFAULT_DISPLAY_ROWS = 6;    
     /** Actual number of rows to display */
@@ -62,9 +65,9 @@
     /** Result of the search query */
     private int resultId = 0;
     /** List of data (results of a search query) displayed in the table */
-    private ArrayList&lt;HistoryRecord&gt; historyDataList = new ArrayList();     
+    private ArrayList&lt;HistoryRecord&gt; historyDataList = new ArrayList&lt;HistoryRecord&gt;();     
     // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
-    private ArrayList&lt;Record&gt; editObjectList = new ArrayList&lt;Record&gt;();    
+    private ArrayList&lt;Object&gt; editObjectList = new ArrayList&lt;Object&gt;();    
     // informace pro uzivatele o record undo
     private String messageUndo;
 
@@ -72,11 +75,12 @@
     //seznam id vsech oznacenych polozek
     private HashSet markListId = new HashSet();
     //Seznam Item + maxIdItem (nejstarsi oznacene id pro dany Item=sloupec)
-    private ArrayList&lt;Object[]&gt; markItem = new ArrayList();
+    private ArrayList&lt;Object[]&gt; markItem = new ArrayList&lt;Object[]&gt;();
     //Informuje o tom, zda byla zvolena volba &quot;SelectAll&quot;
     private boolean selectAll;    
     
-    //*********************Record of history, ... ***************************************//    
+    //*********************Record of history, ... ***************************************//   
+    private Object data;
     private Occurrence occurrence;
     private Habitat habitat;
     private AuthorOccurrence authorOccurrence;
@@ -105,9 +109,7 @@
     /** Date and time when the reccord was changed*/
     private java.util.Date when = null;	
     /** Old value of attribute*/    
-    private String oldValue;
-    /** New value of attribute*/
-    //private String newValue;
+    private String oldValue;      
    /** Name of user who did changed*/
     private String nameUser;
     
@@ -119,8 +121,7 @@
     /** Informaciton about location for specified occurrenc*/
     private String location;
     
-    //********************************************************//
-    /** Mapping of entities */           
+    //********************************************************//          
     private Hashtable&lt;String, Integer&gt; authorsOccurrenceHash;
     private Hashtable&lt;String, Integer&gt; occurrenceHash; 
     private Hashtable&lt;String, Integer&gt; authorHash;
@@ -128,211 +129,222 @@
     private Hashtable&lt;String, Integer&gt; metadataHash;
     private Hashtable&lt;String, Integer&gt; publicationHash;
     private Hashtable&lt;String, Enum&gt; editTypeHash;
-    //pro territory, village a phytochorion neni treba tvorit mapovani
     
+    //*********************************************************//
+    public static final String ERROR_SEARCH_RECORD = L10n.getString(&quot;Error.historyRecordSearchFailed&quot;);
+    public static final String ERROR_SEARCH_DATA = L10n.getString(&quot;Error.historyDataSearchFailed&quot;);
+    public static final String ERROR_SEARCH_OBJECT = L10n.getString(&quot;Error.historyObjectSearchFailed&quot;);
+    public static final String ERROR_SEARCH_AUTHOR = L10n.getString(&quot;Error.historyAuthorSearchFailed&quot;);
+    public static final String ERROR_PROCESS = L10n.getString(&quot;Error.historyProcessResultsFailed&quot;);
+    public static final String ERROR_UPDATE = L10n.getString(&quot;Error.historyUpdateResultsFailed&quot;);
+    public static final String ERROR_DELETE = L10n.getString(&quot;Error.historyDeleteResultsFailed&quot;);  
         
     /**
-     * Creates a new instance of History - history of whole database
+     * Creates a new instance of History - history of Occurrences, Habitats, Authors, 
+     * Publications, Metadata, Territories, Phytochorions, Villages
+     * @param database Instance of a database management object
      */
-    public History(DBLayer database) {
+    public History(DBLayer database){
           
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
        this.database = database;
        
-       //nacist vsechny data z historie --&gt;bez podminky, jen je seradit podle casu
+       //Search history data (without condition, order by date)
        searchWholeHistoryData();
-       //opet funkci pro vyzadani si dat postupne
+       //Process results 
        processResult(1, displayRows);
     }
     
     /**  
      *  Creates a new instance of History - history of specific occurrence 
      *  @param database Instance of a database management object
-     *  @param idOcc
+     *  @param idObj identifier of specific occurrence
      * */
-    public History(DBLayer database, int idOcc)
+    public History(DBLayer database, int idObj)
     {
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
        this.database = database;       
        
        SelectQuery query = null;
-       int resultId = 0;
-       Object[] objectOccurrence = null;
-       Object[] objHis = null;
+       int resultIdRecord = 0;
+       Object[] object = null;      
        
-       try {
-       	    query = database.createQuery(Occurrence.class);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, idOcc, null);            
-            resultId = database.executeQuery(query);
-            objectOccurrence = database.more(resultId, 0, 0);       
-            objHis = (Object[])objectOccurrence[0];                            
+       try {    	  
+		    query = database.createQuery(Occurrence.class);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, idObj, null);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.DELETED, null, 0, null);    	                   
+            resultIdRecord = database.executeQuery(query);
+            object = database.next(resultIdRecord);                    
+            database.closeQuery(query);
        } catch(RemoteException e) {
-       	    System.err.println(&quot;RemoteException - History(), createQuery&quot;);       	  
+       	    logger.error(&quot;Remote exception caught in History. Details: &quot;+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);
+       	    return;
        } catch(DBLayerException e) {
-       	    System.err.println(&quot;DBLayerException - History(), createQuery&quot;);       	  
-            logger.error(&quot;Processing search occurrence results failed: &quot;+e.toString());            
+    	    logger.error(&quot;Search selected occurrence failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);             
+            return;
        }                                          
+       if (object == null) {
+    	   logger.error(&quot;tOccurrence doesn't contain required data&quot;);  
+    	   setError(ERROR_SEARCH_RECORD); 
+       } else {
+    	   
+    	   occurrence = (Occurrence)object[0];    	   
+    	   setData(occurrence);
+    	   
+	       //Save basic information about specific occurrence 
+	       setNameAuthor(getAllNameOfAuthors(getAllAuthors(occurrence, 0)));
+	       setNamePlant(occurrence.getPlant().getTaxon());       
+	       setLocation(occurrence.getHabitat().getNearestVillage().getName());	            
+	       
+	       //Save information about data entries concerned with specific occurrence
+	       setWhen(occurrence.getCreatedWhen());
+	       setNameUser(occurrence.getCreatedWho().getWholeName());
+	       
+	       //Searching for information about data editing concerned with specific occurrence
+	       searchEditHistory(occurrence);
+	       
+	       //Process results of a search &quot;edit&quot; query 
+	       processResult(1,displayRows);
+       }
+    }	
 
-       occurrence = ((Occurrence)objHis[0]);
+    /**  
+     *  Creates a new instance of History - history of specific habitat 
+     *  @param database Instance of a database management object
+     *  @param idObj integer containing identifier of specific habitat
+     *  @param infoHabitat
+     * */
+    public History(DBLayer database, int idObj, String infoHabitat)
+    {
+       logger = Logger.getLogger(this.getClass().getPackage().getName());	 
+       this.database = database;       
        
-       //FIXME: bude nutno dovyhledavat autory
-       setNameAuthor(getAllNameOfAuthors(getAllAuthors(occurrence, 0)));
-       setNamePlant(occurrence.getPlant().getTaxon());       
-       setLocation(occurrence.getHabitat().getNearestVillage().getName());
+       SelectQuery query = null;
+       int resultIdRecord = 0;
+       Object[] object = null;      
        
-       try {           
+       try {    	  
+		    query = database.createQuery(Habitat.class);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, idObj, null);
+      	    query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.DELETED, null, 0, null);    	                   
+            resultIdRecord = database.executeQuery(query);
+            object = database.next(resultIdRecord);                    
             database.closeQuery(query);
        } catch(RemoteException e) {
-       	    System.err.println(&quot;RemoteException&quot;);
-       }           
-       
-       //Searching for information about data entries concerned with specified occurrence
-       searchInsertInfo();
-       //Searching for information about data editing concerned with specified occurrence
-       searchEditHistory();
-       //Process results of a search &quot;edit&quot; query 
-       processResult(1,displayRows);
-    }	
-    
-    
-    /**
-     *  Searches for information about data entries concerned with specified occurrence.   
-     */
-    public void searchInsertInfo() {
-            
-       // Create new Select query
-       SelectQuery query = null;
-       int resultIdInsert = 0;
-       Object[] object = null;
-       
-       try {
-       	    query = database.createQuery(HistoryChange.class);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.RECORDID, null, occurrenceId, null);
-       	    query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryChange.OPERATION, null, HistoryChange.HISTORYCHANGE_INSERT, null);
-       	    resultIdInsert = database.executeQuery(query);
-       	    object = database.next(resultIdInsert);
-       	    database.closeQuery(query);
-       } catch(RemoteException e) {
-       	    System.err.println(&quot;RemoteException- searchInsertInfo(), createQuery&quot;);       	  
+       	    logger.error(&quot;Remote exception caught in History. Details: &quot;+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);
+       	    return;
        } catch(DBLayerException e) {
-       	    System.err.println(&quot;DBLayerException - searchInsertInfo(), createQuery&quot;);
-       }            
-        
+    	    logger.error(&quot;Search selected habitat failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);             
+            return;
+       }                                          
        if (object == null) {
-    	   logger.error(&quot;tHistoryChange doesn't contain required data&quot;);
+    	   logger.error(&quot;tHabitat doesn't contain required data&quot;);  
+    	   setError(ERROR_SEARCH_RECORD); 
        } else {
-    	   //TODO: INFORMACE O INSERTU NALEZU BY SE DALY ZJISKAT Z TABULKY TOCCURRENCE - TO BUDE I LEPSI 
-    	   setWhen(((HistoryChange)object[0]).getWhen());
-           setNameUser(((HistoryChange)object[0]).getWho().getWholeName());
-           // TOTO BUDE LEPSI 
-           setWhen(occurrence.getCreatedWhen());
-           setNameUser(occurrence.getCreatedWho().getWholeName());
-          
+    	   
+    	   habitat = (Habitat)object[0];    	   
+    	   setData(habitat);
+    	   
+    	   //TODO
+	       //Save basic information about specific habitat	             	      	  
+	       setLocation(habitat.getNearestVillage().getName());	            	       	       
+	       
+	       //Searching for information about data editing concerned with specific habitat
+	       searchEditHistory(habitat);
+	       
+	       //Process results of a search &quot;edit&quot; query 
+	       processResult(1,displayRows);
        }
-       
-    }
+    }	
     
     
     /**     
-     * Searches for information about data editing concerned with specified occurrence. 
-     */
-     
-    public void searchEditHistory()
-    {  
-    	    	
+     * Searches for information about data editing concerned with specific occurrence or habitat. 
+     * @param data object containing specific occurrence or habitat
+     */     
+    public void searchEditHistory(Object data)
+    {      	    	
         //Create new Select query
-        SelectQuery query = null;       
+        SelectQuery query = null; 
+        int resultIdEdit = 0;
 
     	//  Select data from tHistory table
         try {
-		query = database.createQuery(HistoryRecord.class);
-		// Create aliases for table tHistoryChange.      
+		    query = database.createQuery(HistoryRecord.class);
+		    // Create aliases for table tHistoryChange.      
 	        query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);        
-	        // Add restriction to COPERATION column of tJistoryChange table
-	        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.operation&quot;, null, HistoryChange.HISTORYCHANGE_EDIT, null);        
-	        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.recordId&quot;, null, occurrence.getId(), null);    	
+	        // Add restriction to COPERATION column of tHistoryChange table
+	        if (data instanceof Occurrence) {	        	       
+		        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.recordId&quot;, null, ((Occurrence)data).getId(), null);  
+	        } else if (data instanceof Habitat) {	        	        
+		        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.recordId&quot;, null, ((Habitat)data).getId(), null);  
+	        }	
+	        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.operation&quot;, null, HistoryChange.HISTORYCHANGE_EDIT, null);
 	        query.addOrder(PlantloreConstants.DIRECT_DESC, &quot;hc.when&quot;);
-	} catch (RemoteException e) {
-		System.err.println(&quot;RemoteException - searchEditHistory(), createQuery&quot;);
-	} catch (DBLayerException e) {
-		System.err.println(&quot;DBLayerException - searchEditHistory(), createQuery&quot;);
-	}                
-
-        int resultIdEdit = 0;
-        try {
-            // Execute query                    
-            resultIdEdit = database.executeQuery(query); 
-            // Save &quot;edit&quot; history data
-            setResultId(resultIdEdit);
-        } catch (DBLayerException e) {
-            // Log and set an error                   
-            logger.error(&quot;Searching history data with condition 'operation = edit' failed. Unable to execute search query.&quot;);           
-        } catch (RemoteException e) { 		   
-     	   System.err.println(&quot;RemoteException- searchEditHistory(), executeQuery&quot;);
-	 	}    
-        
-        //zde nejde zavrit session closeQuery
+	        resultIdEdit = database.executeQuery(query); 
+		} catch (RemoteException e) {
+			logger.error(&quot;Remote exception caught in History (searchEditHistory). Details: &quot;+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+		} catch (DBLayerException e) {
+			logger.error(&quot;DBLayer exception caught in History (searchEditHistory). Details: &quot;+e.getMessage());
+			setError(ERROR_SEARCH_DATA);            
+		}                
+		setResultId(resultIdEdit);                
     }
     
        
     /**
-     *
+     * Searches for information about data concerned with occurrence, habitat, author, metadata, publication,
+     * territory, village and phytochorion.
      */
     public void searchWholeHistoryData() {
         
         //Create new Select query
-        SelectQuery query = null;       
+        SelectQuery query = null;
+        int resultIdWHistory = 0;
 
     	//  Select data from tHistory table
         try {
 			query = database.createQuery(HistoryRecord.class);
 			// Create aliases for table tHistoryChange.
-			query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);
-			// sort by date/time
+			query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);			
 			query.addOrder(PlantloreConstants.DIRECT_DESC, &quot;hc.when&quot;);
-	} catch (RemoteException e) {
-                System.err.println(&quot;RemoteException - searchWholeHistoryData(), createQuery&quot;);
-	} catch (DBLayerException e) {
-                System.err.println(&quot;DBLayerException - searchWholeHistoryData(), createQuery&quot;);
-        }
-
-    	
-        int resultId = 0;
-        try {
-            // Execute query                    
-            resultId = database.executeQuery(query);
-            // Save &quot;edit&quot; history data
-            setResultId(resultId);    
-        } catch (DBLayerException e) {                            
-            logger.error(&quot;Searching whole history data failed. Unable to execute search query.&quot;);           
-        } catch (RemoteException e) { 		   
-     	   System.err.println(&quot;RemoteException- searchWholeHistoryData(), executeQuery&quot;);
-        }   
-        
-        //zde nelze zavrit session closeQuery
+			resultIdWHistory = database.executeQuery(query);
+		} catch (RemoteException e) {
+			logger.error(&quot;Remote exception caught in History (searchWholeHistoryData). Details: &quot;+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+		} catch (DBLayerException e) {
+			logger.error(&quot;DBLayer exception caught in History (searchWholeHistoryData). Details: &quot;+e.getMessage());
+			setError(ERROR_SEARCH_DATA);
+	    }
+		setResultId(resultIdWHistory);                 
     }
     
    /**
      * Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field of the class. 
-     * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
+     * @param from number of the first row to show in table. Number of the first row to retraieve is 1.
      * @param count number of rows to retrieve 
      */
-    public void processResult(int fromTable, int count) {
+    public void processResult(int from, int count) {
         
         if (this.resultId != 0) {
             int currentRow = getResultRows();
             logger.debug(&quot;Rows in the result: &quot;+currentRow);
-            logger.debug(&quot;Max available rows: &quot;+(fromTable+count-1));
+            logger.debug(&quot;Max available rows: &quot;+(from+count-1));
            
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
-            int to = Math.min(currentRow, fromTable+count-1);           
+            int to = Math.min(currentRow, from+count-1);           
             if (to &lt;= 0) {
             	historyDataList = new ArrayList&lt;HistoryRecord&gt;(); 
             	setDisplayRows(0);
             	setCurrentDisplayRows(&quot;0-0&quot;);
             } else {
                 logger.debug(&quot;Retrieving query results: 1 - &quot;+to);
-                setCurrentDisplayRows(fromTable+ &quot;-&quot; + to);
+                setCurrentDisplayRows(from+ &quot;-&quot; + to);
                 try {                	 
                      // Retrieve selected row interval 
                 	Object[] objectHistory;
@@ -351,62 +363,62 @@
                     for (int i=0; i&lt;countResult; i++ ) {                    							
 						Object[] objHis = (Object[])objectHistory[i];
                         this.historyDataList.add((HistoryRecord)objHis[0]);
-                    }           
-                    //Update current first displayed row (only if data retrieval was successful)
-                    setCurrentFirstRow(fromTable); 
+                    }                               
                 } catch (DBLayerException e) {                  
-                    logger.error(&quot;Processing search results failed: &quot;+e.toString());            
-                }             
+                    logger.error(&quot;Processing search results failed: &quot;+e.toString());   
+                    setError(this.ERROR_PROCESS);
+                }    
+                // Update current first displayed row (only if data retrieval was successful).
+                if (!this.isError()) {
+                    logger.info(&quot;Results successfuly retrieved&quot;);                   
+                    setCurrentFirstRow(from);
+                }
             }
-        }         
+            // Tell observers to update
+            setChanged();
+            notifyObservers();
+            // Clean error flag 
+            this.error = null;
+         }         
     }
     
     /**
-     *
+     *  Rollback changes from now to date of selected record 
+     *  @param toResult int containing identifier of selected record
      */
     public void undoToDate(int toResult) {
         
-        //Inicalization of hashTable
+        //Initialization of hashTable
         initAuthorsOccurrenceHash();
     	initOccurrenceHash();
     	initHabitatHash();   
         initPublicationHash();
         initAuthorHash();      
         initMetadataHash();
-        	
-    	//number of result
-    	//int countResult = this.historyDataList.size();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
-    	//relationship = false;
-    	//editHabitat = false;
-    	
-    	//take from younger record to older record, undo tu selected row
-    	for( int i=0; i &lt; toResult; i++) {
-    		
+        	    	
+    	//read record from younger to older until selected row        
+    	for( int i=0; i &lt; toResult; i++) {    		
     		//init history data 
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();
-                recordId = historyChange.getRecordId();
-                operation = historyChange.getOperation();
-    		                                                
-               /** 
-                * Pri insertu a editu nedohledavam column --&gt; prvne rozdelit podle operace a pro edit dale rozdelit podle column
-                */
-                if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
-                    undoInsertDelete(1);
-                } else if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
-                    undoEdit();
-                } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
-                    undoInsertDelete(0);
-                } else {
-                    logger.error(&quot;Incorrect opreration code: &quot;+ operation);
-                }                
+            recordId = historyChange.getRecordId();
+            operation = historyChange.getOperation();
+		  
+            if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
+                undoInsertDelete(1);
+            } else if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
+                undoEdit();
+            } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
+                undoInsertDelete(0);
+            } else {
+                logger.error(&quot;Incorrect opreration code: &quot;+ operation);
+            }                
         }
     }
     
     /**
-     *  Volani UNDO z historie pro jeden nalez
+     *  Rollback selected data editing concerned with specific occurrence or habitat. 
      */
     public void undoSelected() {
     	
@@ -416,35 +428,30 @@
     	initHabitatHash();    	  
         	
     	//number of result
-    	int countResult = getResultRows();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu    	
+    	int countResult = getResultRows();    	   
     	
-    	//take from younger record to older record
+    	//take record from younger to older
     	for( int i=0; i &lt; countResult; i++) {
     		if (! markListId.contains(i)) {
     			continue;
     		}
     		
-    		// init history data about edit of record
+    		// init history data about editing concerned with record
     		historyRecord = (HistoryRecord)historyDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();    		  		    			           
-                recordId = historyChange.getRecordId();           	   
-                operation = historyChange.getOperation();
-       
-            
-            //zavolani funkce, ktera undo pro operaci edit
+            recordId = historyChange.getRecordId();           	   
+            operation = historyChange.getOperation();
+                               
             undoEdit();    		
     	}
-    	//generated information form user
+    	//generated information message for user
     	generateMessageUndo();
     }
     
     /**
-     * ??? Habitat - nemuselo by se zaznamenavat cDelete
-     * v tabulkach Phytochorion, Village, Territory nebude mo&#382;no mazat zaznamy (ani se nepredpoklada, ze by k t&#233;to operaci m&#283;lo dochazet), proto v nich nen&#237; ani CDELETE.
-     * delete == 1 ... smazat
-     * delete == 0 ... obnovit
+     *   Rollback operation insert or delete. 
+     *   @param isDelete int containing informaciton about insertion or erasure of record. 
      */
     public void undoInsertDelete(int isDelete) {
         if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE)){
@@ -454,7 +461,7 @@
              //Add to list of changed Record
              if (!editObjectList.contains((Record)occurrence))                 
                 editObjectList.add((Record)occurrence);       
-             //pripsat PRI obnovani z DELETE obnoveni i autoru (autorOcc)
+             //Update author of specific occurrence
              isDelete = (isDelete == 1) ? 2 : isDelete;
              Object[] objects = getAllAuthors(occurrence, 2-isDelete);
              int countResult = objects.length;               
@@ -473,8 +480,7 @@
              //Add to list of changed Record             
              if (!editObjectList.contains((Record)authorOccurrence))                 
                 editObjectList.add((Record)authorOccurrence);             
-       } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
-            //jeste rozmyslet, zda to tu bude
+       } else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {            
                Object[] object = searchObject(&quot;Habitat&quot;,recordId);  
                Habitat habitat = (Habitat)object[0];
                habitat.setDeleted(isDelete);
@@ -504,16 +510,16 @@
              if (!editObjectList.contains((Record)author))                 
                 editObjectList.add((Record)author);             
         }  else {
-            logger.error(&quot;No table defined&quot;);
+            logger.error(&quot;Name of table is incorrect.&quot;);
         }
     }
     
     /**
-     *
+     * Rollaback operation Update.
      */
     public void undoEdit() {
         
-        //init history data about edit of record
+        //init history data about editing concerned with record
         columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
         oldRecordId = historyChange.getOldRecordId();                        	           
         oldValue = historyRecord.getOldValue();
@@ -537,42 +543,58 @@
         } else if (tableName.equals(PlantloreConstants.ENTITY_VILLAGE)) {
                 undoVillage();
         } else {
-            logger.error(&quot;No table defined&quot;);
+            logger.error(&quot;Name of table is incorrect.&quot;);
         }
     }
 
     
-      /**
-     *
+     /**
+     *  Rollback data editing concerned with specific occurrence and author
      */
     public void undoAuthorOccurrence() {
         
-        Object[] object = searchObject(&quot;AuthorOccurrence&quot;, recordId);
-        AuthorOccurrence authorOccurrence = (AuthorOccurrence)object[0];  
-        
-        occurrenceId = historyChange.getRecordId();	
-        
-        //test, zda jiz dany zaznam byl editovan
+    	int authorOccId = historyChange.getRecordId();
+    	occurrenceId = historyChange.getRecordId();	
+    	AuthorOccurrence authorOccurrence = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof AuthorOccurrence) {    			
+    			int listAutOccId = ((AuthorOccurrence)(editObjectList.get(i))).getId();
+    			if (authorOccId == listAutOccId) {
+    				contain = true;
+    				placings = i;   
+    				authorOccurrence = (AuthorOccurrence)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	}    
+    	
+    	if (!contain) {
+        	// Select record AuthorOccurrence where id = authorOccurrenceId 
+    		Object[] object = searchObject(&quot;AuthorOccurrence&quot;, authorOccId);
+            authorOccurrence = (AuthorOccurrence)object[0];
+        }     	                 
+                
         boolean objectList = editObjectList.contains((Record)authorOccurrence); 
         if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+        	//add object to list of editing object
             editObjectList.add((Record)authorOccurrence);
         }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;authorOccurrence: &quot;+ authorOccurrence.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+       
+       // Get number of columnName from authorOccurrence mapping
         int columnConstant;
-        if (authorsOccurrenceHash.containsKey(columnName)) {
-                 columnConstant = (Integer)authorsOccurrenceHash.get(columnName); 
+        if (columnName == null) {
+        	columnConstant = 1;
+        } else if (authorsOccurrenceHash.containsKey(columnName)) {
+            columnConstant = (Integer)authorsOccurrenceHash.get(columnName); 
         } else {
-             columnConstant = 0;
+            columnConstant = 0;
         }        	    			
       
         // Save new value for the column        		
         switch (columnConstant) {
-            case 1:  //Author
+            case 1:  //Author of occurrence - add author, remove author or change role of author
                 if (authorOccurrence.getDeleted() == 1) {
                     authorOccurrence.setDeleted(0);
                 } else {
@@ -590,35 +612,44 @@
             default:
                 logger.error(&quot;No column defined for name &quot;+ columnName);	                   
         }
+        
+        if (contain) {        	
+        	editObjectList.set(placings, (Record)authorOccurrence);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add authorOccurrence&quot;);
+            editObjectList.add(authorOccurrence);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific occurrence
      */
     public void undoOccurrence() {
-        
-        //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
+               
     	occurrenceId = historyChange.getRecordId();
-    	//Select record Occurrence where id = occurrenceId 
-        Object[] objectOcc = searchObject(&quot;Occurrence&quot;,occurrenceId);
-        occurrence = (Occurrence)objectOcc[0];                           	
-        
-        boolean objectList = editObjectList.contains((Record)occurrence);
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            logger.debug(&quot;ObjectList... add occurrences&quot;);
-            editObjectList.add((Record)occurrence);
-        }
-        
-        logger.debug(&quot;editObjectList: &quot;+objectList);
-        logger.debug(&quot;OccurrenceID: &quot;+occurrence.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
+    	Occurrence occ = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Occurrence) {    			
+    			int listOccId = ((Occurrence)(editObjectList.get(i))).getId();
+    			if (occurrenceId.equals(listOccId)) {
+    				contain = true;
+    				placings = i;   
+    				occ = (Occurrence)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	}    	    	               
                 
-        if (occurrenceId != recordId){
-            logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
-        }
-
-        //Get a specified number of columnName from occurrence mapping.
+        if (!contain) {
+        	// Select record Occurrence where id = occurrenceId 
+            Object[] objectOcc = searchObject(&quot;Occurrence&quot;,occurrenceId);
+            occ = (Occurrence)objectOcc[0];                    	
+        }    
+                
+        //Get number of columnName from occurrence mapping.
         int columnConstant;
         if (occurrenceHash.containsKey(columnName)) {
                  columnConstant = (Integer)occurrenceHash.get(columnName); 
@@ -636,38 +667,38 @@
                 Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
                 Plant plant = (Plant)object[0];
                 //Set old value to attribute plantID
-                occurrence.setPlant(plant);
+                occ.setPlant(plant);
                 logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
             } else {
                  logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
             } 
             break;
         case 2: //Year	
-            //Set old value to attribute Year          		
-                occurrence.setYearCollected(Integer.parseInt(oldValue));
+               //Set old value to attribute Year          		
+                occ.setYearCollected(Integer.parseInt(oldValue));
                 logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
                 //Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(Integer.parseInt(oldValue),occ.getMonthCollected(),occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
                 break;
         case 3: //Month 
                 // Set old value to attribute Month 
-                occurrence.setMonthCollected(Integer.parseInt(oldValue));
+                occ.setMonthCollected(Integer.parseInt(oldValue));
                 logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(occ.getYearCollected(), Integer.parseInt(oldValue), occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());              		
             break;
         case 4: //Day	                	
                 // Set old value to attribute Day            		
-                occurrence.setDayCollected(Integer.parseInt(oldValue));
+                occ.setDayCollected(Integer.parseInt(oldValue));
                 logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                isoDateTime.setTime(occ.getTimeCollected());
+                isoDateTime.set(occ.getYearCollected(), occ.getMonthCollected(), Integer.parseInt(oldValue));
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());
                 break;
         case 5: //Time 	                		                	
                 // Set old value to attribute Time   
@@ -678,26 +709,26 @@
                 } catch (ParseException e) {
                         logger.error(&quot;Parse time failed. &quot;+ e);
                 }
-                occurrence.setTimeCollected(time);
+                occ.setTimeCollected(time);
                 logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
                 // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
                 isoDateTime.setTime(time);
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                isoDateTime.set(occ.getYearCollected(), occ.getMonthCollected(), occ.getDayCollected());
+                occ.setIsoDateTimeBegin(isoDateTime.getTime());
             break;
         case 6: //Source	                	
                 // Set old value to attribute Source 
-                occurrence.setDataSource(oldValue);
+                occ.setDataSource(oldValue);
                 logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
                 break;
         case 7: //Herbarium
                 // Set old value to attribute Herbarium
-                occurrence.setHerbarium(oldValue);
+                occ.setHerbarium(oldValue);
                 logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
             break;
         case 8: //Note occurrence	
                 // Set old value to attribute Note occurence	                	
-                occurrence.setNote(oldValue);
+                occ.setNote(oldValue);
                 logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
                 break;
         case 9: //Publication  
@@ -706,39 +737,77 @@
                     Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
                     Publication publication = (Publication)objectPubl[0];
                     //Set old value to attribute publicationID
-                    occurrence.setPublication(publication);
+                    occ.setPublication(publication);
                     logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
                 }else {
                     logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
                 }
             break;
+        case 10: //metadata
+        		//Select record Publication where id = oldRocordId 
+	            if (oldRecordId &gt; 0){
+	                Object[] objectMetadata = searchObject(&quot;Metadata&quot;,oldRecordId);
+	                Metadata metadata = (Metadata)objectMetadata[0];
+	                //Set old value to attribute metadataID
+	                occ.setMetadata(metadata);
+	                logger.debug(&quot;Set selected value for update of attribute Metadata.&quot;);
+	            }else {
+	                logger.error(&quot;UNDO - Incorrect oldRecordId for Metadata.&quot;);
+	            }
+        	break;
+        case 11: //habitat
+        		//Select record Publication where id = oldRocordId 
+	            if (oldRecordId &gt; 0){
+	                Object[] objectHabitat = searchObject(&quot;Habitat&quot;,oldRecordId);
+	                Habitat habitat = (Habitat)objectHabitat[0];
+	                //Set old value to attribute habitatID
+	                occ.setHabitat(habitat);
+	                logger.debug(&quot;Set selected value for update of attribute Habitat.&quot;);
+	            }else {
+	                logger.error(&quot;UNDO - Incorrect oldRecordId for Habitat.&quot;);
+	            }
+        	break;
         default:            
             logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-        }         
+        }    
+        
+        if (contain) {        	
+        	editObjectList.set(placings, (Record)occ);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add occurrences&quot;);
+            editObjectList.add(occ);
+        }
     }
         
     /**
-     *
+     * Rollback data editing concerned with specific habitat
      */
     public void undoHabitat() {
-        
-        //historie lokalit se sleduje zvlast                
-        int habitatId = historyChange.getRecordId();	
-        Object[] object = searchObject(&quot;Habitat&quot;,habitatId);        
-        Habitat habitat = (Habitat)object[0];
-      
-        //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu
-        //protoze neni k dispozici kaskadovy update musi se do seznamu objektu pridat i Habitat, i kdyz na nej muzem pristupovat pres konkretni zaznam
-        boolean objectList = editObjectList.contains((Record)habitat); 
-        if (!objectList) {
-            //pridani objektu do listu - informace o tom, ze byl dany objekt editovan (editace habitat vzdy v ramci occurrence)
-            editObjectList.add((Record)habitat);
-        }
-        logger.debug(&quot;editObjectList: &quot;+objectList);
-        logger.debug(&quot;Habitat - OccurrenceID: &quot;+habitat.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-        // Get a specified number of columnName from habitat mapping.
+                         
+        int habitatId = historyChange.getRecordId();	        
+        Habitat hab = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Habitat) {    			
+    			int listHabId = ((Habitat)(editObjectList.get(i))).getId();
+    			if (habitatId == listHabId) {
+    				contain = true;
+    				placings = i; 
+    				hab = (Habitat)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Habitat where id = habitatId 
+    		Object[] object = searchObject(&quot;Habitat&quot;,habitatId);        
+            hab = (Habitat)object[0];
+        } 
+                             
+        // Get number of columnName from habitat mapping.
         int columnConstant;
         if (habitatHash.containsKey(columnName)) {
                  columnConstant = (Integer)habitatHash.get(columnName); 
@@ -748,95 +817,108 @@
 
         // Save new value for the column        		
         switch (columnConstant) {
-        case 1:  //Quadrant     	                	
-                /* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
-                 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
-                 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
-                 */ 	                		  
-                occurrence.getHabitat().setQuadrant(oldValue);		                	
+        case 1:  //Quadrant     	                	                	                		  
+                hab.setQuadrant(oldValue);		                	
                 logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);                	
             break;
         case 2: //Place description 	                	 	                			                		 
-                occurrence.getHabitat().setDescription(oldValue);		                	
+                hab.setDescription(oldValue);		                	
                 logger.debug(&quot;Set selected value for update of attribute Description.&quot;);              	              	
                 break;
         case 3:  //Country 	                	 	                			                		 
-                occurrence.getHabitat().setCountry(oldValue);		                	
+                hab.setCountry(oldValue);		                	
                 logger.debug(&quot;Set selected value for update of attribute Country.&quot;);                
             break;
         case 4: //Altitude 	                	                			                		 
-                occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
+                hab.setAltitude(Double.parseDouble(oldValue));		                	
                 logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);                
                 break;
         case 5:  //Latitude   	                		                			                		  
-                occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
+                hab.setLatitude(Double.parseDouble(oldValue));		                	
                 logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);                
             break;
         case 6: //Longitude 	                		                			                		
-                occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
+                hab.setLongitude(Double.parseDouble(oldValue));		                	
                 logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);                
                 break;
         case 7: //Nearest bigger seat   	                	 	                			                		 
-                //Nacteni Village pro nasledny update tHabitat.cNearestVillageId
+                //Select record Village where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
                         Village village = (Village)objectVill[0];
-                occurrence.getHabitat().setNearestVillage(village);
+                hab.setNearestVillage(village);
                 logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
                 } else {
                         logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
                 }                
             break;
         case 8: //Phytochorion or phytochorion code 	                	             			                		 
-                // Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
+                // Select record Phytochoria where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
                         Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
-                        occurrence.getHabitat().setPhytochorion(phytochorion);
+                        hab.setPhytochorion(phytochorion);
                         logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
                 }else {
                         logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
                 }                
             break; 	               
         case 9:  //Territory   	                	                			                		  
-                // Nacteni Territory pro nasledny update tHabitat.cTerritory
+                // Select record Territory where id = oldRocordId 
                 if (oldRecordId != 0){
                         Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
                         Territory territory = (Territory)objectTerr[0];
-                        occurrence.getHabitat().setTerritory(territory);
+                        hab.setTerritory(territory);
                         logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
                 }else {
                         logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
                 }	               
             break;
         case 10: //Note habitat	                		                			                		  
-                occurrence.getHabitat().setNote(oldValue);		                	
+                hab.setNote(oldValue);		                	
                 logger.debug(&quot;Set selected value for update of attribute Note.&quot;);                
                 break;
         default:            
             logger.error(&quot;Habitat - No column defined for name &quot;+ columnName);	                   
-        }  	          
+        }
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)hab);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add habitat&quot;);
+            editObjectList.add(hab);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific publication
      */
     public void undoPublication() {
-                
-        Object[] object = searchObject(&quot;Publication&quot;, recordId);
-        publication = (Publication)object[0];
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)publication); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)publication);
-        }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;Publication: &quot;+publication.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+         
+    	int publicationId = historyChange.getRecordId();	        
+        Publication publication = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Publication) {    			
+    			int listPubId = ((Publication)(editObjectList.get(i))).getId();
+    			if (publicationId == listPubId) {
+    				contain = true;
+    				placings = i; 
+    				publication = (Publication)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Publication where id = publicationId 
+    		Object[] object = searchObject(&quot;Publication&quot;, publicationId);
+            publication = (Publication)object[0];
+        } 
+            	        
+       // Get number of columnName from publication mapping.
         int columnConstant;
         if (publicationHash.containsKey(columnName)) {
                  columnConstant = (Integer)publicationHash.get(columnName); 
@@ -877,27 +959,44 @@
         default:            
             logger.error(&quot;Publication - No column defined for name &quot;+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)publication);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add publication&quot;);
+            editObjectList.add(publication);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific author
      */
     public void undoAuthor() {
         
-       Object[] object = searchObject(&quot;Author&quot;, recordId);
-       author = (Author)object[0];
+    	int authorId = historyChange.getRecordId();	        
+        Author author = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Author) {    			
+    			int listAutId = ((Author)(editObjectList.get(i))).getId();
+    			if (authorId == listAutId) {
+    				contain = true;
+    				placings = i; 
+    				author = (Author)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Author where id = authorId 
+    		Object[] object = searchObject(&quot;Author&quot;, authorId);
+            author = (Author)object[0];
+        } 	
        
-       //test, zda jiz dany zaznam byl editovan
-       boolean objectList = editObjectList.contains((Record)author); 
-       if (!objectList) {
-       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-           editObjectList.add((Record)author);
-       }
-       logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-       logger.debug(&quot;author: &quot;+author.getId());
-       logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+    	// Get number of columnName from author mapping.
         int columnConstant;
         if (authorHash.containsKey(columnName)) {
                  columnConstant = (Integer)authorHash.get(columnName); 
@@ -942,27 +1041,44 @@
         default:            
             logger.error(&quot;Author - No column defined for name &quot;+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)author);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add author&quot;);
+            editObjectList.add(author);
+        }
     }
     
     /**
-     *
+     * Rollback data editing concerned with specific metadata
      */
     public void undoMetadata() {
-        
-       Object[] object = searchObject(&quot;Metadata&quot;, recordId);
-       metadata = (Metadata)object[0];
        
-       //test, zda jiz dany zaznam byl editovan
-       boolean objectList = editObjectList.contains((Record)metadata); 
-       if (!objectList) {
-       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-           editObjectList.add((Record)metadata);
-       }
-       logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-       logger.debug(&quot;metadata: &quot;+ metadata.getId());
-       logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
+    	int metadataId = historyChange.getRecordId();	        
+        Metadata metadata = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Metadata) {    			
+    			int listOccId = ((Metadata)(editObjectList.get(i))).getId();
+    			if (metadataId == listOccId) {
+    				contain = true;
+    				placings = i; 
+    				author = (Author)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Metadata where id = metadataId 
+    		Object[] object = searchObject(&quot;Metadata&quot;, metadataId);
+    	    metadata = (Metadata)object[0];
+        }
+    	
+        // Get number of columnName from metadata mapping.
         int columnConstant;
         if (metadataHash.containsKey(columnName)) {
                  columnConstant = (Integer)metadataHash.get(columnName); 
@@ -1027,28 +1143,45 @@
         default:            
             logger.error(&quot;Metadata - No column defined for name &quot;+ columnName);	                   
         } 
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)metadata);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add metadata&quot;);
+            editObjectList.add(metadata);
+        }
     }
     
     
     /**
-     *
+     * Rollback data editing concerned with specific phytochorion
      */
     public void undoPhytochorion() {
         
-        Object[] object = searchObject(&quot;Phytochorion&quot;, recordId);
-        phytochorion = (Phytochorion)object[0];     
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)phytochorion); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)phytochorion);
+    	int phytId = historyChange.getRecordId();	        
+        Phytochorion phytochorion = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Phytochorion) {    			
+    			int listPhytId = ((Phytochorion)(editObjectList.get(i))).getId();
+    			if (phytId == listPhytId) {
+    				contain = true;
+    				placings = i; 
+    				phytochorion = (Phytochorion)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Phytochorion where id = phytochorionId 
+    		Object[] object = searchObject(&quot;Phytochorion&quot;, phytId);
+            phytochorion = (Phytochorion)object[0];     
         }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;phytochorion: &quot;+phytochorion.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-      
-        if (columnName.equals(&quot;namePhytochorion&quot;)) {
+    	
+    	if (columnName.equals(&quot;namePhytochorion&quot;)) {
             phytochorion.setCode(oldValue);	                 
             logger.debug(&quot;Phytochorion - Set selected value for update of attribute WholeName.&quot;);                 	
         } else if (columnName.equals(&quot;code&quot;)) {
@@ -1056,70 +1189,115 @@
              logger.debug(&quot;Phytochorion - Set selected value for update of attribute Address.&quot;);                 	             	
         } else {
             logger.error(&quot;Phytochorion - No column defined for name &quot;+ columnName);
-        }              
+        }   
+    	
+    	if (contain) {        	
+        	editObjectList.set(placings,(Record)phytochorion);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add phytochorion&quot;);
+            editObjectList.add(phytochorion);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific village
      */
     public void undoVillage() {
        
-        Object[] object = searchObject(&quot;Village&quot;, recordId);
-        village = (Village)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)village); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)village);
+    	int villageId = historyChange.getRecordId();	        
+        Village village = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Village) {    			
+    			int listVillId = ((Village)(editObjectList.get(i))).getId();
+    			if (villageId == listVillId) {
+    				contain = true;
+    				placings = i; 
+    				village = (Village)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Village where id = villageId 
+    		Object[] object = searchObject(&quot;Village&quot;, villageId);
+            village = (Village)object[0];     
         }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;village: &quot;+village.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
+       
        // Save new value for the column
         if (columnName.equals(&quot;nameVillage&quot;)) {
             village.setName(oldValue);	                 
             logger.debug(&quot;Village - Set selected value for update of attribute Name.&quot;);                 	
         } else {
             logger.error(&quot;Village - No column defined for name &quot;+ columnName);	                   
-        }       
+        }   
+        
+        if (contain) {        	
+        	editObjectList.set(placings,(Record)village);        
+        } else {
+        	// add object to list of editing object
+            logger.debug(&quot;ObjectList - add village&quot;);
+            editObjectList.add(village);
+        }
     }
     
     /**
-     *
+     *  Rollback data editing concerned with specific territory
      */
     public void undoTerritory() {
        
-        Object[] object = searchObject(&quot;Territory&quot;, recordId);
-        territory = (Territory)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains((Record)territory); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add((Record)territory);
+    	int territoryId = historyChange.getRecordId();	        
+        Territory territory = null;
+    	int placings = 0;
+    	boolean contain = false;
+    	for (int i=0; i &lt; editObjectList.size(); i++) {
+    		if (editObjectList.get(i) instanceof Territory) {    			
+    			int listTerrId = ((Territory)(editObjectList.get(i))).getId();
+    			if (territoryId == listTerrId) {
+    				contain = true;
+    				placings = i; 
+    				territory = (Territory)(editObjectList.get(i));
+    				break;
+    			}
+    		}
+    	} 
+    	
+    	if (!contain) {
+        	// Select record Territory where id = territoryId 
+    		Object[] object = searchObject(&quot;Territory&quot;, territoryId);
+    		territory = (Territory)object[0];     
         }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;territory: &quot;+territory.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
+    	        
        if (columnName.equals(&quot;nameTerritory&quot;)) {
            territory.setName(oldValue);	                 
            logger.debug(&quot;Territory - Set selected value for update of attribute Name.&quot;);                 	 
        } else {
            logger.error(&quot;Territory - No column defined for name &quot;+ columnName);	                   
-       }        
+       }     
+       
+       if (contain) {        	
+       	   editObjectList.set(placings,(Record)territory);        
+       } else {
+       	// add object to list of editing object
+           logger.debug(&quot;ObjectList - add territory&quot;);
+           editObjectList.add(territory);
+       }
     }
     
     /**
      * 
-     * @param id
-     * @return
+     * @param typeObject string containing information about type of object
+     * @param id int containing identifier of record
+     * @return object defined by parameters typeObject and id
      */
     public Object[] searchObject(String typeObject, int id) {       
     	SelectQuery query = null;
-
+    	int resultIdObject = 0;
+    	Object[] object = null;
+    	
         try {
             if (typeObject.equals(&quot;Occurrence&quot;)){
                 query = database.createQuery(Occurrence.class);
@@ -1153,97 +1331,88 @@
                 query.addRestriction(PlantloreConstants.RESTR_EQ, Metadata.ID, null, id , null);
             } else {
                 logger.error(&quot;SearchObject() - Incorrect type of object.&quot;);
+                
             }
+            resultIdObject = database.executeQuery(query);
+            object = database.next(resultIdObject);
+            database.closeQuery(query);
         } catch(RemoteException e) {
-            System.err.println(&quot;RemoteException, searchObject() - &quot;+typeObject+&quot;, createQuery&quot;);
+        	logger.error(&quot;Remote exception caught in History. Details: &quot;+e.getMessage());
+       	    setError(ERROR_SEARCH_OBJECT);
+	       	 //Tell observers to update
+	         setChanged();
+	         notifyObservers();
         } catch(DBLayerException e) {
-            System.err.println(&quot;DBLayerException, searchObject() - &quot;+typeObject+&quot;, createQuery&quot;);
+        	logger.error(&quot;Search selected &quot; + typeObject  +&quot; failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_OBJECT);   
+            //Tell observers to update
+            setChanged();
+            notifyObservers();
         }
-        
-        int resultId = 0;
-        try {                   
-            resultId = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching &quot; +typeObject+ &quot; failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- executeQuery &quot; +typeObject);
- 	} 
-       Object[] objects = null;
-       Object[] object = null;
-       try {
-       	    // Retrieve selected row interval         	
-            try {
-                 objects = database.more(resultId, 0, 0);  
-            } catch(RemoteException e) {            	
-                logger.debug(&quot;RemoteException- searchObject, more&quot;);            	
-            }   
-            object = (Object[])objects[0];           
-            //close session
-            database.closeQuery(query);            
-       } catch (DBLayerException e) {
-           // Log and set error in case of an exception
-           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());            
-       } catch (RemoteException e) {
-           // Log and set error in case of an exception
-           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());            
-       }       
-       return object; 	       	          	   
-           	        
+       
+        //TODO
+	   if (object == null) {
+		   logger.error(&quot;t&quot;+typeObject+ &quot; doesn't contain required data&quot;);  
+		   setError(ERROR_SEARCH_OBJECT);		   
+		   //Tell observers to update
+           setChanged();
+           notifyObservers();
+	   } 	   
+       return object; 	       	          	              	        
     }
     
-    /*
-     * Funkce, ktera mi dohleda vsechny autory ke konkretnimu nalezu
-     * isDlete - rekne, zda pozadujeme vsechny aktivni nebo neaktivni zaznamy
+    /**     
+     * Seach all authors concerned with specific occurrence
+     * @param occurrence 
+     * @param idDelete 
      */
     public Object[] getAllAuthors(Occurrence occurrence, int isDelete) {        
         
         SelectQuery query = null;        
-        int resultId = 0;        
+        int resultIdAuthors = 0; 
+        Object[] objects = null;
         try {
             query = database.createQuery(AuthorOccurrence.class);
             query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.OCCURRENCE, null, occurrence , null);
-            if (isDelete == 1) {
-                query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 1 , null);
+            if (isDelete == 0) {
+                query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 0 , null);
             } else {
-                Object[] args = new Object[8];
-                args[0] = PlantloreConstants.RESTR_EQ;
-                args[1] = AuthorOccurrence.DELETED;
-                args[2] = null;
-                args[3] = 0;                    
-                args[4] = PlantloreConstants.RESTR_EQ;
-                args[5] = AuthorOccurrence.DELETED;
-                args[6] = null;
-                args[7] = 2;
-                query.addOrRestriction(args);                
+            	query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 2 , null);                               
             }
-            resultId = database.executeQuery(query);
+            resultIdAuthors = database.executeQuery(query);
+            int to = database.getNumRows(resultIdAuthors); 
+            if (to &gt; 0)
+                objects = database.more(resultIdAuthors, 0, to-1);
+            database.closeQuery(query);
         } catch(RemoteException e) {
-            System.err.println(&quot;RemoteException, getAllAuthors() - AuthorOccurrence, createQuery&quot;);
+        	logger.error(&quot;Remote exception caught in History. Details: &quot;+e.getMessage());
+       	    setError(ERROR_SEARCH_AUTHOR);
+       	    //Tell observers to update
+            setChanged();
+            notifyObservers();
         } catch(DBLayerException e) {
-            System.err.println(&quot;RemoteException, getAllAuthors() - AuthorOccurrence, createQuery&quot;);
+        	logger.error(&quot;Search authors failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_AUTHOR); 
+            //Tell observers to update
+            setChanged();
+            notifyObservers();
+        }     
+        
+        //TODO
+        if(objects == null ) {
+        	logger.error(&quot;tAuthorOccurrence doesn't contain required data&quot;);  
+ 		    setError(ERROR_SEARCH_AUTHOR);
+ 		    //Tell observers to update
+            setChanged();
+            notifyObservers();
         }
-       Object[] objects = null;   
-       
-       try {
-            int to = database.getNumRows(resultId); 
-            if (to &gt; 0)
-                objects = database.more(resultId, 0, to-1);  
-        } catch (RemoteException ex) {
-            ex.printStackTrace();
-        } catch (DBLayerException ex) {
-            ex.printStackTrace();
-        }         
-       //close session
-        try {
-            database.closeQuery(query);
-        } catch(RemoteException e) {
-            System.err.println(&quot;RemoteException, getAllAuthors() - AuthorOccurrence, createQuery&quot;);
-        }         
+        
        return objects;
     }
     
-    /*
-     * Funkce, ktera vrati jmena autoru pro dany nalez
+    /**
+     *  Get names of authors for specific occurrence
+     *  @param objects  
      */
     public String getAllNameOfAuthors(Object[] objects) {
         if (objects == null)
@@ -1262,12 +1431,11 @@
     }
     
     /**
-     *  ..... pri whole history se bude do promennych occurrence, atd. nacitat vice ruznych objektu s jinym ID
-     *  ....Musim si ty jednotlive objekty pamatovat --&gt; pole objektu, kde budou jednotlive editovane objekty
+     *  Update data in the database.
      */
     public void commitUpdate() {    	                
         
-        ArrayList&lt;Enum&gt; editType = new ArrayList();
+        ArrayList&lt;Enum&gt; editType = new ArrayList&lt;Enum&gt;();
         String type;
         Enum key;
         initEditTypeHash();
@@ -1275,28 +1443,35 @@
     	int count = editObjectList.size();        
     	for (int i=0; i&lt; count; i++) {
     		try {
-    			logger.debug(&quot;Object for update: &quot;+editObjectList.get(i).getId()); 
-                        
-                        type = editObjectList.get(i).getClass().getSimpleName();
-                         if (editTypeHash.containsKey(type)) {
-                                 key = (Enum)editTypeHash.get(type); 
-                                 if(!editType.contains(key))
-                                     editType.add(key);
-                        }                         
-                            
-                        database.executeUpdateHistory(editObjectList.get(i));
+    			logger.debug(&quot;Object for update: &quot;+ ((Record)editObjectList.get(i)).getId());                         
+                type = editObjectList.get(i).getClass().getSimpleName();
+                 if (editTypeHash.containsKey(type)) {
+                         key = (Enum)editTypeHash.get(type); 
+                         if(!editType.contains(key))
+                             editType.add(key);
+                }                                                     
+                database.executeUpdateHistory(editObjectList.get(i));
 	        } catch (RemoteException e) {
-	                logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
+	        	logger.error(&quot;Update data failed.Remote exception caught in History. Details: &quot;+e.getMessage());
+	       	    setError(ERROR_UPDATE);
+	       	    //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 	        } catch (DBLayerException e) {
-	                logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
+	        	logger.error(&quot;Update data failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+	            setError(ERROR_UPDATE); 
+	            //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 	        }                
        }    	
-       
+    	//Create array of editing object and call notifyObservers
         informMethod(editType);
     }
     
     /**
-     *  Metoda vytvori pole typu editovanych objektu a preda je v parametru notifyObserver
+     *  Create array of editing object and give this array to parrent
+     *  @param editType
      */
     public void informMethod(ArrayList&lt;Enum&gt; editType) {
         int count = editType.size();
@@ -1310,22 +1485,23 @@
     }
     
     /**
-     *  vycisteni seznamu editovany objektu: 
+     *  Clear list of editing object
      */
     public void clearEditObjectList() {
     	editObjectList.clear();
     }
        
     /**
-     * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
-     * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
+     * Delete selected data from history table. During delete data from table tHistoryChange verify foring key from table tHistory.
+     * @param toResult
+     * @param typeHistory
      */
     public void deleteHistory(int toResult, boolean typeHistory) {
    	
     	//take from younger record to older record
     	for( int i=0; i &lt; toResult; i++) {
-    		if (typeHistory &amp;&amp; !markListId.contains(i)) {
-    			logger.debug(&quot;History of one occurence: &quot;+markListId.contains(i));
+    		if (typeHistory &amp;&amp; !markListId.contains(i)) {    			
+    			//History of occurence or habitat. The record is not selected.
     			continue;    			
     		}    		    		
     		historyRecord = (HistoryRecord)historyDataList.get(i); 
@@ -1334,135 +1510,106 @@
 	    	try {
 				database.executeDeleteHistory(historyRecord);
 				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
-			} catch (RemoteException e) {
-				logger.error(&quot;Deleting historyRecord - remoteException. &quot;+e.toString());
-			} catch (DBLayerException e) {
-				logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
+			} catch (RemoteException e) {				
+				logger.error(&quot;Deleting historyRecord failed.Remote exception caught in History. Details: &quot;+e.getMessage());
+	       	    setError(ERROR_DELETE);
+	       	    //Tell observers to update
+	            setChanged();
+	            notifyObservers();
+			} catch (DBLayerException e) {				
+				logger.error(&quot;Deleting historyRecord failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+	            setError(ERROR_DELETE); 
+	            //Tell observers to update
+	            setChanged();
+	            notifyObservers();
 			}
 			int countResult = getRelationshipHistoryChange(historyChange.getId());			
-			if (countResult == 0) {
-				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
-				//pokud po smazani zaznamu z tHistory jsme nasli alespon jeden zaznam, ktery ma stejny FK na zaznam z tChangeHistory
+			if (countResult == 0) {				
 				try {
 					database.executeDeleteHistory(historyChange);
 					logger.debug(&quot;Deleting historyChange successfully.&quot;);
 				} catch (RemoteException e) {
-					logger.error(&quot;Deleting historyChange - remoteException. &quot;+e.toString());
+					logger.error(&quot;Deleting historyChange failed.Remote exception caught in History. Details: &quot;+e.getMessage());
+		       	    setError(ERROR_DELETE);
+		       	    //Tell observers to update
+		            setChanged();
+		            notifyObservers();
 				} catch (DBLayerException e) {
-					logger.error(&quot;Deleting historyChange failed. &quot;+e.toString());
+					logger.error(&quot;Deleting historyChange failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+		            setError(ERROR_DELETE); 
+		            //Tell observers to update
+		            setChanged();
+		            notifyObservers();
 				}
 			} else {
 				logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
 			}
     	}    	
-		//Clear list 
+		//Clear lists 
     	markListId.clear();
     	markItem.clear();    		
     } 
     
     /**
-     * Zjisteni kolik zaznamu v tabulce tHistory je provazano s konkretnim zaznamem z tHistoryHange 
-     * @param id
-     * @return
+     * Get number of record from tHistory, whitch has the value of attribute cChangeId equals id
+     * @param id identifier of historyChange record 
+     * @return int number of record from tHistory, whitch has the value of attribute cChangeId equals id
      */
     public int getRelationshipHistoryChange(int id){    	
     	SelectQuery query = null;
+    	int resultIdChange = 0;
+    	int countResult = 100;
         try {
                 query = database.createQuery(HistoryRecord.class);
                 // Create aliases for table tHistoryChange.      
                 query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);  
                 // Add restriction to cChangeId column 
                 query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
+                resultIdChange = database.executeQuery(query);
+                countResult = database.getNumRows(resultIdChange);
+                database.closeQuery(query);
         } catch(RemoteException e) {
-        	System.err.println(&quot;RemoteException - searchHistoryChangeId(), createQuery&quot;);       	  
+        	logger.error(&quot;Searching historyChange failed.Remote exception caught in History. Details: &quot;+e.getMessage());
+       	    setError(ERROR_SEARCH_RECORD);       	   
+            setChanged();
+            notifyObservers();       	  
         } catch(DBLayerException e) {
-        	System.err.println(&quot;DBLayerException - searchHistoryChangeId(), createQuery&quot;);       	  
-        }
-        
-        
-        int resultIdChange = 0;
-        try {                   
-        	resultIdChange = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- getRelationshipHistoryChange(), executeQuery&quot;);
-        } 
-
-        int countResult = 100;
-        try {
-            countResult = database.getNumRows(resultIdChange);
-            logger.debug(&quot;getRelationshipHistoryChange - Number of result: &quot;+countResult);
-            //close session
-            database.closeQuery(query);
-        } catch (RemoteException e) {
-            System.err.println(&quot;RemoteException- getRelationshipHistoryChange(), getNumRows&quot;);
-        }
-	return countResult;
-    }
-    
-    /*
-     * Tato funkce vrati pocet zaznamu z tOccurrence, ktere jsou provazany s konktretnim zaznamem v tHabitats
-     */
-    public int getRelationshipHabitat() {
-        SelectQuery query = null;
-        try {
-                query = database.createQuery(Occurrence.class);                
-                query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.HABITAT , null, occurrence.getHabitat() , null);
-        } catch(RemoteException e) {
-        	System.err.println(&quot;RemoteException - getRelationshipHabitat(), createQuery&quot;);       	  
-        } catch(DBLayerException e) {
-        	System.err.println(&quot;DBLayerException - getRelationshipHabitat(), createQuery&quot;);       	  
+        	logger.error(&quot;Searching historyChange failed. DBLayer exception caught in History. Details: &quot;+e.getMessage());       	                                                   
+            setError(ERROR_SEARCH_RECORD);            
+            setChanged();
+            notifyObservers();       	  
         }        
-        
-        int resultIdHabitat = 0;
-        try {                   
-        	resultIdHabitat = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching habitatId failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- getRelationshipHabitat(), executeQuery&quot;);
-        } 
-
-        int countResult = 100;
-        try {
-            countResult = database.getNumRows(resultIdHabitat);
-            logger.debug(&quot;getRelationshipHabitat - Number of result: &quot;+countResult);
-            //close session
-            database.closeQuery(query);
-        } catch (RemoteException e) {
-            System.err.println(&quot;RemoteException- searchHistoryChangeId(), getNumRows&quot;);
-        }
-	return countResult;
+       	return countResult;
     }
-    
-    /*
-     * Tato funkce je volana jen pro UNDO RECORD, coz znamena, ze pracuje jen s konkretnim nalezem
+         
+    /**
+     * Create message contains information about selected items. 
      */
     public void generateMessageUndo() {    	
     	messageUndo = &quot;&quot;;      
-    	int count = markItem.size();
+    	int count = markItem.size();    	
     	for (int i=0; i&lt;count; i++) {
     		Object[] itemList = (Object[])(markItem.get(i));
     		String item = (String)itemList[0];
     		Integer maxId = (Integer)itemList[1];      		
     		oldValue = ((HistoryRecord)historyDataList.get(maxId)).getOldValue(); 
     		messageUndo = messageUndo + item + &quot;  --&gt;  &quot; + oldValue + &quot;\n&quot;;
-    	}
-        //pracuji stale s konkretnim occurrence
-        int countResult = getRelationshipHabitat();			
-        if (countResult &gt; 1) {
-            messageUndo = &quot;\n&quot; + messageUndo + L10n.getString(&quot;Question.UndoDetail&quot;);
-    	}
+    	}       
     }    
 
+    /**
+     * Create message containinig information about operation which will be realised    
+     * @param toDate  Date to which all the changes will be turned back.
+     * @return message containinig information about operation which will be realised
+     */
     public String getMessageUndoToDate(String toDate) {
-        String message = &quot;V&#353;echny zm&#283;ny od &quot; + toDate + &quot; budou zru&#353;eny.&quot;; 
+        String message = &quot;V&#353;echny zm&#283;ny do &quot; + toDate + &quot; budou navr&#225;ceny.&quot;; //All changes to 12.4.06 will be turned back.
         return message;
     }
     
-    /*
-     * Funkce ktera zjisti podrobne informace o polozce, ktera byla editovana
+    /**
+     *  Create message containing details about record
+     *  @param resultNumber 
      */
     public String getDetailsMessage(int resultNumber) {
         
@@ -1474,10 +1621,8 @@
         historyChange = historyRecord.getHistoryChange();
         tableName = historyRecord.getHistoryColumn().getTableName();
         recordId = historyChange.getRecordId();
-                
-        
-        //podle tableName najdeme podrobnosti o konkretnim objektu (autor, publikace, nalez,...)
-         if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
+                        
+        if (tableName.equals(PlantloreConstants.ENTITY_OCCURRENCE) || tableName.equals(PlantloreConstants.ENTITY_HABITAT) || tableName.equals(PlantloreConstants.ENTITY_AUTHOROCCURRENCE)) {           
               //Get details for occurrence
               int occurrenceId = historyChange.getRecordId();
               //Select record Occurrence where id = occurrenceId 
@@ -1494,11 +1639,22 @@
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.COUNTRY) + &quot;: &quot; + occurrence.getHabitat().getCountry() +&quot;\n&quot;;
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +&quot;.&quot;+ Occurrence.DATASOURCE) + &quot;: &quot; + occurrence.getDataSource() + &quot;\n&quot;;
               if (occurrence.getPublication() != null)
-                detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +&quot;.&quot;+ Occurrence.PUBLICATION) + &quot;: &quot; + occurrence.getPublication().getReferenceCitation() + &quot;\n&quot;;
+            	  detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +&quot;.&quot;+ Occurrence.PUBLICATION) + &quot;: &quot; + occurrence.getPublication().getReferenceCitation() + &quot;\n&quot;;
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +&quot;.&quot;+ Occurrence.HERBARIUM) + &quot;: &quot; + occurrence.getHerbarium() +&quot;\n&quot;;
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_OCCURRENCE +&quot;.&quot;+ Occurrence.NOTE) + &quot;: &quot; + occurrence.getNote() + &quot;\n&quot;;
               detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.NOTE) + &quot;: &quot; + occurrence.getHabitat().getNote() +&quot;\n&quot;;
-        } else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
+        }else if (tableName.equals(PlantloreConstants.ENTITY_HABITAT)) {
+        	  //Get details for Publication
+              Object[] object = searchObject(&quot;Habitat&quot;,recordId);
+              Habitat habitat = (Habitat)object[0];
+              detailsMessage = L10n.getString(&quot;History.DetailsOccurrence&quot;) + &quot;\n\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.NEARESTVILLAGE) + &quot;: &quot;+ occurrence.getHabitat().getNearestVillage().getName() + &quot;\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.DESCRIPTION) + &quot;: &quot;+ occurrence.getHabitat().getDescription() + &quot;\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.TERRITORY) + &quot;: &quot;+ occurrence.getHabitat().getTerritory().getName() + &quot;\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.PHYTOCHORION) + &quot;: &quot;+ occurrence.getHabitat().getPhytochorion().getName() +&quot; (Code: &quot; + occurrence.getHabitat().getPhytochorion().getCode() + &quot;)\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.COUNTRY) + &quot;: &quot; + occurrence.getHabitat().getCountry() +&quot;\n&quot;;
+              detailsMessage = detailsMessage + L10n.getString(PlantloreConstants.ENTITY_HABITAT +&quot;.&quot;+ Habitat.NOTE) + &quot;: &quot; + occurrence.getHabitat().getNote() +&quot;\n&quot;;
+    	}else if (tableName.equals(PlantloreConstants.ENTITY_PUBLICATION)) {
               //Get details for Publication
               Object[] object = searchObject(&quot;Publication&quot;,recordId); 
               Publication publication = (Publication)object[0];
@@ -1574,15 +1730,13 @@
         return detailsMessage;
     }
     
-    /*
-     * Tato funkce smaze vsechny data z tabulky tHistoryChange a z tHistory
-     * delete from tHistory;
-     * delete from tHistoryChange;
+    /**
+     *  Delete all date from tables tHistorz and tHistoryChange
      */
     public void clearHistory() {        
         
         try {
-            //smazani dat z tabulky tHistory
+            //delete data from table tHistory
             database.conditionDelete(HistoryRecord.class, HistoryRecord.ID, &quot;&gt;&quot;, 0);
         } catch (RemoteException ex) {
             ex.printStackTrace();
@@ -1591,7 +1745,7 @@
         }
         
         try {            
-            //smazani dat z tabulky tHistoryChange
+            //delete data from  table tHistoryChange
             database.conditionDelete(HistoryChange.class, HistoryChange.ID, &quot;&gt;&quot;, 0);
         } catch (DBLayerException ex) {
             ex.printStackTrace();
@@ -1601,10 +1755,8 @@
         
     }
     
-    /*
-     * Tato funkce projde tabulky s cdelete - tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications
-     * a smaze v techto tabulkach zaznamy, ktere maji cdelete == 1
-     * delete from tAuthors where cdelete = 1;
+    /**
+     * Delete all record with cdelete equals 1 from table tAuthors, tAuthorsOccurrences, tOccurrences, tHabitats, tPublications
      */
     public void clearDatabase() {
         try {
@@ -1668,6 +1820,7 @@
         occurrenceHash.put(Occurrence.NOTE, 8);
         occurrenceHash.put(Occurrence.PUBLICATION, 9);       
         occurrenceHash.put(Occurrence.METADATA, 10);
+        occurrenceHash.put(Occurrence.HABITAT, 11);
     }    
     
     private void initHabitatHash() {
@@ -1741,6 +1894,43 @@
     //**************************//
     
     /**
+     *  Set an error flag.
+     *  @param msg  message explaining the error which occured
+     */
+    public void setError(String msg) {
+        this.error = msg;
+    }
+    
+    /**
+     *  Checks whether an error flag is set.
+     *  return true if an error occured and error message is available, false otherwise
+     */
+    public boolean isError() {
+        if (this.error != null) {
+            return true;
+        } else {
+            return false;
+        }
+    }
+    
+    /**
+     *  Get error message for the error that occured
+     *  @return message explaining the error which occured
+     */
+    public String getError() {
+        return this.error;
+    }
+    
+    
+    public Object getData() {
+    	return data;
+    }
+    
+    public void setData(Object data) {
+    	this.data = data;
+    }
+    
+    /**
      * @return true if all recorda were selected.
      */
     public boolean getSelectAll() {

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -154,7 +154,7 @@
         	   logger.debug(&quot;Button OK was press.&quot;);
         	   model.commitUpdate();
         	   model.deleteHistory(model.getResultRows(), true);
-        	   model.searchEditHistory();
+        	   model.searchEditHistory(model.getData());
         	   model.processResult(1,model.getDisplayRows());
         	   view.getTable().setModel(new HistoryTableModel(model));
         	   int resultRows = model.getResultRows();

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-13 13:45:46 UTC (rev 466)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-07-17 17:11:29 UTC (rev 467)
@@ -1827,6 +1827,10 @@
                     			 historyChange.setOldRecordId(((Habitat)newRec.getValue(columnName)).getId());
                     			 historyRecord.setOldValue(((Habitat)origValue).getDescription());
                          		 historyRecord.setNewValue(((Habitat)newValue).getDescription());
+                    		 } else if (((String)columnName).equals(Occurrence.METADATA)) {
+                    			 historyChange.setOldRecordId(((Metadata)newRec.getValue(columnName)).getId());
+                    			 historyRecord.setOldValue(((Metadata)origValue).getDataSetTitle());
+                         		 historyRecord.setNewValue(((Metadata)newValue).getDataSetTitle());
                     		 } else {
                     			String origValueString = (origValue == null) ? null : origValue.toString(),
                          			   newValueString = (newValue == null) ? null : newValue.toString(); 
@@ -1843,9 +1847,7 @@
                     	}
                     }
                 } else if (data instanceof AuthorOccurrence) { 
-                	AuthorOccurrence newRec = (AuthorOccurrence)data;
-                	// Save the HistoryChange object
-                    sess.save(historyChange);
+                	AuthorOccurrence newRec = (AuthorOccurrence)data;                	
                 	//delete == 0 ...edit information about Author in occurrence
                 	//delete == 1 ...delete Auhtor from occurrence
                 	//aoInsert == 1 ...add new Author to occurrence                      
@@ -1872,6 +1874,8 @@
                         	hist.setNewValue(newRec.getAuthor().getWholeName());
 	                        hist.setOldValue(null);
                         }
+                        // Save the HistoryChange object
+                        sess.save(historyChange);
                         // Save History record
                         sess.save(hist);                                                       
                 	} else {
@@ -1902,7 +1906,10 @@
 	                            String origValueString = (origRec.getValue((String)cols.get(i)) == null) ? null : origValue.toString(),
 	                           			   newValueString = (newRec.getValue((String)cols.get(i)) == null) ? null : newValue.toString(); 
 	                      		hist.setOldValue(origValueString);
-	                           	hist.setNewValue(newValueString);	                            
+	                           	hist.setNewValue(newValueString);
+	                            // Save the HistoryChange object
+	                            sess.save(historyChange);
+	                            // Save the History object
 	                            sess.save(hist);  
                             }
                         }
@@ -1915,6 +1922,7 @@
                         Object origValue = (origRec.getValue((String)cols.get(i)) == null) ? new String(&quot;&quot;) : origRec.getValue((String)cols.get(i));                        
                         Object newValue = (newRec.getValue((String)cols.get(i)) == null) ? new String(&quot;&quot;) : newRec.getValue((String)cols.get(i));                                                
                         if (!origValue.equals(newValue)) {
+                        	System.out.println(&quot; &gt;&gt; DIFFERENT_COLUMN: &quot; + (String)cols.get(i));
                             // Read record from THISTORYCOLUMN first                           	
                             res = sess.createCriteria(HistoryColumn.class)
                                 .add(Restrictions.eq(HistoryColumn.TABLENAME, PlantloreConstants.ENTITY_HABITAT))


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000601.html">[Plantlore-dev] r466 - in trunk: analysis/database	src/net/sf/plantlore/client/history	src/net/sf/plantlore/common/record	src/net/sf/plantlore/config/hibernate src/net/sf/plantlore/server
</A></li>
	<LI>Next message: <A HREF="000603.html">[Plantlore-dev] Plantlore
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#602">[ date ]</a>
              <a href="thread.html#602">[ thread ]</a>
              <a href="subject.html#602">[ subject ]</a>
              <a href="author.html#602">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
