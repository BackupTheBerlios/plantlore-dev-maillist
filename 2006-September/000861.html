<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r614 - in trunk/src/net/sf/plantlore:	client/checklist client/createdb client/export	client/export/builders client/export/component client/login	common common/debug common/record
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r614%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09client/checklist%20client/createdb%20client/export%0A%09client/export/builders%20client/export/component%20client/login%0A%09common%20common/debug%20common/record&In-Reply-To=%3C200609011309.k81D9eBx017347%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000860.html">
   <LINK REL="Next"  HREF="000862.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r614 - in trunk/src/net/sf/plantlore:	client/checklist client/createdb client/export	client/export/builders client/export/component client/login	common common/debug common/record</H1>
    <B>krater at mail.berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r614%20-%20in%20trunk/src/net/sf/plantlore%3A%0A%09client/checklist%20client/createdb%20client/export%0A%09client/export/builders%20client/export/component%20client/login%0A%09common%20common/debug%20common/record&In-Reply-To=%3C200609011309.k81D9eBx017347%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r614 - in trunk/src/net/sf/plantlore:	client/checklist client/createdb client/export	client/export/builders client/export/component client/login	common common/debug common/record">krater at mail.berlios.de
       </A><BR>
    <I>Fri Sep  1 15:09:40 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000860.html">[Plantlore-dev] r613 - trunk/lib
</A></li>
        <LI>Next message: <A HREF="000862.html">[Plantlore-dev] r615 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#861">[ date ]</a>
              <a href="thread.html#861">[ thread ]</a>
              <a href="subject.html#861">[ subject ]</a>
              <a href="author.html#861">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: krater
Date: 2006-09-01 15:09:26 +0200 (Fri, 01 Sep 2006)
New Revision: 614

Added:
   trunk/src/net/sf/plantlore/client/export/component/ProjectionSelectionModel.java
Removed:
   trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
   trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
Modified:
   trunk/src/net/sf/plantlore/client/checklist/Checklist.java
   trunk/src/net/sf/plantlore/client/checklist/ChecklistCtrl.java
   trunk/src/net/sf/plantlore/client/checklist/ChecklistView.java
   trunk/src/net/sf/plantlore/client/createdb/CreateDB.java
   trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthCtrl.java
   trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthView.java
   trunk/src/net/sf/plantlore/client/createdb/CreateDBCtrl.java
   trunk/src/net/sf/plantlore/client/createdb/CreateDBView.java
   trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
   trunk/src/net/sf/plantlore/client/export/Builder.java
   trunk/src/net/sf/plantlore/client/export/ExportMng2.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
   trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
   trunk/src/net/sf/plantlore/client/export/ExportTask2.java
   trunk/src/net/sf/plantlore/client/export/Projection.java
   trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
   trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
   trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
   trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
   trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
   trunk/src/net/sf/plantlore/client/login/AuthCtrl.java
   trunk/src/net/sf/plantlore/client/login/AuthView.java
   trunk/src/net/sf/plantlore/client/login/DBInfo.java
   trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java
   trunk/src/net/sf/plantlore/client/login/ItemView2.java
   trunk/src/net/sf/plantlore/client/login/Login.java
   trunk/src/net/sf/plantlore/client/login/LoginCtrl.java
   trunk/src/net/sf/plantlore/client/login/LoginView.java
   trunk/src/net/sf/plantlore/common/Assistant.java
   trunk/src/net/sf/plantlore/common/AutoComboBox.java
   trunk/src/net/sf/plantlore/common/AutoComboBoxNG3.java
   trunk/src/net/sf/plantlore/common/AutoTextArea.java
   trunk/src/net/sf/plantlore/common/ComponentAdjust.java
   trunk/src/net/sf/plantlore/common/DBLayerUtils.java
   trunk/src/net/sf/plantlore/common/DefaultCancelAction.java
   trunk/src/net/sf/plantlore/common/DefaultExceptionHandler.java
   trunk/src/net/sf/plantlore/common/DefaultProgressBar.java
   trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java
   trunk/src/net/sf/plantlore/common/DefaultReconnectDialog.java
   trunk/src/net/sf/plantlore/common/GlobalExceptionHandler.java
   trunk/src/net/sf/plantlore/common/ProgressBarEx.java
   trunk/src/net/sf/plantlore/common/ProgressDialog.java
   trunk/src/net/sf/plantlore/common/Selection.java
   trunk/src/net/sf/plantlore/common/SpringUtilities.java
   trunk/src/net/sf/plantlore/common/StandardAction.java
   trunk/src/net/sf/plantlore/common/TabTransfersFocus.java
   trunk/src/net/sf/plantlore/common/UniqueIDGenerator.java
   trunk/src/net/sf/plantlore/common/debug/MemoryMonitor.java
   trunk/src/net/sf/plantlore/common/record/Deletable.java
   trunk/src/net/sf/plantlore/common/record/Record.java
Log:
Javadoc added to several sources.

A problem with GUI freeze in Windows XP fixed (every time the RMI threw the ConnectionException, the GUI froze; but it happened only with the ConnectionException - maybe it has something to do with networking in the OS because there was no trace of this problem in Linux).

Modified: trunk/src/net/sf/plantlore/client/checklist/Checklist.java
===================================================================
--- trunk/src/net/sf/plantlore/client/checklist/Checklist.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/checklist/Checklist.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -24,6 +24,7 @@
 
 /**
  * The Checklist (&quot;&#352;krt&#225;k&quot; in Czech). 
+ * 
  * The Checklist displays plants and allows the User to select some of them
  * easily. The User can use either a mouse or a keyboard to (de)select records.
  * The Checklist supports searching (immediately as User types).

Modified: trunk/src/net/sf/plantlore/client/checklist/ChecklistCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/checklist/ChecklistCtrl.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/checklist/ChecklistCtrl.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -143,7 +143,7 @@
 	}
 	
 	/**
-	 * Restore the checklist to its original state (right after creation).
+	 * Restore the checklist to its original state (right after the creation).
 	 */
 	class Restore extends AbstractAction {
 		public Restore() {

Modified: trunk/src/net/sf/plantlore/client/checklist/ChecklistView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/checklist/ChecklistView.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/checklist/ChecklistView.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -9,7 +9,7 @@
 
 /**
  * The dialog displaying the checklist and several buttons 
- * the allow the checklist to be saved or loaded. 
+ * that allow the checklist to be saved, or loaded, or restored. 
  *
  * @author  Erik Kratochv&#237;l
  */

Modified: trunk/src/net/sf/plantlore/client/createdb/CreateDB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/createdb/CreateDB.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/createdb/CreateDB.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -12,9 +12,28 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
+ * CreateDB is a CreationTask factory. 
+ * Its sole purpose is to gather information required for the
+ * creation of that task and create a new record in the list
+ * of databases the User accessed (see Login).
+ * &lt;br/&gt;
+ * The CreationTask is a long running operation that 
+ * &lt;ol&gt;
+ * &lt;li&gt;
+ * Connects to the database engine and creates a new database.
+ * The creation of the database includes the creation of all tables,
+ * the default administrator (if it is not already created) and filling those
+ * tables with values that are necessary for proper work with Plantlore. 
+ * &lt;/li&gt;
+ * &lt;li&gt;
+ * Optionally fills all (so called) immutable tables with records 
+ * that apply to the Czech Republic. 
+ * Those are tables are: villages, plants, territories, and phytochoria.
+ * &lt;/li&gt;
+ * &lt;/ol&gt;
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 29.8.2006
+ * @since 2006-08-29
  *
  */
 public class CreateDB extends Observable {
@@ -25,41 +44,70 @@
 	private DBInfo info;
 	private boolean leaveEmpty = false;
 		
-	
+	/**
+	 * Create a new CreateDB.
+	 * 
+	 * @param config	The configuration that manages the list of databases the User accessed.
+	 */
 	public CreateDB(MainConfig config) {
 		this.config = config;
 	}
 	
-	
+	/**
+	 * Set information about the datbase that shall come to existence.
+	 *  
+	 * @param alias	The name that will be presented to the User.
+	 * @param engine	The type of the database (the database engine).
+	 * @param port	The port where the database engine listens.
+	 * @param identifier	The name of the database that will be created.
+	 * @param leaveEmpty		True if the immutable tables shall remain empty. 
+	 */
 	public void setDBInfo(String alias, String engine, int port, String identifier, boolean leaveEmpty) {
 		info = new DBInfo(alias, null, 0, engine, port, identifier, &quot;&quot;, new String[Login.MAX_NAMES]);
 		this.leaveEmpty = leaveEmpty; 
 	}
 	
+	/**
+	 * Add the database info to the list of databases permanently.
+	 * 
+	 * @param info	The info to be added.
+	 */
 	protected void addDBInfoPermanently(DBInfo info) {
 		ArrayList&lt;DBInfo&gt; dbinfos = config.getDBinfos();
 		dbinfos.add( info );
 		config.setDBInfos( dbinfos, info );
 		try {
 			config.save();
-		} catch(java.io.IOException e) { /* Oh my.. */ }
+		} catch(java.io.IOException e) { /* Never mind. */ }
 		
 		setChanged();
 		notifyObservers( info );
 	}
 	
-	
+	/**
+	 * Create a new Creation Task that is capable of creating the new database.
+	 *  
+	 * @param username	The name of the account that allows us to connect to the database
+	 * engine and perform all actions necessary (create DB, create roles and users, ...) - and Administrator
+	 * typically.
+	 * @param password	The password protecting that account.
+	 * 
+	 * @return	The Creation task.
+	 */
 	public synchronized Task createCreationTask(String username, String password) {
+		// Set the first user name to the Administrator of the database.
+		info.getUsers()[0] = username;
 		return new CreationTask(info, username, password, leaveEmpty);
 	}
 	
 	
 	
 	/**
-	 * Creation of the database.
+	 * The Creation of the database.
 	 * 
-	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
-	 * @since 29.8.2006
+	 * @author Erik Kratochv&#237;l (The skeleton of the task.)
+	 * @author Tom&#225;&#353; Kova&#345;&#237;k (at least I hope so)
+	 * @since 2006-08-29
 	 *
 	 */
 	private class CreationTask extends Task {
@@ -68,6 +116,14 @@
 		private transient String name, password;
 		private boolean leaveEmpty;
 		
+		/**
+		 * Create a new Creation Task.
+		 * 
+		 * @param dbinfo	The holder object containing information about the new database.
+		 * @param name		The account name that shall be used to connect to the database.
+		 * @param password	The password protecting that account.
+		 * @param leaveEmpty		Leave the immutable tables empty (do not fill them).
+		 */
 		public CreationTask(DBInfo dbinfo, String name, String password, boolean leaveEmpty) {
 			this.dbinfo = dbinfo;
 			this.name = name;

Modified: trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthCtrl.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthCtrl.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -6,7 +6,13 @@
 import net.sf.plantlore.common.StandardAction;
 import net.sf.plantlore.common.Task;
 
-
+/**
+ * The mapping of the button in the view to actions.
+ * The User can click to start the Creation of the database using the previously 
+ * supplied data.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public class CreateDBAuthCtrl {
 	
 	private CreateDBAuthView view;
@@ -23,6 +29,8 @@
 				Task creation = model.createCreationTask(user, new String(view.password.getPassword()));
 				new DefaultProgressBar(creation, view, true);
 				creation.start();
+				
+				view.password.setText(&quot;&quot;);
 			}
 		});
 	}

Modified: trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthView.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/createdb/CreateDBAuthView.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,9 +1,3 @@
-/*
- * CreateDBAuthView.java
- *
- * Created on 31. srpen 2006, 9:03
- */
-
 package net.sf.plantlore.client.createdb;
 
 import java.awt.Dialog;
@@ -14,12 +8,14 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
- *
- * @author  yaa
+ * The view allows the User to specify the Authentication information
+ * - the User name (or the Account name) and the Password of that account.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  */
 public class CreateDBAuthView extends javax.swing.JDialog implements Observer {
     
-    /** Creates new form CreateDBAuthView */
+    
     public CreateDBAuthView(Dialog parent, CreateDB model) {
     	super(parent, true);
     	
@@ -103,10 +99,8 @@
     public void update(Observable source, final Object parameter) {
 		java.awt.EventQueue.invokeLater(new Runnable() {
     		public void run() {
-    			if(parameter instanceof DBInfo) {
+    			if(parameter instanceof DBInfo)
     				setVisible(false);
-    				password.setText(&quot;&quot;);
-    			}
     		}
 		});
 	}

Modified: trunk/src/net/sf/plantlore/client/createdb/CreateDBCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/createdb/CreateDBCtrl.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/createdb/CreateDBCtrl.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -8,7 +8,14 @@
 import net.sf.plantlore.l10n.L10n;
 
 
-
+/**
+ * The mapping of the button in the view to action
+ * that opens the second part of the dialog - the Authentication.
+ * 
+ * Also the field validity check is performed.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public class CreateDBCtrl {
 	
 	private CreateDBView view;

Modified: trunk/src/net/sf/plantlore/client/createdb/CreateDBView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/createdb/CreateDBView.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/createdb/CreateDBView.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,9 +1,3 @@
-/*
- * CreateDBView.java
- *
- * Created on 29. srpen 2006, 15:21
- */
-
 package net.sf.plantlore.client.createdb;
 
 import java.awt.Frame;
@@ -14,13 +8,15 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
+ * The view presents the User with several fields
+ * so that the User can supply information about the database
+ * that shall be created.
  *
- * @author  yaa
+ * @author  Erik Kratochv&#237;l
  */
 public class CreateDBView extends javax.swing.JDialog implements Observer {
 	
 	    
-    /** Creates new form CreateDBView */
     public CreateDBView(Frame parent, CreateDB model) {
     	super(parent, true);
     	
@@ -182,6 +178,9 @@
     // End of variables declaration//GEN-END:variables
     
     
+    /**
+     * Hide the dialog if the DBInfo has been added successfully.
+     */
 	public void update(Observable source, final Object parameter) {
 		java.awt.EventQueue.invokeLater(new Runnable() {
     		public void run() {

Modified: trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/AbstractBuilder.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -7,7 +7,7 @@
 
 /**
  * A default implementation of the Builder interface.
- * It is strongly recommended to subclass the AbstractBuilder
+ * If it seems convenient you may subclass the AbstractBuilder
  * and implement the &lt;code&gt;output()&lt;/code&gt; method
  * instead of implementing the whole Builder interface
  * yourself.
@@ -27,28 +27,28 @@
 	
 	
 	/**
-	 * Create a new DefaultBuilder.
+	 * Create a new Abstract Builder.
 	 * 
-	 * @param template The template describing which columns are selected.
+	 * @param projections The template describing which columns are selected.
 	 */
-	public AbstractBuilder(Projection template) {
-		setTemplate(template);
+	public AbstractBuilder(Projection projections) {
+		setProjections(projections);
 	}
 	
 	/**
 	 * Set another template.
 	 * The builder stores a clone of the template.
 	 *  
-	 * @param template The new template. &lt;b&gt;Mustn't be &lt;i&gt;null&lt;/i&gt;&lt;/b&gt;.
+	 * @param projections The new template. &lt;b&gt;Mustn't be &lt;i&gt;null&lt;/i&gt;&lt;/b&gt;.
 	 */
-	public void setTemplate(Projection template) {
-		this.template = (template == null) ? null : template.clone();
+	public void setProjections(Projection projections) {
+		this.template = (projections == null) ? null : projections.clone();
 	}
 	
 	/**
 	 * @return A clone of the template this Builder currently uses.
 	 */
-	public Projection getTemplate() {
+	public Projection getProjections() {
 		return (template == null) ? null : template.clone();
 	}
 	

Modified: trunk/src/net/sf/plantlore/client/export/Builder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Builder.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/Builder.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -6,7 +6,7 @@
 
 /**
  * Interface for building the output. 
- * The builder is responsible for &quot;building&quot; the output when given 
+ * The builder is responsible for &quot;building&quot; the output when it is given 
  * a record. The Director calls only these few methods - everything
  * else is &quot;particular-implementation specific&quot;.
  * 

Deleted: trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,328 +0,0 @@
-package net.sf.plantlore.client.export;
-
-import java.io.IOException;
-import java.rmi.RemoteException;
-import java.util.List;
-import java.util.Observable;
-
-import net.sf.plantlore.common.Pair;
-import net.sf.plantlore.common.PlantloreConstants;
-import net.sf.plantlore.common.Selection;
-import net.sf.plantlore.common.exception.ExportException;
-import net.sf.plantlore.common.record.*;
-import net.sf.plantlore.l10n.L10n;
-import net.sf.plantlore.middleware.DBLayer;
-import net.sf.plantlore.middleware.SelectQuery;
-import net.sf.plantlore.common.exception.DBLayerException;
-
-import org.apache.log4j.Logger;
-
-/**
- * The Director class (for export).
- * Purpose: The Director continualy fetches results of the resultset
- * identified by the &lt;code&gt;result&lt;/code&gt;.
- * The selected results (records containted in the &lt;code&gt;selection&lt;/code&gt;)
- * are passed to the &lt;code&gt;builder&lt;/code&gt; - the builder is responsible for
- * creating a corresponing output.
- * &lt;br/&gt;
- * The Director is supposed to run in a separate thread which is why
- * all exceptions are handled in the &lt;code&gt;run()&lt;/code&gt; method
- * in a following manner:
- * &lt;pre&gt;
- * catch(AnException e) { setChanged(); notifyObservers( e ); }
- * &lt;/pre&gt;
- *  
- * &lt;br/&gt;
- * The DefaultDirector can run in two &quot;modes&quot; - either using projections
- * or regular records. 
- * If projections are used, the records are reconstructed so that the
- * same Builders can be used in both cases. 
- *
- * 
- * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 2006-04-21
- * @version 2.0
- *
- * @see net.sf.plantlore.client.common.Selection
- * @see net.sf.plantlore.client.export.Builder
- * @see net.sf.plantlore.middleware.DBLayer
- */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">- at Deprecated</A>
-public class DefaultDirector extends Observable implements Runnable {
-	
-	private Logger logger = Logger.getLogger(getClass().getPackage().getName());
-	
-	private Builder build;
-	private Selection selection;
-	private DBLayer database;
-	private int result;
-	private int totalNumberOfRecords = Integer.MAX_VALUE;
-	
-	private boolean ignoreDead = true;
-	
-	private boolean aborted = false;
-	private boolean useProjections = false;
-	
-	private List&lt;Pair&lt;Class, String&gt;&gt; description;
-	
-	private int count = 0;
-	
-	//private Class rootTable;
-
-
-	/**
-	 * Create a new export Director. The Director iterates over the results 
-	 * of the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;database.executeQuery(query)&lt;/code&gt;)
-	 * and selected records (i.e. records in the &lt;code&gt;selection&lt;/code&gt;)
-	 * passes to the &lt;code&gt;builder&lt;/code&gt;.
-	 * 
-	 * @param builder	The particular builder used to construct the final output.
-	 * @param result	The result describing the resultset that will be iterated over.
-	 * @param database	The database layer that will quench the Director's thirst for more results.
-	 * @param selection	The set of selected records.
-	 */
-	public DefaultDirector(Builder builder, int result, DBLayer database, Selection selection) 
-	throws ExportException {
-		setBuilder(builder); 
-		setResult(result); 
-		setDatabase(database); 
-		setSelection(selection); 
-	}
-	
-	/**
-	 * Create a new export Director. The Director iterates over the results 
-	 * of the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;database.executeQuery(query)&lt;/code&gt;)
-	 * and selected records (i.e. records in the &lt;code&gt;selection&lt;/code&gt;)
-	 * passes to the &lt;code&gt;builder&lt;/code&gt;.
-	 * 
-	 * @param builder	The particular builder used to construct the final output.
-	 * @param result	The result describing the resultset that will be iterated over.
-	 * @param database	The database layer that will quench the Director's thirst for more results.
-	 * @param selection	The set of selected records.
-	 * @param useProjections	Use projections instead of standard records.
-	 * @param description	The list of [Table, Column] - values of these columns will be returned 
-	 * by the database layer if projections are used
-	 */
-	public DefaultDirector(Builder builder, int result, DBLayer database, Selection selection, 
-			boolean useProjections, List&lt;Pair&lt;Class, String&gt;&gt; description, Class rootTable) 
-	throws ExportException {
-		this(builder, result, database, selection);
-		this.useProjections = useProjections;
-		this.description = description;
-		//this.rootTable = rootTable;
-		if(rootTable != null) try { 
-			torso = (Record)rootTable.newInstance();
-			torso.createTorso();
-		} catch (Exception e) {
-			// What shall we do? The torso is not complete!
-		}
-	}
-	
-	
-	/**
-	 * Set a new Builder
-	 * @param builder	The builder to be used.
-	 * @throws ExportException	If the builder is not valid.
-	 */
-	protected void setBuilder(Builder builder) 
-	throws ExportException {
-		if(builder == null) {
-			logger.warn(&quot;The builder is null!&quot;);
-			throw new ExportException(L10n.getString(&quot;Error.InvalidBuilder&quot;));
-		}
-		build = builder;
-	}
-
-	/**
-	 * Set a new resultset identificator.
-	 * 
-	 * @param result	The identifier of the resultset.
-	 * @throws ExportException	If the identifier is not valid.
-	 */
-	protected void setResult(int result) 
-	throws ExportException {
-		if(result &lt; 0) {
-			logger.warn(&quot;The result set is probably not valid!&quot;);
-			throw new ExportException(L10n.getString(&quot;Error.InvalidResultset&quot;));
-		}
-		this.result =  result;
-	}
-	
-	/**
-	 * Set a new database layer.
-	 * @param db	The database layer to be set.
-	 * @throws ExportException	If the database layer is not valid.
-	 */
-	protected void setDatabase(DBLayer db) 
-	throws ExportException {
-		if(db == null) {
-			logger.error(&quot;The database layer is null!&quot;);
-			throw new ExportException(L10n.getString(&quot;Error.InvalidDBLayer&quot;));
-		}
-		this.database = db;
-	}
-	
-	/**
-	 * Set a new selection.	
-	 * @param selection	The selection to be cloned.
-	 * @throws ExportException	If the selection is not valid.
-	 */
-	protected void setSelection(Selection selection) 
-	throws ExportException {
-		if(selection == null || selection.isEmpty()) {
-			logger.warn(&quot;The selection is null or empty!&quot;);
-			throw new ExportException(L10n.getString(&quot;Error.InvalidSelection&quot;));
-		}
-		this.selection = selection.clone();
-	}
-	
-	/**
-	 * Set whether records marked as dead should be omited. Default is true.
-	 * 
-	 * @param ignore	True if dead records should be omited.
-	 */
-	public void ignoreDead(boolean ignore) {
-		this.ignoreDead = ignore;
-	}
-	
-	
-	public void setExpectedNumberOfRecords(int total) {
-		this.totalNumberOfRecords = total;
-	}
-	
-	/** 
-	 * How many records have been exported.
-	 * 
-	 * @return The exact number of exported records.
-	 */
-	public int exportedRecords() { 
-		return count;
-	}
-	
-		
-	/**
-	 * Find all AuthorOccurrences associated with the &lt;code&gt;Occurrence&lt;/code&gt;
-	 * and send them to the Builder, too.
-	 * 
-	 * @param occurrence	The currently processed occurrence data.
-	 */
-	private void loadAssociatedAuthors(Occurrence occurrence) 
-	throws RemoteException, IOException, DBLayerException {
-		
-		logger.debug(&quot;Processing the associated information about Authors.&quot;);
-		
-		SelectQuery query = database.createQuery(AuthorOccurrence.class);
-		query.createAlias(AuthorOccurrence.OCCURRENCE, &quot;OCC&quot;);
-
-		// AuthorOccurrence.OCCURRENCE = Occurrence.ID  &amp;&amp;  Occurrence.ID = occ.getId()
-		query.addRestriction(PlantloreConstants.RESTR_EQ_PROPERTY, AuthorOccurrence.OCCURRENCE, &quot;OCC.&quot;+Occurrence.ID, null, null);
-		query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;OCC.&quot;+Occurrence.ID, null, occurrence.getId(), null);
-		int resultId = database.executeQuery( query );
-		
-		// Take all results and spit'em out.
-		int rows = database.getNumRows( resultId );
-		for(int i = 0; i &lt; rows; i++) {
-			logger.debug(&quot;Fetching associated data (Author, AuthorOccurrence).&quot;);
-			
-			Object[] pulp = database.more( resultId, i, i );
-			AuthorOccurrence ao = (AuthorOccurrence) ((Object[])pulp[0])[0];
-			ao.setOccurrence( null ); // cut off the way back to the occurrence
-			if(ao.isDead() &amp;&amp; ignoreDead) continue;
-			
-			logger.debug(&quot;New author-occurence record: &quot; + ao);
-			
-			build.part( ao );
-		}
-		database.closeQuery( query );
-		
-		logger.debug(&quot;Author-occurence processed.&quot;);
-	}
-	
-	
-	/** 
-	 * Execute the exporting procedure -
-	 * fetch all results from the resultset and those that are selected
-	 * send to the builder to process them.
-	 */
-	public void run() {
-		try {
-			logger.info(&quot;Export begins...&quot;);
-			build.header();
-			
-			// Iterate over the result of the query.
-			int rows = database.getNumRows( result );
-			count = 0;
-			for(int i = 0; i &lt; rows &amp;&amp; !aborted &amp;&amp; count &lt; totalNumberOfRecords; i++) {
-				
-				logger.debug(&quot;Fetching a new record from the database.&quot;);
-				
-				Record record;
-				if(useProjections) 
-					record = reconstruct( (Object[])database.more( result, i, i )[0] );
-				else
-					record = (Record)((Object[])database.more( result, i, i )[0])[0];
-				
-				
-				logger.debug(&quot;New record No. &quot;+i+&quot; fetched: &quot;+record);
-				if( !selection.contains( record ) || (ignoreDead &amp;&amp; record.isDead()) ) 
-					continue; // Is the record selected?
-				
-				logger.debug(&quot;The record is in the selection. It will be exported.&quot;);
-			
-				count++;
-				build.startRecord();
-				
-				// Build this part of the record.
-				build.part( record );
-				
-				/* -----------------------------------------------------------
-				 * Deal with the one-to-many relationship
-				 * of Occurence -&gt; AuthorOccurence ~ Author
-				 * ----------------------------------------------------------- */
-				if( record instanceof Occurrence ) 
-					loadAssociatedAuthors( (Occurrence)record );
-				
-				build.finishRecord();
-				
-				setChanged(); notifyObservers( count );
-			}
-
-			build.footer();
-			logger.info(&quot;Export completed. &quot; + count + &quot; records sent to output. &quot;);
-		}
-		catch(Exception e) {
-			logger.error(&quot;Export ended prematurely. Only &quot;+count+&quot; records exported.&quot;);
-			logger.error(&quot;The problem: &quot;+e);
-			e.printStackTrace();
-			setChanged(); notifyObservers( e ); 
-		}
-		if(aborted) logger.info(&quot;Export aborted. &quot; + count + &quot; records sent to output.&quot;);
-	}
-	
-	/**
-	 * Abort the export immediately.
-	 */
-	public void abort() {
-		aborted = true;
-	}
-	
-	/**
-	 * The base of the record to be reconstructed.
-	 */
-	private Record torso;
-	
-	/**
-	 * Reconstruct the record from the given values. 
-	 * 
-	 * @param values	Values of columns (in the same order as in the Description).
-	 * @return	The reconstructed record.
-	 */
-	private Record reconstruct(Object[] values) {
-		for(int i = 0; i &lt; description.size(); i++ ) {
-			Pair&lt;Class, String&gt; d = description.get(i);
-			torso.setValue(d.getFirst(), d.getSecond(), values[i]);
-		}
-		return torso;
-	}
-
-}

Modified: trunk/src/net/sf/plantlore/client/export/ExportMng2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -5,7 +5,6 @@
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 import java.io.Writer;
-import java.rmi.RemoteException;
 
 import net.sf.plantlore.client.export.builders.*;
 import net.sf.plantlore.client.export.component.FileFormat;
@@ -20,41 +19,22 @@
 import org.apache.log4j.Logger;
 
 /**
- * The Export Manager. This class controls the whole process of export -
- * starting with creation of all necessary participants
- * and ending with the final cleanup. 
- * &lt;br/&gt;
- * There are several entities involved in the export:
- * &lt;ul&gt;
- * &lt;li&gt;&lt;b&gt;DBLayer&lt;/b&gt; the database layer that will carry out the requests.
- * 					Mustn't be null!&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;Director&lt;/b&gt; iterates over the &lt;i&gt;result set&lt;/i&gt; 
- * 					and &lt;i&gt;selected records&lt;/i&gt; passes to the &lt;i&gt;builder&lt;/i&gt;,&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;Builder&lt;/b&gt; writes the records to the &lt;i&gt;output&lt;/i&gt;.&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;Selection&lt;/b&gt; stores the list of all selected records 
- * 					(&lt;i&gt;restriction&lt;/i&gt; in the database terminology).&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;SelectQuery&lt;/b&gt; identifies the result set as well (in fact the resultId is derived from it).&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;Projection&lt;/b&gt; stores the list of all selected columns that should be 
- * 					exported (&lt;i&gt;projection&lt;/i&gt; in the database terminology).&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;File&lt;/b&gt; stores the name of file as the user has suggested it.&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;XFilter&lt;/b&gt; suggests the final name of the &lt;i&gt;file&lt;/i&gt;
- * 					and is used to determine which &lt;i&gt;builder&lt;/i&gt; will be used
- * 					to produce the output.&lt;/li&gt;
- * &lt;/ul&gt;
  * 
+ * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-29 
  * @version 2.0
- * @see net.sf.plantlore.client.export.Builder
  */
 public class ExportMng2 {
 	
-	
+	/**
+	 * The encoding that should be used for all files.
+	 */
 	public static final String ENCODING = &quot;UTF-8&quot;;
 	
 	
 	/**
-	 * List of all filters the Export Manager is capable to handle.
+	 * List of all file formats the Export Manager is capable to handle.
 	 */
 	protected FileFormat[] filters = new FileFormat[] {
 			new FileFormat(L10n.getString(&quot;Format.PlantloreNative&quot;), false, false, &quot;.xml&quot;, &quot;.pln&quot;),
@@ -168,11 +148,6 @@
 	 * Set a new DBLayer.
 	 */
 	synchronized public void setDBLayer(DBLayer dblayer) {
-		if(query != null) try {
-			db.closeQuery(query);
-		} catch(Exception e) {
-			// Never mind.
-		}
 		db = dblayer;
 	}
 	
@@ -198,35 +173,18 @@
 			this.selection = selection.clone();
 	}
 	
-	/**
-	 * Set the active filter. The type of the filter will be used 
-	 * to determine the appropriate extension of the file
-	 * and to create a correct Builder (for the format this
-	 * filter represents). 
-	 */
 	synchronized public void setActiveFileFilter(FileFormat filter) {
 		this.filter = filter; 
 	}
 	
-	/**
-	 * Set the selected file. Into this file the builder will 
-	 * spit its output. 
-	 */
 	synchronized public void setSelectedFile(String filename) { 
 		this.filename = filename; 
 	}
 	
-	
-	/**
-	 * Set a particular select query. The manager will execute this select query
-	 * and update the &lt;code&gt;resultId&lt;/code&gt; if Projections are not used.
-	 * On the other hand, if Projections are used, it is the &lt;code&gt;setTemplate()&lt;/code&gt;
-	 * that executes the query after it adds desired projections.
-	 */
 	synchronized public void setSelectQuery(SelectQuery query) { 
 		// Close the previous query!
 		if(this.query != null) try {
-			db.closeQuery(this.query);  // This must go here because of the RMI!
+			db.closeQuery(this.query);
 		} catch (Exception e) {
 			// Never mind.
 		}
@@ -236,13 +194,7 @@
 	
 	
 	
-	
-	/**
-	 * Start the export procedure. The export will run in its own thread.
-	 * 
-	 * @throws ExportException	If information provided is not complete.
-	 * @throws IOException	If anything with the file goes wrong (insufficient disk space, insufficient permissions).
-	 */
+
 	synchronized public ExportTask2 createExportTask() 
 	throws ExportException, IOException, DBLayerException {
 		// Check if all necessary components are valid.
@@ -302,7 +254,6 @@
 		}
 
 		
-		// Start a new task.
 		ExportTask2 t = new ExportTask2(db, query, writer, builder, selection);
 		t.ignoreDead( filter.ignoreDead() );
 		
@@ -321,7 +272,7 @@
 	
 		
 	/**
-	 * @return The list of filters describing formats this Export Manager can handle.
+	 * @return The list of file formats this Export Manager can handle.
 	 */
 	public FileFormat[] getFileFormats() {
 		return filters.clone();

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrl2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -59,7 +59,7 @@
 			putValue(NAME, L10n.getString(&quot;Export.Title&quot;));
 		}
 		public void actionPerformed(ActionEvent arg0) {
-			Projection t = viewB.tsm.getTemplate();
+			Projection t = viewB.tsm.getProjections();
 			viewB.setVisible(false);
 			model.setTemplate( t ); // Set the new template.
 			viewB.tsm.clearSelection();

Modified: trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -8,7 +8,7 @@
 
 import java.awt.Frame;
 
-import net.sf.plantlore.client.export.component.TemplateSelectionModel;
+import net.sf.plantlore.client.export.component.ProjectionSelectionModel;
 import net.sf.plantlore.client.export.component.ExtendedTree;
 import net.sf.plantlore.l10n.L10n;
 
@@ -18,13 +18,13 @@
  */
 public class ExportMngViewB extends javax.swing.JDialog {
 	
-	protected TemplateSelectionModel tsm;
+	protected ProjectionSelectionModel tsm;
     
     /** Creates new form ExportMngView */
     public ExportMngViewB(Frame parent) {
     	super(parent, true);
     	
-    	tsm = new TemplateSelectionModel( new Projection() );
+    	tsm = new ProjectionSelectionModel( new Projection() );
     	
         initComponents();
         getRootPane().setDefaultButton(next);

Modified: trunk/src/net/sf/plantlore/client/export/ExportTask2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/ExportTask2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -187,7 +187,7 @@
 			ao.setOccurrence( null ); // cut off the way back to the occurrence
 			if(ao.isDead() &amp;&amp; ignoreDead) continue;
 			
-			logger.debug(&quot;New author-occurence record: &quot; + ao);
+			logger.debug(&quot;New author-occurence record: &quot; + ao.toFullString());
 			
 			build.part( ao );
 		}
@@ -199,7 +199,18 @@
 	
 	
 	/**
-	 * Reconstruct the record from the given values. 
+	 * Reconstruct the record from the given values, if projections were used.
+	 * &lt;br/&gt;
+	 * An example: Let us suppose that we created projection for 
+	 * &lt;code&gt;Occurrence.ID&lt;/code&gt; and &lt;code&gt;Plant.TAXON&lt;code&gt; and
+	 * &lt;code&gt;NearestVillage.NAME&lt;/code&gt;. Database layer returns
+	 * [3292, &quot;Rubus sp.&quot;, &quot;&#268;esk&#233; Bud&#283;jovice&quot;]. The `description` is the key to
+	 * those values, as it says:
+	 * &lt;code&gt;Occurrence.ID = 3292&lt;/code&gt;,
+	 * &lt;code&gt;Plant.TAXON = Rubus sp.&lt;/code&gt; and
+	 * &lt;code&gt;NearestVillage = &#268;esk&#233; Bud&#283;jovice&lt;/code&gt;.
+	 * &lt;br/&gt;
+	 * Without the description we would not know what value belongs to which column.
 	 * 
 	 * @param values	Values of columns (in the same order as in the Description).
 	 * @return	The reconstructed record.

Modified: trunk/src/net/sf/plantlore/client/export/Projection.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Projection.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/Projection.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -12,96 +12,130 @@
 
 
 /**
- * The template holds information about the selected columns and tables.
- * This information may used by builders and access rights managers
- * to decide, whether or not the currently
- * considered column should be exported / is accessible.
+ * The Projection class holds information about the selected columns and tables.
+ * This information may used by builders  to decide, whether or not 
+ * the currently considered column should be exported.
  * &lt;br/&gt;
- * Note: The template doesn't know anything about the structure
+ * Note: The Projection doesn't know anything about the structure
  * (mapping) of the database.  
  * &lt;br/&gt;
- * A little dictionary:
  * &lt;ul&gt;
  * &lt;li&gt;&lt;i&gt;foreign key&lt;/i&gt; a column of a table that refers to another table,&lt;/li&gt;
  * &lt;li&gt;&lt;i&gt;property&lt;/i&gt; a column of a table that contains a (possibly null) value,
  * but doesn't refer to another table&lt;/li&gt;
  * &lt;li&gt;&lt;i&gt;nn&lt;/i&gt; a property that cannot be null (defined in the db model)&lt;/li&gt;
  * &lt;/ul&gt;
+ * &lt;br/&gt;
+ * The list of projections can be applied to a query in order to set its projections.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-22
- * @version 1.1
+ * @version 1.3
  */
 public class Projection {
 	
 	/** The list of all pairs Table.Column that are set. */
 	private Collection&lt;String&gt; columns = new HashSet&lt;String&gt;(100);
 	
-	
 
-	
-	/** Create a new template. */
+	/** 
+	 * Create a new Projection. 
+	 * No columns are selected. 
+	 */
 	public Projection() {/* Nothing to be done. Just to have a default constructor. */}
 	
-	/** A copy constructor. */
-	public Projection(Projection template) {
-		columns = new HashSet&lt;String&gt;( template.columns );
+	/**
+	 * Create a new Projection. Use the same values as the supplied &lt;code&gt;projection&lt;/code&gt;.
+	 * 
+	 * @param projection	The Projection that should be copied.
+	 */
+	public Projection(Projection projection) {
+		columns = new HashSet&lt;String&gt;( projection.columns );
 	}
 	
-	
+	/**
+	 * @return A shallow copy of this Projection.
+	 */
 	@Override
 	public Projection clone() {
 		return new Projection(this);
 	}
 	
-	
-	/** Select the &lt;code&gt;table.column&lt;/code&gt;. */
+	/** 
+	 * Add the &lt;code&gt;table.column&lt;/code&gt; to the list of projections.
+	 * 
+	 * @param table		The class representing the table.
+	 * @param column	The name of the column.
+	 * @return	Itself.
+	 */
 	public Projection set(Class table, String column) { 
-		System.out.println(&quot;+ &quot;+table.getSimpleName()+&quot;.&quot;+column);
 		columns.add(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
 		return this;
 	}
 	
-	/** Unselect the &lt;code&gt;table.column&lt;/code&gt;. */
+	/**
+	 * Remove the &lt;code&gt;table.column&lt;/code&gt; from the list of projections.
+	 * 
+	 * @param table		The class representing the table.
+	 * @param column	The name of the column.
+	 * @return Itself.
+	 */ 
 	public Projection unset(Class table, String column) { 
-		System.out.println(&quot;- &quot;+table.getSimpleName()+&quot;.&quot;+column);
 		columns.remove(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
 		return this;
 	}
 	
-	/** @return true if the &lt;code&gt;table.column&lt;/code&gt; is set.*/
+	/** 
+	 * 
+	 * @param table	The class representing the table.
+	 * @param column	The name of the column.
+	 * @return True if the &lt;code&gt;table.column&lt;/code&gt; is part of the list of projections.
+	 */
 	public boolean isSet(Class table, String column) {
 		return columns.contains(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
 	}
 	
-	/** Unselect all columns of all tables. */
+	/** 
+	 * Deselect all columns of all tables - deselect everything.
+	 * 
+	 *  @return Itself.
+	 */
 	public Projection unsetEverything() { 
 		columns.clear();
 		return this;
 	}
 	
-	/** Select all columns (properties) of all tables. */
+	/** 
+	 * Select all columns (properties) of all tables.
+	 * 
+	 *  @return Itself.
+	 */
 	public Projection setEverything() {
 		for(Class table : Record.BASIC_TABLES)
 			setAllProperties(table);
 		return this;
 	}
 	
-	/** Select all not null columns (properties). */
-	public void setEverythingNN() {
-		// Implementation missing!
-	}
-	
-	/** Select all properties of this &lt;code&gt;table&lt;/code&gt;. */
+	/** 
+	 * Select all properties of the &lt;code&gt;table&lt;/code&gt;.
+	 * 
+	 * @param table	The table whose properties shall be set.
+	 * @return Itself.
+	 */
 	public Projection setAllProperties(Class table) {
 		try {
 			for( String column : ((Record)table.newInstance()).getProperties() )
 				set(table, column);
-		} catch(Exception e) {/* Not good :/. */}
+		} catch(Exception e) {/* This should not happen. */}
 		return this;
 	}
 	
-	/** Select all not-null properties of the specified &lt;code&gt;table&lt;/code&gt;. */
+	/**
+	 * Select all not-null properties of the specified &lt;code&gt;table&lt;/code&gt;. 
+	 * 
+	 * @param table	The table whose properties shall be set.
+	 * @return Itself.
+	 */
 	public Projection setAllNN(Class table) {
 		try {
 			Record record = ((Record)table.newInstance());
@@ -109,12 +143,12 @@
 			nnProperties.removeAll(record.getForeignKeys());
 			for( String column :  nnProperties )
 				set(table, column);
-		} catch(Exception e) {/* Not good. */}
+		} catch(Exception e) {/* This should not happen. */}
 		return this;
 	}
 	
 	/**
-	 * @return true if nothing is selected.
+	 * @return True if nothing is selected.
 	 */
 	public boolean isEmpty() {
 		return columns.isEmpty();
@@ -122,10 +156,10 @@
 	
 		
 	/**
-	 * Match this template against another one.
+	 * Match this list of projections against another one.
 	 * 
-	 * @param t	The template against which the matching will be done.
-	 * @return	True if this template is a superset of the other template.
+	 * @param t	The list against which the matching will take place.
+	 * @return	True if this list of projections is a superset of the other.
 	 */ 
 	public boolean match(Projection t) { 
 		return columns.containsAll(t.columns); 
@@ -134,6 +168,19 @@
 	
 	private List&lt;Pair&lt;Class, String&gt;&gt; plan;
 	
+	/**
+	 * Description of the columns. If projections are used 
+	 * then Hibernate will return a list of values. 
+	 * So as to be able to distinguish what value belongs
+	 * to which column, we need the list of &lt;code&gt;table.column&lt;/code&gt;.
+	 * The description of the columns together with the list of values
+	 * can be used to restore the original record.
+	 * 
+	 * @return	The list of &lt;code&gt;table.column&lt;/code&gt; that identifies the name
+	 * of the table and column where a value might belong. 
+	 * 
+	 *  @see net.sf.plantlore.client.export.ExportTask2#reconstruct(Object[])
+	 */
 	public List&lt;Pair&lt;Class, String&gt;&gt; getDescription() {
 		return plan;
 	}
@@ -144,6 +191,8 @@
 	 * @param q	The query to be modified.
 	 * @param tables	The important tables. The first table is considered the root table.
 	 * @return The column description.
+	 * 
+	 * @see net.sf.plantlore.client.export.ExportTask2#reconstruct(Object[])
 	 */
 	public List&lt;Pair&lt;Class, String&gt;&gt; addProjections(SelectQuery q, Class...tables) {
 		plan = new ArrayList&lt;Pair&lt;Class,String&gt;&gt;(20);

Modified: trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -13,7 +13,16 @@
 /**
  * CSV Builder.
  * 
- * The first line is the list of names of exported columns.
+ * The builder produces a comma separated values file format.
+ * The first line is the list of names of exported columns;
+ * the rest of the file contains values of those columns.
+ * &lt;br/&gt;
+ * A sample output:
+ * &lt;br/&gt;
+ * &lt;pre&gt;
+ * Author.WholeName, Author.Email, Plant.Taxon, Plant.CzechName 
+ * Erik Kratochv&#237;l, <A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>, Gagea pratensis (Pers.) Dumort., ostru&#382;in&#237;k m&#283;kk&#253;
+ * &lt;pre&gt;
  *  
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-23
@@ -44,10 +53,7 @@
 	
 	/**
 	 * Create a new CSV Builder. 
-	 * The output is written in the format of comma separated values:&lt;br/&gt;
-	 * &lt;pre&gt;
-	 * Erik Kratochv&#237;l, <A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>, Gagea pratensis (Pers.) Dumort., ostru&#382;in&#237;k m&#283;kk&#253;
-	 * &lt;pre&gt;
+
 	 * 
 	 * @param output	The writer where the output will be sent.
 	 * @param tmp	The template that describes the selected columns and tables.

Modified: trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/builders/TrainingBuilder.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -10,7 +10,8 @@
  * Convenient if you wish to see the results immediately
  * on the default output.
  * &lt;br/&gt;
- * The output has the following form:&lt;br/&gt;
+ * A sample output:
+ * &lt;br/&gt;
  * &lt;pre&gt;
  * &lt;157&gt;
  *   Author.WholeName = Erik Kratochv&#237;l
@@ -27,27 +28,47 @@
 	
 	private int i = 0;
 	
-	public TrainingBuilder(Projection template) {
-		super(template);
+	/**
+	 * Create a new Training Builder. 
+	 * 
+	 * @param projections	The list of columns that shall be sent to the output.
+	 */
+	public TrainingBuilder(Projection projections) {
+		super(projections);
 	}
  
+	/**
+	 * Create a header of the output.
+	 */
 	public void header() throws IOException {
 		System.out.println(&quot;Training Builder engaged.&quot;);		
 	}
   
+	/**
+	 * Create a footer of the output.
+	 */
 	public void footer() throws IOException {
 		System.out.println(&quot;Training Builder disengaged.&quot;);
 	}
  
+	/**
+	 * Start processing another record.
+	 */
 	public void startRecord() throws IOException {
 		System.out.println(&quot; &lt;&quot; + i + &quot;&gt;&quot;);
 	}
 
+	/**
+	 * Finish processing of the record.
+	 */
 	public void finishRecord() throws IOException {
 		System.out.println(&quot; &lt;/&quot; + i + &quot;&gt;&quot;);
 		i++;
 	}
 	
+	/**
+	 * Send a part of the record to the output.
+	 */
 	protected void output(Class table, String column, Object value) throws IOException {
 		System.out.println(&quot;   &quot; + table.getSimpleName() + &quot;.&quot; + column + &quot; = &quot; + value);
 	}

Modified: trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/builders/XMLBuilder2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -13,20 +13,30 @@
 import net.sf.plantlore.common.record.*;
 
 /**
- * An improved version of the previous XMLBuilder. 
- * This XMLBuilder is capable of creating files of virtually any size.
- * The builder uses the Dom4j to create just one Occurrence element
- * at a time; that element is written down when another Occurrence
- * record arrives to be processed. 
+ * This XMLBuilder creates a XML tree from the supplied records.
+ * The builder uses the Dom4j to create just one element at a time; 
+ * that element is written down when another record arrives to be processed. 
  * &lt;br/&gt;
  * This way, the creation of an element is handled by the Dom4j 
  * (all those necessary conversions 
  * of &lt;code&gt;&gt;&lt;/code&gt; to &lt;code&gt;&amp;gt;&lt;/code&gt; etc.)
+ * but it does not share the Dom4j's greatest weakness: its hunger for memory,
+ * because the whole document is not kept in memory.
  * &lt;br/&gt;
+ * A sample output:
+ * &lt;br/&gt;
+ * &lt;pre&gt;
+ *   &lt;plant&gt;
+ *      &lt;taxon&gt;Gagea pratensis (Pers.) Dumort.&lt;/taxon&gt;
+ *      &lt;czechname&gt;ostru&#382;in&#237;k m&#283;kk&#253;&lt;/czechname&gt;
+ *   &lt;/plant&gt; 
+ * &lt;/pre&gt;
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-07-21
- *
+ * @version 2.0
+ * 
+ * @see net.sf.plantlore.client.export.Builder
  */
 public class XMLBuilder2 implements Builder {
 	

Modified: trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/component/ExtendedTree.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -15,37 +15,38 @@
 
 /**
  * The extension of a JTree that allows the User to see the database model
- * in a compact form. The tree expects the database hierarchy when it's created.
+ * in a compact form. The tree expects a database hierarchy - that hierarchy will
+ * be traversed to build the tree.
+ * &lt;br/&gt;
  * Two default hierarchies are already present - the &lt;code&gt;DefaultHierarchy&lt;/code&gt;
  * which is loaded when no other hierarchy is specified and displays the database
- * model in the hierarchy, 
+ * model in the natural hierarchy (i.e. following the database model), 
  * and the &lt;code&gt;SimpleHierarchy&lt;/code&gt; which is a simplified version with
  * all tables as sub-root nodes.
  * Both hierarchies are hard-wired and must be updated if the database
  * model changes!
  * &lt;br/&gt;
- * The selected nodes are visualized to the User in another colour.
+ * The selected (marked) nodes are visualized to the User in another colour.
  * Collapsing a node &lt;b&gt;will cause&lt;/b&gt; deselection of all of its selected
  * sub-nodes. This is a feature that will prevent the User from selecting
  * a group of columns and forgeting about them. 
  * &lt;br/&gt;
- * The XTree uses instances of XNode class - that is, the label of the
- * node is derived from the XNode.toString(). Should you have a desire
- * to implement the L10N, modify that method appropriatelly.
+ * The ExtendedTree uses instances of UserTreeNode class - that is, the label of the
+ * node is derived from the UserTreeNode.toString(). 
  * &lt;br/&gt;
- * The XTree cannot produce a Projection - in order to create and update 
+ * The ExtendedTree cannot produce a list of projections - in order to create and update 
  * the Projection &quot;automatically&quot; create your own TreeSelectionModel
  * that is capable of such an action. 
  * &lt;pre&gt;
- * XTree tree = new XTree( );
+ * ExtendedTree tree = new ExtendedTree( );
  * tree.setSelectionModel( new YSelectionModel() );
  * &lt;/pre&gt;
  * where
  * &lt;pre&gt;
- * class TemplateSelectionModel extends DefaultTreeSelectionModel {
- * 		private Projection template;
+ * class ProjectionSelectionModel extends DefaultTreeSelectionModel {
+ * 		private Projection projection;
  * 
- *		// Use this to achieve compatibility with the default XTree selection model.
+ *		// Use this to achieve compatibility with the default ExtendedTree selection model.
  *		@Override 
  *		public void setSelectionPath(TreePath path) {
  *			if( isPathSelected(path) )
@@ -56,10 +57,10 @@
  *		@Override 
  *		public void removeSelectionPaths(TreePath[] paths) {
  *			for(TreePath path : paths) {
- *				XNode x  = (XNode) 
+ *				UserTreeNode x  = (UserTreeNode) 
  *					((DefaultMutableTreeNode)path.getLastPathComponent())
  *					.getUserObject();
- *				template.unset(x.table, x.column);    // update the Projection 
+ *				projection.unset(x.table, x.column);    // update the list of projections 
  *			} 
  *			super.removeSelectionPaths( paths ); 
  *		}
@@ -74,7 +75,7 @@
  * @since 2006-04-29
  * @version 1.0
  * @see net.sf.plantlore.client.export.Projection
- * @see net.sf.plantlore.client.export.ExportMng.XSelectionModel
+ * @see net.sf.plantlore.client.export.ExportMng.ProjectionSelectionModel
  */
 public class ExtendedTree extends javax.swing.JTree {
 	
@@ -284,7 +285,7 @@
 	};
 	
 	/**
-	 * Create a new XTree with the Default Hierarchy Model.
+	 * Create a new ExtendedTree with the Default Hierarchy Model.
 	 */
 	public ExtendedTree( ) {
 		this( DefaultHierarchy );
@@ -292,7 +293,8 @@
 	
 		
 	/**
-	 * Create a new XTree with a specified Hierarchy Model.
+	 * Create a new ExtendedTree using the specified Hierarchy Model.
+	 * 
 	 * @param hierarchy The hierarchy to be processed.
 	 */
 	public ExtendedTree( Object[] hierarchy ) {
@@ -371,7 +373,7 @@
 	
 	
 	/**
-	 * SPecialized Cell Renderer that shows no icons and
+	 * Specialized Cell Renderer that shows no icons and
 	 * displayes mandatory columns with a different coulour.
 	 * 
 	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)

Modified: trunk/src/net/sf/plantlore/client/export/component/FileFormat.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/component/FileFormat.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -7,8 +7,12 @@
 
 /**
  * An implementation of a FileFilter.
- * The XFilter stores a list of extensions
- * that are related to a particular format.
+ * The FileFormat stores a list of extensions that are related to a particular format and
+ * some switches that further describe the format - such as whether the format accepts
+ * records that were marked as deleted (ignoreDead) or whether the whole record is to
+ * be exported or the User can pick only some columns (columnSelection).
+ * 
+ * 
  * &lt;br/&gt;
  * For example: 
  * &lt;code&gt;Comma Separated Values (*.txt, *.csv)&lt;/code&gt;
@@ -26,22 +30,24 @@
 	private boolean ignoreDead = true;
 	
 	/**
-	 * Create a new XFilter.
+	 * Create a new FileFormat.
 	 * 
-	 * @param description The description of the filter.
+	 * @param description The description of the filter - some textual string that may be presented to the User.
 	 * @param extensions	The list of extensions that are related to this filter.
 	 */
 	public FileFormat(String description, String... extensions) {
 		this.description = description;
-		this.extensions = new ArrayList&lt;String&gt;( extensions.length );
-		for(String ext : extensions) this.extensions.add(ext);
+		this.extensions = new ArrayList&lt;String&gt;(extensions.length);
+		for (String ext : extensions)
+			this.extensions.add(ext);
 	}
 	
 	/**
-	 * Create a new XFilter.
+	 * Create a new FileFormat.
 	 * 
-	 * @param description	The description of the filter.
-	 * @param columnSelectionEnabled	The format allows further modifications.
+	 * @param description	The description of the filter - some textual string that may be presented to the User.
+	 * @param columnSelectionEnabled	The user can select which columns will be exported.
+	 * @param ignoreDead		The format should contain only those records that were not marked as deleted.
 	 * @param extensions	The list of extensions that are related to this filter.
 	 */
 	public FileFormat(String description, boolean columnSelectionEnabled, boolean ignoreDead, String... extensions) {
@@ -58,7 +64,7 @@
 	}
 	
 	/**
-	 *	@return True if dead records should be omited.
+	 *	@return True if dead records should be omitted.
 	 */
 	public boolean ignoreDead() {
 		return ignoreDead;

Added: trunk/src/net/sf/plantlore/client/export/component/ProjectionSelectionModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/ProjectionSelectionModel.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/component/ProjectionSelectionModel.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -0,0 +1,91 @@
+package net.sf.plantlore.client.export.component;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import javax.swing.tree.DefaultTreeSelectionModel;
+import javax.swing.tree.TreePath;
+
+import net.sf.plantlore.client.export.Projection;
+
+/**
+ * A TreeSelectionModel modified to update a list of projections. 
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @see net.sf.plantlore.client.export.component.ExtendedTree
+ * @see net.sf.plantlore.client.export.component.UserTreeNode
+ */
+public class ProjectionSelectionModel extends DefaultTreeSelectionModel {
+	
+	private Projection projections;
+	
+	
+	/**
+	 * Create a new ProjectionSelectionModel and use the supplied projections
+	 * to store the selected columns.
+	 * 
+	 * @param projections
+	 */
+	public ProjectionSelectionModel(Projection projections) {
+		this.projections = projections;
+	}
+	
+	/**
+	 * Setting a selection path
+	 * adds the selection path if it is not selected
+	 * or removes it if it is selected.
+	 */
+	@Override 
+	public void setSelectionPath(TreePath path) {
+		if( isPathSelected(path) )
+			removeSelectionPath(path);
+		else
+			addSelectionPath(path);
+	}
+	
+	/**
+	 * Update the list of projections appropriately.
+	 */
+	@Override 
+	public void removeSelectionPaths(TreePath[] paths) {
+		for(TreePath path : paths) {
+			if(path == null) continue;
+			Object node = path.getLastPathComponent();
+			if(node instanceof DefaultMutableTreeNode) {
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
+				projections.unset(x.table, x.column);  
+			}
+		}
+		super.removeSelectionPaths( paths );
+	}
+	
+	/**
+	 * Update the list of projections appropriately.
+	 */
+	@Override 
+	public void addSelectionPaths(TreePath[] paths) {
+		for(TreePath path : paths) {
+			Object node = path.getLastPathComponent();
+			if(node instanceof DefaultMutableTreeNode) {
+				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
+				// Select table.column records (not the table only). 
+				if(x.column != null) projections.set(x.table, x.column);
+			}
+		}
+		super.addSelectionPaths( paths );
+	}
+	
+	@Override
+	public void clearSelection() {
+		super.clearSelection();
+		projections.unsetEverything();
+	}
+			
+	/**
+	 * 
+	 * @return The list of projections (the list of selected columns).
+	 */
+	public Projection getProjections() {
+		return projections;
+	}
+	
+}

Deleted: trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,86 +0,0 @@
-package net.sf.plantlore.client.export.component;
-
-import javax.swing.tree.DefaultMutableTreeNode;
-import javax.swing.tree.DefaultTreeSelectionModel;
-import javax.swing.tree.TreePath;
-
-import net.sf.plantlore.client.export.Projection;
-
-/**
- * A TreeSelectionModel modified to update a Projection. 
- * 
- * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 29.4.2006
- * @see net.sf.plantlore.client.export.component.ExtendedTree
- * @see net.sf.plantlore.client.export.component.UserTreeNode
- */
-public class TemplateSelectionModel extends DefaultTreeSelectionModel {
-	
-	private Projection template;
-	
-	
-	
-	public TemplateSelectionModel(Projection template) {
-		this.template = template;
-	}
-	
-	/**
-	 * Setting a selection path
-	 * adds the selection path if it is not selected
-	 * or removes it if it is selected.
-	 */
-	@Override 
-	public void setSelectionPath(TreePath path) {
-		if( isPathSelected(path) )
-			removeSelectionPath(path);
-		else
-			addSelectionPath(path);
-	}
-	
-	/**
-	 * Update the Projection appropriately.
-	 */
-	@Override 
-	public void removeSelectionPaths(TreePath[] paths) {
-		for(TreePath path : paths) {
-			if(path == null) continue;
-			Object node = path.getLastPathComponent();
-			if(node instanceof DefaultMutableTreeNode) {
-				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
-				template.unset(x.table, x.column);  
-			}
-		}
-		super.removeSelectionPaths( paths );
-	}
-	
-	/**
-	 * Update the Projection appropriately.
-	 */
-	@Override 
-	public void addSelectionPaths(TreePath[] paths) {
-		for(TreePath path : paths) {
-			Object node = path.getLastPathComponent();
-			if(node instanceof DefaultMutableTreeNode) {
-				UserTreeNode x  = (UserTreeNode) ((DefaultMutableTreeNode)node).getUserObject();
-				// Select table.column records (not the table only). 
-				if(x.column != null) template.set(x.table, x.column);
-			}
-		}
-		super.addSelectionPaths( paths );
-	}
-	
-	@Override
-	public void clearSelection() {
-		super.clearSelection();
-		template.unsetEverything();
-	}
-			
-	/**
-	 * 
-	 * @return A copy of the inner template that stores the list of selected columns.
-	 */
-	public Projection getTemplate() {
-		return template;
-	}
-	
-}

Modified: trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/export/component/UserTreeNode.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -3,16 +3,17 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
- * A representation of a node in an XTree.
+ * A representation of a node in an ExtendedTree.
  * Every node corresponds to a &lt;code&gt;column&lt;/code&gt; of a &lt;code&gt;table&lt;/code&gt;.
- *  
+ * This is meant merely as a holder object - the hierarchy is represented elsewhere
+ * and in a different way.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-29
  * @see net.sf.plantlore.client.export.component.ExtendedTree
  */
 public class UserTreeNode {
-	/** The table whose columns this node represents. */
+	/** The table whose column this node represents. */
 	public Class table;
 	/** The column of the table this node represents. */
 	public String column;
@@ -20,15 +21,17 @@
 	public boolean nn;
 	
 	/**
-	 * Create a new XNode. The node represents 
-	 * a (possibly mandatory) column of a table.
+	 * Create a new UserTreeNode. 
+	 * The node represents one (possibly mandatory) column of a table.
 	 */
 	public UserTreeNode(Class table, String column, boolean notNullProperty) {
-		this.table = table; nn = notNullProperty; this.column = column;
+		this.table = table; 
+		this.nn = notNullProperty; 
+		this.column = column;
 	}
 	
 	/**
-	 * Create a new XNode. The node represents a column of a table.
+	 * Create a new UserTreeNode. The node represents a column of a table.
 	 */
 	public UserTreeNode(Class table, String column) {
 		this(table, column, false);
@@ -36,7 +39,6 @@
 	
 	/**
 	 * Get the name of the column.
-	 * TODO: L10n may be useful here!
 	 */
 	@Override
 	public String toString() {

Modified: trunk/src/net/sf/plantlore/client/login/AuthCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/AuthCtrl.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/AuthCtrl.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -3,15 +3,19 @@
 import java.awt.event.ActionEvent;
 
 import javax.swing.AbstractAction;
-import javax.swing.JOptionPane;
 
 import net.sf.plantlore.common.DefaultCancelAction;
+import net.sf.plantlore.common.DefaultExceptionHandler;
 import net.sf.plantlore.common.DefaultProgressBarEx;
 import net.sf.plantlore.common.Task;
-import net.sf.plantlore.common.exception.DBLayerException;
 import net.sf.plantlore.l10n.L10n;
 
-
+/**
+ * The mapping of buttons in the view to actions.
+ * The User can click to start the Connection to the database.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public class AuthCtrl {
 	
 	private AuthView view;
@@ -23,7 +27,10 @@
 		view.discard.setAction( new DefaultCancelAction(view) );
 	}
 
-	
+	/**
+	 *	Gather the information from the dialog and 
+	 * execute the connection task.
+	 */
 	class NextAction2 extends AbstractAction {
 		public NextAction2() {
 			putValue(SHORT_DESCRIPTION, L10n.getString(&quot;Login.AuthorizeTT&quot;));
@@ -31,29 +38,21 @@
 		}
 		public void actionPerformed(ActionEvent arg0) {
 			String user = ((javax.swing.JTextField)view.user.getEditor().getEditorComponent()).getText();
-
 			Task connect = model.createConnectionTask(user, new String(view.password.getPassword()));
 			
 			// My own ProgressBar - 
-			// it is not clever to offer reconnection after the login failed...
+			// it would not be wise to offer reconnection right after the login failed...
 			new DefaultProgressBarEx(connect, view, true) {
 				@Override
 				public void exceptionHandler(Exception ex) {
 					getTask().stop();
-					
-					String problem = ex.getMessage();
-					//TODO: DEFAULTNI HANDLER!
-					if(ex instanceof DBLayerException &amp;&amp; ex.getCause() != null )
-						problem = problem + ( (DBLayerException)ex ).getErrorInfo();
-					
-					JOptionPane.showMessageDialog( 
-							parent, 
-							problem, 
-							L10n.getString(&quot;Error.ConnectionFailed&quot;), 
-							JOptionPane.ERROR_MESSAGE );
+					DefaultExceptionHandler.handle(parent, ex, L10n.getString(&quot;Login.ConnectionFailed&quot;), true);
 				}
 			};
 			connect.start();
+			
+			// Discard the password!
+			view.password.setText(&quot;&quot;);
 		}
 	}
 	

Modified: trunk/src/net/sf/plantlore/client/login/AuthView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/AuthView.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/AuthView.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,9 +1,3 @@
-/*
- * AuthView.java
- *
- * Created on 9. duben 2006, 18:04
- */
-
 package net.sf.plantlore.client.login;
 
 import java.awt.Cursor;
@@ -16,12 +10,17 @@
 import net.sf.plantlore.middleware.DBLayer;
 
 /**
- *
- * @author  yaa
+ * The view allows the User to specify the Authentication information
+ * - the User name (or the Account name) and the Password of that account.
+ * 
+ * The list of User names is reloaded accoring to the currently selected record
+ * in the LoginView.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  */
 public class AuthView extends javax.swing.JDialog implements Observer {
 	
-    /** Creates new form AuthView */
+    
     public AuthView(Dialog parent, Login model) {
     	super(parent, true);
     	
@@ -115,6 +114,7 @@
     
     /**
      * Reload the list of usernames according to the currently selected record.
+     * Hide the dialog if it is no longer necessary.
      */
     public void update(Observable source, final Object arg) {
     	java.awt.EventQueue.invokeLater(new Runnable() {
@@ -127,21 +127,9 @@
     				password.setText(&quot;&quot;);
     				setTitle(L10n.getString(&quot;Login.ConnectingTo&quot;) + &quot; &quot; + selected.toString());
     			}
-    			// Exception! We must display the exception to the user.
-//    			else if(arg instanceof Exception) {
-//    				next.setEnabled(true);
-//    				setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));
-//    				JOptionPane.showMessageDialog(
-//    						null, 
-//    						((Exception)arg).getMessage(), 
-//    						L10n.getString(&quot;Error.LoginFailed&quot;), 
-//    						JOptionPane.ERROR_MESSAGE);
-//    			}
     			// The database layer has been created, we are no longer neccessary
-    			else if(arg instanceof DBLayer) {
+    			else if(arg instanceof DBLayer) 
     				setVisible(false);
-    				password.setText(&quot;&quot;); // Erase the password from the field.
-    			}
     		}
     	});
 	}

Modified: trunk/src/net/sf/plantlore/client/login/DBInfo.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/DBInfo.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/DBInfo.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,17 +1,21 @@
 package net.sf.plantlore.client.login;
 
 /**
- * Store information about one DB.
+ * Store information about one database connection.
+ * 
  * &lt;ul&gt;
- * &lt;li&gt;&lt;b&gt;alias&lt;/b&gt; ~ the name that will be presented to the user (such as &lt;i&gt;&quot;Home Database&quot;&lt;/i&gt;)&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;host&lt;/b&gt; ~ the host name of the server where the database is located&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;port&lt;/b&gt; ~ the port number where the server listens&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;db&lt;/b&gt; ~ the database identificator&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;user&lt;/b&gt; ~ last five user names that have been used for authentication&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;alias&lt;/b&gt; The name that will be presented to the User (such as &lt;i&gt;&quot;Home Database&quot;&lt;/i&gt;)&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;host&lt;/b&gt; The host name or ip address where the Server is located.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;port&lt;/b&gt; The port where the Server listens.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;databaseType&lt;/b&gt; The type of the database engine (postgresql, oraclesql, etc.)&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;databasePort&lt;/b&gt; The port where the database engine listens.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;databaseIdentifier&lt;/b&gt; The database identifier (usually a name of the database).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;databaseParameter&lt;/b&gt; Some additional parameter for the JDBC connection string.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;user&lt;/b&gt; The list of last user names that have been used during Authentication.&lt;/li&gt;
  * &lt;/ul&gt;
  * 
  * @author Erik Kratochv&#237;l
- * @version 1.0 final
+ * @version 4.0
  */
 public class DBInfo {
 	protected String alias;
@@ -24,10 +28,9 @@
 	protected String[] users;
 	
 	/**
-	 * Pick a user. The selected name will be moved to the start of the list.
-	 * The selected user will be at the top of the list next time.
+	 * Move the selected name to the top of the list.
 	 * 
-	 * @param name	The chosen user.
+	 * @param name		The chosen user.
 	 */
 	public void promoteUser(String name) {
 		int id = users.length - 1;
@@ -45,12 +48,26 @@
 		return alias;
 	}
 	
-	
+	/**
+	 * Create a shallow copy of this DBInfo.
+	 */
 	public DBInfo clone() {
 		return new DBInfo(
 				alias, host, port, databaseType, databasePort, databaseIdentifier, databaseParameter, users );
 	}
 
+	/**
+	 * Create a new DBInfo.
+	 * 
+	 * @param alias	The name that will be presented to the User (such as &lt;i&gt;&quot;Home Database&quot;&lt;/i&gt;)
+	 * @param host	The host name or ip address where the Server is located.
+	 * @param port	The port where the Server listens.
+	 * @param databaseType	The type of the database engine (postgresql, oraclesql, etc.)
+	 * @param databasePort	The port where the database engine listens.
+	 * @param databaseIdentifier	The database identifier (usually a name of the database).
+	 * @param databaseParameter	Some additional parameter for the JDBC connection string.
+	 * @param users	 The list of last user names that have been used during Authentication.
+	 */
 	public DBInfo(String alias, String host, int port, String databaseType, int databasePort, String databaseIdentifier, String databaseParameter, String[] users) {
 		this.alias = alias;
 		this.host = host;
@@ -62,35 +79,66 @@
 		this.users = users;
 	}
 
-	
+	/**
+	 * 
+	 * @return	The name that will be presented to the User (such as &lt;i&gt;&quot;Home Database&quot;&lt;/i&gt;).
+	 */
 	public String getAlias() {
 		return alias;
 	}
 
+	/**
+	 * 
+	 * @return	The database identifier (usually a name of the database).
+	 */
 	public String getDatabaseIdentifier() {
 		return databaseIdentifier;
 	}
 
+	/**
+	 * 
+	 * @return	Some additional parameter for the JDBC connection string.
+	 */
 	public String getDatabaseParameter() {
 		return databaseParameter;
 	}
 
+	/**
+	 * 
+	 * @return	The port where the database engine listens.
+	 */
 	public int getDatabasePort() {
 		return databasePort;
 	}
 
+	/**
+	 * 
+	 * @return	The type of the database engine (postgresql, oraclesql, etc.)
+	 */
 	public String getDatabaseType() {
 		return databaseType;
 	}
 
+	/**
+	 * 
+	 * @return	The host name or ip address where the Server is located.
+	 */
 	public String getHost() {
 		return host;
 	}
 
+	/**
+	 * 
+	 * @return	The port where the Server listens.
+	 */
 	public int getPort() {
 		return port;
 	}
 
+	/**
+	 * 
+	 * @return	The list of last user names that have been used during Authentication.
+	 */
 	public String[] getUsers() {
 		return users;
 	}

Modified: trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/ItemCtrl2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -7,17 +7,36 @@
 import net.sf.plantlore.common.DefaultCancelAction;
 import net.sf.plantlore.l10n.L10n;
 
+/**
+ * The mapping of buttons in the view to actions.
+ * In the ADD mode a new record is created,
+ * in the EDIT mode the selected record is altered.
+ * 
+ * Also the field validity check is performed.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public class ItemCtrl2 {
 	
 	private Login model;
 	private ItemView2 view;
 	
+	/**
+	 * The Controller distinguishes two modes.
+	 * In the ADD mode all fields are blank and the record is created and added to the list.
+	 * In the EDIT mode all fields are pre-filled with values of the selected record
+	 * and then the record is altered. 
+	 */
 	public enum Mode { ADD, EDIT }
 	
 	private Mode mode = Mode.ADD;
 	
 	
-	// Switch between the ADD/EDIT behaviour
+	/**
+	 * Switch between the two modes.
+	 * 
+	 * @param m	The mode that should be used from now on.
+	 */
 	public void setMode(Mode m) {
 		this.mode = m;
 		switch(m) {
@@ -46,7 +65,12 @@
 		}
 	}
 	
-	
+	/**
+	 * Create a new Item Controller. Requires the Model and the View.
+	 * 
+	 * @param login The model.
+	 * @param itemview	The view.
+	 */
 	public ItemCtrl2(Login login, ItemView2 itemview) {
 		this.model = login; this.view = itemview;
 		view.next.setAction(new NextAction());
@@ -58,10 +82,10 @@
 	}
 	
 	
-	
-
-	
-	
+	/**
+	 * Gather the data from the dialog, perform validity checks,
+	 * and add/edit the record. 
+	 */
 	class NextAction extends AbstractAction {
 		
 		public NextAction() {
@@ -94,7 +118,7 @@
     						view, 
     						L10n.getString(&quot;Error.MissingSeveralCompulsoryFields&quot;), 
     						L10n.getString(&quot;Error.MissingCompulsoryFieldTitle&quot;), 
-    						JOptionPane.ERROR_MESSAGE);
+    						JOptionPane.WARNING_MESSAGE);
 					return;
 				}
 					
@@ -147,7 +171,7 @@
     						view, 
     						L10n.getString(&quot;Error.MissingSeveralCompulsoryFields&quot;), 
     						L10n.getString(&quot;Error.MissingCompulsoryFieldTitle&quot;), 
-    						JOptionPane.ERROR_MESSAGE);
+    						JOptionPane.WARNING_MESSAGE);
 					return;
 				}
 				

Modified: trunk/src/net/sf/plantlore/client/login/ItemView2.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/ItemView2.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/ItemView2.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,9 +1,3 @@
-/*
- * ItemView2.java
- *
- * Created on 25. &#269;ervenec 2006, 16:25
- */
-
 package net.sf.plantlore.client.login;
 
 import java.awt.Dialog;
@@ -13,14 +7,17 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
+ * ItemView displays the dialog where the User can alter values
+ * that are required for connection making. The values are pre-filled
+ * according to the currently selected record.
  *
- * @author  yaa
+ * @author  Erik Kratochv&#237;l
+ * @see Login#getSelected()
  */
 public class ItemView2 extends javax.swing.JDialog implements Observer {
     
 	private Login model;
 	
-    /** Creates new form ItemView2 */
     public ItemView2(Dialog parent, Login model) {
     	super(parent, true);
     	
@@ -234,7 +231,8 @@
     
     
     /**
-     * Fill all fields with information obtained from the currently selected record.
+     * Fill all fields of the dialog
+     * with information obtained from the currently selected record.
      */
     public void update(Observable arg0, Object arg1) {
 		java.awt.EventQueue.invokeLater(new Runnable() {

Modified: trunk/src/net/sf/plantlore/client/login/Login.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/Login.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/Login.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -11,6 +11,8 @@
 
 import org.apache.log4j.Logger;
 
+import spin.Spin;
+
 import net.sf.plantlore.common.record.Right;
 import net.sf.plantlore.l10n.L10n;
 import net.sf.plantlore.middleware.DBLayer;
@@ -21,15 +23,20 @@
  * Login is responsible for the following tasks:
  * &lt;ul&gt;
  * &lt;li&gt;&lt;b&gt;management of the list of databases&lt;/b&gt; - 
- * 			adding, editing, removing records from the list, and the persistent storage of that list,&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;creating and initializing a new dblayer&lt;/b&gt; - only one at a time is active,&lt;/li&gt;
- * &lt;li&gt;&lt;b&gt;destroying the current dblayer (logout)&lt;/b&gt; - so as to make another connection possible&lt;/li&gt;
+ * 			adding, editing, removing records from the list, 
+ * 			and the invocation of methods ensuring the persistent storage of that list,&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;creation and initialization of a new dblayer&lt;/b&gt; -
+ * 			 only one at a time is active,&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;proper destruction of the current dblayer (logout)&lt;/b&gt; - 
+ * 			so as to make another connection possible&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;repeated connection (reconnect)&lt;/b&gt; - 
+ * 			to connect to the database again if the previous connection fails&lt;/li&gt;
  * &lt;/ul&gt;
  * 
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @author Jakub Kotowski
- * @version 1.0
+ * @author Jakub Kotowski (storage and retrieval of the list of databases)
+ * @version 2.0
  */
 public class Login extends Observable {
 	
@@ -65,6 +72,7 @@
 	 * new DBLayers.
 	 *  
 	 * @param factory The factory that will be used to create a new DBLayer. 
+	 * @param mainConfig The configuration tool that is capable of storing the list of databases.
 	 */
 	public Login(DBLayerFactory factory, MainConfig mainConfig) {
 		this.factory = factory;
@@ -75,7 +83,7 @@
 	
 	
 	/**
-	 * Load saved information about the database connections.
+	 * Retrieve saved information about the database connections.
 	 */
 	protected void load() {
 		logger.debug(&quot;Loading the stored list of databases.&quot;);
@@ -93,7 +101,7 @@
 	}
 	
 	/**
-	 * Save the list of database connections for further usage.
+	 * Store the list of database connections for further usage.
 	 */
 	protected void save() {
 		logger.debug(&quot;Saving the list of databases.&quot;);
@@ -108,10 +116,10 @@
 	
 
 	/**
-	 * Create a new record, add it to the list of connections and save that information for
-	 * the future use.
+	 * Create a new record, add it to the list of connections, and save that information for
+	 * future use.
 	 * 
-	
+	 * @see DBInfo
 	 */
 	synchronized public void createRecord(
 			String alias, 
@@ -145,12 +153,10 @@
 	}
 	
 	/**
-	 * Update the selected record.
+	 * Update the selected record, and save that information for
+	 * future use.
 	 * 
-	 * @param alias	Alias of the database.
-	 * @param host	Hostname of the computer where the server dwells.
-	 * @param port	Port where the server listens.
-	 * @param db		Identifier of the database to which the User wants to connect.
+	 * @see DBInfo
 	 */
 	synchronized public void updateSelectedRecord(
 			String alias, 
@@ -173,14 +179,14 @@
 		
 		save();
 		logger.debug(&quot;The selected record has been updated &quot; + selected);
-		this.setChanged(); this.notifyObservers(UPDATE_LIST);
+		this.setChanged(); 
+		this.notifyObservers(UPDATE_LIST);
 	}
 	
 	/**
-	 * @return the list of all records.
+	 * @return The list of all records the User has created.
 	 */
 	synchronized public DBInfo[] getRecords() {
-		// Seeing is believing: <A HREF="http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html#toArray(T[">http://java.sun.com/j2se/1.5.0/docs/api/java/util/Collection.html#toArray(T[</A>])
 		return dbinfos.toArray(new DBInfo[0]);
 	}
 	
@@ -190,7 +196,7 @@
 	 * Set the selected record.
 	 * 
 	 * @param index	The index of the selected record. Zero means first. 
-	 * Negative means nothing gets selected (deselect).
+	 * Negative means nothing gets selected (a.k.a. deselect).
 	 */
 	synchronized public void setSelected(int index) {
 		if(index == lastIndex) 
@@ -222,24 +228,24 @@
 	 * update their database layers.
 	 */
 	private void announceConnection() {
-		logger.debug(&quot;New database layer created for &quot; + proxyLayer);
+		logger.debug(&quot;New database layer created &quot; + proxyLayer);
 		setChanged(); 
 		notifyObservers(proxyLayer);
-		logger.debug(&quot;Observers notified.&quot;);
+		logger.debug(&quot;Observer notification finished.&quot;);
 	}
 	
 
 	
 	/**
-	 * Create a task that will try to forge the connection to the selected database. 
-	 * First, a new database layer is created,
-	 * and second, that database layer is initialized.
+	 * Create a task that will build the connection to the selected database. 
 	 * &lt;br/&gt;
-	 * &lt;b&gt;Warning:&lt;/b&gt;If there is a previously created DBLayer, 
+	 * &lt;b&gt;Warning:&lt;/b&gt;If there is another (previously created) DBLayer, 
 	 * it will be destroyed using the &lt;code&gt;logout()&lt;/code&gt; method. 
 	 * 	  
 	 * @param name The account name (used to access the database).  
 	 * @param password The password to the account.
+	 * 
+	 * @see #logout()
 	 */
 	synchronized public Task createConnectionTask(String name, String password) {
 		if(selected == null) {
@@ -259,13 +265,29 @@
 	}
 	
 	
-	
+	/**
+	 * The task that performs the database layer &quot;creation&quot; 
+	 * (using the supplied DatabaseLayerFactory - so in fact it is the Factory that creates
+	 * that DBLayer)
+	 * and it's initialization. Yet it is not the database layer that is returned - 
+	 * it is a special wrapper that performs further access checks and makes the renewal
+	 * of the database layer a little bit easier. 
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-08-30
+	 */
 	private class ConnectionTask extends Task {
 		
 		private DBInfo dbinfo;
 		private transient String name, password;
 		
-		
+		/**
+		 * Create a new connection task.
+		 * 
+		 * @param dbinfo	A holder object storing all neccessary information for the connection.
+		 * @param name		The account name (used to access the database).
+		 * @param password	The password to the account.
+		 */
 		public ConnectionTask(DBInfo dbinfo, String name, String password) {
 			this.dbinfo = dbinfo;
 			this.name = name;
@@ -280,7 +302,7 @@
 				if(isCanceled())
 					throw new Exception(L10n.getString(&quot;Common.Canceled&quot;));
 				
-				// Create a new database layer.
+				// Create a new database layer ~ ask the DBLayerFactory to create it for us..
 				logger.debug(&quot;Asking the DBLayerFactory for a new DBLayer @ &quot; + dbinfo.host + &quot;:&quot; + dbinfo.port);
 				setStatusMessage( L10n.getString(&quot;Login.Connecting&quot;) );
 				currentDBLayer = factory.create( dbinfo );
@@ -292,13 +314,15 @@
 				
 				// Initialize the database layer.
 				setStatusMessage( L10n.getString(&quot;Login.InitializingDBLayer&quot;) );
-				logger.debug(&quot;Initializing that DBLayer (&quot; + dbinfo.databaseType + &quot;, &quot; + name + &quot;, &quot; + password + &quot;...&quot;);
+				logger.debug(&quot;Initializing that DBLayer.&quot;);
 				
 				User init = currentDBLayer.initialize(dbinfo.getDatabaseIdentifier(), name, password);
 				if(isCanceled())
 					throw new DBLayerException(L10n.getString(&quot;Common.Canceled&quot;));
 				plantloreUser = init;
 				accessRights = init.getRight();
+				
+				logger.debug(&quot;Initialization successful.&quot;);
 			} 
 			catch (Exception e) {
 				logger.error(&quot;The initialization of the DBLayer failed! &quot; + e.getMessage());
@@ -308,7 +332,8 @@
 					try {
 						factory.destroy(currentDBLayer);
 					} catch(Exception re) {
-						// Nothing we can do; the server is probably in trouble, or the network connection failed. 
+						// There's nothing we can do; 
+						// the server is probably in trouble, or the network connection failed. 
 					}
 				// Re-throw the exception so that the view is updated as well.
 				throw e;
@@ -322,7 +347,7 @@
 			fireStopped(null);
 			
 			// Everything went fine - 
-			// there is a new DBLayer which is to be announced to the observers of Login.
+			// there is a new DBLayer and the observers of Login must know about it.
 			announceConnection();
 			
 			return null;
@@ -333,8 +358,9 @@
 	
 	
 	/**
-	 * Disconnect from the current database. 
-	 * The database connection is lost, any operation in progress will cause an exception.
+	 * Disconnect the User from the current database. 
+	 * The database connection will cease to exist - 
+	 * everyone using the database layer will get an exception from now on. 
 	 */
 	public void logout() {
 		if(currentDBLayer != null) 
@@ -347,20 +373,25 @@
 				logger.info(&quot;The client disconnected itself from the server. The communication may no longer be possible.&quot;);
 			} catch(RemoteException e) {
 				logger.warn(&quot;Unable to disconnect from the server. &quot; + e.getMessage());
-				/*setChanged();
-				notifyObservers(e);*/ // Not this time, this is supposed to be silent.
+				// Not this time, this is supposed to be silent.
 			}
 	}
 	
 	
-	
+	/**
+	 * 
+	 * @return The last connection task, ie. the last task that was used to create a connection
+	 * to the database. Restarting that task will lead to the database layer renewal, 
+	 * however, this may lead to problems as old queries and resultset identifiers will
+	 * not be valid with the new database layer!
+	 */
 	synchronized public Task getLastConnectionTask() {
 		return lastConnectionTask;
 	}
 	
 		
 	/**
-	 * @return The last DBLayer that has been created.  
+	 * @return The new DBLayer that has been created.  
 	 */	
 	synchronized public DBLayer getDBLayer() { 
 		return proxyLayer; 
@@ -383,7 +414,20 @@
 	
 	
 	
-	
+	/**
+	 * The DBLayerProxy constitutes a simple wrapper of the received database layer.
+	 * It performs some additional access checks.
+	 * &lt;br/&gt;
+	 * The advantage of the wrapper is that its wrapped database layer can be easily
+	 * switched without clients noting anything. 
+	 * However, in some cases clients using the wrapper must be notified 
+	 * in order to restart their queries and refresh their resultsets.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-08-30
+	 * 
+	 * @see DBLayer
+	 */
 	private class DBLayerProxy implements DBLayer {
 		
 		private DBLayer wrappedDBLayer;
@@ -394,8 +438,11 @@
 		}
 		
 				
-		synchronized public void wrap(DBLayer db) {
-			this.wrappedDBLayer = db;
+		synchronized void wrap(DBLayer db) {
+			if(db == null)
+				this.wrappedDBLayer = db;
+			else
+				this.wrappedDBLayer = (DBLayer) Spin.off( db );
 		}
 
 		synchronized public User initialize(String dbID, String user, String password) throws DBLayerException, RemoteException {
@@ -547,12 +594,12 @@
 		}
 
 		synchronized public int getConnectionCount() throws RemoteException {
-			verifyValidity();
-			return wrappedDBLayer.getConnectionCount();
+			//verifyValidity();
+			return 0; //wrappedDBLayer.getConnectionCount();
 		}
 
 		synchronized public void shutdown() throws RemoteException {
-			throw new Error(&quot;YOU SHOULD NEVER CALL DBLayer.shutdown() YOU IDIOT!&quot;);
+			throw new Error(&quot;It is forbidden to call this method. The proper way to destroy a database layer is the logout() method!&quot;);
 		}
 		
 		@Override

Modified: trunk/src/net/sf/plantlore/client/login/LoginCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/LoginCtrl.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/LoginCtrl.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -10,7 +10,14 @@
 import net.sf.plantlore.common.DefaultCancelAction;
 import net.sf.plantlore.l10n.L10n;
 
-
+/**
+ * The mapping of buttons in the view to actions.
+ * The User can move to the Authorization dialog,
+ * or to the Add/Edit Item dialog, or Delete one item 
+ * from the list.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public class LoginCtrl {
 	
 	private Login model;
@@ -21,7 +28,12 @@
 	private AuthView authView;
 	
 	
-	
+	/**
+	 * Create a new Login Controller. Requires the Model and the View.
+	 * 
+	 * @param login The model.
+	 * @param loginview	The view.
+	 */
 	public LoginCtrl(Login login, LoginView loginview) {
 		this.view = loginview; this.model = login;
 		
@@ -43,13 +55,21 @@
 		view.choice.setSelectedIndex(0);
 	}
 	
-	
+	/**
+	 * Set either this dialog or the Authorization dialog visible.
+	 * The authorization dialog will be opened instead of this one 
+	 * if the selection is non-empty and the View.Remember checkbox is selected.
+	 *  
+	 * @param visible	True if the View should become visible.
+	 */
 	public void setVisible(boolean visible) {
 		JDialog dialog = view.remember.isSelected() &amp;&amp; !view.choice.isSelectionEmpty() ? authView : view;
 		dialog.setVisible(visible);
 	}
 	
-	
+	/**
+	 *	Set the currently selected record in the Model accordingly. 
+	 */
 	class ChoiceChanged implements ListSelectionListener {
 		public void valueChanged(ListSelectionEvent e) {
 			int index = view.choice.getSelectedIndex();
@@ -58,6 +78,9 @@
 		}	
 	}
 	
+	/**
+	 * Open the `Add New Record` dialog. 
+	 */
 	class AddRecordAction extends AbstractAction {
 		public AddRecordAction() {
 			putValue(SHORT_DESCRIPTION, L10n.getString(&quot;Login.AddRecordTT&quot;));
@@ -69,6 +92,9 @@
 		}
 	}
 	
+	/**
+	 *	Remove the selected record.
+	 */
 	class  RemoveRecordAction extends AbstractAction {
 		public RemoveRecordAction() {
 			putValue(SHORT_DESCRIPTION, L10n.getString(&quot;Login.RemoveRecordTT&quot;));
@@ -79,6 +105,9 @@
 		}
 	}
 	
+	/**
+	 * Open the `Edit the Selected Record` dialog.
+	 */
 	class EditRecordAction extends AbstractAction {
 		public EditRecordAction() {
 			putValue(SHORT_DESCRIPTION, L10n.getString(&quot;Login.EditRecordTT&quot;));
@@ -92,6 +121,9 @@
 		}
 	}
 	
+	/**
+	 * Proceed to the Authorization - open the `Authentication` dialog.
+	 */
 	class NextAction extends AbstractAction {
 		public NextAction() {
 			putValue(SHORT_DESCRIPTION, L10n.getString(&quot;Login.NextTT&quot;));

Modified: trunk/src/net/sf/plantlore/client/login/LoginView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/login/LoginView.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/client/login/LoginView.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -14,14 +14,19 @@
 import net.sf.plantlore.middleware.DBLayer;
 
 /**
+ * The view presents the User with the list of databases the User created or
+ * accessed. The User should choose one of them and proceed to Authorization
+ * or He can modify (add/edit/delete) the list of databases.
  *
- * @author  yaa
+ * @author  Erik Kratochv&#237;l
+ * 
+ * @see LoginCtrl
  */
 public class LoginView extends javax.swing.JDialog implements Observer {
 	
 	private Login model;
     
-    /** Creates new form LoginView */
+    
     public LoginView(Frame parent, Login model) {
     	super(parent, true);
     	
@@ -112,7 +117,8 @@
  
     
     /**
-     * Update the list of records (in case there were some changes).
+     * Update the list of records (in case there were some changes)
+     * or hide if no longer necessary.
      */
     public void update(final Observable source, final Object parameter) {
     	java.awt.EventQueue.invokeLater(new Runnable() {

Modified: trunk/src/net/sf/plantlore/common/Assistant.java
===================================================================
--- trunk/src/net/sf/plantlore/common/Assistant.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/Assistant.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -25,6 +25,7 @@
  *
  *    
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @version 1.0
  */
 public class Assistant extends JScrollPane {
 

Modified: trunk/src/net/sf/plantlore/common/AutoComboBox.java
===================================================================
--- trunk/src/net/sf/plantlore/common/AutoComboBox.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/AutoComboBox.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -25,15 +25,13 @@
  * guide this time.&lt;/li&gt;
  * &lt;/ul&gt;
  * &lt;br/&gt;
- * Heavily refined from the source code created by Stephane Crasnier. 
- * &lt;br/&gt;
  * The use of the benevolent behaviour is discouraged as it contradicts the sole purpose 
  * of this component. If you want to allow the User 
  * to leave this field blank, use a special
  * record &quot;------&quot; or &quot;not specified&quot; instead.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @version 1.1 jlist doesn't get updated when the user types
+ * @version 1.1
  * @since The beginning of time.
  */
 public class AutoComboBox extends JComboBox {
@@ -45,7 +43,7 @@
 	
 
 	/**
-	 * Create the AutoComboBox with given array of choices.
+	 * Create a new AutoComboBox starting with the given array of choices.
 	 * 
 	 * @param choices	&lt;b&gt;Sorted&lt;/b&gt; list of available choices (items).
 	 */
@@ -58,11 +56,18 @@
 		editor.setDocument(a); editor.addKeyListener(a); editor.addFocusListener(a);
 	}
 	
-	
+	/**
+	 * Create an empty AutoComboBox.
+	 */
 	public AutoComboBox() {
 		this(new String[] { null });		
 	} 
 	
+	/**
+	 * An extension of JList.addItem(). This method allows you to add several items at once.
+	 * 
+	 * @param items	The list of items to be inserted (added) into the list.
+	 */
 	public void addItems(Object[] items) {
 		for(Object item : items)
 			if(item != null) 

Modified: trunk/src/net/sf/plantlore/common/AutoComboBoxNG3.java
===================================================================
--- trunk/src/net/sf/plantlore/common/AutoComboBoxNG3.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/AutoComboBoxNG3.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,6 +1,5 @@
 package net.sf.plantlore.common;
 
-import java.awt.Color;
 import java.awt.event.FocusEvent;
 import java.awt.event.FocusListener;
 import java.awt.event.KeyEvent;
@@ -8,12 +7,9 @@
 import java.util.Arrays;
 import java.util.HashSet;
 import java.util.Set;
-import javax.swing.BorderFactory;
 
 import javax.swing.JComboBox;
 import javax.swing.JTextField;
-import javax.swing.border.Border;
-import javax.swing.plaf.basic.BasicComboBoxEditor;
 import javax.swing.plaf.metal.MetalComboBoxEditor;
 import javax.swing.text.AttributeSet;
 import javax.swing.text.BadLocationException;
@@ -89,12 +85,10 @@
 		JTextField e = (JTextField)(editor.getEditorComponent());
 		AutoDocument a = new AutoDocument(); // change the model ~~&gt; AutoDocument 
 		e.setDocument(a); e.addKeyListener(a); e.addFocusListener(a);
-                //setBorder(BorderFactory.createLineBorder(Color.BLUE));
-                //updateUI();
 	}
 	
 	/**
-	 * Create the AutoComboBox with given array of values
+	 * Create a new AutoComboBox filled with given values.
 	 * 
 	 * @param values	&lt;b&gt;Sorted&lt;/b&gt; list of available values (items).
 	 * @param strict	True if the AutoComboBox should not accept values (items)
@@ -114,11 +108,20 @@
 			super.setPopupVisible(visibility);
 	}
 	
-	
+	/**
+	 * Create an empty AutoComboBox.
+	 * 
+	 */
 	public AutoComboBoxNG3() {
 		this(new String[] { &quot;&quot; });		
 	} 
 	
+	/**
+	 * Create a new AutoComboBox filled with given values.
+	 * 
+	 * @param strict	True if the AutoComboBox should not accept values (items)
+	 *        that are not in the list of available values.
+	 */
 	public AutoComboBoxNG3(boolean strict) {
 		this(new String[] { &quot;&quot; });
                 this.strict = strict;
@@ -287,10 +290,18 @@
 		public void focusGained(FocusEvent arg0) {}
 	}
     
+	/**
+	 * 
+	 * @return The maximum number of character the user can type in the &quot;benevolent&quot; mode.
+	 */
 	public int getCapacity() {
 		return capacity;
 	}
 
+	/**
+	 * 
+	 * @param capacity	The maximum number of character the user can type in the &quot;benevolent&quot; mode.
+	 */
 	public void setCapacity(int capacity) {
 		this.capacity = capacity;
 	}

Modified: trunk/src/net/sf/plantlore/common/AutoTextArea.java
===================================================================
--- trunk/src/net/sf/plantlore/common/AutoTextArea.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/AutoTextArea.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -11,7 +11,7 @@
 /**
  * AutoTextArea is an extension of the default &lt;code&gt;JTextArea&lt;/code&gt;. It operates in two modes:
  * &lt;dl&gt;
- * &lt;dt&gt;FREE_ROAM&lt;/dt&gt;
+ * &lt;dt&gt;FREE ROAM&lt;/dt&gt;
  * &lt;dd&gt;This mode allows the User to move freely through entries with minor limitations.
  * 	&lt;ul&gt;
  * 		&lt;li&gt;&lt;code&gt;Up&lt;/code&gt;, &lt;code&gt;Down&lt;/code&gt;,&lt;code&gt;Left&lt;/code&gt;, 
@@ -334,32 +334,55 @@
 			this.values.add(obj);
 	}
 	
-        public AutoTextArea(Container container) {
-                this(new String[] {&quot;&quot;}, container);
-        }
-        
-        public AutoTextArea(JDialog dialog) {
-            this(new String[] {&quot;&quot;}, dialog.getLayeredPane());
-        }
-        
-        public AutoTextArea(JFrame frame) {
-            this(new String[] {&quot;&quot;}, frame.getLayeredPane());
-        }
-        
-        public void setChoices(Object[] choices) {
-            if (choices == null)
-                choices = new String[] {&quot;&quot;};
-            assistant.setChoices(choices);
-            assistant.getList().addMouseListener(this);
-            this.choices = choices;
-            this.values = new HashSet&lt;Object&gt;(choices.length);
-            for(Object obj : choices)
-                    this.values.add(obj);
-            
-            firePropertyChange(ALLOWED_VALUES_CHANGED, null, null);
-        }
-        
 	/**
+	 * Create the AutoTextArea with a Visual Assistant that helps with choosing items from the
+	 * list of available (allowed) strings. The initial list is empty.
+	 * 
+	 * @param container	The container which the AutoTextArea is added to.  
+	 */
+	public AutoTextArea(Container container) {
+		this(new String[] {&quot;&quot;}, container);
+	}
+	
+	/**
+	 * Create the AutoTextArea with a Visual Assistant that helps with choosing items from the
+	 * list of available (allowed) strings. The initial list is empty.
+	 * 
+	 * @param dialog	The parent dialog which the AutoTextArea is added to.  
+	 */
+	public AutoTextArea(JDialog dialog) {
+		this(new String[] {&quot;&quot;}, dialog.getLayeredPane());
+	}
+	
+	/**
+	 * Create the AutoTextArea with a Visual Assistant that helps with choosing items from the
+	 * list of available (allowed) strings. The initial list is empty.
+	 * 
+	 * @param frame	The parent frame which the AutoTextArea is added to.  
+	 */
+	public AutoTextArea(JFrame frame) {
+		this(new String[] {&quot;&quot;}, frame.getLayeredPane());
+	}
+	
+	/**
+	 * Replace the old list of choices with the new one.
+	 * 
+	 * @param choices	The list of new available values that will replace the old one.
+	 */
+	public void setChoices(Object[] choices) {
+		if (choices == null)
+			choices = new String[] {&quot;&quot;};
+		assistant.setChoices(choices);
+		assistant.getList().addMouseListener(this);
+		this.choices = choices;
+		this.values = new HashSet&lt;Object&gt;(choices.length);
+		for(Object obj : choices)
+			this.values.add(obj);
+		
+		firePropertyChange(ALLOWED_VALUES_CHANGED, null, null);
+	}
+	
+	/**
 	 * The list of choices, or &quot;allowed values&quot; - for fast searching.
 	 */
 	private HashSet&lt;Object&gt; values;
@@ -428,52 +451,6 @@
 	}
 
 	
-//	public static void main(String[] args) throws InterruptedException {
-//		String lookAndFeel = UIManager.getSystemLookAndFeelClassName();
-//        try { UIManager.setLookAndFeel(lookAndFeel); }
-//        catch (Exception e) { JFrame.setDefaultLookAndFeelDecorated(true); }
-//        
-//        String[]
-//        	ch = {&quot;Anubis&quot;, &quot;Apophis&quot;, &quot;Ayiana&quot;, &quot;Baal&quot;, &quot;Baldur&quot;, &quot;Camulus&quot;, &quot;Cronus&quot;, &quot;Daniel Jackson&quot;,
-//					&quot;Elizabeth Weir&quot;, &quot;Freir&quot;, &quot;George Hammond&quot;, &quot;Hallowed are the Ori&quot;, &quot;Heimdall&quot;, &quot;Hermiod&quot;,
-//					&quot;Chaya Sar&quot;, &quot;Imhotep&quot;, &quot;Jack O'Neill&quot;, &quot;John Sheppard&quot;, &quot;Jonas Quinn&quot;, &quot;Khalek&quot;, &quot;Klorel&quot;,
-//					&quot;Loki&quot;, &quot;Martoufe&quot;, &quot;Master Bra'tac&quot;, &quot;Nerus&quot;, &quot;Oma Desala&quot;, &quot;Penegal&quot;, &quot;Qetesh&quot;,
-//					&quot;Ra&quot;, &quot;Radek Zelenka&quot;, &quot;Replicarter&quot;, &quot;Rodney McKay&quot;, &quot;Ronon Dex&quot;,
-//					&quot;Samantha Carter&quot;, &quot;Sokar&quot;, &quot;&#352;evron&quot;, 
-//					&quot;Teyla Emmagan&quot;, &quot;The Eight&quot;, &quot;The Fifth&quot;, &quot;The First&quot;, &quot;The Fourth&quot;,
-//					&quot;The Second&quot;, &quot;The Seventh&quot;, &quot;The Sixth&quot;, &quot;The Third&quot;, &quot;Thor&quot;, &quot;Ty'alc&quot;, &quot;Vala Mal Doran&quot;, &quot;Yu&quot;};
-//        
-//		JFrame f = new JFrame();
-//		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-//		AutoTextArea a = new AutoTextArea(ch, f); 
-//		a.setPreferredSize(new Dimension(400, 300));
-//		a.setFont(new Font(&quot;Verdana&quot;, 0, 12));
-//		a.setCapacity(5);
-//		JScrollPane sp = new JScrollPane(a);
-//		sp.setVerticalScrollBarPolicy(JScrollPane.VERTICAL_SCROLLBAR_ALWAYS);
-//		
-//		
-//		JPanel ugly = new JPanel(new BorderLayout());
-//		ugly.add(new JButton(&quot;foooooooo&quot;), BorderLayout.WEST);
-//		ugly.add(new JButton(&quot;sue&quot;), BorderLayout.NORTH);
-//		ugly.add(/*a*/sp, BorderLayout.CENTER);
-//		
-//				
-//		JButton b = new JButton(&quot;Done&quot;);
-//		f.getContentPane().add(new JLabel(&quot;be ugly and give some space&quot;), BorderLayout.WEST);
-//		f.getContentPane().add(new JLabel(&quot;be ugly and give more space&quot;), BorderLayout.NORTH);
-//		f.getContentPane().add(ugly/*a*/, BorderLayout.CENTER);
-//		f.getContentPane().add(b, BorderLayout.SOUTH);
-//		f.pack();
-//		f.setVisible(true);
-//		
-//		Thread.sleep(10000);
-//		a.addLines(new String[]{&quot;Martoufe&quot;, &quot;The Fourth&quot;,  &quot;Baldur&quot;, &quot;Chaya Sar&quot;, &quot;Ygzotot&quot;});
-//		
-//	}
-
-
-	
 	/*======================================================================
 	 	Unimplemented &amp; uninteresting methods
 	  ======================================================================*/

Modified: trunk/src/net/sf/plantlore/common/ComponentAdjust.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ComponentAdjust.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/ComponentAdjust.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -15,9 +15,12 @@
 /** The purpose of ComponentAdjust is to ease manual creation of swing dialogs.
  * You can add your components to an instance of this class and then adjust their
  * width by calling setMaxWidth() method.
+ * 
+ * This class is no longer in use by any other class. It shall be removed from the repository.
  *
  * @author Jakub
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ComponentAdjust
 {
     ArrayList&lt;JComponent&gt; list;

Modified: trunk/src/net/sf/plantlore/common/DBLayerUtils.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DBLayerUtils.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DBLayerUtils.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -45,12 +45,12 @@
  * Class offering convenience methods for DBLayer.
  * 
  * Every class requiring high-level work with the database 
- * should use these methods so as to unite the behaviour through the application. 
+ * should use these methods so as to unite the behaviour throughout the application. 
  *
  * 
  *
- * @author reimei
- * @author kaimu
+ * @author Jakub Kotowski
+ * @author Erik Kratochv&#237;l
  */
 public class DBLayerUtils {
     private DBLayer db;
@@ -84,13 +84,19 @@
 	}
     
     
-    /** Creates a new instance of TempClass */
+    /**
+     * Create a new Utils using the supplied Database layer.
+     *   
+     * @param db		The database layer that should be used to perform all the operations.
+     */
     public DBLayerUtils(DBLayer db) {
         this(db, null, true);
     }
     
     /**
-     * @param db
+     * Create a new Utils using the supplied Database layer.
+     * 
+     * @param db		The database layer that should be used to perform all the operations.
      * @param isCacheEnabled	Gives you the possibility to switch off the cache 
      * (which is enabled by default), because it is highly likely it will not contain up-to-date data.
      */
@@ -101,7 +107,13 @@
     }
     
     
-    
+    /**
+     * Processing of some records require the User's assistance. It this way
+     * you can set the User's true intention with the problematic record.
+     * 
+     * @param intention	The true intention with the record as the User decided.
+     * @see #expectDecision()
+     */
     public void setIntention(Intention intention) {
     	this.intention = intention;
     	this.notify();
@@ -109,9 +121,14 @@
     
     
     /**
-     * There are some cases in which DBLayer utils needs assistance.
+     * There are some cases in which DBLayer utils needs assistance of the User.
+     * This method gives you the time needed to contact and inform the User
+     * and then pass His decision using the setIntention() method.
+     * &lt;br/&gt;
+     * The execution of the operation that required the assistance 
+     * will be suspended until the setIntention() method is called.
      *
-     * You must call setIntention(Intention.SOMETHING);
+     * @see #setIntention(Intention) 
      */
     private Intention expectDecision() {
     	if(decisionCallback == null)
@@ -163,7 +180,7 @@
         AuthorOccurrence[] authorResults = null;
         SelectQuery sq = db.createQuery(AuthorOccurrence.class);        
         sq.addRestriction(PlantloreConstants.RESTR_EQ,AuthorOccurrence.OCCURRENCE,null,o,null);
-        sq.addRestriction(PlantloreConstants.RESTR_EQ,AuthorOccurrence.DELETED,null,0,null);
+        sq.addRestriction(PlantloreConstants.RESTR_EQ,Deletable.DELETED,null,0,null);
         int resultid = db.executeQuery(sq);
         int resultCount = db.getNumRows(resultid);
         authorResults = new AuthorOccurrence[resultCount];
@@ -187,7 +204,7 @@
     public void deleteHabitat(Habitat h) throws DBLayerException, RemoteException {
         SelectQuery sq = db.createQuery(Occurrence.class);        
         sq.addRestriction(PlantloreConstants.RESTR_EQ,Occurrence.HABITAT,null,h,null);
-        sq.addRestriction(PlantloreConstants.RESTR_EQ,Occurrence.DELETED, null, 0, null);
+        sq.addRestriction(PlantloreConstants.RESTR_EQ,Deletable.DELETED, null, 0, null);
         int resultid = db.executeQuery(sq);
         int resultCount = db.getNumRows(resultid);
         if (resultCount == 0) {
@@ -208,7 +225,7 @@
     public void deleteHabitatInTransaction(Habitat h) throws DBLayerException, RemoteException {
         SelectQuery sq = db.createQuery(Occurrence.class);        
         sq.addRestriction(PlantloreConstants.RESTR_EQ,Occurrence.HABITAT,null,h,null);
-        sq.addRestriction(PlantloreConstants.RESTR_EQ,Occurrence.DELETED, null, 0, null);
+        sq.addRestriction(PlantloreConstants.RESTR_EQ,Deletable.DELETED, null, 0, null);
         int resultid = db.executeQuery(sq);
         int resultCount = db.getNumRows(resultid);
         if (resultCount == 0) {
@@ -234,7 +251,7 @@
     
     
 	/**
-	 * Find out how many records share the supplied &lt;code&gt;record&lt;/code&gt;.
+	 * Find out how many records (alive or not) share the supplied &lt;code&gt;record&lt;/code&gt;.
 	 *  
 	 * @param record	The record in question.
 	 * @return	The number of records that share the supplied &lt;code&gt;record&lt;/code&gt;. 
@@ -248,7 +265,7 @@
 	 * Find out how many records share the supplied &lt;code&gt;record&lt;/code&gt;.
 	 * 	 * 
 	 * @param record	The record in question.
-	 * @param aliveOnly	Ommit records marked as deleted.
+	 * @param aliveOnly	True if it should ommit records marked as deleted.
 	 * @return	The number of records that share the supplied &lt;code&gt;record&lt;/code&gt;. 
 	 */
 	public int sharedBy(Record record, boolean aliveOnly) 
@@ -383,9 +400,6 @@
 				query.addRestriction(RESTR_EQ, key, null, subrecord, null);
 			}
 			
-			
-			
-			
 			// Is there such record?
 			int results = db.executeQuery( query );
 			int rows = db.getNumRows( results );
@@ -396,7 +410,7 @@
 			
 			record = null;
 			if( rows != 0 ) 
-				record = (Record)((Object[])(db.more(results, 0, 0)[0]))[0]; // Well, THIS is ugly!
+				record = (Record)((Object[])(db.more(results, 0, 0)[0]))[0]; 
 		} finally {
 			db.closeQuery( query );
 		}
@@ -499,7 +513,12 @@
 		
 	}
 	
-	
+	/**
+	 * Insert a record that belongs to an immutable table into the database.
+	 * 
+	 * @param record	The record to be inserted.
+	 * @return	The inserted record.
+	 */
 	public Record insertImmutableRecord(Record record)
 	throws RemoteException, DBLayerException {
 		if( !Record.IMMUTABLE.contains(record) )
@@ -652,7 +671,13 @@
 		return current;
 	}
 	
-	
+	/**
+	 * Replace a record that belongs to an immutable table by another record.
+	 * 
+	 * @param current	The record to be replaced.
+	 * @param replacement	The replacement of the current record.
+	 * @return	The replacement.
+	 */
 	public Record updateImmutableRecord(Record current, Record replacement) 
 	throws RemoteException, DBLayerException {
 		if( !Record.IMMUTABLE.contains(current) ||
@@ -798,7 +823,9 @@
 	/**
 	 * It is impossible to delete a record of the type (I), if there is at least one
 	 * record refering to it (undeleted as well as deleted).
-    */
+	 * 
+	 * @param The record that is to be deleted. 
+	 */
 	public void deleteImmutableRecord(Record record)
 	throws RemoteException, DBLayerException {
 		if( !Record.IMMUTABLE.contains(record) )
@@ -819,7 +846,7 @@
 	 * a simple table will be created from supplied record(s).
 	 * 
 	 * @param records
-	 * @return
+	 * @return A table model containing all records.
 	 */
 	public TableModel createTableFor(Record... records) {
 		return new RecordTable(records);
@@ -896,9 +923,7 @@
 	
 	
 	/**
-	 * NOT TESTED!
-	 * 
-	 * High-level record processor. 
+	 * High-level occurrence data processor. 
 	 * Incorporates all rules that bind the record processing. 
 	 * 
 	 * @param occ	The basic occurrence record.

Modified: trunk/src/net/sf/plantlore/common/DefaultCancelAction.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultCancelAction.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DefaultCancelAction.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -28,32 +28,58 @@
 	protected JFrame frame;
 	
 	
+	/**
+	 * Create a new Cancel action that hides the given frame.
+	 * 
+	 * @param frame	The frame to be hidden.
+	 * @param name		The caption of the button.
+	 * @param tooltip	The tooltip displayed over the button.
+	 */
 	public DefaultCancelAction(JFrame frame, String name, String tooltip) {
 		putValue(SHORT_DESCRIPTION, tooltip);
 		putValue(NAME, name);
 		this.frame = frame;
 	}
 	
+	/**
+	 * Create a new Cancel action that hides the given dialog.
+	 * 
+	 * @param dialog	The dialog to be hidden.
+	 * @param name		The caption of the button.
+	 * @param tooltip	The tooltip displayed over the button.
+	 */
 	public DefaultCancelAction(JDialog dialog, String name, String tooltip) {
 		putValue(SHORT_DESCRIPTION, tooltip);
 		putValue(NAME, name);
 		this.dialog = dialog;
 	}
 	
-	
+	/**
+	 * Create a new Cancel action that hides the given frame.
+	 * The caption of the button is set to a default value.
+	 * 
+	 * @param frame	The frame to be hidden.
+	 */
 	public DefaultCancelAction(JFrame frame) {
 		putValue(NAME, L10n.getString(&quot;Common.Cancel&quot;));
 		this.frame = frame;
 	}
 	
-	
+	/**
+	 * Create a new Cancel action that hides the given dialog.
+	 * The caption of the button is set to a default value.
+	 * 
+	 * @param dialog	The dialog to be hidden.
+	 */
 	public DefaultCancelAction(JDialog dialog) {
 		putValue(NAME, L10n.getString(&quot;Common.Cancel&quot;));
 		this.dialog = dialog;
 	}
 
 	
-	
+	/**
+	 * Hide the frame (or dialog).
+	 */
 	public void actionPerformed(ActionEvent e) {
 		if(frame != null)
 			frame.setVisible(false);

Modified: trunk/src/net/sf/plantlore/common/DefaultExceptionHandler.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultExceptionHandler.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DefaultExceptionHandler.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,5 +1,6 @@
 package net.sf.plantlore.common;
 
+import java.awt.Component;
 import java.rmi.*;
 import java.rmi.server.ExportException;
 
@@ -11,75 +12,155 @@
 import net.sf.plantlore.l10n.L10n;
 
 /**
+ * The Default Exception Handler offers a united exception handling and
+ * error presentation. It can offer reconnect if it is reasonable.
+ * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 28.8.2006
- *
+ * @since 2006-08-28
+ * @version 1.0
  */
 public class DefaultExceptionHandler {
+	
+	private static DefaultExceptionHandler D = new DefaultExceptionHandler();
 
+
 	private DefaultExceptionHandler() {}
-	
-	
+
+
+	/**
+	 * Announce the exception to the User.
+	 * 
+	 * @param parent	The parent window (in order to maintain the proper window hierachy in Swing).
+	 * @param e	The exception to be announced.
+	 */
 	public static void handle(java.awt.Component parent, Exception e) {
-		handle(parent, e, L10n.getString(&quot;Error.General&quot;));		
+		handle(parent, e, L10n.getString(&quot;Error.General&quot;), false);		
 	}
 	
-	
+	/**
+	 * Announce the exception to the User.
+	 * 
+	 * @param parent	The parent window (in order to maintain the proper window hierachy in Swing).
+	 * @param e	The exception to be announced.
+	 * @param title The title the window should have instead of the default title.
+	 */
 	public static void handle(java.awt.Component parent, Exception e, String title) {
+		handle(parent, e, title, false);
+	}
+		
+	/**
+	 * Announce the exception to the User.
+	 * 
+	 * @param parent	The parent window (in order to maintain the proper window hierachy in Swing).
+	 * @param e	The exception to be announced.
+	 * @param title The title the window should have instead of the default title.
+	 * @param doNotOfferReconnect True if the reconnect procedure should not be offered
+	 * 					even if it might seem reasonable.
+	 */	
+	public static void handle(
+			java.awt.Component parent, 
+			Exception e, 
+			String title, 
+			boolean doNotOfferReconnect) {
+		
+		boolean isReconnectReasonable = false;
+		String problemDescription = e.getMessage();
+		
 		/*
 		 * REMOTE EXCEPTION HANDLER
 		 */
 		if( e instanceof RemoteException ) {
-			String problemDescription = e.getMessage();
-			
+			// The caller does not have permission to perform the action requested by the method call.
 			if( e instanceof AccessException )
 				problemDescription = L10n.getString(&quot;Error.Server.AccessDenied&quot;);
-			else if( e instanceof ConnectException )
+			
+			// Connection is refused to the remote host for a remote method call.
+			else if( e instanceof ConnectException ) {
 				problemDescription = L10n.getString(&quot;Error.Server.ConnectionRefused&quot;);
+				isReconnectReasonable = true;
+			}
+			
+			// An IOException occured while making a connection to the remote host for a remote method call.
 			else if( e instanceof ConnectIOException )
 				problemDescription = L10n.getString(&quot;Error.Server.ConnectionRefused&quot;);
+			
+			// An attempt to export a remote object failed.
 			else if( e instanceof ExportException )
 				problemDescription = L10n.getString(&quot;Error.Server.ExportFailed&quot;);
+			
+			// Occurs while marshalling the remote call header, arguments or 
+			// return value for a remote method call.
+			// Or if the receiver does not support the protocol version of the sender.
 			else if( e instanceof MarshalException )
 				problemDescription = L10n.getString(&quot;Error.Server.MarshallingFailed&quot;);
+			
+			// An attempt was made to invoke a method on an object 
+			// that no longer exists in the remote virtual machine.
 			else if( e instanceof NoSuchObjectException )
 				problemDescription = L10n.getString(&quot;Error.Server.ObjectDoesNotExistAnymore&quot;);
-			else if( e instanceof ServerError )
+			
+			// An Error was thrown while processing the invocation on the server, 
+			// either while unmarshalling the arguments, executing the remote method itself, 
+			// or marshalling the return value.
+			else if( e instanceof ServerError ) {
 				problemDescription = L10n.getString(&quot;Error.Server.InTrouble&quot;);
-			else if( e instanceof ServerException )
+				isReconnectReasonable = true;
+			}
+			
+			// A RemoteException was thrown while processing the invocation on the server, 
+			// either while unmarshalling the arguments or executing the remote method itself.
+			else if( e instanceof ServerException ) {
 				problemDescription = L10n.getString(&quot;Error.Server.InTrouble&quot;);
+				isReconnectReasonable = true;
+			}
+			
+			// A valid stub class could not be found for a remote object when it is exported.
 			else if( e instanceof StubNotFoundException )
 				problemDescription = L10n.getString(&quot;Error.Server.StubNotFound&quot;);
+			
+			// If the client of a remote method call receives, as a result of the call, 
+			// a checked exception that is not among the checked exception types 
+			// declared in the throws clause of the method in the remote interface.
 			else if( e instanceof UnexpectedException )
 				problemDescription = L10n.getString(&quot;Error.Server.UnexpectedProblem&quot;);
+			
+			// If a java.net.UnknownHostException occurs while creating a connection 
+			// to the remote host for a remote method call.
 			else if( e instanceof UnknownHostException )
 				problemDescription = L10n.getString(&quot;Error.Server.UnknownHost&quot;);
+			
+			// Could be thrown while unmarshalling the parameters or results of a remote method call.
 			else if( e instanceof UnmarshalException )
 				problemDescription = L10n.getString(&quot;Error.Server.UnmarshallingFailed&quot;);
 
-			DefaultReconnectDialog.show(parent, problemDescription);
+			
 		}
 		
 		/*
 		 * DBLAYER EXCEPTION HANDLER
 		 */
-		else if( e instanceof DBLayerException &amp;&amp; ((DBLayerException)e).isReconnectNecessary() ) {
+		else if( e instanceof DBLayerException ) {
 			DBLayerException d = (DBLayerException)e;
-			String problemDescription = d.getMessage();
 			if(d.getCause() instanceof JDBCException)
-				problemDescription = d.getMessage() + &quot;\n&quot;  + d.getErrorInfo();
-			DefaultReconnectDialog.show(parent, problemDescription);
+				problemDescription = problemDescription + &quot;\n&quot;  + d.getErrorInfo();
+			isReconnectReasonable = d.isReconnectNecessary();
 		}
 		
-		/*
-		 * OTHER EXCEPTIONS HANDLER
-		 */
+		// Announce the error and offer the reconnection.
+		if( isReconnectReasonable &amp;&amp; ! doNotOfferReconnect )
+			DefaultReconnectDialog.show(parent, problemDescription);
+		// Just announce the problem.
 		else
 			JOptionPane.showMessageDialog( 
 					parent, 
-					e.getMessage(), 
+					problemDescription, 
 					title, 
 					JOptionPane.ERROR_MESSAGE );
+		
+		System.out.println(&quot;~~DefaultExceptionHandler~~&quot;);
+		System.out.println(problemDescription);
+		
 	}
 	
+	
 }

Modified: trunk/src/net/sf/plantlore/common/DefaultProgressBar.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultProgressBar.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DefaultProgressBar.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -5,7 +5,7 @@
 
 /**
  * A simple and convenient
- * implementation of the abstract ProgressBar.
+ * implementation of the abstract ProgressBar with the default exception handler.
  * &lt;br/&gt;
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
@@ -14,22 +14,39 @@
  */
 public class DefaultProgressBar extends ProgressBar {
 	
+	/**
+	 * Create a new Default ProgressBar that will monitor the state 
+	 * of the supplied task.
+	 * 
+	 * @param task	The task this ProgressBar should monitor.
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param modal	True if the ProgressBar should be modal.
+	 */
 	public DefaultProgressBar(Task task, JFrame parent, boolean modal) {
 		super(task, parent, modal);
 	}
 	
+	/**
+	 * Create a new Default ProgressBar that will monitor the state 
+	 * of the supplied task.
+	 * 
+	 * @param task	The task this ProgressBar should monitor.
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param modal	True if the ProgressBar should be modal.
+	 */
 	public DefaultProgressBar(Task task, JDialog parent, boolean modal) {
 		super(task, parent, modal);
 	}
 	
-	
+	/**
+	 * Stop the task and handle the exception with the DefaultExceptionHandler.
+	 * 
+	 * @see DefaultExceptionHandler
+	 */
 	@Override
 	public void exceptionHandler(Exception ex) {
-		
 		getTask().stop();
-		
 		DefaultExceptionHandler.handle(parent, ex);
-		
 	}
 	
 }

Modified: trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DefaultProgressBarEx.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -5,7 +5,7 @@
 
 /**
  * A simple and convenient
- * implementation of the abstract ProgressBar.
+ * implementation of the abstract ProgressBarEx with the default exception handler.
  * &lt;br/&gt;
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
@@ -14,24 +14,39 @@
  */
 public class DefaultProgressBarEx extends ProgressBarEx {
 	
+	/**
+	 * Create a new Default ProgressBar that will monitor the state 
+	 * of the supplied task.
+	 * 
+	 * @param task	The task this ProgressBar should monitor.
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param modal	True if the ProgressBar should be modal.
+	 */
 	public DefaultProgressBarEx(Task task, JFrame parent, boolean modal) {
 		super(task, parent, modal);
 	}
 	
+	/**
+	 * Create a new Default ProgressBar that will monitor the state 
+	 * of the supplied task.
+	 * 
+	 * @param task	The task this ProgressBar should monitor.
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param modal	True if the ProgressBar should be modal.
+	 */
 	public DefaultProgressBarEx(Task task, JDialog parent, boolean modal) {
 		super(task, parent, modal);
 	}
 	
-	
-
-	
+	/**
+	 * Stop the task and handle the exception with the DefaultExceptionHandler.
+	 * 
+	 * @see DefaultExceptionHandler
+	 */
 	@Override
 	public void exceptionHandler(Exception ex) {
-		
 		getTask().stop();
-		
 		DefaultExceptionHandler.handle(parent, ex);
-		
 	}
 	
 }

Modified: trunk/src/net/sf/plantlore/common/DefaultReconnectDialog.java
===================================================================
--- trunk/src/net/sf/plantlore/common/DefaultReconnectDialog.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/DefaultReconnectDialog.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -5,22 +5,39 @@
 import net.sf.plantlore.l10n.L10n;
 import net.sf.plantlore.client.AppCoreCtrl;
 
-
+/**
+ * The dialog that offers the User the possibility to perform automatic reconnection
+ * if the connection with the database is lost.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @version 1.0
+ */
 public class DefaultReconnectDialog {
 	
-	private static String[] options = new String[] { L10n.getString(&quot;Overview.MenuFileReconnect&quot;), L10n.getString(&quot;Common.Ok&quot;) };
+	private static String[] options = new String[] { 
+		L10n.getString(&quot;Overview.MenuFileReconnect&quot;), 
+		L10n.getString(&quot;Common.Ok&quot;) };
+	
 	private static AppCoreCtrl.ReconnectAction defaultReconnectAction;
 
-	
+	/**
+	 * Set the default reconnect action.
+	 * 
+	 * @param reconnect	The action that will be called if the User decides the reconnect is needed. 
+	 */
 	public static void setDefaultReconnectAction(AppCoreCtrl.ReconnectAction reconnect) {
 		defaultReconnectAction = reconnect;
 	}
 	
-	
+	/**
+	 * Display the reconnect dialog. If the reconnection is selected by the User, the supplied
+	 * `reconnect` action will be used instead of the default one.
+	 * 
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param e	The exception that must be announced to the User.
+	 * @param reconnect	The reconnect action that will be used instead of the default one.
+	 */
 	public static void show(Component parent, Exception e, AppCoreCtrl.ReconnectAction reconnect) {
-		
-		//reconnect.setParent(parent);
-		
 		int choice = JOptionPane.showOptionDialog(
 				parent, 
 				e.getMessage(), 
@@ -31,20 +48,31 @@
 				options,
 				options[0]
 		);
-		
 		if(choice == 0) 
 			reconnect.actionPerformed(null);
 	}
 	
-	
+	/**
+	 * Display the reconnect dialog. If the reconnection is selected by the User, the default
+	 * reconnect action will be used.
+	 * 
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param e	The exception that must be announced to the User.
+	 */
 	public static void show(Component parent, Exception e) {
 		show(parent, e.getMessage());
 	}
 	
+	/**
+	 * Display the reconnect dialog. If the reconnection is selected by the User, the default
+	 * reconnect action will be used. Instead of automatic exception handling, this time you
+	 * can specify your own problem description. 
+	 * 
+	 * @param parent	The parent window in order to maintain the Swing window hierarchy.
+	 * @param problemDescription	The string that will be displayed to the User.
+	 */
 	public static void show(Component parent, String problemDescription) {
-		
 		defaultReconnectAction.setParent(parent);
-		
 		int choice = JOptionPane.showOptionDialog(
 				parent, 
 				problemDescription, 
@@ -55,7 +83,6 @@
 				options,
 				options[0]
 		);
-		
 		if(choice == 0 &amp;&amp; defaultReconnectAction != null) 
 			defaultReconnectAction.actionPerformed(null);
 	}

Modified: trunk/src/net/sf/plantlore/common/GlobalExceptionHandler.java
===================================================================
--- trunk/src/net/sf/plantlore/common/GlobalExceptionHandler.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/GlobalExceptionHandler.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -11,22 +11,40 @@
 
 
 /**
+ * In case there are some unchecked exceptions or something goes really really
+ * wrong (and is not covered by other catch blocks) the Global Exception handler
+ * will catch that stranded exception, display a message to the User, and try
+ * to shut down the application in a civilized manner.
+ * &lt;br/&gt;
+ * This is the last resort and the less you see this message the better job we have done.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 24.8.2006
- *
+ * @since 2006-08-24
+ * @version 1.0
  */
 public class GlobalExceptionHandler implements UncaughtExceptionHandler {
 	
+	/**
+	 * Make sure the DefaultException handler is not installed twice.
+	 */
 	private static boolean installed = false;
 	private Logger logger = Logger.getLogger(net.sf.plantlore.client.Plantlore.class.getPackage().getName());
 	
 	private final ActionListener silentFinalAction;
 	
+	/**
+	 * Create a new Global Exception handler.
+	 * 
+	 * @param silentFinalAction The action that will perform silent (i.e. without exceptions) cleanup.
+	 */
 	private GlobalExceptionHandler(ActionListener silentFinalAction) {
 		this.silentFinalAction = silentFinalAction;
 	}
 	
+	/**
+	 * Write a message into the log describing the problem,
+	 * display a message to the User, and call the silentFinalAction().
+	 */
 	public void uncaughtException(Thread t, Throwable e) {
 		logger.fatal(
 				&quot;Thread &quot; + t.getName() + &quot; (&quot; + t.getClass().getName() + &quot;) &quot; +
@@ -34,9 +52,9 @@
 				&quot;The application will be terminated.&quot;
 		);
 		
-                //FIXME (maybe)
-                e.printStackTrace();
-                
+		//FIXME (maybe)
+		e.printStackTrace();
+		
 		JOptionPane.showMessageDialog( 
 				null,
 				L10n.getString(&quot;Error.UnhandledExceptionalState&quot;) +
@@ -49,7 +67,14 @@
 			silentFinalAction.actionPerformed(null);
 	}
 
-	
+	/**
+	 * Install the Global exception handler. Thread safe. At most once semantics.
+	 * 
+	 * @param silentFinalAction	The action that will be called to perform the final cleanup.
+	 * This action should be very sturdy and should throw no exceptions. At the end of the
+	 * action there should be the call &lt;code&gt;System.exit(1);&lt;/code&gt; that will terminate
+	 * the application - there is no point in continuing because no error recovery is possible.
+	 */
 	public static synchronized void install(ActionListener silentFinalAction) {
 		if( !installed ) {
 			Thread.setDefaultUncaughtExceptionHandler( new GlobalExceptionHandler(silentFinalAction) );

Modified: trunk/src/net/sf/plantlore/common/ProgressBarEx.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressBarEx.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/ProgressBarEx.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -15,7 +15,8 @@
 import net.sf.plantlore.l10n.L10n;
 
 
-/** ProgressBar dialog that works as an observer of a given Task.
+/** 
+ * ProgressBar dialog works as an observer of a given Task.
  *
  * The dialog sets itself visible after it receives a STARTING Message, disposes
  * itself after getting a STOPPED Message and in the time between it updates it's
@@ -24,29 +25,43 @@
  * If constructed with an indeterminate Task works in indeterminate mode until it
  * receives a LENGHT_CHANGED message from the Task. Then it switches to determinate mode.
  *
- * Exceptions trhown by the task are processed by the abstract exceptionHandler() method.
+ * Exceptions thrown by the task are processed by the abstract exceptionHandler() method.
+ * 
+ * This extended version introduces the possibility to cancel the performed task.
+ * &lt;b&gt;It is up to the creator of the Task to monitor the Task.isCancelled() and react properly!&lt;/b&gt;
  *
  * @author  Erik Kratochv&#237;l
  */
 public abstract class ProgressBarEx extends ProgressBar {
     
-    /** Creates a new progress bar, initially invisible. It becomes visible after it receives
+    /** 
+     * Create a new progress bar, initially invisible. It becomes visible after it receives
      * a STARTING Message from the Task.
      *
-     * @param task the task to be monitored
-     * @param parent the parent frame of this dialog
-     * @modal whether to open in modal mode
-     *
+     * @param task The task to be monitored.
+     * @param parent The parent frame of this dialog.
+     * @modal Whether to open in modal mode.
      */
     public ProgressBarEx(Task task, java.awt.Frame parent, boolean modal) {
         super(task, parent, modal);
         
     }
     
+    /** 
+     * Create a new progress bar, initially invisible. It becomes visible after it receives
+     * a STARTING Message from the Task.
+     *
+     * @param task The task to be monitored.
+     * @param parent The parent dialog of this dialog.
+     * @modal Whether to open in modal mode.
+     */
     public ProgressBarEx(Task task, javax.swing.JDialog parent, boolean modal) {
         super(task, parent, modal);
     }    
  
+    /**
+     * Slightly different initialization - the Cancel button must be provided with an Action!
+     */
     @Override
     protected void initialize() {
     	logger = Logger.getLogger(this.getClass().getPackage().getName());
@@ -134,6 +149,9 @@
     }// &lt;/editor-fold&gt;//GEN-END:initComponents
     
 
+    /**
+     * Cancel the current task. 
+     */
     private class CancelTaskAction extends AbstractAction {
     	public CancelTaskAction() {
     		putValue(NAME, L10n.getString(&quot;Common.Cancel&quot;));

Modified: trunk/src/net/sf/plantlore/common/ProgressDialog.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressDialog.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/ProgressDialog.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -17,8 +17,11 @@
 
 /**
  *
- * @author Tomas Kovarik
+ * The use of ProgressDialog is not recommended anymore. Use the Task and ProgressBar instead!
+ * It should be removed from repository for good.
+ * 
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class ProgressDialog {
     
     private JDialog progress;

Modified: trunk/src/net/sf/plantlore/common/Selection.java
===================================================================
--- trunk/src/net/sf/plantlore/common/Selection.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/Selection.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -7,9 +7,12 @@
 
 /**
  * A list of selected records. The selection allows
- * selection of new records, removal of selected records (deselection),
+ * the selection of new records, removal of selected records (deselection),
  * selection of all records, deselection of all records,
  * and inversion of the current selection.
+ * &lt;br/&gt;
+ * The Selection is used to store the list of records the User marked to be exported
+ * or printed.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-23
@@ -46,7 +49,7 @@
 		
 	/**
 	 * Remove a selected record from the selection (deselect).
-	 * @param id Of the record that is deselected.
+	 * @param id Identifier of the record that is deselected.
 	 */
 	public Selection remove(Integer id) {
 		if( !inverted ) selected.remove(id);
@@ -80,13 +83,13 @@
 
 	/**
 	 * @param id	The primary key of the record.
-	 * @return true if a record with this primary key is selected.
+	 * @return True if the record with this primary key is selected.
 	 */
 	public boolean contains(Integer id) { return selected.contains(id) ^ inverted; }
 	
 	/**
 	 * @param r	The record.
-	 * @return true if the record is selected.
+	 * @return True if the record is selected.
 	 */
 	public boolean contains(Record r) { return selected.contains(r.getId()) ^ inverted; }
 	
@@ -99,7 +102,7 @@
 	}
 	
 	/**
-	 * @return true if nothing is selected;
+	 * @return True if nothing is selected;
 	 */
 	public boolean isEmpty() {
 		return selected.isEmpty() ^ inverted;
@@ -109,13 +112,21 @@
 	public Selection clone() {
 		return new Selection( this );
 	}
-        
-        public Collection&lt;Integer&gt; values() {
-            return selected;
-        }
-        
-        public void clear() {
-            selected.clear();
-            inverted = false;
-        }
+	
+	/**
+	 * 
+	 * @return	A collection of identifiers of all selected records.
+	 */
+	public Collection&lt;Integer&gt; values() {
+		return selected;
+	}
+	
+	/**
+	 * An alias for Selection.none().
+	 *
+	 * @see #none()
+	 */
+	public Selection clear() {
+		return none();
+	}
 }

Modified: trunk/src/net/sf/plantlore/common/SpringUtilities.java
===================================================================
--- trunk/src/net/sf/plantlore/common/SpringUtilities.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/SpringUtilities.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -20,6 +20,7 @@
  * These utilities are used by several programs, such as
  * SpringBox and SpringCompactGrid.
  */
<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">+ at Deprecated</A>
 public class SpringUtilities {
     private static final Logger logger = Logger.getLogger(SpringUtilities.class.getPackage().getName());
     

Modified: trunk/src/net/sf/plantlore/common/StandardAction.java
===================================================================
--- trunk/src/net/sf/plantlore/common/StandardAction.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/StandardAction.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -6,8 +6,21 @@
 import net.sf.plantlore.client.resources.Resource;
 import net.sf.plantlore.l10n.L10n;
 
+/**
+ * Standard Action introduces the extended constructor that can
+ * automatically assign a caption, a short description,
+ * and an image to the button. 
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public abstract class StandardAction extends AbstractAction {
 	
+	/**
+	 * Create a new StandardAction.
+	 * 
+	 * @param text The base string that will be used to obtain the caption, the tooltip text
+	 * and an image from the L10N.
+	 */
 	public StandardAction(String text) {
 		putValue(NAME, L10n.getString(text));
 		putValue(SHORT_DESCRIPTION, L10n.getString(text+&quot;TT&quot;));

Modified: trunk/src/net/sf/plantlore/common/TabTransfersFocus.java
===================================================================
--- trunk/src/net/sf/plantlore/common/TabTransfersFocus.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/TabTransfersFocus.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -39,7 +39,7 @@
 	}
 	
 	/**
-	 * Neutralize the behaivour.
+	 * Neutralize the effect this class has on the component.
 	 */
 	public void neutralize() {
 		a.removeKeyListener(this);

Modified: trunk/src/net/sf/plantlore/common/UniqueIDGenerator.java
===================================================================
--- trunk/src/net/sf/plantlore/common/UniqueIDGenerator.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/UniqueIDGenerator.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -5,7 +5,7 @@
 import java.security.SecureRandom;
 
 /**
- * A unique number generator.
+ * A unique identifier generator.
  *
  * Based on <A HREF="http://www.javapractices.com/Topic56.cjp">http://www.javapractices.com/Topic56.cjp</A>
  * 
@@ -15,7 +15,12 @@
  */
 public class UniqueIDGenerator {
 	
-	
+	/**
+	 * Encode the digest to some human readable format.
+	 * 
+	 * @param input	The digest from SHA1 or MD5
+	 * @return
+	 */
 	static private String encode( byte[] input){
 	    StringBuffer result = new StringBuffer();
 	    char[] digits = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f' };

Modified: trunk/src/net/sf/plantlore/common/debug/MemoryMonitor.java
===================================================================
--- trunk/src/net/sf/plantlore/common/debug/MemoryMonitor.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/debug/MemoryMonitor.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -1,14 +1,11 @@
-/*
- * MemoryMonitor.java
- *
- * Created on 1. srpen 2006, 11:18
- */
-
 package net.sf.plantlore.common.debug;
 
 /**
+ * A simple memory monitor that displays the memory in use.
+ * It is not intended to be a part of the final release. 
+ * Its use is limited to the debugging purposes.
  *
- * @author  yaa
+ * @author  Erik Kratochv&#237;l
  */
 public class MemoryMonitor extends javax.swing.JFrame {
     

Modified: trunk/src/net/sf/plantlore/common/record/Deletable.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/Deletable.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/record/Deletable.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -2,12 +2,34 @@
 
 import java.io.Serializable;
 
+/**
+ * An interface that serves as an annotation that some records 
+ * must be deleted from the database in a different way - 
+ * they should be marked as deleted (instead of just removed from 
+ * the database for good).
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ */
 public interface Deletable extends Serializable {
 	
+	/**
+	 * The name of the column. It is the same for all `deletable` records.
+	 */
 	static final String DELETED = &quot;deleted&quot;;
 	
+	/**
+	 * 
+	 * @param arg	The &quot;delete level&quot;. 
+	 * 0 = alive (not deleted), 
+	 * 1 = deleted (dead), 
+	 * 2 = deleted (because the associated record was deleted)
+	 */
 	void setDeleted(Integer arg);
 	
+	/**
+	 * 
+	 * @return	The &quot;delete level&quot;.
+	 */
 	Integer getDeleted();
 
 }

Modified: trunk/src/net/sf/plantlore/common/record/Record.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/Record.java	2006-09-01 13:00:13 UTC (rev 613)
+++ trunk/src/net/sf/plantlore/common/record/Record.java	2006-09-01 13:09:26 UTC (rev 614)
@@ -136,11 +136,23 @@
 		return null;
 	}
 	
-	
+	/**
+	 * Return the subrecord of this record of the specified type.
+	 * 
+	 * @param name	The simple name of the class of the subrecord.
+	 * 	@return	The subrecord of the specified type if it exists or null otherwise.
+	 */
 	public Record findSubrecord(String name) {
 		return findSubrecord(this, name);
 	}
 	
+	/**
+	 * Return the subrecord of the base record of the specified type.
+	 * 
+	 * @param base	The base record.
+	 * @param name	The simple name of the class of the subrecord.
+	 * @return	The subrecord of the specified type if it exists or null otherwise.
+	 */
 	public static Record findSubrecord(Record base, String name) {
 		if( base.getClass().getSimpleName().equalsIgnoreCase(name) )
 			return base;
@@ -164,7 +176,7 @@
 	
 	
 	/**
-	 * @return	The record with all subrecords (accessible via foreign keys) created.
+	 * @return	The record with all its subrecords (accessible via foreign keys) properly allocated.
 	 */
 	public Record createTorso() {
 		StringBuilder className;
@@ -182,7 +194,9 @@
 	}
 	
 	/**
-	 * Set a &lt;code&gt;value&lt;/code&gt; of the &lt;code&gt;column&lt;/code&gt; of the &lt;code&gt;subrecord&lt;/code&gt;.
+	 * Set a &lt;code&gt;value&lt;/code&gt; of the &lt;code&gt;column&lt;/code&gt; 
+	 * of a subrecord from the given &lt;code&gt;table&lt;/code&gt;.
+	 * 
 	 * @param table	The type of the subrecord.
 	 * @param column	The name of the column.
 	 * @param value	The value to be set to that column.
@@ -193,7 +207,14 @@
 			subrecord.setValue(column, value);
 	}
 	
-	
+	/**
+	 * Set a &lt;code&gt;value&lt;/code&gt; of the &lt;code&gt;column&lt;/code&gt; 
+	 * of a subrecord from the given &lt;code&gt;table&lt;/code&gt;.
+	 * 
+	 * @param table	The simple name of the table of the subrecord.
+	 * @param column	The name of the column.
+	 * @param value	The value to be set to that column.
+	 */
 	public void setValue(String table, String column, Object value) {
 		Record subrecord = findSubrecord(table);
 		if(subrecord != null) 
@@ -220,7 +241,7 @@
 		try {
 			setValue(column, value);
 		} catch(Exception e) {
-			// Whatever
+			// Consume the exception.
 		}
 	}
 	
@@ -284,7 +305,11 @@
 	 */
 	public List&lt;String&gt; getForeignKeys() { return new ArrayList&lt;String&gt;(0); }
 	
-	
+	/**
+	 * 
+	 * @param key	The name of the foreign key in question.
+	 * @return	True if the key is a name of a column that happens to be a foreign key.
+	 */
 	public boolean isForeignKey(String key) {
 		for(String fk : getForeignKeys())
 			if( key.equalsIgnoreCase(fk) )
@@ -297,7 +322,11 @@
 	 */
 	public List&lt;String&gt; getColumns() { return new ArrayList&lt;String&gt;(0); }
 	
-	
+	/**
+	 * 
+	 * @param property		The name of the property in question.
+	 * @return	True if the property is a name of a column that is not a foreign key.
+	 */
 	public boolean isColumn(String property) {
 		for(String column : getColumns())
 			if( property.equalsIgnoreCase(column) )
@@ -333,7 +362,6 @@
 	public boolean areAllNNSet() {
 		for( String column : getNN() ) { 
 			Object value = getValue(column);
-			//System.out.println(&quot; # &quot;+this.getClass().getSimpleName()+&quot;.&quot;+column+&quot; = [&quot;+value+&quot;].&quot;);
 			if( value == null ) {
 				System.out.println(getClass().getSimpleName()+&quot;.&quot;+column+&quot; = 0&quot;);
 				return false;
@@ -419,7 +447,12 @@
 		return null;
 	}
 	
-	
+	/**
+	 * Array to List convertor.
+	 * 
+	 * @param values	A (classical) array o values.
+	 * @return	A List of the same values.
+	 */
 	protected List&lt;String&gt; asList(String...values) {
 		return new ArrayList&lt;String&gt;(Arrays.asList(values));
 	}
@@ -438,14 +471,17 @@
 
 	/**
 	 * Convert the record into a string. 
-	 * The list of values spans across subrecords as well.
-	 * For debug purposes mostly.
 	 */
 	@Override
 	public String toString() {
 		return this.getClass().getSimpleName();
 	}
 	
+	/**
+	 * Convert the record into a long string. 
+	 * The list of values spans across subrecords as well.
+	 * For debug purposes only.
+	 */
 	public String toFullString() {
 		
 		StringBuilder sigma = new StringBuilder();
@@ -457,8 +493,6 @@
 			if(subrecord != null)	sigma.append( subrecord.toString() );
 		}
 		return sigma.toString();
-		
-		//return this.getClass().getSimpleName();
 	}
 	                
 }


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000860.html">[Plantlore-dev] r613 - trunk/lib
</A></li>
	<LI>Next message: <A HREF="000862.html">[Plantlore-dev] r615 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#861">[ date ]</a>
              <a href="thread.html#861">[ thread ]</a>
              <a href="subject.html#861">[ subject ]</a>
              <a href="author.html#861">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
