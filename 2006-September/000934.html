<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r674 - in trunk: installer/launch4j	src/net/sf/plantlore/client	src/net/sf/plantlore/client/overview/search	src/net/sf/plantlore/config
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-September/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r674%20-%20in%20trunk%3A%20installer/launch4j%0A%09src/net/sf/plantlore/client%0A%09src/net/sf/plantlore/client/overview/search%0A%09src/net/sf/plantlore/config&In-Reply-To=%3C200609042331.k84NVrPi019783%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000933.html">
   <LINK REL="Next"  HREF="000935.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r674 - in trunk: installer/launch4j	src/net/sf/plantlore/client	src/net/sf/plantlore/client/overview/search	src/net/sf/plantlore/config</H1>
    <B>fraktalek at mail.berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r674%20-%20in%20trunk%3A%20installer/launch4j%0A%09src/net/sf/plantlore/client%0A%09src/net/sf/plantlore/client/overview/search%0A%09src/net/sf/plantlore/config&In-Reply-To=%3C200609042331.k84NVrPi019783%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r674 - in trunk: installer/launch4j	src/net/sf/plantlore/client	src/net/sf/plantlore/client/overview/search	src/net/sf/plantlore/config">fraktalek at mail.berlios.de
       </A><BR>
    <I>Tue Sep  5 01:31:53 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000933.html">[Plantlore-dev] r673 - trunk/src/net/sf/plantlore/server
</A></li>
        <LI>Next message: <A HREF="000935.html">[Plantlore-dev] r675 -	trunk/src/biocase/DataproBioCASE/www/querytool
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#934">[ date ]</a>
              <a href="thread.html#934">[ thread ]</a>
              <a href="subject.html#934">[ subject ]</a>
              <a href="author.html#934">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: fraktalek
Date: 2006-09-05 01:30:38 +0200 (Tue, 05 Sep 2006)
New Revision: 674

Added:
   trunk/installer/launch4j/launch4j.jar
Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/overview/search/Search.java
   trunk/src/net/sf/plantlore/client/overview/search/SearchCtrl.java
   trunk/src/net/sf/plantlore/config/log4j.properties
Log:
Our build script now needs the launch4j.jar to be able to execute, adding it.
Log4j properties back to debug level.
Better exception propagation from search.



Added: trunk/installer/launch4j/launch4j.jar
===================================================================
(Binary files differ)


Property changes on: trunk/installer/launch4j/launch4j.jar
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-09-04 22:56:34 UTC (rev 673)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-09-04 23:30:38 UTC (rev 674)
@@ -495,7 +495,15 @@
 
 					searchModel.setColumns(columns);
 					searchModel.clearAndNotify();
-					searchModel.constructQuery();
+                                        try {
+                                            searchModel.constructQuery();
+                                        } catch (RemoteException ex) {
+                                            DefaultExceptionHandler.handle(view, ex);
+                                            return;
+                                        } catch (DBLayerException ex) {
+                                            DefaultExceptionHandler.handle(view, ex);
+                                            return;
+                                        }
 				}
 				if (s.equals(&quot;DYNAMIC_PAGE_LOADING&quot;)) {
 					model.dynamicPageLoading = prefs.getBoolean(
@@ -977,7 +985,16 @@
                             case HABITAT:
                                 searchModel.clearAndNotify();
                                 searchModel.setHabitatId(nodeInfo.getId());
-                                searchModel.constructQuery();
+
+                                try {
+                                    searchModel.constructQuery();
+                                } catch (RemoteException ex) {
+                                    DefaultExceptionHandler.handle(view, ex);
+                                    return;
+                                } catch (DBLayerException ex) {
+                                    DefaultExceptionHandler.handle(view, ex);
+                                    return;
+                                }
                         }//switch
                     }//if search
                     
@@ -1720,14 +1737,23 @@
 
                                 view.getSBM().display(L10n.getString(&quot;Message.LoadingOverviewData&quot;));
                                 searchModel.clearAndNotify();
-                                searchModel.constructQuery();
+                                
+                                try {
+                                    searchModel.constructQuery();
+                                } catch (RemoteException ex) {
+                                    DefaultExceptionHandler.handle(view, ex);
+                                    return;
+                                } catch (DBLayerException ex) {
+                                    DefaultExceptionHandler.handle(view, ex);
+                                    return;
+                                }
 
                                 view.getSBM().displayDefaultText();
 
                                 view.initOverview();
                                 view.setCursor(Cursor.getDefaultCursor());
                                 setDatabaseDependentCommandsEnabled(true);
-
+                                logger.debug(&quot;======= rows: &quot;+model.getResultsCount());
                                 //this can't be done earlier. must be done after the query is created
                                 //otherwise this listener would give the overview table model commands to load data
                                 //for a query that doesn't exist yet
@@ -1771,7 +1797,7 @@
 			Task task = new Task() {
 				public Object task() throws DBLayerException, RemoteException {
                                     //refreshAction.setEnabled(false);
-                                    setStatusMessage(&quot;Loading overview data...&quot;);
+                                    setStatusMessage(L10n.getString(&quot;Overview.Message.LoadingOccurrences&quot;));
 					searchModel.clear();
 					searchModel.constructQuery();
 					fireStopped(null);
@@ -1781,14 +1807,21 @@
 			return task;
 		} else {
 			searchModel.clear();
-			searchModel.constructQuery();
+                        try {
+                            searchModel.constructQuery();
+                        } catch (DBLayerException ex) {
+                            DefaultExceptionHandler.handle(view, ex);
+                            return null;
+                        } catch (RemoteException ex) {
+                            DefaultExceptionHandler.handle(view, ex);
+                            return null;
+                        }
 			return null;
 		}
 	}
 
         /** Handles the refresh action invoked from overview. */
 	class RefreshAction extends AbstractAction {
-            String prom = &quot;Promenna z refresh action.&quot;;
             Task task = refreshOverview(true);
             
 		public RefreshAction() {
@@ -1815,7 +1848,7 @@
                             }
                         };*/
 
-			System.out.println(&quot;Dispatcher: &quot;+Dispatcher.getDispatcher().dispatch(task, view, true));
+			Dispatcher.getDispatcher().dispatch(task, view, true);
 		}
 
 	}

Modified: trunk/src/net/sf/plantlore/client/overview/search/Search.java
===================================================================
--- trunk/src/net/sf/plantlore/client/overview/search/Search.java	2006-09-04 22:56:34 UTC (rev 673)
+++ trunk/src/net/sf/plantlore/client/overview/search/Search.java	2006-09-04 23:30:38 UTC (rev 674)
@@ -628,7 +628,7 @@
     
     
     
-    public SelectQuery constructQuery() {
+    public SelectQuery constructQuery() throws DBLayerException, RemoteException {
         DBLayerUtils dlu = new DBLayerUtils(database);
         SelectQuery sq = null;
         // ExportQuery restriction storage requires these variables.
@@ -636,292 +636,285 @@
         Object arg;
         String habitatAlias = Record.alias(Habitat.class) +&quot;.&quot;;
         
-            //FIXME:
-            try {
-                // Create subquery first
-                SelectQuery subQuery = database.createSubQuery(AuthorOccurrence.class, &quot;ao&quot;);
-                // In the subquery select authors for the given occurrence (occurrence comes from the main query)
-                subQuery.addRestriction(PlantloreConstants.RESTR_EQ_PROPERTY, &quot;ao.&quot;+AuthorOccurrence.OCCURRENCE, &quot;occ.&quot;+Occurrence.ID, null, null);
-                subQuery.addRestriction(PlantloreConstants.RESTR_EQ, &quot;ao.&quot;+AuthorOccurrence.DELETED, null, 0, null);
-                subQuery.addProjection(PlantloreConstants.PROJ_PROPERTY, AuthorOccurrence.AUTHOR);
-                // create the main query
-                sq = database.createQuery(AuthorOccurrence.class);
-                sq.createAlias(AuthorOccurrence.AUTHOR,&quot;author&quot;);
-                sq.createAlias(AuthorOccurrence.OCCURRENCE,&quot;occ&quot;);                
-                sq.createAlias(&quot;occ.&quot;+Occurrence.HABITAT,&quot;habitat&quot;);
-                sq.createAlias(&quot;occ.&quot;+Occurrence.PLANT,&quot;plant&quot;);
-                // Add publications using LEFT OUTER JOIN - so that occurrences without a publication are displayed as well
-                sq.createAlias(&quot;occ.&quot;+Occurrence.PUBLICATION,&quot;publication&quot;, PlantloreConstants.LEFT_OUTER_JOIN);
-                sq.createAlias(&quot;occ.&quot;+Occurrence.METADATA,&quot;metadata&quot;);
-                sq.createAlias(&quot;habitat.&quot;+Habitat.PHYTOCHORION,&quot;phyt&quot;);
-                sq.createAlias(&quot;habitat.&quot;+Habitat.NEARESTVILLAGE,&quot;vill&quot;);
-                sq.createAlias(&quot;habitat.&quot;+Habitat.TERRITORY,&quot;territory&quot;);
-                // Add subquery to the query. Compare authoroccurrence.authorid with the result of a subquery (LEALL: &lt;= all(...))
-                sq.addRestriction(PlantloreConstants.SUBQUERY_LEALL, AuthorOccurrence.AUTHOR, null, subQuery, null);    
-                sq.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 0, null);
-                sq.addOrder(PlantloreConstants.DIRECT_DESC, &quot;occ.&quot;+Occurrence.YEARCOLLECTED); //setridit podle roku
-                sq.addRestriction(PlantloreConstants.RESTR_EQ, &quot;occ.&quot;+Occurrence.DELETED, null, 0, null);
-                for (Column column : columns) {
-                    switch (column.type) {
-                        case AUTHOR:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;author.&quot;+Author.WHOLENAME);
-                            break;
-                        case HABITAT_ALTITUDE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.ALTITUDE);
-                            break;
-                        case HABITAT_COUNTRY:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.COUNTRY);
-                            break;
-                        case HABITAT_DESCRIPTION:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.DESCRIPTION);                    
-                            break;
-                        case HABITAT_LATITUDE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.LATITUDE);
-                            break;
-                        case HABITAT_LONGITUDE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.LONGITUDE);
-                            break;
-                        case HABITAT_NEAREST_VILLAGE_NAME:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;vill.&quot;+NearestVillage.NAME);
-                            break;
-                        case HABITAT_NOTE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.NOTE);
-                            break;
-                        case HABITAT_QUADRANT:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.QUADRANT);
-                            break;
-                        case METADATA_DATASETTITLE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;metadata.&quot;+Metadata.DATASETTITLE);
-                            break;
-                        case NUMBER:
-                            break;
-                        case OCCURRENCE_DATASOURCE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.DATASOURCE);
-                            break;
-                        case OCCURRENCE_DAYCOLLECTED:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.DAYCOLLECTED);
-                            break;
-                        case OCCURRENCE_HERBARIUM:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.HERBARIUM);
-                            break;
-                        case OCCURRENCE_ID:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.ID);                            
-                            break;
-                        case OCCURRENCE_MONTHCOLLECTED:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.MONTHCOLLECTED);
-                            break;
-                        case OCCURRENCE_NOTE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.NOTE);
-                            break;
-                        case OCCURRENCE_TIMECOLLECTED:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.TIMECOLLECTED);
-                            break;
-                        case OCCURRENCE_YEARCOLLECTED:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.YEARCOLLECTED);
-                            break;
-                        case PHYTOCHORION_CODE:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;phyt.&quot;+Phytochorion.CODE);                    
-                            break;
-                        case PHYTOCHORION_NAME:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;phyt.&quot;+Phytochorion.NAME);                    
-                            break;
-                        case PLANT_TAXON:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;plant.&quot;+Plant.TAXON);
-                            break;
-                        case PUBLICATION_COLLECTIONNAME:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;publication.&quot;+Publication.REFERENCECITATION);
-                            break;
-                        case SELECTION:
-                            break;
-                        case TERRITORY_NAME:
-                            sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;territory.&quot;+Territory.NAME);
-                            break;
-                        default:                                                
-                    }
+            // Create subquery first
+            SelectQuery subQuery = database.createSubQuery(AuthorOccurrence.class, &quot;ao&quot;);
+            // In the subquery select authors for the given occurrence (occurrence comes from the main query)
+            subQuery.addRestriction(PlantloreConstants.RESTR_EQ_PROPERTY, &quot;ao.&quot;+AuthorOccurrence.OCCURRENCE, &quot;occ.&quot;+Occurrence.ID, null, null);
+            subQuery.addRestriction(PlantloreConstants.RESTR_EQ, &quot;ao.&quot;+AuthorOccurrence.DELETED, null, 0, null);
+            subQuery.addProjection(PlantloreConstants.PROJ_PROPERTY, AuthorOccurrence.AUTHOR);
+            // create the main query
+            sq = database.createQuery(AuthorOccurrence.class);
+            sq.createAlias(AuthorOccurrence.AUTHOR,&quot;author&quot;);
+            sq.createAlias(AuthorOccurrence.OCCURRENCE,&quot;occ&quot;);                
+            sq.createAlias(&quot;occ.&quot;+Occurrence.HABITAT,&quot;habitat&quot;);
+            sq.createAlias(&quot;occ.&quot;+Occurrence.PLANT,&quot;plant&quot;);
+            // Add publications using LEFT OUTER JOIN - so that occurrences without a publication are displayed as well
+            sq.createAlias(&quot;occ.&quot;+Occurrence.PUBLICATION,&quot;publication&quot;, PlantloreConstants.LEFT_OUTER_JOIN);
+            sq.createAlias(&quot;occ.&quot;+Occurrence.METADATA,&quot;metadata&quot;);
+            sq.createAlias(&quot;habitat.&quot;+Habitat.PHYTOCHORION,&quot;phyt&quot;);
+            sq.createAlias(&quot;habitat.&quot;+Habitat.NEARESTVILLAGE,&quot;vill&quot;);
+            sq.createAlias(&quot;habitat.&quot;+Habitat.TERRITORY,&quot;territory&quot;);
+            // Add subquery to the query. Compare authoroccurrence.authorid with the result of a subquery (LEALL: &lt;= all(...))
+            sq.addRestriction(PlantloreConstants.SUBQUERY_LEALL, AuthorOccurrence.AUTHOR, null, subQuery, null);    
+            sq.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.DELETED, null, 0, null);
+            sq.addOrder(PlantloreConstants.DIRECT_DESC, &quot;occ.&quot;+Occurrence.YEARCOLLECTED); //setridit podle roku
+            sq.addRestriction(PlantloreConstants.RESTR_EQ, &quot;occ.&quot;+Occurrence.DELETED, null, 0, null);
+            for (Column column : columns) {
+                switch (column.type) {
+                    case AUTHOR:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;author.&quot;+Author.WHOLENAME);
+                        break;
+                    case HABITAT_ALTITUDE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.ALTITUDE);
+                        break;
+                    case HABITAT_COUNTRY:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.COUNTRY);
+                        break;
+                    case HABITAT_DESCRIPTION:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.DESCRIPTION);                    
+                        break;
+                    case HABITAT_LATITUDE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.LATITUDE);
+                        break;
+                    case HABITAT_LONGITUDE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.LONGITUDE);
+                        break;
+                    case HABITAT_NEAREST_VILLAGE_NAME:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;vill.&quot;+NearestVillage.NAME);
+                        break;
+                    case HABITAT_NOTE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.NOTE);
+                        break;
+                    case HABITAT_QUADRANT:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;habitat.&quot;+Habitat.QUADRANT);
+                        break;
+                    case METADATA_DATASETTITLE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;metadata.&quot;+Metadata.DATASETTITLE);
+                        break;
+                    case NUMBER:
+                        break;
+                    case OCCURRENCE_DATASOURCE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.DATASOURCE);
+                        break;
+                    case OCCURRENCE_DAYCOLLECTED:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.DAYCOLLECTED);
+                        break;
+                    case OCCURRENCE_HERBARIUM:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.HERBARIUM);
+                        break;
+                    case OCCURRENCE_ID:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.ID);                            
+                        break;
+                    case OCCURRENCE_MONTHCOLLECTED:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.MONTHCOLLECTED);
+                        break;
+                    case OCCURRENCE_NOTE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.NOTE);
+                        break;
+                    case OCCURRENCE_TIMECOLLECTED:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.TIMECOLLECTED);
+                        break;
+                    case OCCURRENCE_YEARCOLLECTED:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;occ.&quot;+Occurrence.YEARCOLLECTED);
+                        break;
+                    case PHYTOCHORION_CODE:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;phyt.&quot;+Phytochorion.CODE);                    
+                        break;
+                    case PHYTOCHORION_NAME:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;phyt.&quot;+Phytochorion.NAME);                    
+                        break;
+                    case PLANT_TAXON:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;plant.&quot;+Plant.TAXON);
+                        break;
+                    case PUBLICATION_COLLECTIONNAME:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;publication.&quot;+Publication.REFERENCECITATION);
+                        break;
+                    case SELECTION:
+                        break;
+                    case TERRITORY_NAME:
+                        sq.addProjection(PlantloreConstants.PROJ_PROPERTY,&quot;territory.&quot;+Territory.NAME);
+                        break;
+                    default:                                                
                 }
-                
-                if (isNotEmpty(village)) {
-                	arg = dlu.getObjectFor(village.getSecond(),NearestVillage.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.NEARESTVILLAGE,null,arg,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.NEARESTVILLAGE, arg));
-                }
-                
-                int notEmpty = 0;
+            }
+
+            if (isNotEmpty(village)) {
+                    arg = dlu.getObjectFor(village.getSecond(),NearestVillage.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.NEARESTVILLAGE,null,arg,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.NEARESTVILLAGE, arg));
+            }
+
+            int notEmpty = 0;
+            for (int i = 0; i &lt; authorList.size(); i++) {
+                Pair&lt;Pair&lt;String,Integer&gt;,String&gt; authorPair = authorList.get(i);
+                if (isNotEmpty(authorPair.getFirst()))
+                    notEmpty++;
+                if (isNotEmpty(authorPair.getSecond()))
+                    notEmpty++;
+            }
+
+            if (notEmpty &gt; 0) {
+                Object[] args = new Object[notEmpty*4];
+                int conditionNumber = 0;
                 for (int i = 0; i &lt; authorList.size(); i++) {
                     Pair&lt;Pair&lt;String,Integer&gt;,String&gt; authorPair = authorList.get(i);
-                    if (isNotEmpty(authorPair.getFirst()))
-                        notEmpty++;
-                    if (isNotEmpty(authorPair.getSecond()))
-                        notEmpty++;
-                }
-                
-                if (notEmpty &gt; 0) {
-                    Object[] args = new Object[notEmpty*4];
-                    int conditionNumber = 0;
-                    for (int i = 0; i &lt; authorList.size(); i++) {
-                        Pair&lt;Pair&lt;String,Integer&gt;,String&gt; authorPair = authorList.get(i);
-                        if (isNotEmpty(authorPair.getFirst())) {
-                            args[4*conditionNumber] = PlantloreConstants.RESTR_EQ;
-                            args[4*conditionNumber+1] = AuthorOccurrence.AUTHOR;
-                            args[4*conditionNumber+2] = null;
-                            args[4*conditionNumber+3] = dlu.getObjectFor(authorPair.getFirst().getSecond(),Author.class);
-                            conditionNumber++;
-                        }
-                        if (isNotEmpty(authorPair.getSecond())) {
-                            args[4*conditionNumber] = PlantloreConstants.RESTR_EQ;
-                            args[4*conditionNumber+1] = AuthorOccurrence.ROLE;
-                            args[4*conditionNumber+2] = null;
-                            args[4*conditionNumber+3] = authorPair.getSecond();
-                            conditionNumber++;
-                        }
+                    if (isNotEmpty(authorPair.getFirst())) {
+                        args[4*conditionNumber] = PlantloreConstants.RESTR_EQ;
+                        args[4*conditionNumber+1] = AuthorOccurrence.AUTHOR;
+                        args[4*conditionNumber+2] = null;
+                        args[4*conditionNumber+3] = dlu.getObjectFor(authorPair.getFirst().getSecond(),Author.class);
+                        conditionNumber++;
                     }
-                    sq.addOrRestriction(args);
-                    //ExportQuery is over the Occurrence table!   exportQuery.addOrRestriction(args); 
-                }
-
-                notEmpty = 0;
-                if (taxonList != null)
-                    for (int i = 0; i &lt; taxonList.size(); i++) {
-                        if (isNotEmpty(taxonList.get(i)))
-                            notEmpty++;
+                    if (isNotEmpty(authorPair.getSecond())) {
+                        args[4*conditionNumber] = PlantloreConstants.RESTR_EQ;
+                        args[4*conditionNumber+1] = AuthorOccurrence.ROLE;
+                        args[4*conditionNumber+2] = null;
+                        args[4*conditionNumber+3] = authorPair.getSecond();
+                        conditionNumber++;
                     }
-                
-                if (notEmpty &gt; 0) {
-                    Object[] args = new Object[notEmpty*4], exportQueryArgs = new Object[notEmpty*4];
-                    for (int i = 0; i &lt; taxonList.size(); i++) {
-                        String taxon = taxonList.get(i);
-                        if (isNotEmpty(taxon)) {
-                            args[4*i] = exportQueryArgs[4*i] = PlantloreConstants.RESTR_EQ;
-                            args[4*i+1] = &quot;occ.&quot;+Occurrence.PLANT; exportQueryArgs[4*i+1] = Occurrence.PLANT; 
-                            args[4*i+2] = exportQueryArgs[4*i+2] = null;
-                            args[4*i+3] = exportQueryArgs[4*i+3] = dlu.getObjectFor(lookupPlant(taxon),Plant.class);
-                        }
-                    }
-                    sq.addOrRestriction(args);
-                    restrictions.add(new Restriction(-1, null, exportQueryArgs));
                 }
-                if (isNotEmpty(localityDescription)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;habitat.&quot;+Habitat.DESCRIPTION,null,&quot;%&quot;+localityDescription+&quot;%&quot;,null);
-                    restrictions.add(new Restriction(RESTR_ILIKE, habitatAlias+Habitat.DESCRIPTION, &quot;%&quot;+localityDescription+&quot;%&quot;));
-                }
-                
-                if (isNotEmpty(occurrenceNote)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;occ.&quot;+Occurrence.NOTE,null,&quot;%&quot;+occurrenceNote+&quot;%&quot;,null);
-                    restrictions.add(new Restriction(RESTR_ILIKE, Occurrence.NOTE, &quot;%&quot;+occurrenceNote+&quot;%&quot;));
-                }
-                
-                if (isNotEmpty(habitatId)) {
-                    arg = dlu.getObjectFor(habitatId,Habitat.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.HABITAT,null,arg,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.HABITAT, arg));                    
-                }
-                
-                if (isNotEmpty(habitatNote)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;habitat.&quot;+Habitat.NOTE,null,&quot;%&quot;+habitatNote+&quot;%&quot;,null);
-                    restrictions.add(new Restriction(RESTR_ILIKE, habitatAlias+Habitat.NOTE, &quot;%&quot;+habitatNote+&quot;%&quot;));
-                }
-                
-                if (isNotEmpty(territoryName)) {
-                	arg = dlu.getObjectFor(territoryName.getSecond(),Territory.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.TERRITORY,null, arg, null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.TERRITORY, arg));
-                }
-                
-                if (isNotEmpty(phytName)) {
-                	arg = dlu.getObjectFor(phytName.getSecond(),Phytochorion.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.PHYTOCHORION,null,arg,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.PHYTOCHORION, arg));
-                }
-                
-                if (isNotEmpty(phytCountry)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.COUNTRY,null,phytCountry,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.COUNTRY, phytCountry));
-                }
-                
-                if (isNotEmpty(quadrant)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.QUADRANT,null,quadrant,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.QUADRANT, quadrant));
-                }
-                
-                if (isNotEmpty(altitude)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.ALTITUDE,null,altitude,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.ALTITUDE, altitude));
-                }
-                
-                if (isNotEmpty(longitude)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.LONGITUDE,null,longitude,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.LONGITUDE, longitude));
-                }
+                sq.addOrRestriction(args);
+                //ExportQuery is over the Occurrence table!   exportQuery.addOrRestriction(args); 
+            }
 
-                if (isNotEmpty(latitude)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.LATITUDE,null,latitude,null);
-                    restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.LATITUDE, latitude));
+            notEmpty = 0;
+            if (taxonList != null)
+                for (int i = 0; i &lt; taxonList.size(); i++) {
+                    if (isNotEmpty(taxonList.get(i)))
+                        notEmpty++;
                 }
 
-                if (isNotEmpty(source)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.DATASOURCE,null,source,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.DATASOURCE, source));
+            if (notEmpty &gt; 0) {
+                Object[] args = new Object[notEmpty*4], exportQueryArgs = new Object[notEmpty*4];
+                for (int i = 0; i &lt; taxonList.size(); i++) {
+                    String taxon = taxonList.get(i);
+                    if (isNotEmpty(taxon)) {
+                        args[4*i] = exportQueryArgs[4*i] = PlantloreConstants.RESTR_EQ;
+                        args[4*i+1] = &quot;occ.&quot;+Occurrence.PLANT; exportQueryArgs[4*i+1] = Occurrence.PLANT; 
+                        args[4*i+2] = exportQueryArgs[4*i+2] = null;
+                        args[4*i+3] = exportQueryArgs[4*i+3] = dlu.getObjectFor(lookupPlant(taxon),Plant.class);
+                    }
                 }
-                
-                if (isNotEmpty(publication)) {
-                    //FIXME: mozna pridat addOrRestriction na vsechny relevantni sloupky Publication
-                	arg = dlu.getObjectFor(publication.getSecond(),Publication.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.PUBLICATION,null,arg,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.PUBLICATION, arg));
-                }
-                
-                if (isNotEmpty(herbarium)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.HERBARIUM,null,herbarium,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.HERBARIUM, herbarium));
-                }
-                
-                if (isNotEmpty(project)) {
-                	arg = dlu.getObjectFor(project.getSecond(),Metadata.class);
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.METADATA,null,arg,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.METADATA, arg));
-                }
-                
-                if (timeChoice == INTERVAL &amp;&amp; isNotEmpty(fromDate)) {
-                    Calendar from = Calendar.getInstance(), to = Calendar.getInstance();
-                    from.setTime(fromDate); to.setTime(toDate);
-                    
-                    //set the begining of the day
-                    from.set(Calendar.HOUR_OF_DAY,0);
-                    from.set(Calendar.MINUTE, 0);
-                    from.set(Calendar.SECOND, 0);
-                    from.set(Calendar.MILLISECOND, 0);
+                sq.addOrRestriction(args);
+                restrictions.add(new Restriction(-1, null, exportQueryArgs));
+            }
+            if (isNotEmpty(localityDescription)) {
+                sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;habitat.&quot;+Habitat.DESCRIPTION,null,&quot;%&quot;+localityDescription+&quot;%&quot;,null);
+                restrictions.add(new Restriction(RESTR_ILIKE, habitatAlias+Habitat.DESCRIPTION, &quot;%&quot;+localityDescription+&quot;%&quot;));
+            }
 
-                    //set the end of the day
-                    to.set(Calendar.HOUR_OF_DAY,23);
-                    to.set(Calendar.MINUTE, 59);
-                    to.set(Calendar.SECOND, 59);
-                    to.set(Calendar.MILLISECOND, 999);
-                    
-                    ArrayList a = new ArrayList();
-                    a.add(from.getTime());
-                    a.add(to.getTime());
-                    System.out.println(&quot;Searching between &quot;+from.getTime()+&quot; and &quot;+to.getTime());
-                    sq.addRestriction(PlantloreConstants.RESTR_BETWEEN,&quot;occ.&quot;+Occurrence.ISODATETIMEBEGIN,null,null,a);
-                    
-                    restrictions.add(new Restriction(RESTR_BETWEEN, Occurrence.ISODATETIMEBEGIN, a));
-                }
-                
-                if (timeChoice == MONTH &amp;&amp; isNotEmpty(month)) {
-                    sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.MONTHCOLLECTED,null,month,null);
-                    restrictions.add(new Restriction(RESTR_EQ, Occurrence.MONTHCOLLECTED, month));
-                }
-                int resultId = database.executeQuery(sq);
-                this.newResultId = resultId;
-                this.newSelectQuery = sq;
-                logger.debug(&quot;Created new query. Number of results: &quot;+database.getNumRows(resultId));
-                //let the SearchBridge in AppCoreCtrl know that new result is there
-                setChanged(); 
-                notifyObservers(resultId);
-            } catch (RemoteException ex) {                
-                ex.printStackTrace();
-            } catch (DBLayerException ex) {
-                ex.printStackTrace();
+            if (isNotEmpty(occurrenceNote)) {
+                sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;occ.&quot;+Occurrence.NOTE,null,&quot;%&quot;+occurrenceNote+&quot;%&quot;,null);
+                restrictions.add(new Restriction(RESTR_ILIKE, Occurrence.NOTE, &quot;%&quot;+occurrenceNote+&quot;%&quot;));
             }
+
+            if (isNotEmpty(habitatId)) {
+                arg = dlu.getObjectFor(habitatId,Habitat.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.HABITAT,null,arg,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.HABITAT, arg));                    
+            }
+
+            if (isNotEmpty(habitatNote)) {
+                sq.addRestriction(PlantloreConstants.RESTR_ILIKE,&quot;habitat.&quot;+Habitat.NOTE,null,&quot;%&quot;+habitatNote+&quot;%&quot;,null);
+                restrictions.add(new Restriction(RESTR_ILIKE, habitatAlias+Habitat.NOTE, &quot;%&quot;+habitatNote+&quot;%&quot;));
+            }
+
+            if (isNotEmpty(territoryName)) {
+                    arg = dlu.getObjectFor(territoryName.getSecond(),Territory.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.TERRITORY,null, arg, null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.TERRITORY, arg));
+            }
+
+            if (isNotEmpty(phytName)) {
+                    arg = dlu.getObjectFor(phytName.getSecond(),Phytochorion.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.PHYTOCHORION,null,arg,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.PHYTOCHORION, arg));
+            }
+
+            if (isNotEmpty(phytCountry)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.COUNTRY,null,phytCountry,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.COUNTRY, phytCountry));
+            }
+
+            if (isNotEmpty(quadrant)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.QUADRANT,null,quadrant,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.QUADRANT, quadrant));
+            }
+
+            if (isNotEmpty(altitude)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.ALTITUDE,null,altitude,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.ALTITUDE, altitude));
+            }
+
+            if (isNotEmpty(longitude)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.LONGITUDE,null,longitude,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.LONGITUDE, longitude));
+            }
+
+            if (isNotEmpty(latitude)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;habitat.&quot;+Habitat.LATITUDE,null,latitude,null);
+                restrictions.add(new Restriction(RESTR_EQ, habitatAlias+Habitat.LATITUDE, latitude));
+            }
+
+            if (isNotEmpty(source)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.DATASOURCE,null,source,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.DATASOURCE, source));
+            }
+
+            if (isNotEmpty(publication)) {
+                //FIXME: mozna pridat addOrRestriction na vsechny relevantni sloupky Publication
+                    arg = dlu.getObjectFor(publication.getSecond(),Publication.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.PUBLICATION,null,arg,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.PUBLICATION, arg));
+            }
+
+            if (isNotEmpty(herbarium)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.HERBARIUM,null,herbarium,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.HERBARIUM, herbarium));
+            }
+
+            if (isNotEmpty(project)) {
+                    arg = dlu.getObjectFor(project.getSecond(),Metadata.class);
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.METADATA,null,arg,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.METADATA, arg));
+            }
+
+            if (timeChoice == INTERVAL &amp;&amp; isNotEmpty(fromDate)) {
+                Calendar from = Calendar.getInstance(), to = Calendar.getInstance();
+                from.setTime(fromDate); to.setTime(toDate);
+
+                //set the begining of the day
+                from.set(Calendar.HOUR_OF_DAY,0);
+                from.set(Calendar.MINUTE, 0);
+                from.set(Calendar.SECOND, 0);
+                from.set(Calendar.MILLISECOND, 0);
+
+                //set the end of the day
+                to.set(Calendar.HOUR_OF_DAY,23);
+                to.set(Calendar.MINUTE, 59);
+                to.set(Calendar.SECOND, 59);
+                to.set(Calendar.MILLISECOND, 999);
+
+                ArrayList a = new ArrayList();
+                a.add(from.getTime());
+                a.add(to.getTime());
+                System.out.println(&quot;Searching between &quot;+from.getTime()+&quot; and &quot;+to.getTime());
+                sq.addRestriction(PlantloreConstants.RESTR_BETWEEN,&quot;occ.&quot;+Occurrence.ISODATETIMEBEGIN,null,null,a);
+
+                restrictions.add(new Restriction(RESTR_BETWEEN, Occurrence.ISODATETIMEBEGIN, a));
+            }
+
+            if (timeChoice == MONTH &amp;&amp; isNotEmpty(month)) {
+                sq.addRestriction(PlantloreConstants.RESTR_EQ,&quot;occ.&quot;+Occurrence.MONTHCOLLECTED,null,month,null);
+                restrictions.add(new Restriction(RESTR_EQ, Occurrence.MONTHCOLLECTED, month));
+            }
+            int resultId = database.executeQuery(sq);
+            this.newResultId = resultId;
+            this.newSelectQuery = sq;
+            logger.debug(&quot;Created new query. Number of results: &quot;+database.getNumRows(resultId));
+            //let the SearchBridge in AppCoreCtrl know that new result is there
+            setChanged(); 
+            notifyObservers(resultId);
         return sq;
     }
     

Modified: trunk/src/net/sf/plantlore/client/overview/search/SearchCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/overview/search/SearchCtrl.java	2006-09-04 22:56:34 UTC (rev 673)
+++ trunk/src/net/sf/plantlore/client/overview/search/SearchCtrl.java	2006-09-04 23:30:38 UTC (rev 674)
@@ -40,9 +40,11 @@
 import net.sf.plantlore.client.*;
 import net.sf.plantlore.client.overview.*;
 import net.sf.plantlore.common.AutoTextArea;
+import net.sf.plantlore.common.DefaultExceptionHandler;
 import net.sf.plantlore.common.Pair;
 import net.sf.plantlore.common.PlantloreConstants;
 import net.sf.plantlore.common.PlantloreHelp;
+import net.sf.plantlore.common.exception.DBLayerException;
 import net.sf.plantlore.common.record.AuthorOccurrence;
 import net.sf.plantlore.common.record.Habitat;
 import net.sf.plantlore.common.record.Occurrence;
@@ -472,8 +474,16 @@
                 JOptionPane.showMessageDialog(view,check.getSecond());
                 return;
             }
-            
-            model.constructQuery();
+            try {
+                
+                model.constructQuery();
+            } catch (DBLayerException ex) {
+                DefaultExceptionHandler.handle(view, ex);
+                return;
+            } catch (RemoteException ex) {
+                DefaultExceptionHandler.handle(view, ex);
+                return;
+            }
             view.setVisible(false);
         }
     }//OkButtonListener

Modified: trunk/src/net/sf/plantlore/config/log4j.properties
===================================================================
--- trunk/src/net/sf/plantlore/config/log4j.properties	2006-09-04 22:56:34 UTC (rev 673)
+++ trunk/src/net/sf/plantlore/config/log4j.properties	2006-09-04 23:30:38 UTC (rev 674)
@@ -1,5 +1,5 @@
 ### set log levels - for more verbose logging change 'info' to 'debug' ###
-log4j.rootLogger=info, stdout
+log4j.rootLogger=debug, stdout
 
 ### direct log messages to stdout ###
 log4j.appender.stdout=org.apache.log4j.ConsoleAppender


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000933.html">[Plantlore-dev] r673 - trunk/src/net/sf/plantlore/server
</A></li>
	<LI>Next message: <A HREF="000935.html">[Plantlore-dev] r675 -	trunk/src/biocase/DataproBioCASE/www/querytool
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#934">[ date ]</a>
              <a href="thread.html#934">[ thread ]</a>
              <a href="subject.html#934">[ subject ]</a>
              <a href="author.html#934">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
