<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r197 - in trunk/src/net/sf/plantlore: client/export client/export/builders client/export/component common common/exception l10n
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r197%20-%20in%20trunk/src/net/sf/plantlore%3A%20client/export%20client/export/builders%20client/export/component%20common%20common/exception%20l10n&In-Reply-To=%3C200604301228.k3UCSGua019699%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000220.html">
   <LINK REL="Next"  HREF="000222.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r197 - in trunk/src/net/sf/plantlore: client/export client/export/builders client/export/component common common/exception l10n</H1>
    <B>krater at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r197%20-%20in%20trunk/src/net/sf/plantlore%3A%20client/export%20client/export/builders%20client/export/component%20common%20common/exception%20l10n&In-Reply-To=%3C200604301228.k3UCSGua019699%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r197 - in trunk/src/net/sf/plantlore: client/export client/export/builders client/export/component common common/exception l10n">krater at berlios.de
       </A><BR>
    <I>Sun Apr 30 14:28:16 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000220.html">[Plantlore-dev] Ako pouzivat help
</A></li>
        <LI>Next message: <A HREF="000222.html">[Plantlore-dev] r198 - trunk/src/net/sf/plantlore/l10n
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#221">[ date ]</a>
              <a href="thread.html#221">[ thread ]</a>
              <a href="subject.html#221">[ subject ]</a>
              <a href="author.html#221">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: krater
Date: 2006-04-30 14:28:09 +0200 (Sun, 30 Apr 2006)
New Revision: 197

Added:
   trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
   trunk/src/net/sf/plantlore/client/export/ExportMng.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
   trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
   trunk/src/net/sf/plantlore/client/export/ExportMngViewA.java
   trunk/src/net/sf/plantlore/client/export/ExportMngViewB.form
   trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
   trunk/src/net/sf/plantlore/client/export/ExportProgressView.form
   trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
   trunk/src/net/sf/plantlore/client/export/component/
   trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
   trunk/src/net/sf/plantlore/client/export/component/XFilter.java
   trunk/src/net/sf/plantlore/client/export/component/XNode.java
   trunk/src/net/sf/plantlore/client/export/component/XTree.java
   trunk/src/net/sf/plantlore/common/exception/
   trunk/src/net/sf/plantlore/common/exception/DBLayerException.java
   trunk/src/net/sf/plantlore/common/exception/ExportException.java
   trunk/src/net/sf/plantlore/common/exception/PlantloreException.java
Removed:
   trunk/src/net/sf/plantlore/client/export/Director.java
Modified:
   trunk/src/net/sf/plantlore/client/export/Builder.java
   trunk/src/net/sf/plantlore/client/export/Template.java
   trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
   trunk/src/net/sf/plantlore/common/AutoComboBox.java
   trunk/src/net/sf/plantlore/common/Selection.java
   trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
Log:
The Export framwork + GUI.

New basic set of Exceptions created.

Modified: trunk/src/net/sf/plantlore/client/export/Builder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Builder.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/Builder.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -13,7 +13,7 @@
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-21
  * @version 1.0
- * @see net.sf.plantlore.client.export.Director
+ * @see net.sf.plantlore.client.export.DefaultDirector
  */
 public interface Builder {
 		

Added: trunk/src/net/sf/plantlore/client/export/DefaultDirector.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/DefaultDirector.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,171 @@
+package net.sf.plantlore.client.export;
+
+import java.io.IOException;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.rmi.RemoteException;
+import java.util.Observable;
+
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.record.*;
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.server.DBLayerException;
+
+import org.apache.log4j.Logger;
+
+/**
+ * The Director class (for export).
+ * Purpose: The Director continualy fetches results of the resultset
+ * identified by the &lt;code&gt;result&lt;/code&gt;.
+ * The selected results (records whose ID is in the &lt;code&gt;selection&lt;/code&gt;)
+ * are passed to the &lt;code&gt;builder&lt;/code&gt; - the builder is responsible for
+ * creating a corresponing output.
+ * &lt;br/&gt;
+ * The Director is supposed to run in a separate thread which is why
+ * all exceptions are handled in the &lt;code&gt;run()&lt;/code&gt; method
+ * in a following manner:
+ * &lt;pre&gt;
+ * catch(AnException e) { setChanged(); notifyObservers( e ); }
+ * &lt;/pre&gt; 
+ *
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-21
+ * @version 0.9 might still slightly change
+ *
+ * @see net.sf.plantlore.client.common.Selection
+ * @see net.sf.plantlore.client.export.Builder
+ * @see net.sf.plantlore.middleware.DBLayer
+ */
+public class DefaultDirector extends Observable implements Runnable {
+	
+	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
+	
+	private Builder build;
+	private Selection selection;
+	private DBLayer database;
+	private int result;
+	
+	private boolean aborted = false;
+	
+	private int count = 0;
+
+	/**
+	 * Create a new export Director. The Director iterates over the results 
+	 * of the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;database.executeQuery(query)&lt;/code&gt;)
+	 * and selected records (i.e. records in the &lt;code&gt;selection&lt;/code&gt;)
+	 * passes to the &lt;code&gt;builder&lt;/code&gt;.
+	 * 
+	 * @param builder	The particular builder used to construct the final output.
+	 * @param result	The result describing the resultset that will be iterated over.
+	 * @param database	The database layer that will quench the Director's thirst for more results.
+	 * @param selection	The set of selected records.
+	 */
+	public DefaultDirector(Builder builder, int result, DBLayer database, Selection selection) {
+		assert(database != null);
+		assert(builder != null);
+		assert(selection != null);
+		
+		this.build = builder; this.result = result; this.database = database;
+		this.selection = selection.clone(); 
+	}
+	
+	
+	/** 
+	 * How many records have been exported.
+	 * 
+	 * @return The exact number of exported records.
+	 */
+	public int exportedRecords() { 
+		return count;
+	}
+	
+	
+	private static Object[] NO_PARAM = new Object[0];
+	
+	/**
+	 * The whole record is returned in a tree structure.
+	 * We must traverse this structure.
+	 * The children are denoted as &lt;i&gt;foreign keys&lt;/i&gt; 
+	 * - they contain other parts of the whole record.
+	 * 
+	 * @param record The &quot;node&quot; in the tree hierarchy representing the
+	 * whole record.
+	 */
+	private void buildPart(Record record) throws IOException {
+		// Build this part of the record.
+		build.part(record);
+		// Now look at all children of this record.
+		for(String key : record.getForeignKeys()) {
+			Method getter = Template.getMethod(record.getClass(), key);
+			try {
+				// And build'em too.
+				buildPart( (Record) getter.invoke( record, NO_PARAM ) );
+			}
+			catch(IllegalAccessException e) { e.printStackTrace(); }
+			catch(InvocationTargetException e) { e.printStackTrace(); }
+		}
+	}
+	
+	
+	/** 
+	 * Execute the exporting procedure -
+	 * fetch all results from the resultset and those that are selected
+	 * send to the builder to process them.
+	 */
+	public void run() {
+		try {
+			logger.info(&quot;Export begins...&quot;);
+			build.header();
+			
+			// Iterate over the result of the query.
+			int rows = database.getNumRows( result );
+			for(int i = 0; i &lt; rows &amp;&amp; !aborted; i++) {
+				Object[] records = database.next( result );
+				Record record = (Record) records[0];
+				if( !selection.contains( record ) ) continue; // Is the record selected?
+			
+				count++;
+				build.startRecord();
+				
+				// Parse the record.
+				buildPart( record );
+				
+				// ONE-TO-MANY HACK:
+				// Occurrence -&gt; AuthorOccurrences &amp; Authors
+				// FIXME: Jak se to ma Director dozvedet, ze ma delat tuhle iteraci :\
+				
+				
+				
+				
+				build.finishRecord();
+				
+				setChanged(); notifyObservers( count );
+			}
+
+			build.footer();
+			logger.info(&quot;Export completed. &quot; + count + &quot; records sent to output.&quot;);
+		}
+		catch(DBLayerException e) {
+			logger.error(&quot;Export ended prematurely &quot; + e);
+			setChanged(); notifyObservers( e ); 
+		}
+		catch(RemoteException e) {
+			logger.error(&quot;Export ended prematurely &quot; + e);
+			setChanged(); notifyObservers( e );
+		}
+		catch(IOException e) {
+			logger.error(&quot;Export ended prematurely &quot; + e); 
+			setChanged(); notifyObservers( e );
+		}
+		if(aborted) logger.info(&quot;Export aborted. &quot; + count + &quot; records sent to output.&quot;);
+	}
+	
+	/**
+	 * Abort the export immediately.
+	 */
+	public void abort() {
+		aborted = true;
+	}
+
+}

Deleted: trunk/src/net/sf/plantlore/client/export/Director.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Director.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/Director.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -1,144 +0,0 @@
-package net.sf.plantlore.client.export;
-
-import java.io.IOException;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.rmi.RemoteException;
-
-import net.sf.plantlore.common.Selection;
-import net.sf.plantlore.common.record.*;
-import net.sf.plantlore.middleware.DBLayer;
-import net.sf.plantlore.server.DBLayerException;
-
-import org.apache.log4j.Logger;
-
-/**
- * The Director class (for export).
- * Purpose: The Director continualy fetches results of the resultset
- * identified by the &lt;code&gt;result&lt;/code&gt;.
- * The selected results (records whose ID is in the &lt;code&gt;selection&lt;/code&gt;)
- * are passed to the &lt;code&gt;builder&lt;/code&gt; - the builder is responsible for
- * creating a corresponing output.
- * 
- * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @since 2006-04-21
- * @version 0.9 might still slightly change
- *
- * @see net.sf.plantlore.client.common.Selection
- * @see net.sf.plantlore.client.export.Builder
- * @see net.sf.plantlore.middleware.DBLayer
- */
-public class Director implements Runnable {
-	
-	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
-	
-	private Builder build;
-	private Selection selection;
-	private DBLayer database;
-	private int result;
-	
-	private int count = 0;
-
-	/**
-	 * Create a new export Director. The Director iterates over the results 
-	 * of the &lt;code&gt;query&lt;/code&gt; (&lt;code&gt;database.executeQuery(query)&lt;/code&gt;)
-	 * and selected records (i.e. records in the &lt;code&gt;selection&lt;/code&gt;)
-	 * passes to the &lt;code&gt;builder&lt;/code&gt;.
-	 * 
-	 * @param builder	The particular builder used to construct the final output.
-	 * @param result	The result describing the resultset that will be iterated over.
-	 * @param database	The database layer that will quench the Director's thirst for more results.
-	 * @param selection	The set of selected records.
-	 */
-	public Director(Builder builder, int result, DBLayer database, Selection selection) {
-		this.build = builder; this.result = result; this.database = database;
-		this.selection = selection;
-	}
-	
-	
-	/** 
-	 * How many records has been exported.
-	 * 
-	 * @return The exact number of exported records.
-	 */
-	public int exportedRecords() { 
-		return count;
-	}
-	
-	
-	private static Object[] NO_PARAM = new Object[0];
-	
-	/**
-	 * The whole record is returned in a tree structure.
-	 * We must traverse this structure.
-	 * The children are denoted as &lt;i&gt;foreign keys&lt;/i&gt; 
-	 * - they contain other parts of the whole record.
-	 * 
-	 * @param record The &quot;node&quot; in the tree hierarchy representing the
-	 * whole record.
-	 */
-	private void buildPart(Record record) throws IOException {
-		// Build this part of the record.
-		build.part(record);
-		// Now look at all children of this record.
-		for(String key : record.getForeignKeys()) {
-			Method getter = Template.getMethod(record.getClass(), key);
-			try {
-				// And build'em too.
-				buildPart( (Record) getter.invoke( record, NO_PARAM ) );
-			}
-			catch(IllegalAccessException e) { e.printStackTrace(); }
-			catch(InvocationTargetException e) { e.printStackTrace(); }
-		}
-	}
-	
-	
-	/** 
-	 * Execute the exporting procedure -
-	 * fetch all results from the resultset and those that are selected
-	 * send to the builder to process them.
-	 */
-	public void run() {
-		try {
-			logger.info(&quot;Export begins...&quot;);
-			build.header();
-			
-			// Iterate over the result of the query.
-			int rows = database.getNumRows( result );
-			for(int i = 0; i &lt; rows; i++) {
-				Object[] records = database.next( result );
-				Record record = (Record) records[0];
-				if( !selection.contains( record ) ) continue; // Is the record selected?
-			
-				count++;
-				build.startRecord();
-				
-				// Parse the record.
-				buildPart( record );
-				
-				// ONE-TO-MANY HACK:
-				// Occurrence -&gt; AuthorOccurrences &amp; Authors
-				// TODO: Iterace pres vsechny AuthorOccurence
-				
-				
-				
-				build.finishRecord();
-			}
-
-			build.footer();
-			logger.info(&quot;Export completed. &quot; + count + &quot; records sent to output.&quot;);
-		}
-		// FIXME: Since the run() method comes from the Runnable interface, it cannot throw
-		// any exceptions :( This is yet to be solved!
-		catch(DBLayerException e) {
-			logger.error(e); e.printStackTrace();
-		}
-		catch(RemoteException e) {
-			logger.error(e); e.printStackTrace();
-		}
-		catch(IOException e) {
-			logger.error(e); e.printStackTrace();
-		}
-	}
-
-}

Added: trunk/src/net/sf/plantlore/client/export/ExportMng.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMng.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,326 @@
+&#65279;package net.sf.plantlore.client.export;
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.io.Writer;
+import java.util.Observable;
+import java.util.Observer;
+
+import net.sf.plantlore.client.export.builders.*;
+import net.sf.plantlore.client.export.component.XFilter;
+import net.sf.plantlore.common.Selection;
+import net.sf.plantlore.common.exception.ExportException;
+import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
+
+import org.apache.log4j.Logger;
+
+/**
+ * The Export Manager. This class controls the whole process of export -
+ * starting with creation of all necessary participants
+ * and ending with the final cleanup. 
+ * &lt;br/&gt;
+ * There are several entities involved in the export:
+ * &lt;ul&gt;
+ * &lt;li&gt;&lt;b&gt;Director&lt;/b&gt; iterates over the &lt;i&gt;result set&lt;/i&gt; 
+ * 					and &lt;i&gt;selected records&lt;/i&gt; passes to the &lt;i&gt;builder&lt;/i&gt;,&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Builder&lt;/b&gt; writes the records to the &lt;i&gt;output&lt;/i&gt;.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Selection&lt;/b&gt; stores the list of all selected records 
+ * 					(&lt;i&gt;restriction&lt;/i&gt; in the database terminology).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;ResultID&lt;/b&gt; identifies the result set.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;Template&lt;/b&gt; stores the list of all selected columns that should be 
+ * 					exported (&lt;i&gt;projection&lt;/i&gt; in the database terminology).&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;File&lt;/b&gt; stores the name of file as the user has suggested it.&lt;/li&gt;
+ * &lt;li&gt;&lt;b&gt;XFilter&lt;/b&gt; suggests the final name of the &lt;i&gt;file&lt;/i&gt;
+ * 					and is used to determine which &lt;i&gt;builder&lt;/i&gt; will be used
+ * 					to produce the output.&lt;/li&gt;
+ * &lt;/ul&gt;
+ *  
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29 
+ * @see net.sf.plantlore.client.export.DefaultDirector
+ * @see net.sf.plantlore.client.export.Builder
+ */
+public class ExportMng extends Observable implements Observer {
+	
+	/**
+	 * List of all filters the Export Manager is capable to handle.
+	 */
+	private XFilter[] filters = new XFilter[] {
+		new XFilter(L10n.getString(&quot;FilterDC&quot;), &quot;.xml&quot;),
+		new XFilter(L10n.getString(&quot;FilterABCD&quot;), &quot;.xml&quot;),
+		new XFilter(L10n.getString(&quot;FilterCSV&quot;), &quot;.txt&quot;, &quot;.csv&quot;),
+		new XFilter(L10n.getString(&quot;FilterXML&quot;), &quot;.xml&quot;),
+		new XFilter(L10n.getString(&quot;FilterPlantloreNative&quot;), &quot;.xml&quot;, &quot;.pln&quot;)
+	};
+	
+	
+	private Logger logger = Logger.getLogger(this.getClass().getPackage().getName());
+	private DBLayer db ;
+	private Template template;
+	private Selection select;
+	private XFilter filter;
+	private File file;
+	private Integer resultId;
+	private DefaultDirector director;
+	private Builder builder;
+	private boolean aborted = false, exportInProgress = false;
+	private int results, selectedResults;
+	
+	private Writer writer;
+	private Thread current;
+		
+	
+	/**
+	 * Create a new Export Manager.
+	 * 
+	 * @param dblayer The database layer mediating the access to the database.
+	 * @param result	The result set identificator which is to be iterated over.
+	 * @param selection	The list of selected records. Shouldn't be empty.
+	 * @param template	The list of selected columns.
+	 */
+	public ExportMng(DBLayer dblayer, int result, Selection selection, Template template) {
+		setDBLayer(dblayer);
+		setResultId(result);
+		setSelection(selection);
+		setTemplate(template); 
+	}
+
+	/**
+	 * Create a new Export manager and &lt;b&gt;mark all records as selected&lt;/b&gt;.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database.
+	 * @param result	The result set identificator which is to be iterated over.
+	 */
+	public ExportMng(DBLayer dblayer, int result) {
+		setDBLayer(dblayer);
+		setResultId(result);
+		setTemplate(null);
+		
+		Selection select = new Selection(); select.all();
+		setSelection(select);
+	}
+	
+	/**
+	 * Create a new Export manager.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database. Shouldn't be empty.
+	 * @param result	The result set identificator which is to be iterated over. Shouldn't be empty.
+	 * @param selection	The list of selected records. Shouldn't be empty.
+	 */
+	public ExportMng(DBLayer dblayer, int result, Selection selection) {
+		this(dblayer, result, selection, null);
+	}
+	
+	/**
+	 * Create a new Export manager.
+	 * 
+	 * @param dblayer	The database layer mediating the access to the database. Shouldn't be empty.
+	 * @param result	The result set identificator which is to be iterated over. Shouldn't be empty.
+	 * @param selection	The list of selected records. Shouldn't be empty.
+	 * @param template	The list of selected columns.
+	 * @param filter	The filter which will be used to determine the appropriate builder of the output.
+	 * @param file	The file where the output will be written.
+	 */
+	public ExportMng(DBLayer dblayer, int result, Selection selection, Template template, XFilter filter, File file) {
+		this(dblayer, result, selection, template);
+		setSelectedFile(file);
+		setActiveFileFilter(filter);
+	}
+	
+	/**
+	 * Set a new DBLayer.
+	 * &lt;b&gt;Forget the current result set identificator&lt;/b&gt; (if there is any) - that identificator
+	 * most probably refered to a result set of the previous dblayer! 
+	 */
+	synchronized public void setDBLayer(DBLayer dblayer) {
+		if(dblayer == null) 
+			logger.warn(&quot;The database layer is null!&quot;);
+		db = dblayer;
+		results = selectedResults = resultId = -1;
+	}
+	
+	/**
+	 * Store a copy of the &lt;code&gt;template&lt;/code&gt;.
+	 */
+	synchronized public void setTemplate(Template template) {
+		if(template == null) this.template = null;
+		else this.template = template.clone();
+	}
+	
+	/**
+	 * Store a copy of the &lt;code&gt;selection&lt;/code&gt;.
+	 */
+	synchronized public void setSelection(Selection selection) {
+		if(selection == null || selection.isEmpty())
+			logger.warn(&quot;The list of selected records is empty!&quot;);
+
+		if(selection == null) select = new Selection();
+		else select = selection.clone();
+
+		selectedResults = -1;
+		if(resultId &gt;= 0 &amp;&amp; results &gt;= 0)
+			selectedResults = selection.size(results);
+	}
+	
+	/**
+	 * Set the active filter. The type of the filter will be used 
+	 * to determine the appropriate extension of the file
+	 * and to create a correct Builder (for the format this
+	 * filter represents). 
+	 */
+	synchronized public void setActiveFileFilter(XFilter filter) {
+		if(filter == null)
+			logger.warn(&quot;The active filter is null!&quot;);
+		this.filter = filter; 
+	}
+	
+	/**
+	 * Set the selected file. Into this file the builder will 
+	 * spit its output. 
+	 */
+	synchronized public void setSelectedFile(File file) { 
+		if(file == null)
+			logger.warn(&quot;The selected file is null!&quot;);
+		this.file = file; 
+	}
+	
+	/**
+	 * Set another result identificator of a Result Set. 
+	 */
+	synchronized public void setResultId(Integer result) { 
+		if(result &lt; 0) 
+			logger.warn(&quot;The result set identificator is null!&quot;);
+
+		this.resultId = result;
+		results = -1;
+		if(resultId &gt;= 0)
+			try {	results = db.getNumRows(resultId); } catch(Exception e) {}
+	}
+	
+	/**
+	 * Start the export procedure. The export procedure
+	 * will run in its own thread.
+	 * 
+	 * @param append	True if the Builder shall append its output to an already existing file.
+	 * @throws ExportException	If the information provided is not complete.
+	 * @throws IOException	If anything with the file goes wrong (insufficient disk space, insufficient permissions).
+	 */
+	synchronized public void start(boolean append) throws ExportException, IOException {
+		// Check if we have all necessary components ready.
+		if( db == null )
+			throw new ExportException(&quot;There is no point in starting an export - the DBLayer is not set!&quot;);
+		if( filter == null ) 
+			throw new ExportException(&quot;The Filter is not set!&quot;);
+		if( file == null ) 
+			throw new ExportException(&quot;The File is not set!&quot;);
+		if( select.isEmpty() )
+			throw new ExportException(&quot;There is no point in starting an export - the list of selected records is empty!&quot;);
+			
+		
+		logger.debug(&quot;Initializing the export environment.&quot;);
+		aborted = false;
+		
+		// Create a new writer.
+		writer = new FileWriter( filter.suggestName(file), append );
+		if(writer == null) {
+			logger.fatal(&quot;Unable to create a new Writer.&quot;);
+			throw new ExportException(&quot;Unable to create a new Writer.&quot;);
+		}
+		
+		// Create a new builder according to the selected format.
+		if(filter.getDescription().equals(L10n.getString(&quot;FilterCSV&quot;)))
+			builder = new CSVBuilder(writer, template);
+		else if(filter.getDescription().equals(L10n.getString(&quot;FilterXML&quot;)))
+			builder = new TrainingBuilder(template);
+		else 
+			builder = new TrainingBuilder(template);
+
+		// Create a new Director and run it in a separate thread.
+		director = new DefaultDirector(builder, resultId, db, select);
+		director.addObserver(this);
+		current = new Thread( director, &quot;Export&quot; );
+		if(current == null) {
+			logger.fatal(&quot;Unable to create a new thread.&quot;);
+			throw new ExportException(&quot;Unable to create a new thread.&quot;);
+		}
+		current.start();
+		
+		exportInProgress = true;
+		
+		// Register a cleanup procedure
+		Thread monitor = new Thread(new Runnable() {
+			public void run() {
+				try {
+					// Sleep until the thread is really dead.
+					current.join();
+					// Dispose of the writer.
+					writer.close();
+					exportInProgress = false;
+					logger.debug(&quot;Environment cleaned up.&quot;);
+				}catch(Exception e) {}
+			}
+		}, &quot;ExportMonitor&quot;);
+		monitor.start();
+	}
+	
+
+	/**
+	 * Abort the current export. You &lt;b&gt;must call&lt;/b&gt; &lt;code&gt;finish()&lt;/code&gt; 
+	 * after calling &lt;code&gt;abort()&lt;/code&gt;. 
+	 */
+	synchronized public void abort() {
+		if(!exportInProgress) return;
+		aborted = true; exportInProgress = false;
+		if(director != null) director.abort();
+		setChanged(); notifyObservers();
+	}
+	
+	/**
+	 * @return True if the export was aborted.
+	 */
+	public boolean isAborted() {
+		return aborted;
+	}
+	
+	/**
+	 * @return True if an export procedure already runs.
+	 */
+	public boolean isExportInProgress() {
+		return exportInProgress;
+	}
+	
+	/**
+	 * @return The total number of results to be exported.
+	 */
+	public int getNumberOfResults() {
+		return selectedResults;
+	}
+	
+	/**
+	 * @return The number of results that have already been exported.
+	 */
+	public int getNumberOfExported() {
+		return director.exportedRecords();
+	}
+	
+	/**
+	 * @return The list of filters describing formats this Export Manager can handle.
+	 */
+	public XFilter[] getFilters() {
+		return filters.clone();
+	}
+
+	
+	/**
+	 * Notify the observers - some of our components has changed its state.
+	 * The parameter can carry either information about progress
+	 * or an exception that has to be dealt with.
+	 */
+	public void update(Observable source, Object parameter) {
+		setChanged(); notifyObservers( parameter );
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlA.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,40 @@
+package net.sf.plantlore.client.export;
+
+import javax.swing.JFileChooser;
+
+import net.sf.plantlore.client.export.component.XFilter;
+
+public class ExportMngCtrlA {
+	
+	
+	private ExportMng model;
+	private ExportMngViewA view;
+	
+	private ExportMngViewB viewB;
+	//private ExportMngCtrlB ctrlB;
+
+	private ExportProgressView  progressView;
+	
+	public ExportMngCtrlA(ExportMng model, ExportMngViewA view, ExportProgressView progressView) {
+		this.model = model; this.view = view; this.progressView = progressView;
+		viewB = new ExportMngViewB();
+		/*ctrlB = */new ExportMngCtrlB(model, viewB, progressView);
+	}
+	
+	public void setVisible(boolean visible) {
+		if(visible) {
+			int result = view.choice.showDialog(null, &quot;Export&quot;);
+			if( result == JFileChooser.APPROVE_OPTION ) {
+				model.setSelectedFile( view.choice.getSelectedFile() );
+				XFilter filter = (XFilter) view.choice.getFileFilter();
+				model.setActiveFileFilter( filter );
+				
+				if( filter.isColumnSelectionEnabled() )
+					viewB.setVisible(true);
+				else
+					progressView.setVisible(true);
+			}
+		}
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngCtrlB.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,48 @@
+package net.sf.plantlore.client.export;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+import javax.swing.JOptionPane;
+
+
+//import net.sf.plantlore.l10n.L10n;
+
+public class ExportMngCtrlB {
+	
+	private ExportMng model;
+	private ExportMngViewB view;
+	private ExportProgressView progressView;
+	
+	public ExportMngCtrlB(ExportMng model, ExportMngViewB view, ExportProgressView progressView) {
+		this.model = model; this.view = view; this.progressView = progressView;
+		view.next.addActionListener( new Next() );
+	}
+	
+	
+	class Next extends AbstractAction {
+		public void actionPerformed(ActionEvent arg0) {
+			Template t = view.tsm.getTemplate();
+			if( t.isEmpty() )
+				JOptionPane.showMessageDialog(view,
+					&quot;You must select some columns!\nThere would be no point in running the export procedure otherwise.&quot;,
+				    &quot;Template empty&quot;,
+				    JOptionPane.WARNING_MESSAGE);
+			else {
+				view.setVisible(false);
+				model.setTemplate( t ); // Set the new template.
+				try {
+					model.start(true);
+					progressView.setVisible(true);
+				}
+				catch(Exception e) {
+					JOptionPane.showMessageDialog(view,
+							&quot;Unable to start the export procedure!\n&quot; + e,
+						    &quot;Export failed...&quot;,
+						    JOptionPane.WARNING_MESSAGE);
+				}
+			}
+		}
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngViewA.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewA.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewA.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,29 @@
+package net.sf.plantlore.client.export;
+
+
+import javax.swing.JFileChooser;
+import javax.swing.filechooser.FileFilter;
+
+
+public class ExportMngViewA {
+	
+	private ExportMng model;
+	protected JFileChooser choice;
+	
+	
+	
+	public ExportMngViewA(ExportMng model) {
+		this.model = model;
+		initComponents();
+	}
+
+	
+	private void initComponents() {
+		JFileChooser chooser = new JFileChooser();
+		chooser.setAcceptAllFileFilterUsed(false);
+		for( FileFilter filter: model.getFilters() )
+			chooser.addChoosableFileFilter(filter);
+	}
+	
+	
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportMngViewB.form
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewB.form	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewB.form	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,63 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
+
+&lt;Form version=&quot;1.3&quot; type=&quot;org.netbeans.modules.form.forminfo.JFrameFormInfo&quot;&gt;
+  &lt;Properties&gt;
+    &lt;Property name=&quot;defaultCloseOperation&quot; type=&quot;int&quot; value=&quot;3&quot;/&gt;
+  &lt;/Properties&gt;
+  &lt;SyntheticProperties&gt;
+    &lt;SyntheticProperty name=&quot;formSizePolicy&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;
+  &lt;/SyntheticProperties&gt;
+  &lt;AuxValues&gt;
+    &lt;AuxValue name=&quot;FormSettings_generateMnemonicsCode&quot; type=&quot;java.lang.Boolean&quot; value=&quot;false&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_listenerGenerationStyle&quot; type=&quot;java.lang.Integer&quot; value=&quot;0&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_variablesLocal&quot; type=&quot;java.lang.Boolean&quot; value=&quot;false&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_variablesModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;2&quot;/&gt;
+  &lt;/AuxValues&gt;
+
+  &lt;Layout&gt;
+    &lt;DimensionLayout dim=&quot;0&quot;&gt;
+      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+          &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+                  &lt;Component id=&quot;jScrollPane1&quot; alignment=&quot;0&quot; pref=&quot;380&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                  &lt;Component id=&quot;next&quot; alignment=&quot;1&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;/Group&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+          &lt;/Group&gt;
+      &lt;/Group&gt;
+    &lt;/DimensionLayout&gt;
+    &lt;DimensionLayout dim=&quot;1&quot;&gt;
+      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+          &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+              &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Component id=&quot;jScrollPane1&quot; pref=&quot;229&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+              &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Component id=&quot;next&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+          &lt;/Group&gt;
+      &lt;/Group&gt;
+    &lt;/DimensionLayout&gt;
+  &lt;/Layout&gt;
+  &lt;SubComponents&gt;
+    &lt;Container class=&quot;javax.swing.JScrollPane&quot; name=&quot;jScrollPane1&quot;&gt;
+
+      &lt;Layout class=&quot;org.netbeans.modules.form.compat2.layouts.support.JScrollPaneSupportLayout&quot;/&gt;
+      &lt;SubComponents&gt;
+        &lt;Component class=&quot;javax.swing.JTree&quot; name=&quot;tree&quot;&gt;
+          &lt;AuxValues&gt;
+            &lt;AuxValue name=&quot;JavaCodeGenerator_VariableModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;4&quot;/&gt;
+          &lt;/AuxValues&gt;
+        &lt;/Component&gt;
+      &lt;/SubComponents&gt;
+    &lt;/Container&gt;
+    &lt;Component class=&quot;javax.swing.JButton&quot; name=&quot;next&quot;&gt;
+      &lt;Properties&gt;
+        &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;Export&quot;/&gt;
+      &lt;/Properties&gt;
+      &lt;AuxValues&gt;
+        &lt;AuxValue name=&quot;JavaCodeGenerator_VariableModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;4&quot;/&gt;
+      &lt;/AuxValues&gt;
+    &lt;/Component&gt;
+  &lt;/SubComponents&gt;
+&lt;/Form&gt;

Added: trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportMngViewB.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,79 @@
+/*
+ * ExportMngView.java
+ *
+ * Created on 29. duben 2006, 21:00
+ */
+
+package net.sf.plantlore.client.export;
+
+import net.sf.plantlore.client.export.component.TemplateSelectionModel;
+import net.sf.plantlore.client.export.component.XTree;
+
+/**
+ *
+ * @author  yaa
+ */
+public class ExportMngViewB extends javax.swing.JDialog {
+	
+	protected TemplateSelectionModel tsm;
+    
+    /** Creates new form ExportMngView */
+    public ExportMngViewB() {
+    	tsm = new TemplateSelectionModel();
+    	
+        initComponents();
+        
+        setLocationRelativeTo(null); // center of the screen
+        setModal(true);
+    }
+    
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot; Generated Code &quot;&gt;//GEN-BEGIN:initComponents
+    private void initComponents() {
+        jScrollPane1 = new javax.swing.JScrollPane();
+        tree = new XTree();
+        next = new javax.swing.JButton();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.HIDE_ON_CLOSE);
+        jScrollPane1.setViewportView(tree);
+
+        next.setText(&quot;Export&quot;);
+        
+        tree.setSelectionModel( tsm );
+
+        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
+        getContentPane().setLayout(layout);
+        layout.setHorizontalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(layout.createSequentialGroup()
+                .addContainerGap()
+                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, next))
+                .addContainerGap())
+        );
+        layout.setVerticalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(layout.createSequentialGroup()
+                .addContainerGap()
+                .add(jScrollPane1, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 229, Short.MAX_VALUE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(next)
+                .addContainerGap())
+        );
+        pack();
+    }// &lt;/editor-fold&gt;//GEN-END:initComponents
+    
+    
+    
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    private javax.swing.JScrollPane jScrollPane1;
+    protected javax.swing.JButton next;
+    protected XTree tree;
+    // End of variables declaration//GEN-END:variables
+    
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressCtrl.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,37 @@
+package net.sf.plantlore.client.export;
+
+import java.awt.event.ActionEvent;
+
+import javax.swing.AbstractAction;
+import javax.swing.JOptionPane;
+
+//import net.sf.plantlore.l10n.L10n;
+
+public class ExportProgressCtrl {
+	
+	private ExportMng model;
+	private ExportProgressView view;
+	
+	public ExportProgressCtrl(ExportMng model, ExportProgressView view) {
+		this.model = model; this.view = view;
+		view.abort.addActionListener( new Abort() );
+	}
+	
+	class Abort extends AbstractAction {
+		public void actionPerformed(ActionEvent arg0) {
+			int response =
+				JOptionPane.showOptionDialog(view,
+					    &quot;The export procedure will be aborted.&quot;,
+					    &quot;Abort export&quot;,
+					    JOptionPane.OK_CANCEL_OPTION,
+					    JOptionPane.WARNING_MESSAGE,
+					    null,
+					    null,
+					    null);
+				if(response == JOptionPane.OK_OPTION) {
+					model.abort();
+				}
+		}
+	}
+
+}

Added: trunk/src/net/sf/plantlore/client/export/ExportProgressView.form
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressView.form	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressView.form	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,69 @@
+&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
+
+&lt;Form version=&quot;1.3&quot; type=&quot;org.netbeans.modules.form.forminfo.JFrameFormInfo&quot;&gt;
+  &lt;Properties&gt;
+    &lt;Property name=&quot;defaultCloseOperation&quot; type=&quot;int&quot; value=&quot;3&quot;/&gt;
+  &lt;/Properties&gt;
+  &lt;SyntheticProperties&gt;
+    &lt;SyntheticProperty name=&quot;formSizePolicy&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;
+  &lt;/SyntheticProperties&gt;
+  &lt;AuxValues&gt;
+    &lt;AuxValue name=&quot;FormSettings_generateMnemonicsCode&quot; type=&quot;java.lang.Boolean&quot; value=&quot;false&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_listenerGenerationStyle&quot; type=&quot;java.lang.Integer&quot; value=&quot;0&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_variablesLocal&quot; type=&quot;java.lang.Boolean&quot; value=&quot;false&quot;/&gt;
+    &lt;AuxValue name=&quot;FormSettings_variablesModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;2&quot;/&gt;
+  &lt;/AuxValues&gt;
+
+  &lt;Layout&gt;
+    &lt;DimensionLayout dim=&quot;0&quot;&gt;
+      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+          &lt;Group type=&quot;102&quot; attributes=&quot;0&quot;&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+                  &lt;Component id=&quot;progress&quot; alignment=&quot;0&quot; pref=&quot;380&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                  &lt;Component id=&quot;status&quot; alignment=&quot;0&quot; pref=&quot;380&quot; max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+                  &lt;Component id=&quot;abort&quot; alignment=&quot;1&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;/Group&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+          &lt;/Group&gt;
+      &lt;/Group&gt;
+    &lt;/DimensionLayout&gt;
+    &lt;DimensionLayout dim=&quot;1&quot;&gt;
+      &lt;Group type=&quot;103&quot; groupAlignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+          &lt;Group type=&quot;102&quot; alignment=&quot;0&quot; attributes=&quot;0&quot;&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Component id=&quot;status&quot; min=&quot;-2&quot; pref=&quot;84&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;EmptySpace max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Component id=&quot;progress&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;EmptySpace max=&quot;32767&quot; attributes=&quot;0&quot;/&gt;
+              &lt;Component id=&quot;abort&quot; min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+              &lt;EmptySpace min=&quot;-2&quot; max=&quot;-2&quot; attributes=&quot;0&quot;/&gt;
+          &lt;/Group&gt;
+      &lt;/Group&gt;
+    &lt;/DimensionLayout&gt;
+  &lt;/Layout&gt;
+  &lt;SubComponents&gt;
+    &lt;Component class=&quot;javax.swing.JLabel&quot; name=&quot;status&quot;&gt;
+      &lt;Properties&gt;
+        &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;asdf&quot;/&gt;
+        &lt;Property name=&quot;verticalAlignment&quot; type=&quot;int&quot; value=&quot;1&quot;/&gt;
+      &lt;/Properties&gt;
+      &lt;AuxValues&gt;
+        &lt;AuxValue name=&quot;JavaCodeGenerator_VariableModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;4&quot;/&gt;
+      &lt;/AuxValues&gt;
+    &lt;/Component&gt;
+    &lt;Component class=&quot;javax.swing.JProgressBar&quot; name=&quot;progress&quot;&gt;
+      &lt;AuxValues&gt;
+        &lt;AuxValue name=&quot;JavaCodeGenerator_VariableModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;4&quot;/&gt;
+      &lt;/AuxValues&gt;
+    &lt;/Component&gt;
+    &lt;Component class=&quot;javax.swing.JButton&quot; name=&quot;abort&quot;&gt;
+      &lt;Properties&gt;
+        &lt;Property name=&quot;text&quot; type=&quot;java.lang.String&quot; value=&quot;Abort&quot;/&gt;
+      &lt;/Properties&gt;
+      &lt;AuxValues&gt;
+        &lt;AuxValue name=&quot;JavaCodeGenerator_VariableModifier&quot; type=&quot;java.lang.Integer&quot; value=&quot;4&quot;/&gt;
+      &lt;/AuxValues&gt;
+    &lt;/Component&gt;
+  &lt;/SubComponents&gt;
+&lt;/Form&gt;

Added: trunk/src/net/sf/plantlore/client/export/ExportProgressView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/ExportProgressView.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,120 @@
+/*
+ * ExportProgressView.java
+ *
+ * Created on 29. duben 2006, 22:01
+ */
+
+package net.sf.plantlore.client.export;
+
+import java.util.Observable;
+import java.util.Observer;
+
+/**
+ *
+ * @author  Erik Kratochv&#237;l
+ */
+public class ExportProgressView extends javax.swing.JFrame implements Observer {
+	
+	private ExportMng model;
+	private int total;
+    
+    /** Creates new form ExportProgressView */
+    public ExportProgressView(ExportMng model) {
+    	this.model = model;
+        initComponents();
+        setLocationRelativeTo(null); // center of the screen
+    }
+    
+    /** This method is called from within the constructor to
+     * initialize the form.
+     * WARNING: Do NOT modify this code. The content of this method is
+     * always regenerated by the Form Editor.
+     */
+    // &lt;editor-fold defaultstate=&quot;collapsed&quot; desc=&quot; Generated Code &quot;&gt;//GEN-BEGIN:initComponents
+    private void initComponents() {
+        status = new javax.swing.JLabel();
+        progress = new javax.swing.JProgressBar();
+        abort = new javax.swing.JButton();
+
+        setDefaultCloseOperation(javax.swing.WindowConstants.HIDE_ON_CLOSE);
+        status.setText(&quot;Erised stra ehru oyt ube cafru oyt on wohsi&quot;);
+        status.setVerticalAlignment(javax.swing.SwingConstants.TOP);
+
+        abort.setText(&quot;Abort&quot;);
+        
+        progress.setMinimum(0);
+
+        org.jdesktop.layout.GroupLayout layout = new org.jdesktop.layout.GroupLayout(getContentPane());
+        getContentPane().setLayout(layout);
+        layout.setHorizontalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(layout.createSequentialGroup()
+                .addContainerGap()
+                .add(layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+                    .add(progress, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
+                    .add(status, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, 380, Short.MAX_VALUE)
+                    .add(org.jdesktop.layout.GroupLayout.TRAILING, abort))
+                .addContainerGap())
+        );
+        layout.setVerticalGroup(
+            layout.createParallelGroup(org.jdesktop.layout.GroupLayout.LEADING)
+            .add(layout.createSequentialGroup()
+                .addContainerGap()
+                .add(status, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, 84, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED)
+                .add(progress, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, org.jdesktop.layout.GroupLayout.PREFERRED_SIZE)
+                .addPreferredGap(org.jdesktop.layout.LayoutStyle.RELATED, org.jdesktop.layout.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
+                .add(abort)
+                .addContainerGap())
+        );
+        pack();
+    }// &lt;/editor-fold&gt;//GEN-END:initComponents
+    
+    
+    
+    // Variables declaration - do not modify//GEN-BEGIN:variables
+    protected javax.swing.JButton abort;
+    protected javax.swing.JProgressBar progress;
+    protected javax.swing.JLabel status;
+    // End of variables declaration//GEN-END:variables
+    
+    
+    @Override
+    public void setVisible(boolean visible) {
+    	status.setText(&quot;Initializing...&quot;);
+    	total = model.getNumberOfResults();
+    	if(total &gt; 0) {
+    		progress.setIndeterminate(false);
+    		progress.setMaximum( total );
+    		progress.setStringPainted(true);
+    	}
+    	else {
+    		progress.setIndeterminate(true);
+    		progress.setStringPainted(false);
+    	}
+    	
+    	super.setVisible(visible);
+    	
+    	update(null, null);
+    }
+    
+    
+    
+	public void update(Observable source, Object parameter) {
+		if(model.isAborted()) 
+			status.setText(&quot;Aborting...&quot;);
+		else if( this.isVisible() ) {
+			int count = model.getNumberOfExported();
+			if(count &gt;= 0) {
+				progress.setValue( count );
+				if(total &gt; 0) { 
+					progress.setString( Integer.toString(100*count / total) );
+					status.setText(&quot;Exporting &quot; + count + &quot;. of &quot; + total);
+				}
+				else
+					status.setText(&quot;Exporting &quot; + count + &quot;.&quot;);
+			}
+		}
+	}
+    
+}

Modified: trunk/src/net/sf/plantlore/client/export/Template.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/Template.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/Template.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -26,7 +26,7 @@
 public class Template {
 	
 	/** The list of all pairs Table.Column that are set. */
-	private Collection&lt;String&gt; columns = new HashSet&lt;String&gt;(20);
+	private Collection&lt;String&gt; columns = new HashSet&lt;String&gt;(100);
 	
 	/** 
 	 * The list of &quot;basic tables&quot; i.e. tables related directly to the Occurence data.
@@ -104,17 +104,19 @@
 			
 	/** Select the &lt;code&gt;table.column&lt;/code&gt;. */
 	public void set(Class table, String column) { 
-		columns.add(table.getSimpleName()+&quot;.&quot;+column);
+		columns.add(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
+		System.out.println(&quot; + &quot; + table.getSimpleName() + (column == null ? &quot;&quot; : &quot;.&quot; + column));
 	}
 	
 	/** Unselect the &lt;code&gt;table.column&lt;/code&gt;. */
 	public void unset(Class table, String column) { 
-		columns.remove(table.getSimpleName()+&quot;.&quot;+column); 
+		columns.remove(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
+		System.out.println(&quot; - &quot; + table.getSimpleName() + (column == null ? &quot;&quot; : &quot;.&quot; + column));
 	}
 	
 	/** @return true if the &lt;code&gt;table.column&lt;/code&gt; is set.*/
-	public boolean isSet(Class table, String column) { 
-		return columns.contains(table.getSimpleName()+&quot;.&quot;+column); 
+	public boolean isSet(Class table, String column) {
+		return columns.contains(table.getSimpleName()+ (column == null ? &quot;&quot; : &quot;.&quot;+column));
 	}
 	
 	/** Unselect all columns of all tables. */
@@ -122,6 +124,13 @@
 		columns.clear(); 
 	}
 	
+	/**
+	 * @return true if nothing is selected.
+	 */
+	public boolean isEmpty() {
+		return columns.isEmpty();
+	}
+	
 		
 	/**
 	 * Match this template against another one.

Modified: trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/builders/CSVBuilder.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -14,7 +14,7 @@
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
  * @since 2006-04-23
- * @version 1.0 final
+ * @version 1.0 header is missing
  */
 public class CSVBuilder extends AbstractBuilder{
 	
@@ -50,6 +50,12 @@
 	}
 	
 	/**
+	 * Make a note that the header is yet to be created.
+	 */
+	public void header() throws IOException {
+	}
+	
+	/**
 	 * Insert a line breaker.
 	 */
 	public void footer() throws IOException {

Added: trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/component/TemplateSelectionModel.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,63 @@
+package net.sf.plantlore.client.export.component;
+
+import javax.swing.tree.DefaultMutableTreeNode;
+import javax.swing.tree.DefaultTreeSelectionModel;
+import javax.swing.tree.TreePath;
+
+import net.sf.plantlore.client.export.Template;
+
+/**
+ * A TreeSelectionModel modified to update its Template. 
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 29.4.2006
+ * @see net.sf.plantlore.client.export.component.XTree
+ * @see net.sf.plantlore.client.export.component.XNode
+ */
+public class TemplateSelectionModel extends DefaultTreeSelectionModel {
+	
+	private Template xtemplate = new Template();
+	
+	@Override 
+	public void setSelectionPath(TreePath path) {
+		if( isPathSelected(path) )
+			removeSelectionPath(path);
+		else
+			addSelectionPath(path);
+	}
+	
+	@Override 
+	public void removeSelectionPaths(TreePath[] paths) {
+		for(TreePath path : paths) {
+			if(path == null) continue;
+			Object node = path.getLastPathComponent();
+			if(node instanceof DefaultMutableTreeNode) {
+				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
+				xtemplate.unset(x.table, x.column);  
+			}
+		}
+		super.removeSelectionPaths( paths );
+	}
+	
+	@Override 
+	public void addSelectionPaths(TreePath[] paths) {
+		for(TreePath path : paths) {
+			Object node = path.getLastPathComponent();
+			if(node instanceof DefaultMutableTreeNode) {
+				XNode x  = (XNode) ((DefaultMutableTreeNode)node).getUserObject();
+				// Select table.column records (not the table only). 
+				if(x.column != null) xtemplate.set(x.table, x.column);
+			}
+		}
+		super.addSelectionPaths( paths );
+	}
+			
+	/**
+	 * 
+	 * @return A copy of the inner template that stores the list of selected columns.
+	 */
+	public Template getTemplate() {
+		return xtemplate.clone();
+	}
+	
+}

Added: trunk/src/net/sf/plantlore/client/export/component/XFilter.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XFilter.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/component/XFilter.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,111 @@
+package net.sf.plantlore.client.export.component;
+
+import java.io.File;
+import java.util.ArrayList;
+
+import javax.swing.filechooser.FileFilter;
+
+/**
+ * An implementation of a FileFilter.
+ * The XFilter stores a list of extensions
+ * that are related to a particular format.
+ * &lt;br/&gt;
+ * For example: 
+ * &lt;code&gt;Comma Separated Values (*.txt, *.csv)&lt;/code&gt;
+ * will store &lt;code&gt;&quot;.txt&quot;, &quot;.csv&quot;&lt;/code&gt;.
+ *  
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @version 1.0
+ */
+public class XFilter extends FileFilter {
+	
+	private String description;
+	private ArrayList&lt;String&gt; extensions;
+	private boolean columnSelection = false;
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description The description of the filter.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public XFilter(String description, String... extensions) {
+		this.description = description;
+		this.extensions = new ArrayList&lt;String&gt;( extensions.length );
+		for(String ext : extensions) this.extensions.add(ext);
+	}
+	
+	/**
+	 * Create a new XFilter.
+	 * 
+	 * @param description	The description of the filter.
+	 * @param columnSelectionEnabled	The format allows further modifications.
+	 * @param extensions	The list of extensions that are related to this filter.
+	 */
+	public XFilter(String description, boolean columnSelectionEnabled, String... extensions) {
+		this(description, extensions);
+		this.columnSelection = columnSelectionEnabled;
+	}
+
+	/**
+	 * @return True if the column selection is available for this format.
+	 */
+	public boolean isColumnSelectionEnabled() {
+		return this.columnSelection;
+	}
+
+	/**
+	 * Decide whether the file meets the requierements - has the correct extension
+	 * or it is in fact a directory.
+	 */
+	@Override
+	public boolean accept(File file) {
+		if( file != null) {
+			if(file.isDirectory()) return true;
+			String name = file.getName() ;
+			int dot = name.lastIndexOf(&quot;.&quot;);
+			if(dot &lt; 0) return false;
+			if(extensions.contains( name.substring(dot) )) return true;
+		}
+		return false;
+	}
+
+	/**
+	 * @return The description of the format.
+	 */
+	@Override
+	public String getDescription() {
+		return description;
+	}
+	
+	/**
+	 * Decide whether the file already has a valid extension.
+	 * A valid extension is an extension that belongs to
+	 * the list of extensions of this format.
+	 * 
+	 * @param file	The file to be tested.
+	 * @return	True if the file has a valid extension of this format.
+	 */
+	public boolean hasExtension(File file) {
+		int dot = file.getName().lastIndexOf(&quot;.&quot;);
+		if(dot &lt; 0) return false;
+		if(extensions.contains( file.getName().substring(dot) )) return true;
+		return false;
+	}
+	
+	/**
+	 * Suggest the name for a file based on the list of extensions.
+	 * If the file already has an extension, the name is not changed.
+	 * An extension is added, if the file has not a valid extension. 
+	 * 
+	 * @param file	The file the name will be derived from.
+	 * @return The suggested name for this file.
+	 * @see net.sf.plantlore.client.export.component.XFilter#hasExtension(File)
+	 */
+	public String suggestName(File file) {
+		if(hasExtension(file)) return file.getName();
+		else return file.getName() + extensions.get(0);
+	}
+	
+}
\ No newline at end of file

Added: trunk/src/net/sf/plantlore/client/export/component/XNode.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XNode.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/component/XNode.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,43 @@
+package net.sf.plantlore.client.export.component;
+
+/**
+ * A representation of a node in an XTree.
+ * Every node corresponds to a &lt;code&gt;column&lt;/code&gt; of a &lt;code&gt;table&lt;/code&gt;.
+ *  
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @see net.sf.plantlore.client.export.component.XTree
+ */
+public class XNode {
+	/** The table whose columns this node represents. */
+	public Class table;
+	/** The column of the table this node represents. */
+	public String column;
+	/** Is it a not-null property in the database? */
+	public boolean nn;
+	
+	/**
+	 * Create a new XNode. The node represents 
+	 * a (possibly mandatory) column of a table.
+	 */
+	public XNode(Class table, String column, boolean notNullProperty) {
+		this.table = table; nn = notNullProperty; this.column = column;
+	}
+	
+	/**
+	 * Create a new XNode. The node represents a column of a table.
+	 */
+	public XNode(Class table, String column) {
+		this(table, column, false);
+	}
+	
+	/**
+	 * Get the name of the column.
+	 * TODO: L10n may be useful here!
+	 */
+	@Override
+	public String toString() {
+		return column == null ? table.getSimpleName() :  column;
+	}
+}
\ No newline at end of file

Added: trunk/src/net/sf/plantlore/client/export/component/XTree.java
===================================================================
--- trunk/src/net/sf/plantlore/client/export/component/XTree.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/client/export/component/XTree.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,386 @@
+package net.sf.plantlore.client.export.component;
+
+import java.awt.Color;
+import java.awt.Component;
+
+
+import javax.swing.JLabel;
+import javax.swing.tree.*;
+
+import net.sf.plantlore.common.record.*;
+
+/**
+ * The extension of a JTree that allows the User to see the database model
+ * in a compact form. The tree expects the database hierarchy when it's created.
+ * Two default hierarchies are already present - the &lt;code&gt;DefaultHierarchy&lt;/code&gt;
+ * which is loaded when no other hierarchy is specified and displays the database
+ * model in the hierarchy, 
+ * and the &lt;code&gt;SimpleHierarchy&lt;/code&gt; which is a simplified version with
+ * all tables as sub-root nodes.
+ * Both hierarchies are hard-wired and must be updated if the database
+ * model changes!
+ * &lt;br/&gt;
+ * The selected nodes are visualized to the User in another colour.
+ * Collapsing a node &lt;b&gt;will cause&lt;/b&gt; deselection of all of its selected
+ * sub-nodes. This is a feature that will prevent the User from selecting
+ * a group of columns and forgeting about them. 
+ * &lt;br/&gt;
+ * The XTree uses instances of XNode class - that is, the label of the
+ * node is derived from the XNode.toString(). Should you have a desire
+ * to implement the L10N, modify that method appropriatelly.
+ * &lt;br/&gt;
+ * The XTree cannot produce a Template - in order to create and update 
+ * the Template &quot;automatically&quot; create your own TreeSelectionModel
+ * that is capable of such an action. 
+ * &lt;pre&gt;
+ * XTree tree = new XTree( );
+ * tree.setSelectionModel( new YSelectionModel() );
+ * &lt;/pre&gt;
+ * where
+ * &lt;pre&gt;
+ * class TemplateSelectionModel extends DefaultTreeSelectionModel {
+ * 		private Template template;
+ * 
+ *		// Use this to achieve compatibility with the default XTree selection model.
+ *		@Override 
+ *		public void setSelectionPath(TreePath path) {
+ *			if( isPathSelected(path) )
+ *				removeSelectionPath(path);
+ *			else
+ *				addSelectionPath(path);
+ *		}
+ *		@Override 
+ *		public void removeSelectionPaths(TreePath[] paths) {
+ *			for(TreePath path : paths) {
+ *				XNode x  = (XNode) 
+ *					((DefaultMutableTreeNode)path.getLastPathComponent())
+ *					.getUserObject();
+ *				template.unset(x.table, x.column);    // update the Template 
+ *			} 
+ *			super.removeSelectionPaths( paths ); 
+ *		}
+ *		@Override 
+ *		public void addSelectionPaths(TreePath[] paths) {
+ *			// ...similar...
+ *		}
+ * }
+ * &lt;/pre&gt;
+ *   
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ * @version 1.0
+ * @see net.sf.plantlore.client.export.Template
+ * @see net.sf.plantlore.client.export.ExportMng.XSelectionModel
+ */
+public class XTree extends javax.swing.JTree {
+	
+	private static Color NotNullColor = new Color(220, 50, 20);
+	private static Color SelectedColor = new Color(20, 150, 20);
+	private static Color DefaultColor = Color.BLACK;
+	
+	
+	/**
+	 * The Default Hierarchy Model of the Database Model.
+	 */
+	public static Object[] DefaultHierarchy = {
+		new XNode(XTree.class, &quot;Plantlore DB&quot;),
+		new Object[] { // OCCURENCE
+			new XNode(Occurrence.class, null),
+			new XNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new XNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new Object[] { // HABITAT
+				new XNode(Habitat.class, null),
+				new Object[] { // TERRITORY
+					new XNode(Territory.class, null),
+					new XNode(Territory.class, Territory.NAME, true)
+				},
+				new Object[] { // PHYTOCHORION
+					new XNode(Phytochorion.class, null),
+					new XNode(Phytochorion.class, Phytochorion.CODE, true),
+					new XNode(Phytochorion.class, Phytochorion.NAME, true),
+				},
+				new XNode(Habitat.class, Habitat.QUADRANT),
+				new XNode(Habitat.class, Habitat.DESCRIPTION),
+				new Object[] { // NEAREST VILLAGE
+					new XNode(Village.class, null),
+					new XNode(Village.class, Village.NAME, true)
+				},
+				new XNode(Habitat.class, Habitat.COUNTRY),
+				new XNode(Habitat.class, Habitat.ALTITUDE),
+				new XNode(Habitat.class, Habitat.LATITUDE),
+				new XNode(Habitat.class, Habitat.LONGITUDE),
+				new XNode(Habitat.class, Habitat.NOTE),
+			},
+			new Object[] { // PLANT
+				new XNode(Plant.class, null),
+				new XNode(Plant.class, Plant.SURVEYTAXID, true),
+				new XNode(Plant.class, Plant.TAXON, true),
+				new XNode(Plant.class, Plant.GENUS),
+				new XNode(Plant.class, Plant.SPECIES),
+				new XNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR, true),
+				new XNode(Plant.class, Plant.CZECHNAME),
+				new XNode(Plant.class, Plant.SYNONYMS),
+				new XNode(Plant.class, Plant.NOTE)
+			},
+			new XNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new XNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new XNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new XNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new XNode(Occurrence.class, Occurrence.DATASOURCE),
+			new Object[] { // PUBLICATION
+				new XNode(Publication.class, null),
+				new XNode(Publication.class, Publication.COLLECTIONNAME),
+				new XNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+				new XNode(Publication.class, Publication.JOURNALNAME),
+				new XNode(Publication.class, Publication.JOURNALAUTHORNAME),
+				new XNode(Publication.class, Publication.REFERENCECITATION, true),
+				new XNode(Publication.class, Publication.REFERENCEDETAIL),
+				new XNode(Publication.class, Publication.URL),
+				new XNode(Publication.class, Publication.NOTE)
+			},
+			new XNode(Occurrence.class, Occurrence.HERBARIUM),
+			new XNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new XNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new XNode(Occurrence.class, Occurrence.NOTE),
+			new Object[] { // METADATA
+				new XNode(Metadata.class, null),
+				new XNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+				new XNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+				new XNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+				new XNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+				new XNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+				new XNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+				new XNode(Metadata.class, Metadata.DATASETTITLE, true),
+				new XNode(Metadata.class, Metadata.DATASETDETAILS),
+				new XNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+				new XNode(Metadata.class, Metadata.SOURCEID, true),
+				new XNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+				new XNode(Metadata.class, Metadata.DATECREATE, true),
+				new XNode(Metadata.class, Metadata.DATEMODIFIED, true),
+				new XNode(Metadata.class, Metadata.RECORDBASIS),
+				new XNode(Metadata.class, Metadata.BIOTOPETEXT),
+				new XNode(Metadata.class, Metadata.VERSIONPLANTSFILE)
+			}
+		},
+		new Object[] { // AUTHOR
+			new XNode(Author.class, null),
+			new XNode(Author.class, Author.WHOLENAME),
+			new XNode(Author.class, Author.ORGANIZATION),
+			new XNode(Author.class, Author.PHONENUMBER),
+			new XNode(Author.class, Author.ROLE),
+			new XNode(Author.class, Author.ADDRESS),
+			new XNode(Author.class, Author.EMAIL),
+			new XNode(Author.class, Author.URL),
+			new XNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new XNode(AuthorOccurrence.class, null),
+			new XNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new XNode(AuthorOccurrence.class, AuthorOccurrence.RESULTREVISION)
+		}
+	};
+	
+	/**
+	 * A simplified Hierarchy Model of the Database Model. 
+	 */
+	public static Object[] SimpleHierarchy = new Object[] {
+		new XNode(XTree.class, &quot;Plantlore DB&quot;),
+		new Object[] { // OCCURENCE
+			new XNode(Occurrence.class, null),
+			new XNode(Occurrence.class, Occurrence.UNITIDDB, true),
+			new XNode(Occurrence.class, Occurrence.UNITVALUE, true),
+			new XNode(Occurrence.class, Occurrence.YEARCOLLECTED, true),
+			new XNode(Occurrence.class, Occurrence.MONTHCOLLECTED),
+			new XNode(Occurrence.class, Occurrence.DAYCOLLECTED),
+			new XNode(Occurrence.class, Occurrence.TIMECOLLECTED),
+			new XNode(Occurrence.class, Occurrence.DATASOURCE),
+			new XNode(Occurrence.class, Occurrence.HERBARIUM),
+			new XNode(Occurrence.class, Occurrence.CREATEDWHEN, true),
+			new XNode(Occurrence.class, Occurrence.UPDATEDWHO, true),
+			new XNode(Occurrence.class, Occurrence.NOTE)
+		},
+		new Object[] { // TERRITORY
+			new XNode(Territory.class, null),
+			new XNode(Territory.class, Territory.NAME, true)
+		},
+		new Object[] { // PHYTOCHORION
+			new XNode(Phytochorion.class, null),
+			new XNode(Phytochorion.class, Phytochorion.CODE, true),
+			new XNode(Phytochorion.class, Phytochorion.NAME, true),
+		},
+		new Object[] { // NEAREST VILLAGE
+			new XNode(Village.class, null),
+			new XNode(Village.class, Village.NAME, true)
+		},
+		new Object[] { // HABITAT
+			new XNode(Habitat.class, null),
+			new XNode(Habitat.class, Habitat.QUADRANT),
+			new XNode(Habitat.class, Habitat.DESCRIPTION),
+			new XNode(Habitat.class, Habitat.COUNTRY),
+			new XNode(Habitat.class, Habitat.ALTITUDE),
+			new XNode(Habitat.class, Habitat.LATITUDE),
+			new XNode(Habitat.class, Habitat.LONGITUDE),
+			new XNode(Habitat.class, Habitat.NOTE)
+		},
+		new Object[] { // PLANT
+			new XNode(Plant.class, null),
+			new XNode(Plant.class, Plant.SURVEYTAXID, true),
+			new XNode(Plant.class, Plant.TAXON, true),
+			new XNode(Plant.class, Plant.GENUS),
+			new XNode(Plant.class, Plant.SPECIES),
+			new XNode(Plant.class, Plant.SCIENTIFICNAMEAUTHOR, true),
+			new XNode(Plant.class, Plant.CZECHNAME),
+			new XNode(Plant.class, Plant.SYNONYMS),
+			new XNode(Plant.class, Plant.NOTE)
+		},
+		new Object[] { // PUBLICATION
+			new XNode(Publication.class, null),
+			new XNode(Publication.class, Publication.COLLECTIONNAME),
+			new XNode(Publication.class, Publication.COLLECTIONYEARPUBLICATION),
+			new XNode(Publication.class, Publication.JOURNALNAME),
+			new XNode(Publication.class, Publication.JOURNALAUTHORNAME),
+			new XNode(Publication.class, Publication.REFERENCECITATION, true),
+			new XNode(Publication.class, Publication.REFERENCEDETAIL),
+			new XNode(Publication.class, Publication.URL),
+			new XNode(Publication.class, Publication.NOTE)
+		},
+		new Object[] { // METADATA
+			new XNode(Metadata.class, null),
+			new XNode(Metadata.class, Metadata.TECHNICALCONTACTNAME, true),
+			new XNode(Metadata.class, Metadata.TECHNICALCONTACTEMAIL),
+			new XNode(Metadata.class, Metadata.TECHNICALCONTACTADDRESS),
+			new XNode(Metadata.class, Metadata.CONTENTCONTACTNAME, true),
+			new XNode(Metadata.class, Metadata.CONTENTCONTACTEMAIL),
+			new XNode(Metadata.class, Metadata.CONTENTCONTACTADDRESS),
+			new XNode(Metadata.class, Metadata.DATASETTITLE, true),
+			new XNode(Metadata.class, Metadata.DATASETDETAILS),
+			new XNode(Metadata.class, Metadata.SOURCEINSTITUTIONID, true),
+			new XNode(Metadata.class, Metadata.SOURCEID, true),
+			new XNode(Metadata.class, Metadata.OWNERORGANIZATIONABBREV),
+			new XNode(Metadata.class, Metadata.DATECREATE, true),
+			new XNode(Metadata.class, Metadata.DATEMODIFIED, true),
+			new XNode(Metadata.class, Metadata.RECORDBASIS),
+			new XNode(Metadata.class, Metadata.BIOTOPETEXT),
+			new XNode(Metadata.class, Metadata.VERSIONPLANTSFILE)
+		},
+		new Object[] { // AUTHOR
+			new XNode(Author.class, null),
+			new XNode(Author.class, Author.WHOLENAME),
+			new XNode(Author.class, Author.ORGANIZATION),
+			new XNode(Author.class, Author.PHONENUMBER),
+			new XNode(Author.class, Author.ROLE),
+			new XNode(Author.class, Author.ADDRESS),
+			new XNode(Author.class, Author.EMAIL),
+			new XNode(Author.class, Author.URL),
+			new XNode(Author.class, Author.NOTE)
+		},
+		new Object[] { // AUTHOR-OCCURENCE
+			new XNode(AuthorOccurrence.class, null),
+			new XNode(AuthorOccurrence.class, AuthorOccurrence.ROLE),
+			new XNode(AuthorOccurrence.class, AuthorOccurrence.RESULTREVISION)
+		}
+	};
+	
+	/**
+	 * Create a new XTree with the Default Hierarchy Model.
+	 */
+	public XTree( ) {
+		this( DefaultHierarchy );
+	}
+	
+	
+	/**
+	 * Create a new XTree with a specified Hierarchy Model.
+	 * @param hierarchy The hierarchy to be processed.
+	 */
+	public XTree( Object[] hierarchy ) {
+		super( processHierarchy(hierarchy) );
+		
+	    setCellRenderer( new XCellRenderer() );
+	    setToggleClickCount(1);
+	    setSelectionModel( new XSelectionModel() );
+	}
+	
+	
+	/**
+	 * A modified selection model. A single click will 
+	 * add a leaf to the current selection.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-04-29
+	 */	
+	public class XSelectionModel extends DefaultTreeSelectionModel {
+		
+		@Override 
+		public void setSelectionPath(TreePath path) {
+			if( isPathSelected(path) )
+				removeSelectionPath(path);
+			else
+				addSelectionPath(path);
+		}
+	}
+	
+	
+	/**
+	 * SPecialized Cell Renderer that shows no icons and
+	 * displayes mandatory columns with a different coulour.
+	 * 
+	 * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+	 * @since 2006-04-29
+	 */
+	protected class XCellRenderer extends DefaultTreeCellRenderer {
+		
+		public XCellRenderer() {
+			setOpenIcon(null); 
+		    setClosedIcon(null); 
+		    setLeafIcon(null);
+		}
+		
+		@Override
+		public Component getTreeCellRendererComponent(
+				javax.swing.JTree tree, 
+				Object value, 
+				boolean selected, 
+				boolean expanded, 
+				boolean leaf, 
+				int row, 
+				boolean hasFocus) {
+			// Let the default implementation handle the drawing.
+			JLabel label =  (JLabel) 
+				super.getTreeCellRendererComponent(tree, value, false, expanded, leaf, row, false);
+			// Modify the result of the predecessor.
+			if( selected &amp;&amp; leaf ) 
+				label.setForeground( SelectedColor );
+			else
+				if( ((XNode)((DefaultMutableTreeNode)value).getUserObject()).nn )
+					label.setForeground( NotNullColor );
+				else 
+					label.setForeground( DefaultColor );
+			return label;
+		}
+	}
+	
+	
+	
+	/**
+	 * Transform the simple Object[] hierarchy into an internal representation 
+	 * of the JTree.
+	 * @param hierarchy The hierarchy to be converted.
+	 * @return The root of the transformed hierarchy.
+	 */
+	private static DefaultMutableTreeNode processHierarchy(Object[] hierarchy) {
+		DefaultMutableTreeNode node = new DefaultMutableTreeNode(hierarchy[0]);
+		DefaultMutableTreeNode child;
+		for (int i = 1; i &lt; hierarchy.length; i++) {
+			Object nodeSpecifier = hierarchy[i];
+			if (nodeSpecifier instanceof Object[]) // Ie node with children
+				child = processHierarchy((Object[]) nodeSpecifier);
+			else
+				child = new DefaultMutableTreeNode(nodeSpecifier); // Ie Leaf
+			node.add(child);
+		}
+		return (node);
+	}
+	
+
+}

Modified: trunk/src/net/sf/plantlore/common/AutoComboBox.java
===================================================================
--- trunk/src/net/sf/plantlore/common/AutoComboBox.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/common/AutoComboBox.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -1,16 +1,12 @@
 package net.sf.plantlore.common;
 
-import java.awt.BorderLayout;
 import java.awt.event.FocusEvent;
 import java.awt.event.FocusListener;
 import java.awt.event.KeyEvent;
 import java.awt.event.KeyListener;
 
-import javax.swing.JButton;
 import javax.swing.JComboBox;
-import javax.swing.JFrame;
 import javax.swing.JTextField;
-import javax.swing.UIManager;
 import javax.swing.text.AttributeSet;
 import javax.swing.text.BadLocationException;
 import javax.swing.text.PlainDocument;
@@ -37,7 +33,7 @@
  * record &quot;------&quot; or &quot;not specified&quot; instead.
  * 
  * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
- * @version 1.1
+ * @version 1.1 jlist doesn't get updated when the user types
  * @since The beginning of time.
  */
 public class AutoComboBox extends JComboBox {
@@ -45,10 +41,8 @@
 	protected boolean allowNew = false;
 	protected int capacity = 32;
 	
-	private Object last;
+
 	
-	
-	
 
 	/**
 	 * Create the AutoComboBox with given array of choices.
@@ -113,7 +107,6 @@
 							super.remove(0, getLength());
 							super.insertString(0, item.substring(0, prefix.length()), null); // rewrite the text
 							noMatch = false;
-							last = getItemAt(i);
 							break;
 						}
 					}
@@ -151,22 +144,4 @@
 	}
 
 	
-/* ================================================================================== */
-	public static void main(String[] args) {
-		String lookAndFeel = UIManager.getSystemLookAndFeelClassName();
-        try { UIManager.setLookAndFeel(lookAndFeel); }
-        catch (Exception e) { JFrame.setDefaultLookAndFeelDecorated(true); }
-		
-		JFrame f = new JFrame();
-		//String[] ch = { &quot;Daniel Jackson&quot;, &quot;Etrachlorethylen&quot;, &quot;Jack O'Neill&quot;, &quot;Samantha Carter&quot;, &quot;Tetrachlorethylen&quot;, &quot;Tetraethylen&quot;, &quot;Thor&quot;, &quot;Ty'alc&quot; };
-		String[] ch = new String[1000];
-		for(int i = 0; i &lt; 1000; i++) ch[i] = Integer.toBinaryString(i);
-		
-		f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
-		f.getContentPane().add(new AutoComboBox(ch), BorderLayout.NORTH);
-		f.getContentPane().add(new JButton(&quot;Done&quot;), BorderLayout.SOUTH);
-		f.pack();
-		f.setVisible(true);
-	}
-
 }

Modified: trunk/src/net/sf/plantlore/common/Selection.java
===================================================================
--- trunk/src/net/sf/plantlore/common/Selection.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/common/Selection.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -20,16 +20,37 @@
 	private boolean inverted = false;
 	
 	/**
-	 * Add another record to the selection.
+	 * Create a new empty selection.
+	 */
+	public Selection() {}
+	
+	/**
+	 * Create a new selection containing the same records 
+	 * as the other &lt;code&gt;selection&lt;/code&gt;
+	 * @param selection The selection to duplicate.
+	 */
+	public Selection(Selection selection) {
+		selected = new HashSet&lt;Integer&gt;( selection.selected );
+		inverted = selection.inverted;
+	}
+	
+	/**
+	 * Add another record to the selection. 
 	 * @param id	The primary key of the record.
 	 */
-	public void add(Integer id) { selected.add(id); }
+	public void add(Integer id) {
+		if( !inverted ) selected.add(id);
+		else selected.remove(id);
+	}
 		
 	/**
 	 * Remove a selected record from the selection (deselect).
 	 * @param id Of the record that is deselected.
 	 */
-	public void remove(Integer id) { selected.remove(id); }
+	public void remove(Integer id) {
+		if( !inverted ) selected.remove(id);
+		else selected.add(id);
+	}
 	
 	/**
 	 * Invert the current selection.
@@ -57,5 +78,25 @@
 	 * @return true if the record is selected.
 	 */
 	public boolean contains(Record r) { return selected.contains(r.getId()) ^ inverted; }
+	
+	/**
+	 * @param total The number of all records (from which the selection is made).
+	 * @return The number of selected records.
+	 */
+	public int size(int total) {
+		return inverted ? total - selected.size() : selected.size();
+	}
+	
+	/**
+	 * @return true if nothing is selected;
+	 */
+	public boolean isEmpty() {
+		return selected.isEmpty() ^ inverted;
+	}
+	
+	@Override
+	public Selection clone() {
+		return new Selection( this );
+	}
 
 }

Added: trunk/src/net/sf/plantlore/common/exception/DBLayerException.java
===================================================================
--- trunk/src/net/sf/plantlore/common/exception/DBLayerException.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/common/exception/DBLayerException.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,13 @@
+package net.sf.plantlore.common.exception;
+
+/**
+ * An exception thrown every time something in the database layer
+ * (DBLayer) went wrong.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ *
+ */
+public class DBLayerException extends PlantloreException {
+
+}

Added: trunk/src/net/sf/plantlore/common/exception/ExportException.java
===================================================================
--- trunk/src/net/sf/plantlore/common/exception/ExportException.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/common/exception/ExportException.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,22 @@
+package net.sf.plantlore.common.exception;
+
+/**
+ * An exception thrown every time something during the export
+ * went wrong - typically when some variables are not initialized
+ * properly and the export cannot start the execution.
+ * &lt;br/&gt;
+ * This exception is &lt;b&gt;not&lt;/b&gt; thrown if anything goes wrong with the
+ * output (not enough disk space, insufficient permissions). 
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ *
+ */
+public class ExportException extends PlantloreException {
+	
+	public ExportException() { super(); }
+	
+	public ExportException(String message) { super(message); }
+	
+
+}

Added: trunk/src/net/sf/plantlore/common/exception/PlantloreException.java
===================================================================
--- trunk/src/net/sf/plantlore/common/exception/PlantloreException.java	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/common/exception/PlantloreException.java	2006-04-30 12:28:09 UTC (rev 197)
@@ -0,0 +1,19 @@
+package net.sf.plantlore.common.exception;
+
+import java.io.Serializable;
+
+/**
+ * A common ancestor of all exceptions thrown by Plantlore.
+ * The ancestor is Serializable so as to be able to travel
+ * through the RMI framework.
+ * 
+ * @author Erik Kratochv&#237;l (<A HREF="https://lists.berlios.de/mailman/listinfo/plantlore-dev">discontinuum at gmail.com</A>)
+ * @since 2006-04-29
+ *
+ */
+public class PlantloreException extends Exception implements Serializable {
+
+	public PlantloreException() { super(); }
+
+	public PlantloreException(String message) { super(message); }
+}

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-04-30 01:28:13 UTC (rev 196)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-04-30 12:28:09 UTC (rev 197)
@@ -207,6 +207,19 @@
 Database = Database
 Change = Change
 
+# EXPORT | IMPORT
+FilterPlantloreNative = Plantlore native (for future import)
+FilterXML = Extensible Markup Language (XML)
+FilterCSV = Comma Separated Value (CSV)
+FilterABCD = ABCD Schema native
+FilterDC = DarwinCore native
+FilterConsole = Console output
+
+Export = Export
+
+ExportColumns = Select columns you want to export
+
+
 Next = &amp;Next
 Refresh = &amp;Refresh
 RefreshTT = Reload the list of the connected clients.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000220.html">[Plantlore-dev] Ako pouzivat help
</A></li>
	<LI>Next message: <A HREF="000222.html">[Plantlore-dev] r198 - trunk/src/net/sf/plantlore/l10n
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#221">[ date ]</a>
              <a href="thread.html#221">[ thread ]</a>
              <a href="subject.html#221">[ subject ]</a>
              <a href="author.html#221">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
