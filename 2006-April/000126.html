<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r123 - trunk/src/net/sf/plantlore/client/history
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r123%20-%20trunk/src/net/sf/plantlore/client/history&In-Reply-To=%3C200604102004.k3AK47pq008200%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000125.html">
   <LINK REL="Next"  HREF="000127.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r123 - trunk/src/net/sf/plantlore/client/history</H1>
    <B>Lada at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r123%20-%20trunk/src/net/sf/plantlore/client/history&In-Reply-To=%3C200604102004.k3AK47pq008200%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r123 - trunk/src/net/sf/plantlore/client/history">Lada at berlios.de
       </A><BR>
    <I>Mon Apr 10 22:04:07 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000125.html">[Plantlore-dev] plantlore
</A></li>
        <LI>Next message: <A HREF="000127.html">[Plantlore-dev] r124 - trunk/src/net/sf/plantlore/common/record
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#126">[ date ]</a>
              <a href="thread.html#126">[ thread ]</a>
              <a href="subject.html#126">[ subject ]</a>
              <a href="author.html#126">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: Lada
Date: 2006-04-10 22:04:03 +0200 (Mon, 10 Apr 2006)
New Revision: 123

Modified:
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
Log:
Update History - clever marking, overwrite function for Undo + finish programing Undo.

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-04-10 19:22:55 UTC (rev 122)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-04-10 20:04:03 UTC (rev 123)
@@ -4,10 +4,16 @@
 package net.sf.plantlore.client.history;
 
 import java.rmi.RemoteException;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Calendar;
 import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.HashSet;
 import java.util.Hashtable;
 import java.util.Observable;
+import java.util.Set;
 
 import net.sf.plantlore.l10n.L10n;
 import net.sf.plantlore.middleware.DBLayer;
@@ -43,7 +49,7 @@
     /** Instance of a database management object */
     private DBLayer database;   
     /** Constant with default number of rows to display */
-    private static final int DEFAULT_DISPLAY_ROWS = 2;    
+    private static final int DEFAULT_DISPLAY_ROWS = 6;    
     /** Actual number of rows to display */
     private int displayRows = DEFAULT_DISPLAY_ROWS;   
     /** Index of the first record shown in the table */
@@ -54,12 +60,23 @@
     //*******Informations about searching Result from database*****//
     /** Result of the search query */
     private int resultId = 0;
-    /** Data (results of a search query) displayed in the table */
-    private Object[][] editHistoryData;
     /** List of data (results of a search query) displayed in the table */
-    private ArrayList&lt;HistoryRecord&gt; editHistoryDataList;
+    private ArrayList&lt;HistoryRecord&gt; editHistoryDataList = new ArrayList();    
+    //seznam id vsech oznacenych polozek
+    private HashSet markListId = new HashSet();
+    //Seznam Item + maxIdItem (nejstarsi oznacene id pro dany Item=sloupec)
+    private ArrayList&lt;Object[]&gt; markItem = new ArrayList();
+    //Informuje o tom, zda byla zvolena volba &quot;SelectAll&quot;
+    private boolean selectAll;
+    //Informuje o tom zda exituje pro dany nalez vazba 1:1 mezi tabulkami tHabitats a tOccurrences
+    private boolean relationship;
+    //Informuje o tom zda doslo k editaci polozky z tabulky tHabitat
+    private boolean editHabitat;
+    //zprava pro uzivatele
+    private String messageUndo;
    
-    //********************* ***************************************//    
+    
+    //*********************Record of history ***************************************//    
     private Occurrence occurrence;
 	private HistoryRecord historyRecord;
 	private HistoryChange historyChange;
@@ -76,7 +93,7 @@
 	/**Unique value identified record before changed */
 	private int oldRecordId;
 	/** Operation whitch was used*/   
-	private String operation;
+	private int operation;
 	/** Date and time when the reccord was changed*/
 	private java.util.Date when = new Date();	
 	/** Old value of attribute*/    
@@ -85,7 +102,7 @@
 	private String newValue;
    /** Name of user who did changed*/
 	private String nameUser;
-
+	
 	//**************Informations about occurrences***************//
 	/** Name of plant for specified occurrenc*/
 	private String namePlant;
@@ -96,9 +113,9 @@
 	
 	 //********************************************************//
 	 /** Mapping of entities */
-     private Hashtable&lt;String, Integer&gt; publicationHash;
-     private Hashtable&lt;String, Integer&gt; habitatHash;
-     private Hashtable&lt;String, Integer&gt; occurrenceHash;  
+	private Hashtable&lt;String, Integer&gt; publicationHash;
+	private Hashtable&lt;String, Integer&gt; habitatHash;
+	private Hashtable&lt;String, Integer&gt; occurrenceHash;  
     
     /**  
      *  Creates a new instance of History 
@@ -110,7 +127,7 @@
     public History(DBLayer database, String namePlant, String nameAuthor, String location, int idOcc)
     {
        logger = Logger.getLogger(this.getClass().getPackage().getName());	 
-       this.database = database;	
+       this.database = database;       
        
  /*
   *  v konstruktoru se bude predavat reference na OCCURRENCE pro ktery je vyvolana
@@ -173,7 +190,8 @@
  *     ...musit to byt retezec autoru - muze jich byt vice
  *     ...v historii se editace autoru zaznamenavat nebude 
  */       
-              	   
+        
+       
        //Searching for information about data entries concerned with specified occurrence
        searchInsertInfo();
 	   //Searching for information about data editing concerned with specified occurrence
@@ -183,8 +201,7 @@
     }	
 
     /**
-     *  Searches for information about data entries concerned with specified occurrence.
-     *  @param idOccurrence Unique value identified occurrence
+     *  Searches for information about data entries concerned with specified occurrence.   
      */
     public void searchInsertInfo() {
             
@@ -204,13 +221,11 @@
            resultIdInsert = database.executeQuery(query);        
        } catch (DBLayerException e) {
            // Log and set an error                   
-           logger.error(&quot;Searching history (inserting) failed. Unable to execute search query.&quot;);
-           //setError(e);
-           // setError(&quot;Searching history failed. Please contact your administrator.&quot;);
+           logger.error(&quot;Searching history data with condition 'operation = insert' failed. Unable to execute search query.&quot;);          
        } catch (RemoteException e) {		 
     	   System.err.println(&quot;RemoteException- searchInsertInfo(), executeQuery&quot;);
 	} finally {
-    	   logger.debug(&quot;Searching history (inserting) ends successfully&quot;);
+    	   logger.debug(&quot;Searching history data with condition 'operation = insert' ends successfully&quot;);
            // Save &quot;insert&quot; history data
            setInsertResult(resultIdInsert);                    
        }              
@@ -218,8 +233,7 @@
     
     
     /**     
-     * Searches for information about data editing concerned with specified occurrence.
-     * @param idOccurrence Unique value identified occurrence
+     * Searches for information about data editing concerned with specified occurrence. 
      */
      
     public void searchEditHistory()
@@ -236,8 +250,8 @@
 		}
         // Create aliases for table tHistoryChange.      
         query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);        
-        // Add restriction to CUNITVALUE column of tOccurence table
-        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.operation&quot;, null, HistoryChange.HISTORYCHANGE_EDIT, null);
+        // Add restriction to COPERATION column of tJistoryChange table
+        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.operation&quot;, null, HistoryChange.HISTORYCHANGE_EDIT, null);        
         query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.occurrence&quot;, null, occurrence, null);    	
         query.addOrder(PlantloreConstants.DIRECT_DESC, &quot;hc.when&quot;);        
     	
@@ -247,19 +261,16 @@
             resultIdEdit = database.executeQuery(query);        
         } catch (DBLayerException e) {
             // Log and set an error                   
-            logger.error(&quot;Searching history (editing) failed. Unable to execute search query.&quot;);
-            //setError(e);
-            // setError(&quot;Searching history failed. Please contact your administrator.&quot;);
+            logger.error(&quot;Searching history data with condition 'operation = edit' failed. Unable to execute search query.&quot;);           
         } catch (RemoteException e) { 		   
-     	   System.err.println(&quot;RemoteException- searchInsertInfo(), executeQuery&quot;);
+     	   System.err.println(&quot;RemoteException- searchEditHistory(), executeQuery&quot;);
 	 	} finally {
-	 		logger.debug(&quot;Searching history (editing) ends successfully&quot;);
+	 		logger.debug(&quot;Searching history data with condition 'operation = edit' ends successfully&quot;);
         	// Save &quot;edit&quot; history data
             setEditResult(resultIdEdit);                  
 	 	}              
     }
     
-
     
     /**     
      * Sets information about data (date, name of user) entries concerned with specified occurrence 
@@ -267,9 +278,8 @@
      */
     public void setInsertResult(int resultIdInsert) {
    	    	
-    	if (getResultRows() &gt; 1) {
-    		// Log an error                   
-            logger.error(&quot;Too many results for inserting query.&quot;);  
+    	if (getResultRows() &gt; 1) {                
+            logger.error(&quot;Too many results for searching insert operation.&quot;);  
     	}
             	
     	logger.debug(&quot;Retrieving query results.&quot;); 
@@ -278,26 +288,21 @@
         	 // Retrieve selected row interval         	
          	try {
          		objectHistory = database.more(resultIdInsert, 1, 1);  
-         	} catch(RemoteException e) {
-             	System.err.println(&quot;RemoteException- setInsertResult, more&quot;);
+         	} catch(RemoteException e) {             	
              	logger.debug(&quot;RemoteException- setInsertResult, more&quot;);
              	return;
              }   
          	Object[] objHis = (Object[])objectHistory[0]; 
-         	//setWhen(((HistoryChange)objHis[0]).getWhen());
-         	//setNameUser(((HistoryChange)objHis[0]).getWho().getWholeName());
-         	
-            this.when = ((HistoryChange)objHis[0]).getWhen();
-            this.nameUser = ((HistoryChange)objHis[0]).getWho().getWholeName();
-           
-        } catch (DBLayerException e) {
-            // Log and set error in case of an exception
+         	setWhen(((HistoryChange)objHis[0]).getWhen());
+         	setNameUser(((HistoryChange)objHis[0]).getWho().getWholeName());         	
+        } catch (DBLayerException e) {         
             logger.error(&quot;Processing search (inserting) results failed: &quot;+e.toString());            
         } finally { 
-        	logger.debug(&quot;Sets 'insert' data ends successfully. When= &quot; + this.when + &quot; &quot;);        	
+        	logger.debug(&quot;Sets 'insert' data ends successfully.&quot;);        	
         }        
     }
     
+    
     /**
      * Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field of the class. 
      * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
@@ -312,11 +317,13 @@
            
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
             int to = Math.min(currentRow, fromTable+count-1);           
-            if (to == 0) {
-                this.editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;();                
+            if (to &lt;= 0) {
+            	editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;(); 
+            	setDisplayRows(0);
+            	setCurrentDisplayRows(&quot;0-0&quot;);
             } else {
                 logger.debug(&quot;Retrieving query results: 1 - &quot;+to);
-                setCurrentDisplayRow(fromTable+ &quot;-&quot; + to);
+                setCurrentDisplayRows(fromTable+ &quot;-&quot; + to);
                 try {                	 
                      // Retrieve selected row interval 
                 	Object[] objectHistory;
@@ -336,8 +343,7 @@
 						Object[] objHis = (Object[])objectHistory[i];
                         this.editHistoryDataList.add((HistoryRecord)objHis[0]);
                     }                     
-                } catch (DBLayerException e) {
-                    // Log an error in case of an exception
+                } catch (DBLayerException e) {                  
                     logger.error(&quot;Processing search results failed: &quot;+e.toString());            
                 } finally { 
                 	logger.debug(&quot;Sets 'edit' data ends successfully&quot;);
@@ -347,77 +353,14 @@
             }
         }         
     }
-    
+       
+
     /**
-     * z db vzdy ziskame vysledek od 1 do &quot;to&quot; - tato funkce nacte data pro zobrazeni 
-     * ve view (data, ktere v dane chvili uvidi uzivatel).  
-     * @return Object[][] with data values for displaying in the table
-     */
-    public Object[][] getData() {
-    	    	
-    	int countResult = editHistoryDataList.size();
-    	int firstRow = getCurrentFirstRow();
-    	int countRow = countResult - firstRow + 1;
-    	int ii = 0;    	
-        editHistoryData = new Object[countRow][6];
-    	for (int i=firstRow-1; i &lt; countResult; i++) {    		
-    		editHistoryData[ii][0] = new Boolean(false);    		
-    	    editHistoryData[ii][1] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWhen();
-    	    editHistoryData[ii][2] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWho().getWholeName();    	   
-    	    editHistoryData[ii][3] = L10n.getString((((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName()));
-    	    editHistoryData[ii][4] = ((HistoryRecord)editHistoryDataList.get(i)).getOldValue();
-    	    editHistoryData[ii][5] = ((HistoryRecord)editHistoryDataList.get(i)).getNewValue();
-    	    ii++;
-    	}  
-    	return this.editHistoryData;
-    	
-    }    
-    
-  
-    /**
      * 
      * @param id
      * @return
      */
-    public int searchHistoryChangeId(int id){
-    	SelectQuery query = null;
-        try {
-        	    query = database.createQuery(HistoryRecord.class);
-        } catch(RemoteException e) {
-        	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
-        }                    
-        // Create aliases for table tHistoryChange.      
-        query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);        
-        // Add restriction to CUNITVALUE column of tOccurence table
-        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
-        
-        int resultIdChange = 0;
-        try {                   
-        	resultIdChange = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- searchHistoryChangeId(), executeQuery&quot;);
- 	    } finally {
-     	   logger.debug(&quot;Searching historyChangeId ends successfully.&quot;);
-        }         
- 	    
- 	    int countResult = 100;
- 	    try {
-			countResult = database.getNumRows(resultIdChange);
-			logger.debug(&quot;SearchHistoryChangeId - Number of result: &quot;+countResult);
-		} catch (RemoteException e) {
-			System.err.println(&quot;RemoteException- searchHistoryChangeId(), getNumRows&quot;);
-		}		
-		return countResult;
-    }
-    
-    /**
-     * 
-     * @param id
-     * @return
-     */
-    public Object[] searchObject(String typeObject, int id, String oldRecordValue) { 
+    public Object[] searchObject(String typeObject, int id) { 
     	
     	SelectQuery query = null;
     	if (typeObject.equals(&quot;Habitat&quot;)){
@@ -433,35 +376,35 @@
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject() - Plant, createQuery&quot;);       	  
             }            
-            query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.TAXON, null, oldRecordValue , null);
-    	}else if (typeObject.equals(&quot;Village&quot;)){
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Publication&quot;)){
     		try {
+            	query = database.createQuery(Publication.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Publication, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Publication.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Village&quot;)){
+    		try {
             	query = database.createQuery(Village.class);	        		        	    
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject()- Village, createQuery&quot;);       	  
             }            
-            query.addRestriction(PlantloreConstants.RESTR_EQ, Village.NAME, null, oldRecordValue, null);
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Village.ID, null, id, null);
     	}  else if  (typeObject.equals(&quot;Territory&quot;)){
     		try {
             	query = database.createQuery(Territory.class);	        		        	    
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject()- Territory, createQuery&quot;);       	  
             }            
-            query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.NAME, null, oldRecordValue , null); 
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.ID, null, id , null); 
     	} else if (typeObject.equals(&quot;Phytochorion&quot;)){
     		try {
             	query = database.createQuery(Phytochorion.class);	        		        	    
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject()- Phytochorion, createQuery&quot;);       	  
             }            
-            query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.NAME, null, oldRecordValue , null);
-    	} else if (typeObject.equals(&quot;PhytochorionCode&quot;)){
-    		try {
-            	query = database.createQuery(Phytochorion.class);	        		        	    
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject()- Phytochorion code, createQuery&quot;);       	  
-            }            
-            query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.CODE, null, oldRecordValue , null);
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.ID, null, id , null);
     	} else {
     		logger.error(&quot;SearchObject() - Incorrect type of object.&quot;);
     	}
@@ -495,73 +438,41 @@
        }     	        
     }
     
+ 
     /**
-     * 
-     *
+     * UNDO - funce projde oznacene zaznamy a nastavi stare hodnoty
+     * Pokud dojde zmenou k ovlivneni vice nalezu, tak o tom informuje uzivatele
      */
-    public void deleteHistoryRecords() {
-    	try {
-			database.executeDelete(historyRecord);
-			logger.debug(&quot;Deleting historyRecord successfully.&quot;);
-		} catch (RemoteException e) {
-			logger.error(&quot;Deleting historyRecord - remoteException. &quot;+e.toString());
-		} catch (DBLayerException e) {
-			logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
-		}
-		int countResult = searchHistoryChangeId(historyRecord.getHistoryChange().getId());
-		if (countResult == 1) {
-			//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
-			try {
-				database.executeDelete(historyChange);
-				logger.debug(&quot;Deleting historyChange successfully.&quot;);
-			} catch (RemoteException e) {
-				logger.error(&quot;Deleting historyChange - remoteException. &quot;+e.toString());
-			} catch (DBLayerException e) {
-				logger.error(&quot;Deleting historyChange failed. &quot;+e.toString());
-			}
-		} else {
-			logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
-		}
-    }
-    
-    /**
-     * Tato funkce bude menit hodnoty v DB (DELETE v historii, zmena v jakekoliv 
-     * tabulce pro kterou se zaznamenava historie) - UNDO
-     * 
-     * bude volana z CTR po stisku klavesy
-     * jako parametr dostane seznam oznacenych zmen, ktere se maji vratit
-     * 
-     * jde o update database :-)
-     */
-    public void updateOlderChanges(ArrayList markResult)
+    public void updateOlderChanges()
     {    	
     	    	
     	//Inicalization of hashTable
     	initOccurrenceHash();
-    	initHabitatHash();
-    	initPublicationHash();   
-    	    	
-    	//number of selected rows
-    	int countMark = markResult.size();
-    	// Index of firt row currently displayed
-    	int indexFirstRow = getCurrentFirstRow();
-    	//List of changed ITEM
-    	ArrayList&lt;String&gt; changedList = new ArrayList&lt;String&gt;();
-    	//take from older record to younger record
-    	for( int i=countMark-1; i &gt;= 0; i--) {    	
-    		logger.debug(&quot;Number of selected row: &quot;+markResult.get(i));
-    		historyRecord = (HistoryRecord)editHistoryDataList.get((Integer)markResult.get(i)+ getCurrentFirstRow()-1);    		
+    	initHabitatHash();    	  
+        	
+    	//number of result
+    	int countResult = getEditResult();
+    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
+    	relationship = false;
+    	editHabitat = false;
+    	
+    	//take from younger record to older record
+    	for( int i=0; i &lt; countResult; i++) {
+    		if (! markListId.contains(i)) {
+    			continue;
+    		}
+    		
+    		//init history data about edit of record
+    		historyRecord = (HistoryRecord)editHistoryDataList.get(i);    		
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();
-    		columnName = historyRecord.getHistoryColumn().getColumnName();
-    		// oldRecordId je defautne nastaveno v databazi na hodnotu 0 !!!    			
+    		columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
 			oldRecordId = historyChange.getOldRecordId();
 			recordId = historyChange.getRecordId();
-			occurrenceId = historyChange.getOccurrence().getId();
+			occurrenceId = historyChange.getOccurrence().getId();		   
+			operation = historyChange.getOperation();
 			oldValue = historyRecord.getOldValue();
-			
-			this.editHistoryDataList.remove((Integer)markResult.get(i)+ getCurrentFirstRow()-1);
-			
+						
     		if (tableName.equals(&quot;Occurrence&quot;)){  
     			if (occurrenceId != recordId){
     				logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
@@ -574,113 +485,97 @@
     	        } else {
     	             columnConstant = 0;
     	        }        	    			
-    			    			
+    			  
+    			//init Calendar    		
+    			Calendar isoDateTime = new GregorianCalendar();
+    			
     			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
     			logger.debug(&quot;ColumnName: &quot;+ columnName);
     			logger.debug(&quot;OldValue: &quot;+ oldValue);    			     			
     			
     			switch (columnConstant) {
 	                case 1: //Taxon  
-	                	//test, zda byla nastavena hodnota pro update pro Taxon 
-	                	// pokud ano, tak se jedna o mladsi zmenu, ktera bude jen smazana z tabulek historie
-	                	if ( ! changedList.contains(&quot;taxon&quot;) ){
-	                		changedList.add(&quot;taxon&quot;);		                		
-                			Object[] object = searchObject(&quot;Plant&quot;,0,&quot;oldValue&quot;);
+	                	if (oldRecordId &gt; 0 ) {
+		                	//Select record Plant where id = oldRocordId 
+		                	Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
 		                	Plant plant = (Plant)object[0];
+		                	//Set old value to attribute plantID
 		                	occurrence.setPlant(plant);
-		                	logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Taxon. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();	                			                		                			                
+		                	logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
+		    			}else {
+		    				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+		    			}
 	                    break;
 	                case 2: //Year	
-	                	if (! changedList.contains(&quot;year&quot;)) {
-	                		changedList.add(&quot;year&quot;);	                		
-		                	occurrence.setYearCollected(Integer.parseInt(oldValue));
-		                	logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
-		                	//Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-	                		Date time = occurrence.getTimeCollected();
-	                		Date isoDateTime = new Date();
-	                		isoDateTime.setDate(occurrence.getDayCollected());
-	                		isoDateTime.setMonth(occurrence.getMonthCollected());
-	                		isoDateTime.setYear(Integer.parseInt(oldValue));	                		
-	                		//occurrence.setIsoDateTimeBegin(isoDateTime);
-	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Year. &quot;);	                		
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();             	
+                	    //Set old value to attribute Year          		
+	                	occurrence.setYearCollected(Integer.parseInt(oldValue));
+	                	logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
+	                	//Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
+                		isoDateTime.setTime(occurrence.getTimeCollected());
+                		isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
+                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
 	                	break;
 	                case 3: //Month 
-	                	if (! changedList.contains(&quot;month&quot;)) {
-	                		changedList.add(&quot;month&quot;);	                		
-	                		occurrence.setMonthCollected(Integer.parseInt(oldValue));
-	                		logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Month. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                	// Set old value to attribute Month 
+                		occurrence.setMonthCollected(Integer.parseInt(oldValue));
+                		logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
+                		// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                		isoDateTime.setTime(occurrence.getTimeCollected());
+                		isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
+                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
 	                    break;
 	                case 4: //Day	                	
-	                	if (! changedList.contains(&quot;day&quot;)) {
-	                		changedList.add(&quot;day&quot;);	                		
-		                	occurrence.setDayCollected(Integer.parseInt(oldValue));
-		                	logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Day. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+                		// Set old value to attribute Day            		
+	                	occurrence.setDayCollected(Integer.parseInt(oldValue));
+	                	logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
+	                	// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+	                	isoDateTime.setTime(occurrence.getTimeCollected());
+                		isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
+                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
 	                	break;
-	                case 5: //Time 	                	
-	                	if (! changedList.contains(&quot;time&quot;)) {
-	                		changedList.add(&quot;time&quot;);
-	                		//hodnota se bude muset rozdelit na hodiny:minuty:sekundy a pak se ulozit pomoci get a set metod pro Date
-		                	//occurrence.setTimeCollected(Integer.parseInt(oldValue));
-	                		logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Time. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                case 5: //Time 	                		                	
+                		// Set old value to attribute Time   
+	                	Date time = new Date();
+	                	SimpleDateFormat df = new SimpleDateFormat( &quot;HH:mm:ss.S&quot; );
+	                	try {
+							time = df.parse( oldValue );
+						} catch (ParseException e) {
+							logger.error(&quot;Parse time failed. &quot;+ e);
+						}
+						occurrence.setTimeCollected(time);
+                		logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
+                		// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+	                	isoDateTime.setTime(time);
+                		isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
+                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
 	                    break;
 	                case 6: //Source	                	
-	                	if (! changedList.contains(&quot;source&quot;)) {
-	                		changedList.add(&quot;source&quot;);
-		                	occurrence.setDataSource(oldValue);
-		                	logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of DataSource. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                	// Set old value to attribute Source 
+	                	occurrence.setDataSource(oldValue);
+	                	logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
 	                	break;
 	                case 7: //Herbarium
-	                	if (! changedList.contains(&quot;hebarium&quot;)){
-	                		changedList.add(&quot;herbarium&quot;);
-	                		occurrence.setHerbarium(oldValue);
-	                		logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Herbarium. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                	// Set old value to attribute Herbarium
+                		occurrence.setHerbarium(oldValue);
+                		logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
 	                    break;
 	                case 8: //Note occurrence	
-	                	if (! changedList.contains(&quot;noteOccurrence&quot;)) {
-	                		changedList.add(&quot;noteOccurrence&quot;);
-	                		occurrence.setNote(oldValue);
-	                		logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of NoteOccurrence. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                	// Set old value to attribute Note occurence	                	
+                		occurrence.setNote(oldValue);
+                		logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
 	                	break;
+	                case 9: //Publication  
+	                	//Select record Publication where id = oldRocordId 
+	                	if (oldRecordId &gt; 0){
+		                	Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
+		                	Publication publication = (Publication)objectPubl[0];
+		                	//Set old value to attribute publicationID
+		                	occurrence.setPublication(publication);
+		                	logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
+		    			}else {
+		    				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+		    			}
+	                    break;
 	                default:            
 	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
     			}  	
@@ -689,12 +584,15 @@
     			
     			// Get a specified number of columnName from habitat mapping.
     			int columnConstant;
-    			if (occurrenceHash.containsKey(columnName)) {
-    				 columnConstant = (Integer)occurrenceHash.get(columnName); 
+    			if (habitatHash.containsKey(columnName)) {
+    				 columnConstant = (Integer)habitatHash.get(columnName); 
     	        } else {
     	             columnConstant = 0;
     	        }        	    			
-    			    			
+    			  
+    			//informuje o tom, ze byla editovana tabulka tHabitat 
+    			editHabitat = true;
+    			
     			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
     			logger.debug(&quot;ColumnName: &quot;+ columnName);
     			logger.debug(&quot;OldValue: &quot;+ oldValue);  
@@ -702,413 +600,236 @@
     			
     			// Save new value for the column        		
      			switch (columnConstant) {
- 	                case 1:  //Quadrant    
- 	                	if (! changedList.contains(&quot;quadrant&quot;)) {
-	                		changedList.add(&quot;quadrant&quot;);
-	                		if (oldRecordId != 0 ){
-		                		/*
-		                		 * Zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-		                		 * Do occurrence.cHabitatId ulozit nacteny objekt Habitat
-		                		 * Zjistit, zda na aktulani objkt Habitat existuji jeste nejake FK z tOccurrence.cHabitatID
-		                		 * pokud neexistuji, tak ho smazem ...Pozor na to,ze smazane zaznamy jsou oznaceny jeko cDelete=1 !!!
-		                		 */
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Qudrant.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setQuadrant(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Quadrant. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();	                	              		               
+ 	                case 1:  //Quadrant     	                	
+                		/* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
+                		 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
+                		 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
+                		 */ 	                		  
+                		occurrence.getHabitat().setQuadrant(oldValue);		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {
+	                		// existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
+	                		// potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
+	                		// nebo zda editaci nalezu vznikla vazvba 1:1
+	                		relationship = true;
+	                	} 	                	
  	                    break;
- 	                case 2: //Place description
- 	                	if (! changedList.contains(&quot;description&quot;)) {
-	                		changedList.add(&quot;description&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//Zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Description.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setDescription(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Description Habitat.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Description Habitat. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 2: //Place description 	                	 	                			                		 
+                		occurrence.getHabitat().setDescription(oldValue);		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	              	
  	                	break;
- 	                case 3:  //Country
- 	                	if (! changedList.contains(&quot;country&quot;)) {
-	                		changedList.add(&quot;country&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//menou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Country.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setCountry(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Country. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 3:  //Country 	                	 	                			                		 
+                		occurrence.getHabitat().setCountry(oldValue);		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
  	                    break;
- 	                case 4: //Altitude
- 	                	if (! changedList.contains(&quot;altitude&quot;)) {
-	                		changedList.add(&quot;altitude&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//menou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Altitude.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Altitude. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 4: //Altitude 	                	                			                		 
+                		occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
  	                	break;
- 	                case 5:  //Latitude  
- 	                	if (! changedList.contains(&quot;latitude&quot;)) {
-	                		changedList.add(&quot;latitude&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//menou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Latitude.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Latitude. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 5:  //Latitude   	                		                			                		  
+                		occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
  	                    break;
- 	                case 6: //Longitude
- 	                	if (! changedList.contains(&quot;longitude&quot;)) {
-	                		changedList.add(&quot;longitude&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//menou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Longitude.&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Longitude. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 6: //Longitude 	                		                			                		
+                		occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
  	                	break;
- 	                case 7: //Nearest bigger seat  	
- 	                	if (! changedList.contains(&quot;nameVillage&quot;)) {
-	                		changedList.add(&quot;nameVillage&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);	   
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Village.&quot;);
-		                	}else {		                	
-		                		// Nacteni Village pro nasledny update tHabitat.cNearestVillageId
-	                			Object[] object = searchObject(&quot;Village&quot;,0,oldValue);
-	                			Village village = (Village) object[0];
-			                	occurrence.getHabitat().setNearestVillage(village);
-			                	logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
-		                	}	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Village. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 7: //Nearest bigger seat   	                	 	                			                		 
+                		//Nacteni Village pro nasledny update tHabitat.cNearestVillageId
+            			if (oldRecordId != 0){
+            				Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
+                			Village village = (Village)objectVill[0];
+    	                	occurrence.getHabitat().setNearestVillage(village);
+    	                	logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
+            			} else {
+            				logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
+            			}
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
  	                    break;
- 	                case 8: //Phytochorion or hytochorion code 	                	
- 	                	if (! changedList.contains(&quot;phytochorion&quot;)) {
-	                		changedList.add(&quot;phytochorion&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);	 	    
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Phytochorion.&quot;);
-		                	}else {		                	
-		                		// Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
-	                			Object[] object = searchObject(&quot;Phytochorion&quot;,0,oldValue);
-	                			Phytochorion phytochorion = (Phytochorion) object[0];
-			                	occurrence.getHabitat().setPhytochorion(phytochorion);
-			                	logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
-		                	}	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Phytochorion. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
- 	                	break; 	
- 	               case 9: //Phytochorion code	                	
-	                	if (! changedList.contains(&quot;phytochorionCode&quot;)) {
-	                		changedList.add(&quot;phytochorionCode&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);	 	   
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute PhytochorionCode.&quot;);
-		                	}else {		                	
-		                		// Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
-	                			Object[] object = searchObject(&quot;PhytochorionCode&quot;,0,oldValue);
-	                			Phytochorion phytochorion = (Phytochorion) object[0];
-			                	occurrence.getHabitat().setPhytochorion(phytochorion);
-			                	logger.debug(&quot;Set selected value for update of attribute Phytochorion code.&quot;);
-		                	}	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Phytochorion code. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                	break; 	     
-	                case 10:  //Territory        
-	                	if (! changedList.contains(&quot;nameTerritory&quot;)) {
-	                		changedList.add(&quot;nameTerritory&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);	 	
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute Territory.&quot;);
-		                	}else {		                	
-		                		// Nacteni Territory pro nasledny update tHabitat.cTerritory
-	                			Object[] object = searchObject(&quot;Territory&quot;,0,oldValue);
-	                			Territory territory = (Territory) object[0];
-			                	occurrence.getHabitat().setTerritory(territory);
-			                	logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
-		                	}	                		
-	                	} else {
-	                		logger.debug(&quot;Later edit of Territory. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+ 	                case 8: //Phytochorion or phytochorion code 	                	             			                		 
+                		// Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
+ 	                	if (oldRecordId != 0){
+	            			Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
+	            			Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
+		                	occurrence.getHabitat().setPhytochorion(phytochorion);
+		                	logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
+ 	                	}else {
+            				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+            			}
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
+ 	                    break; 	               
+	                case 9:  //Territory   	                	                			                		  
+                		// Nacteni Territory pro nasledny update tHabitat.cTerritory
+	                	if (oldRecordId != 0){
+	            			Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
+	            			Territory territory = (Territory)objectTerr[0];
+		                	occurrence.getHabitat().setTerritory(territory);
+		                	logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
+	                	}else {
+            				logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
+            			}	
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	        	
 	                    break;
-	                case 11: //Note habitat
-	                	if (! changedList.contains(&quot;noteHabitat&quot;)) {
-	                		changedList.add(&quot;noteHabitat&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute NoteHabitat&quot;);
-		                	}else {		                	
-			                	occurrence.getHabitat().setNote(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute NoteHabitat.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of NoteHabitat. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
+	                case 10: //Note habitat	                		                			                		  
+                		occurrence.getHabitat().setNote(oldValue);		                	
+	                	logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
+	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+	                		relationship = true;
+	                	} 	
 	                	break;
  	                default:            
  	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-     			}  	
-    		} else if (tableName.equals(&quot;Publication&quot;)){
-    			
-    			// Get a specified number of columnName from publication mapping.
-    			int columnConstant;
-    			if (occurrenceHash.containsKey(columnName)) {
-    				 columnConstant = (Integer)occurrenceHash.get(columnName); 
-    	        } else {
-    	             columnConstant = 0;
-    	        }        	    			
-    			    			
-    			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
-    			logger.debug(&quot;ColumnName: &quot;+ columnName);
-    			logger.debug(&quot;OldValue: &quot;+ oldValue);  
-    			 			
-    			
-    			// Save new value for the column    			         		
-    			switch (columnConstant) {
-	                case 1: //Collection Name   
-	                	if (! changedList.contains(&quot;collectionName&quot;)) {
-	                		changedList.add(&quot;collectionName&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute CollectionName.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setCollectionName(oldValue);
-			                	//Update atribute isoDataTimeBegin (CollectionName + CollectionYearPublication + JournalName + JournalAuthor)
-			                	Integer publicationYear = occurrence.getPublication().getCollectionYearPublication();
-			                	String journalName = occurrence.getPublication().getJournalName();
-			                	String journalAuthor = occurrence.getPublication().getJournalAuthorName();
-			                	occurrence.getPublication().setReferenceCitation(oldValue+&quot; &quot;+publicationYear+&quot; &quot;+journalName+&quot; &quot;+journalAuthor);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute CollectionName .&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of CollectionName . &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                    break;
-	                case 2: //Year of publication
-	                	if (! changedList.contains(&quot;colletionYearPublication&quot;)) {
-	                		changedList.add(&quot;colletionYearPublication&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute CollectionYearPublication.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setCollectionYearPublication(Integer.parseInt(oldValue));
-			                	//Update atribute isoDataTimeBegin (CollectionName + CollectionYearPublication + JournalName + JournalAuthor)
-			                	String collectionName = occurrence.getPublication().getCollectionName();			                	
-			                	String journalName = occurrence.getPublication().getJournalName();
-			                	String journalAuthor = occurrence.getPublication().getJournalAuthorName();
-			                	occurrence.getPublication().setReferenceCitation(collectionName+&quot; &quot;+oldValue+&quot; &quot;+journalName+&quot; &quot;+journalAuthor);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of Year of publication .&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of Year of publication. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                	break;
-	                case 3: //Journal  
-	                	if (! changedList.contains(&quot;journalName&quot;)) {
-	                		changedList.add(&quot;journalName&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute JournalName.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setJournalName(oldValue);
-			                	// Update atribute isoDataTimeBegin (CollectionName + CollectionYearPublication + JournalName + JournalAuthor)			                	
-			                	String collectionName = occurrence.getPublication().getCollectionName();
-			                	Integer publicationYear = occurrence.getPublication().getCollectionYearPublication();			                	
-			                	String journalAuthor = occurrence.getPublication().getJournalAuthorName();
-			                	occurrence.getPublication().setReferenceCitation(collectionName+&quot; &quot;+publicationYear+&quot; &quot;+oldValue+&quot; &quot;+journalAuthor);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute JournalName .&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of JournalName . &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                    break;
-	                case 4: //Author of journal
-	                	if (! changedList.contains(&quot;journalAuthor&quot;)) {
-	                		changedList.add(&quot;journalAuthor&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute JournalAuthor.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setJournalAuthorName(oldValue);
-			                	//Update atribute isoDataTimeBegin (CollectionName + CollectionYearPublication + JournalName + JournalAuthor)			                	
-			                	String collectionName = occurrence.getPublication().getCollectionName();
-			                	Integer publicationYear = occurrence.getPublication().getCollectionYearPublication();
-			                	String journalName = occurrence.getPublication().getJournalName();			                	
-			                	occurrence.getPublication().setReferenceCitation(collectionName+&quot; &quot;+publicationYear+&quot; &quot;+journalName+&quot; &quot;+oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute JournalAuthor .&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of JournalAuthor. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                	break;	                
-	                case 5: //Reference detail
-	                	if (! changedList.contains(&quot;referenceDetail&quot;)) {
-	                		changedList.add(&quot;referenceDetail&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute ReferenceDetail.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setReferenceDetail(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute ReferenceDetail.&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of ReferenceDetail. &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                	break;
-	                case 6: //URL    
-	                	if (! changedList.contains(&quot;url&quot;)) {
-	                		changedList.add(&quot;url&quot;);
-	                		if (oldRecordId != 0 ){
-		                		//zmenou polozky doslo k insertu a prenastaveni occurrence.cHabitatId --&gt; nutno nacist a ulozitHabitat s id = oldRecordId
-	                			Object[] object = searchObject(&quot;Habitat&quot;,oldRecordId,&quot;&quot;);
-	                			Habitat habitatOld = (Habitat) object[0];
-			                	occurrence.setHabitat(habitatOld);
-			                	logger.debug(&quot;Change tOccurrence.cHabitatId. The change was created by attribute URLpublication.&quot;);
-		                	}else {		                	
-			                	occurrence.getPublication().setUrl(oldValue);
-		                	}
-	                		logger.debug(&quot;Set selected value for update of attribute URL (publication).&quot;);
-	                	} else {
-	                		logger.debug(&quot;Later edit of ReferenceDetail (publication). &quot;);
-	                	}
-	                	//Delete record from tHistory and tHistoryChange
-	                	deleteHistoryRecords();
-	                    break;	                
-	                default:            
-	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-    			}  	
+     			}  	    		
     		} else {
     			logger.equals(&quot;No table defined&quot;);
-    		}    			
-    		
+    		}    			    		
     	}
+ 
+    	//informovat uzivatele, co bude provedeno (viz seznam markLIstId, markItem) a dat mu volbu, zda ano ci ne... zde je nutne, aby fungovalo spravne 
+    	//executeUpdate, aby k update doslo az po jeho zavolani....!!!!
+    	//zavolat delete na vsechny vracene polozky Historiie - projit seznam s ID
+    	//v tabulce tOccurrences by se meli aktualizovat polozky cUpdateWhen a cUpdatewho na uzivatele a cas, ktery zavolal undo
+    	//zavolat znovu dotaz do db, aby se aktualizovaly vysledky ... createQuery, atd.
     	
-    	//projdem vysledky od 0 do zobrazeneho vysledku
-    	//pokud je tu informace o editaci polozky, ktere byla vracena starsi hodnota, tak se tato informace smaze 
-    	for( int i=0; i&lt;indexFirstRow-1; i++) {
-    		String columnName = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName();
-    		if (changedList.contains(columnName)){
-    			
-    		}
-    			
+    	//vygenerovani zpravy pro uzivatele    	
+    	generateMessageUndo();
+    }
+    
+    public void generateMessageUndo() {    	
+    	messageUndo = &quot;Budou provedeny n&#225;sleduj&#237;c&#237; zm&#283;ny:\n&quot;;
+    	int count = markItem.size();
+    	for (int i=0; i&lt;count; i++) {
+    		Object[] itemList = (Object[])(markItem.get(i));
+    		String item = (String)itemList[0];
+    		Integer maxId = (Integer)itemList[1];      		
+    		oldValue = ((HistoryRecord)editHistoryDataList.get(maxId)).getOldValue(); 
+    		messageUndo = messageUndo + item + &quot; --&gt; &quot; + oldValue + &quot;\n&quot;;
     	}
+    	if (!relationship &amp;&amp; editHabitat) {
+    		logger.debug(relationship);
+    		logger.debug(editHabitat);
+    		messageUndo = &quot;\n&quot; + messageUndo + &quot;Tyto zm&#283;ny ovlivn&#237; v&#237;ce n&#225;lez&#367;.\n&quot;;
+    	}
+    }
+    
+    public void commitUpdate() {
+    	try {
+			database.executeUpdate(occurrence);
+		} catch (RemoteException e) {
+			logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
+		} catch (DBLayerException e) {
+			logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
+		}
+    }
+  
+    /**
+     * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
+     * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
+     */
+    public void deleteHistoryRecords() {
 
+    	//count of selected record
+    	int count = editHistoryDataList.size();
+    	
+    	//take from younger record to older record
+    	for( int i=0; i &lt; count; i++) {
+    		if (! markListId.contains(i)) {
+    			continue;
+    		}    		    		
+    		historyRecord = (HistoryRecord)editHistoryDataList.get(i);     	  	
+	    	try {
+				database.executeDelete(historyRecord);
+				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
+			} catch (RemoteException e) {
+				logger.error(&quot;Deleting historyRecord - remoteException. &quot;+e.toString());
+			} catch (DBLayerException e) {
+				logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
+			}
+			int countResult = searchHistoryChangeId(i);			
+			if (countResult == 1) {
+				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
+				try {
+					database.executeDelete(historyChange);
+					logger.debug(&quot;Deleting historyChange successfully.&quot;);
+				} catch (RemoteException e) {
+					logger.error(&quot;Deleting historyChange - remoteException. &quot;+e.toString());
+				} catch (DBLayerException e) {
+					logger.error(&quot;Deleting historyChange failed. &quot;+e.toString());
+				}
+			} else {
+				logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
+			}
+    	}
+    	//Clear list 
+    	markListId.clear();
+    	markItem.clear();
+    } 
+    
+    /**
+     * Zjisteni kolik zaznamu v tabulce tHistory je provazano s konkretnim zaznamem z tHistoryHange 
+     * @param id
+     * @return
+     */
+    public int searchHistoryChangeId(int id){
+    	HistoryChange historyChange = ((HistoryRecord)editHistoryDataList.get(id)).getHistoryChange();
+    	SelectQuery query = null;
+        try {
+        	    query = database.createQuery(HistoryRecord.class);
+        } catch(RemoteException e) {
+        	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
+        }        
+        // Add restriction to cChangeId column 
+        query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryRecord.HISTORYCHANGE, null, historyChange , null);
+        
+        int resultIdChange = 0;
+        try {                   
+        	resultIdChange = database.executeQuery(query);        
+        } catch (DBLayerException e) {                   
+            logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
+        } catch (RemoteException e) {		 
+     	   System.err.println(&quot;RemoteException- searchHistoryChangeId(), executeQuery&quot;);
+ 	    } finally {
+     	   logger.debug(&quot;Searching historyChangeId ends successfully.&quot;);
+        }         
+ 	    
+ 	    int countResult = 100;
+ 	    try {
+			countResult = database.getNumRows(resultIdChange);
+			logger.debug(&quot;SearchHistoryChangeId - Number of result: &quot;+countResult);
+		} catch (RemoteException e) {
+			System.err.println(&quot;RemoteException- searchHistoryChangeId(), getNumRows&quot;);
+		}		
+		return countResult;
     }
     
+    
      //***************************//
     //****Init Hashtable*********//
     //**************************//
     
     private void initOccurrenceHash() {
-        occurrenceHash = new Hashtable&lt;String, Integer&gt;(9); 
+    	occurrenceHash = new Hashtable&lt;String, Integer&gt;(9); 
         occurrenceHash.put(&quot;plantId&quot;,1);
         occurrenceHash.put(&quot;yearCollected&quot;,2);
         occurrenceHash.put(&quot;monthCollected&quot;,3);
@@ -1117,23 +838,12 @@
         occurrenceHash.put(&quot;dataSource&quot;,6);
         occurrenceHash.put(&quot;herbarium&quot;,7);        
         occurrenceHash.put(&quot;noteOccurrence&quot;,8);
-        //isoDataTimeBegin je slozena s Year + Month + Day + Time ... mela by se zmenit vzdy, kdyz
-        // dojde ke zmene nektere z techto polozek ... jak to nejlepe zaridit???
-        //occurrenceHash.put(&quot;isoDataTimeBegin&quot;,9);
-        /*
-         * Jak se bude chovat cUpdateWhen, cUpdateWho v historii - asi se nastavi 
-         * cas vyvolani undo v historii a uzivatel, ktery to vyvolal
-         */
-        //occurrenceHash.put(&quot;cUpdateWhen&quot;,10);
-        //occurrenceHash.put(&quot;cUpdateWho&quot;,11);
-        /*
-         * Uvadet nejakou informaci z metadat - pripadne jakou
-         */
-        //occurrenceHash.put(&quot;metadataId&quot;,12);
+        occurrenceHash.put(&quot;publicationId&quot;,9);       
+        //occurrenceHash.put(&quot;metadataId&quot;,10);
     }    
     
     private void initHabitatHash() {
-        habitatHash = new Hashtable&lt;String, Integer&gt;(11);        
+    	habitatHash = new Hashtable&lt;String, Integer&gt;(11);         
         habitatHash.put(&quot;quadrant&quot;,1);
         habitatHash.put(&quot;description&quot;,2);
         habitatHash.put(&quot;country&quot;,3);
@@ -1142,34 +852,70 @@
         habitatHash.put(&quot;longitude&quot;,6);      
         habitatHash.put(&quot;nameVillage&quot;,7);      
         habitatHash.put(&quot;namePhytochorion&quot;,8);
-        habitatHash.put(&quot;code&quot;,9);
-        habitatHash.put(&quot;nameTerritory&quot;,10);
-        habitatHash.put(&quot;noteHabitat&quot;,11);
-    }
+        habitatHash.put(&quot;code&quot;,8);
+        habitatHash.put(&quot;nameTerritory&quot;,9);
+        habitatHash.put(&quot;noteHabitat&quot;,10);
+    }    
     
-    private void initPublicationHash() {
-        publicationHash = new Hashtable&lt;String, Integer&gt;(7);                       
-        publicationHash.put(&quot;collectionName&quot;,1);
-        publicationHash.put(&quot;colletionYearPublication&quot;,2);
-        publicationHash.put(&quot;journalName&quot;,3);
-        publicationHash.put(&quot;journalAuthorName&quot;,4);
-        //publicationHash.put(&quot;referenceCitation&quot;,7);
-        publicationHash.put(&quot;referenceDetail&quot;,5);
-        publicationHash.put(&quot;url&quot;,6);
-    }
-    
+   
     //****************************//
     //****Get and set metods*****//
     //**************************//
     
+    /**
+     * @return true if all recorda were selected.
+     */
+    public boolean getSelectAll() {
+		  return this.selectAll;		  
+	   }
+
+    /**
+     * Set information if all records were selected. 
+     * @param selectAll
+     */
+	 public void setSelectAll(boolean selectAll) {
+		  this.selectAll = selectAll;		  
+	 } 
+    
+	 public HashSet getMarkListId() {
+		  return this.markListId;		  
+	   }
+
+	 public void setMarkListId(HashSet markListId) {
+		  this.markListId = markListId;		  
+	 } 
+	 
+    public ArrayList&lt;Object[]&gt; getMarkItem() {
+		  return this.markItem;		  
+	   }
+
+	 public void setMarkItem(ArrayList&lt;Object[]&gt; markItem) {
+		  this.markItem = markItem;		  
+	 } 
+    
+    public ArrayList&lt;HistoryRecord&gt; getEditHistoryDataList() {
+		  return this.editHistoryDataList;		  
+	   }
+
+	 public void setEditHistoryDataList(ArrayList&lt;HistoryRecord&gt; editHistoryDataList) {
+		  this.editHistoryDataList = editHistoryDataList;		  
+	 } 
+    
      public String getCurrentDisplayRows() {
 		  return this.displayRow;		  
 	   }
 
-	 public void setCurrentDisplayRow(String displayRow) {
+	 public void setCurrentDisplayRows(String displayRow) {
 		  this.displayRow = displayRow;		  
 	 } 
      
+     public String getMessageUndo() {
+		  return this.messageUndo;		  
+	   }
+
+	 public void setMessageUndo(String messageUndo) {
+		  this.messageUndo = messageUndo;		  
+	 } 
     
     /**
      *  Set result of a database operation. This is used only for search operations.
@@ -1348,7 +1094,7 @@
 	*   Get operation whitch was used
 	*   @return operation whitch was used
 	*/
-	public String getOperation() {
+	public int getOperation() {
 	  return this.operation;
 	}
 
@@ -1356,7 +1102,7 @@
 	*   Set operation whitch was used
 	*   @param operation string containing operation whitch was used 
 	*/
-	public void setOperation(String operation) {
+	public void setOperation(int operation) {
 	  this.operation = operation;
 	}
 	 

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-10 19:22:55 UTC (rev 122)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-10 20:04:03 UTC (rev 123)
@@ -97,7 +97,7 @@
                model.processEditResult(firstRow, model.getDisplayRows()); 
                if (model.getCurrentFirstRow() &gt; 1){
                }
-               view.getTable().setModel(new HistoryTableModel(model.getData()));
+               view.getTable().setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
                view.setCurrentRowsInfo(from + &quot;-&quot; + to);
@@ -117,13 +117,17 @@
            logger.debug(&quot;current first row: &quot;+model.getCurrentFirstRow());
            logger.debug(&quot;num rows in the result: &quot;+ model.getResultRows());            
            logger.debug(&quot;display rows: &quot;+ model.getDisplayRows());
-           logger.debug(&quot;num rows in table (view) &quot;+ view.getTable().getRowCount());          
+           logger.debug(&quot;num rows in table (view) &quot;+ view.getTable().getRowCount());              
            if (model.getCurrentFirstRow()+ view.getTable().getRowCount()&lt;=model.getResultRows()) {
                model.processEditResult(model.getCurrentFirstRow()+ model.getDisplayRows(), view.getTable().getRowCount());
-               view.getTable().setModel(new HistoryTableModel(model.getData()));  
+               view.getTable().setModel(new HistoryTableModel(model));             
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
-               view.setCurrentRowsInfo(from + &quot;-&quot; + to);
+               if (to &lt;= 0){
+            	   view.setCurrentRowsInfo(&quot;0-0&quot;);
+               }else {
+            	   view.setCurrentRowsInfo(from + &quot;-&quot; + to);
+               }               
            }                       
        }
    }
@@ -134,13 +138,10 @@
     */
    class selectAllButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {
-    	   logger.debug(&quot;selectAll&quot;);
-    	   int countRow = view.getTable().getRowCount();    	  
-           for (int row=0; row &lt; countRow; row++)
-           {         	     	
-         	  view.getTable().setValueAt(true, row, 0);            	  
-           }       
+       {    	   
+    	   model.setSelectAll(true);
+    	   model.processEditResult(1,model.getResultRows());    	   
+    	   view.getTable().setModel(new HistoryTableModel(model));  
        }
    }
    
@@ -150,13 +151,10 @@
     */
    class unselectAllButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {
-    	   logger.debug(&quot;unselectAll&quot;);
-    	   int countRow = view.getTable().getRowCount();    	   
-           for (int row=0; row &lt; countRow; row++)
-           {        	        	  
-         	  view.getTable().setValueAt(false, row, 0);          	  
-           }           
+       {    
+    	   ArrayList&lt;Object[]&gt; markItem = new ArrayList();    	   
+    	   model.setMarkItem(markItem); 
+    	   view.getTable().setModel(new HistoryTableModel(model));
        }
    }
    
@@ -166,22 +164,32 @@
     */
    class undoSelectedButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
-       {
-    	   int countRow = view.getTable().getRowCount(); 
-    	   //list with number of selected rows
-    	   ArrayList markRows = new ArrayList();
-           for (int row=0; row &lt; countRow; row++)
-           {           	  
-         	  if (view.getTable().getValueAt(row, 0).equals(true)) {
-         		 System.out.println(&quot;undo &quot;+ row); 
-         		 markRows.add(row);         		          		          		
-         	  }     
-           }
-           model.updateOlderChanges(markRows);  
-           view.getTable().setModel(new HistoryTableModel(model.getData()));
-           int from = model.getCurrentFirstRow();
-           int to = from + view.getTable().getRowCount() - 1;
-           view.setCurrentRowsInfo(from + &quot;-&quot; + to);
+       {    	   
+           model.updateOlderChanges();            
+           int okCancle = view.messageUndo(model.getMessageUndo());
+           logger.debug(&quot;button &quot;+okCancle);
+           if (okCancle == 0){
+        	   //Button OK was press
+        	   logger.debug(&quot;Button OK was press.&quot;);
+        	   model.commitUpdate();
+        	   model.deleteHistoryRecords();
+        	   model.searchEditHistory();
+        	   model.processEditResult(1,model.getDisplayRows());
+        	   view.getTable().setModel(new HistoryTableModel(model));
+        	   int resultRows = model.getResultRows();
+        	   if (resultRows == 0) {
+        		   view.setCurrentRowsInfo(&quot;0-0&quot;); 
+        	   } else {
+        		   int from = model.getCurrentFirstRow();
+                   int to = from + view.getTable().getRowCount() - 1;               
+                   view.setCurrentRowsInfo(from + &quot;-&quot; + to);    
+        	   }               
+               view.setCountResutl(resultRows);
+           } else {
+        	   //Button Cancle was press
+        	   //neco jako rollback - bude se volat nebo to bude zarizeno tim, ze se nezavola executeUpdate??
+        	   logger.debug(&quot;Button Cancle was press.&quot;);
+           }           
        }
    }
     
@@ -192,7 +200,7 @@
    class rowSetDisplayChangeListener implements PropertyChangeListener {
 	   public void propertyChange(PropertyChangeEvent e) {
            // Save old value
-           int oldValue = model.getDisplayRows();
+           int oldValue = model.getDisplayRows();           
            // Check whether new value &gt; 0
            if (view.getDisplayRows() &lt; 1) {
                view.setDisplayRows(oldValue);
@@ -208,7 +216,7 @@
            // If neccessary reload search results
            if ((oldValue != view.getDisplayRows()) &amp;&amp; (model.getDisplayRows() &lt;= model.getResultRows())) {
                model.processEditResult(model.getCurrentFirstRow(), view.getDisplayRows());
-               view.getTable().setModel(new HistoryTableModel(model.getData()));
+               view.getTable().setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
                view.setCurrentRowsInfo(from + &quot;-&quot; + to);               

Modified: trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-04-10 19:22:55 UTC (rev 122)
+++ trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-04-10 20:04:03 UTC (rev 123)
@@ -1,11 +1,18 @@
 package net.sf.plantlore.client.history;
 
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
 import javax.swing.DefaultCellEditor;
 import javax.swing.JCheckBox;
 import javax.swing.table.AbstractTableModel;
 import javax.swing.table.TableColumn;
 import javax.swing.table.TableColumnModel;
 
+import org.apache.log4j.Logger;
+
+import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.l10n.L10n;
 
 /** 
@@ -14,6 +21,14 @@
  */
 public class HistoryTableModel extends AbstractTableModel
 {
+	//Logger
+	private Logger logger;
+	// History model
+	private History model; 
+	private ArrayList&lt;HistoryRecord&gt; editHistoryDataList;
+    private HashSet markListId;
+    private ArrayList&lt;Object[]&gt; markItem;
+	
 	/** Names of the columns */
     private String[] columnNames;
     /** Data values displayed in the table*/
@@ -26,24 +41,20 @@
     public final static int OLD_VALUE = 4;
     public final static int NEW_VALUE = 5;
     
-    /** Creates a new instance of HistoryTableModel */
-    public HistoryTableModel()
-    {    	
-    	init();
-    }
 
     /** 
      *  Creates a new instance of HistoryTableModel with the specified data values  
-     *  @param tableData data values 
+     *  @param model
      */
-    public HistoryTableModel(Object[][] tableData)
+    public HistoryTableModel(History model)
     {
-    	data = tableData;
-    	init();    	
-
-    }    
+    	logger = Logger.getLogger(this.getClass().getPackage().getName());
+    	this.model = model;        
+    	initColumns();    	
+    	initData();    	
+    }  
    
-    private void init() {
+    private void initColumns() {
         columnNames = new String[6];        
         columnNames[0] = L10n.getString(&quot;historyColX&quot;);        
         columnNames[1] = L10n.getString(&quot;historyColDate&quot;);        
@@ -51,8 +62,162 @@
         columnNames[3] = L10n.getString(&quot;historyColItem&quot;);        
         columnNames[4] = L10n.getString(&quot;historyColOldValue&quot;);       
         columnNames[5] = L10n.getString(&quot;historyColNewValue&quot;);        
+    }       
+    
+    /**
+     * Load data for dislaying 
+     */
+    public void initData() {
+    	
+    	logger.debug(&quot;Init data.&quot;);
+    	
+    	editHistoryDataList = model.getEditHistoryDataList();
+    	if (editHistoryDataList.size()==0 ){
+    		this.data = new Object[0][];
+    		return;
+    	}
+    	markItem = model.getMarkItem();    	
+    	int firstRow = model.getCurrentFirstRow();
+    	int countResult = Math.min(editHistoryDataList.size(), firstRow+ model.getDisplayRows()-1);
+    	int countRow = countResult - firstRow + 1;
+    	boolean mark = false;
+    	int ii = 0;  
+    	//If was use button &quot;sellect all&quot; we must init list of mark item
+    	boolean selectAll = model.getSelectAll();
+    	if (selectAll) {
+    		initMarkAllItem();
+    		mark = true;    		
+    	}
+    	//loud data for view
+        Object[][] editHistoryData = new Object[countRow][6];   
+    	for (int i=firstRow-1; i &lt; countResult; i++) {  
+    		String item = L10n.getString(((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName());    		
+    		if (! selectAll){     			
+    			mark = isMark(item, i);
+    		}
+    		editHistoryData[ii][0] = new Boolean(mark);    		
+    	    editHistoryData[ii][1] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWhen();
+    	    editHistoryData[ii][2] = ((HistoryRecord)editHistoryDataList.get(i)).getHistoryChange().getWho().getWholeName();    	   
+    	    editHistoryData[ii][3] = item;
+    	    editHistoryData[ii][4] = ((HistoryRecord)editHistoryDataList.get(i)).getOldValue();
+    	    editHistoryData[ii][5] = ((HistoryRecord)editHistoryDataList.get(i)).getNewValue();
+    	    ii++;
+    	}      	
+    	model.setSelectAll(false);
+    	this.data = editHistoryData;    	
+    }    
+    
+    /**
+     * Check marking row
+     * @param item
+     * @return
+     */
+    public boolean isMark(String item, int itemId) {    	
+    	int count = markItem.size();       	
+    	for( int i=0; i &lt; count; i++){
+    		Object[] itemList = (Object[])(markItem.get(i));
+    		String itemFromList = (String)itemList[0];
+    		Integer maxId = (Integer)itemList[1];
+    		logger.debug(&quot;IsMark - itemFromList: &quot;+itemFromList + &quot;, item: &quot;+ item + &quot;, maxId: &quot;+ maxId + &quot;, itemId: &quot;+ itemId);
+    		if (item.equals(itemFromList)) {
+    			if (itemId &lt;= maxId) {
+    				return true;
+    			}
+    		}
+    	}
+    	return false;
     }
+ 
+    /**
+     * 
+     * @param row
+     * @param value
+     */
+    public void updateMarkList(String item, int row, boolean value) {    	    	    	
+    	int itemId = row + model.getCurrentFirstRow() - 1;
+    	boolean contains = false;    	
+    	int count = markItem.size();
+    	logger.debug(&quot;Update markListItem. Count item: &quot;+count);
+    	//ArrayList&lt;Object[]&gt; tmpMarkItem = markItem;
+    	for( int i=0; i &lt; count; i++){
+    		Object[] itemList = (Object[])(markItem.get(i));
+    		String itemFromList = (String)itemList[0];
+    		Integer maxId = (Integer)itemList[1];    
+    		logger.debug(&quot;MarkItem update - item: &quot;+ itemFromList + &quot;, maxId: &quot; + maxId);
+    		if (value) {    		    			    			
+    			if (item.equals(itemFromList)) { 
+    				contains = true;
+					if (itemId &gt; maxId) {
+						//Set max id of mark item
+						itemList[1] = itemId;
+					   	markItem.set(i, itemList);
+					}
+				}
+		    } else {
+		    	if (item.equals(itemFromList)) {
+		    		contains = true;
+		    		if (itemId &lt;= maxId){
+		    			//search smaller id of mark item
+		    			int newId = searchSmaller(item, itemId);
+		    			if (newId != -1) {
+		    				itemList[1] = newId;
+			    			markItem.set(i,itemList);
+			    			logger.debug(&quot;Unmark - new itemId is &quot;+ itemList[1].toString());
+		    			} else {
+		    				markItem.remove(i);
+			    			logger.debug(&quot;Unmark - remote record has id: &quot;+ itemId);
+			    			return;
+		    			}
+		    	    }else {		    		
+		    			markItem.remove(i);
+		    			logger.debug(&quot;Unmark - remote record has id: &quot;+ itemId);
+		    			return;
+		    		}
+		    	}				 
+			}      	
+    	}
+    	if (! contains) {
+    		Object [] itemList = new Object[2];    		
+			itemList[0] = item;
+			itemList[1] = itemId;
+			markItem.add(itemList);
+		}       	
+    }
+ 
+    /**
+     * 
+     *
+     */
+    public void initMarkAllItem() {    	
+    	editHistoryDataList = model.getEditHistoryDataList();    	
+    	int countResult = editHistoryDataList.size();    	
+    	for (int i=0; i &lt; countResult; i++) {      		    		    	
+    		String item = L10n.getString(((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName());
+    		updateMarkList(item, i, true);
+    	} 
+    	model.setMarkItem(markItem);
+    	updateMarkListId();
+    	logger.debug(&quot;All records were selected.&quot;);    	
+    }
     
+    /**
+     * 
+     *
+     */
+    public void updateMarkListId() {
+    	markListId = new HashSet();
+    	editHistoryDataList = model.getEditHistoryDataList();
+    	markItem = model.getMarkItem();
+    	int countResult = editHistoryDataList.size();    	
+    	for (int i=0; i &lt; countResult; i++) {  
+    		String item = L10n.getString(((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName());    		    		
+    		if (isMark(item, i)){
+    			markListId.add(i);
+    		}
+    	}        	
+    	model.setMarkListId(markListId);
+    	logger.debug(&quot;List ID of selected record: &quot;+ markListId.toString());
+    }
     
     /** 
      *  Allows to edit of the MARK cell.
@@ -76,39 +241,38 @@
      * @param column index of column
      */
     public void setValueAt(Object value, int row, int column)
-    {
+    {    	
         data[row][column] = value;
-        if (column == 0) {
-        	if ((Boolean)value){        	    
-        	    selectYounger(row, column);        	    
-        	} else {        		
-        		selectOlder(row, column);
-        	}
-        }
-        //repaint view - with new value
-        this.fireTableCellUpdated(row, column);
+        if (column == 0) {       
+        	 String item = (String)getValueAt(row, 3);
+        	 updateMarkList(item, row, (Boolean)value);         	 
+       	     model.setMarkItem(markItem); 
+        	 //update data
+        	 initData();
+        	 //Update list of selected record
+        	 updateMarkListId();
+        	 //update view
+        	 this.fireTableDataChanged();
+        }        
     }
 
-    public void selectYounger(int row, int column){
-    	String item = (String)getValueAt(row, 3);
-    	for(int i=0; i &lt; row; i++) {
-    		if (item.equals(getValueAt(i,3))) {
-    			setValueAt(true,i,0);
-    			System.out.print(&quot;oznaceno &quot; +i + &quot; \n&quot; );
-    		}
+    /**
+     * 
+     * @param item
+     * @param itemId
+     * @return
+     */
+    public int searchSmaller(String item, int itemId) {    	
+    	int itemNewId = -1;
+    	int firstRow = model.getCurrentFirstRow();
+    	for( int i=itemId-firstRow; i &gt;=0 ; i--){
+    		if (getValueAt(i,3).equals(item)){
+    			return i+firstRow-1;
+    		}    		
     	}
+    	return -1;
     }
     
-    public void selectOlder(int row, int column){
-    	String item = (String)getValueAt(row, 3);
-    	for(int i=row+1; i &lt; data.length; i++) {
-    		if (item.equals(getValueAt(i,3))) {
-    			setValueAt(false,i,0);
-    			System.out.print(&quot;odznaceno &quot; +i + &quot; \n&quot; );
-    		}
-    	}
-    }
-    
     /**
      * Gets the value of the given cell.
      * @param row index of row

Modified: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-04-10 19:22:55 UTC (rev 122)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-04-10 20:04:03 UTC (rev 123)
@@ -16,6 +16,7 @@
 import javax.swing.JComboBox;
 import javax.swing.JFormattedTextField;
 import javax.swing.JFrame;
+import javax.swing.JOptionPane;
 import javax.swing.JRadioButton;
 import javax.swing.JDialog;
 import javax.swing.JLabel;
@@ -270,12 +271,7 @@
         infoInsertPanel.add(insertWhoValueLabel, gbConstraints);              
         
         // Add table to the infoEditPanel panel    
-        //!!!pro velke mnozstvi dat je lepsi pouzit AbstractTableModel, ktera umoznuje postupne nacitani do pameti
-        // defaultTableModel vytvari odkazy na vsechny zapouzdrene informace
-        
-        data = model.getData();
-        
-        tableEditList = new JTable(new HistoryTableModel(data));        
+        tableEditList = new JTable(new HistoryTableModel(model));        
         TableColumnModel tcm = tableEditList.getColumnModel();        
         TableColumn tc;
         for (int i = 0; i &lt; tableEditList.getColumnCount(); i++) {
@@ -422,6 +418,10 @@
         
     }     
  
+    public int messageUndo(String message) {
+    	int okCancle = JOptionPane.showConfirmDialog(historyDialog, message, &quot;Information about change&quot;, JOptionPane.OK_CANCEL_OPTION);
+    	return okCancle;
+    }
 
     public void close() {
         historyDialog.dispose();
@@ -438,6 +438,11 @@
     	return this.tableEditList;
     }
     
+    public void setCountResutl(Integer resultRows)
+    {
+    	this.countResutl.setText(resultRows.toString());
+    }
+    
     /** */
     public void setCurrentRowsInfo(String displayedRows)
     {


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000125.html">[Plantlore-dev] plantlore
</A></li>
	<LI>Next message: <A HREF="000127.html">[Plantlore-dev] r124 - trunk/src/net/sf/plantlore/common/record
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#126">[ date ]</a>
              <a href="thread.html#126">[ thread ]</a>
              <a href="subject.html#126">[ subject ]</a>
              <a href="author.html#126">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
