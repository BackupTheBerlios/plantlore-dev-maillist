<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r147 - trunk/src/net/sf/plantlore/client/history
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r147%20-%20trunk/src/net/sf/plantlore/client/history&In-Reply-To=%3C200604172211.k3HMBTXX001859%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000151.html">
   <LINK REL="Next"  HREF="000153.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r147 - trunk/src/net/sf/plantlore/client/history</H1>
    <B>lada at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r147%20-%20trunk/src/net/sf/plantlore/client/history&In-Reply-To=%3C200604172211.k3HMBTXX001859%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r147 - trunk/src/net/sf/plantlore/client/history">lada at berlios.de
       </A><BR>
    <I>Tue Apr 18 00:11:29 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000151.html">[Plantlore-dev] [Fwd: Re:plantlore]
</A></li>
        <LI>Next message: <A HREF="000153.html">[Plantlore-dev] r148 - trunk/src/net/sf/plantlore/common
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#152">[ date ]</a>
              <a href="thread.html#152">[ thread ]</a>
              <a href="subject.html#152">[ subject ]</a>
              <a href="author.html#152">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lada
Date: 2006-04-18 00:11:28 +0200 (Tue, 18 Apr 2006)
New Revision: 147

Modified:
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistory.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
Log:
WholeHistory - add functions for UNDO. Update History -delete from history.

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-04-15 09:44:04 UTC (rev 146)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-04-17 22:11:28 UTC (rev 147)
@@ -74,48 +74,49 @@
     private boolean editHabitat;
     //zprava pro uzivatele
     private String messageUndo;
-   
+    //zaznamenani ITEM, jejichz zmena ovlibni vice polozek
+   private ArrayList&lt;String&gt; itemAffectMore = new ArrayList();
     
     //*********************Record of history ***************************************//    
     private Occurrence occurrence;
-	private HistoryRecord historyRecord;
-	private HistoryChange historyChange;
+    private HistoryRecord historyRecord;
+    private HistoryChange historyChange;
 	
     //	**************Informations about HistoryRecord*************//	
-	/** Name of the table where value was changed*/
-	private String tableName;  
-	/** Name of the column where value was changed*/
-	private String columnName;
-	/** Unique value identified occurrence */	
-	private Integer occurrenceId;
-	/**Unique value identified record in table where value was changed */
-	private int recordId;
-	/**Unique value identified record before changed */
-	private int oldRecordId;
-	/** Operation whitch was used*/   
-	private int operation;
-	/** Date and time when the reccord was changed*/
-	private java.util.Date when = new Date();	
-	/** Old value of attribute*/    
-	private String oldValue;
-	/** New value of attribute*/
-	private String newValue;
-   /** Name of user who did changed*/
-	private String nameUser;
+    /** Name of the table where value was changed*/
+    private String tableName;  
+    /** Name of the column where value was changed*/
+    private String columnName;
+    /** Unique value identified occurrence */	
+    private Integer occurrenceId;
+    /**Unique value identified record in table where value was changed */
+    private int recordId;
+    /**Unique value identified record before changed */
+    private int oldRecordId;
+    /** Operation whitch was used*/   
+    private int operation;
+    /** Date and time when the reccord was changed*/
+    private java.util.Date when = new Date();	
+    /** Old value of attribute*/    
+    private String oldValue;
+    /** New value of attribute*/
+    private String newValue;
+    /** Name of user who did changed*/
+    private String nameUser;
 	
-	//**************Informations about occurrences***************//
-	/** Name of plant for specified occurrenc*/
-	private String namePlant;
-	/** Name of author for specified occurrenc*/
-	private String nameAuthor;
-	/** Informaciton about location for specified occurrenc*/
-	private String location;
-	
-	 //********************************************************//
-	 /** Mapping of entities */
-	private Hashtable&lt;String, Integer&gt; publicationHash;
-	private Hashtable&lt;String, Integer&gt; habitatHash;
-	private Hashtable&lt;String, Integer&gt; occurrenceHash;  
+    //**************Informations about occurrences***************//
+    /** Name of plant for specified occurrenc*/
+    private String namePlant;
+    /** Name of author for specified occurrenc*/
+    private String nameAuthor;
+    /** Informaciton about location for specified occurrenc*/
+    private String location;
+
+     //********************************************************//
+     /** Mapping of entities */
+    private Hashtable&lt;String, Integer&gt; publicationHash;
+    private Hashtable&lt;String, Integer&gt; habitatHash;
+    private Hashtable&lt;String, Integer&gt; occurrenceHash;  
     
     /**  
      *  Creates a new instance of History 
@@ -197,7 +198,7 @@
 	   //Searching for information about data editing concerned with specified occurrence
 	   searchEditHistory();
 	   //Process results of a search &quot;edit&quot; query 
-	   processEditResult(1,displayRows);
+	   processResult(1,displayRows);
     }	
 
     /**
@@ -308,7 +309,7 @@
      * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
      * @param count number of rows to retrieve 
      */
-    public void processEditResult(int fromTable, int count) {
+    public void processResult(int fromTable, int count) {
     	
     	if (this.resultId != 0) {
     		int currentRow = getResultRows();
@@ -330,8 +331,8 @@
                  	try {
                  		objectHistory = database.more(this.resultId, 1, to);  
                  	} catch(RemoteException e) {
-                     	System.err.println(&quot;RemoteException- processEditResult, more&quot;);
-                     	logger.debug(&quot;RemoteException- processEditResult, more&quot;);
+                     	System.err.println(&quot;RemoteException- processResult, more&quot;);
+                     	logger.debug(&quot;RemoteException- processResult, more&quot;);
                      	return;
                      }                   
                     int countResult = objectHistory.length;  
@@ -467,24 +468,24 @@
     		historyChange = historyRecord.getHistoryChange();
     		tableName = historyRecord.getHistoryColumn().getTableName();
     		columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
-			oldRecordId = historyChange.getOldRecordId();
-			recordId = historyChange.getRecordId();
-			occurrenceId = historyChange.getOccurrence().getId();		   
-			operation = historyChange.getOperation();
-			oldValue = historyRecord.getOldValue();
+            oldRecordId = historyChange.getOldRecordId();
+            recordId = historyChange.getRecordId();
+            occurrenceId = historyChange.getOccurrence().getId();		   
+            operation = historyChange.getOperation();
+            oldValue = historyRecord.getOldValue();
 						
     		if (tableName.equals(&quot;Occurrence&quot;)){  
     			if (occurrenceId != recordId){
     				logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
     			}
     			
-    			//Get a specified number of columnName from occurrence mapping.
-    			int columnConstant;
-    			if (occurrenceHash.containsKey(columnName)) {
-    				 columnConstant = (Integer)occurrenceHash.get(columnName); 
-    	        } else {
-    	             columnConstant = 0;
-    	        }        	    			
+                        //Get a specified number of columnName from occurrence mapping.
+                        int columnConstant;
+                        if (occurrenceHash.containsKey(columnName)) {
+                                 columnConstant = (Integer)occurrenceHash.get(columnName); 
+                        } else {
+                             columnConstant = 0;
+                        }        	    			
     			  
     			//init Calendar    		
     			Calendar isoDateTime = new GregorianCalendar();
@@ -496,15 +497,15 @@
     			switch (columnConstant) {
 	                case 1: //Taxon  
 	                	if (oldRecordId &gt; 0 ) {
-		                	//Select record Plant where id = oldRocordId 
-		                	Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
-		                	Plant plant = (Plant)object[0];
-		                	//Set old value to attribute plantID
-		                	occurrence.setPlant(plant);
-		                	logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
-		    			}else {
-		    				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-		    			}
+                                    //Select record Plant where id = oldRocordId 
+                                    Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
+                                    Plant plant = (Plant)object[0];
+                                    //Set old value to attribute plantID
+                                    occurrence.setPlant(plant);
+                                    logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
+                                    }else {
+                                            logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+                                    }
 	                    break;
 	                case 2: //Year	
                 	    //Set old value to attribute Year          		
@@ -582,16 +583,16 @@
     		} else if (tableName.equals(&quot;Habitat&quot;) || tableName.equals(&quot;Village&quot;)
     				   || tableName.equals(&quot;Territory&quot;) || tableName.equals(&quot;Phytochorion&quot;)){
     			
-    			// Get a specified number of columnName from habitat mapping.
-    			int columnConstant;
-    			if (habitatHash.containsKey(columnName)) {
-    				 columnConstant = (Integer)habitatHash.get(columnName); 
+                // Get a specified number of columnName from habitat mapping.
+                int columnConstant;
+                if (habitatHash.containsKey(columnName)) {
+                         columnConstant = (Integer)habitatHash.get(columnName); 
     	        } else {
     	             columnConstant = 0;
     	        }        	    			
     			  
     			//informuje o tom, ze byla editovana tabulka tHabitat 
-    			editHabitat = true;
+    			editHabitat = true;                       
     			
     			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
     			logger.debug(&quot;ColumnName: &quot;+ columnName);
@@ -611,42 +612,42 @@
 	                		// existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
 	                		// potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
 	                		// nebo zda editaci nalezu vznikla vazvba 1:1
-	                		relationship = true;
+	                		relationship = true;                                                                            
 	                	} 	                	
  	                    break;
  	                case 2: //Place description 	                	 	                			                		 
                 		occurrence.getHabitat().setDescription(oldValue);		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                         
 	                	} 	              	
  	                	break;
  	                case 3:  //Country 	                	 	                			                		 
                 		occurrence.getHabitat().setCountry(oldValue);		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                          
 	                	} 	
  	                    break;
  	                case 4: //Altitude 	                	                			                		 
                 		occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                          
 	                	} 	
  	                	break;
  	                case 5:  //Latitude   	                		                			                		  
                 		occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                        
 	                	} 	
  	                    break;
  	                case 6: //Longitude 	                		                			                		
                 		occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                         
 	                	} 	
  	                	break;
  	                case 7: //Nearest bigger seat   	                	 	                			                		 
@@ -660,7 +661,7 @@
             				logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
             			}
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                        
 	                	} 	
  	                    break;
  	                case 8: //Phytochorion or phytochorion code 	                	             			                		 
@@ -674,7 +675,7 @@
             				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
             			}
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                        
 	                	} 	
  	                    break; 	               
 	                case 9:  //Territory   	                	                			                		  
@@ -688,21 +689,21 @@
             				logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
             			}	
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                      
 	                	} 	        	
 	                    break;
 	                case 10: //Note habitat	                		                			                		  
                 		occurrence.getHabitat().setNote(oldValue);		                	
 	                	logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
 	                	if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;
+	                		relationship = true;                                        
 	                	} 	
 	                	break;
  	                default:            
  	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
      			}  	    		
     		} else {
-    			logger.equals(&quot;No table defined&quot;);
+    			logger.error(&quot;No table defined&quot;);
     		}    			    		
     	}
  
@@ -717,7 +718,7 @@
     }
     
     public void generateMessageUndo() {    	
-    	messageUndo = &quot;Budou provedeny n&#225;sleduj&#237;c&#237; zm&#283;ny:\n&quot;;
+    	messageUndo = &quot;Budou provedeny n&#225;sleduj&#237;c&#237; zm&#283;ny:\n&quot;;      
     	int count = markItem.size();
     	for (int i=0; i&lt;count; i++) {
     		Object[] itemList = (Object[])(markItem.get(i));
@@ -757,7 +758,9 @@
     		if (! markListId.contains(i)) {
     			continue;
     		}    		    		
-    		historyRecord = (HistoryRecord)editHistoryDataList.get(i);     	  	
+    		historyRecord = (HistoryRecord)editHistoryDataList.get(i); 
+    		historyChange = historyRecord.getHistoryChange();    		
+        	
 	    	try {
 				database.executeDelete(historyRecord);
 				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
@@ -766,9 +769,10 @@
 			} catch (DBLayerException e) {
 				logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
 			}
-			int countResult = searchHistoryChangeId(i);			
-			if (countResult == 1) {
+			int countResult = searchHistoryChangeId(historyChange.getId());			
+			if (countResult == 0) {
 				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
+				//pokud po smazani zaznamu z tHistory jsme nasli alespon jeden zaznam, ktery ma stejny FK na zaznam z tChangeHistory
 				try {
 					database.executeDelete(historyChange);
 					logger.debug(&quot;Deleting historyChange successfully.&quot;);
@@ -792,15 +796,17 @@
      * @return
      */
     public int searchHistoryChangeId(int id){
-    	HistoryChange historyChange = ((HistoryRecord)editHistoryDataList.get(id)).getHistoryChange();
+    	
     	SelectQuery query = null;
         try {
         	    query = database.createQuery(HistoryRecord.class);
         } catch(RemoteException e) {
         	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
-        }        
+        }     
+        // Create aliases for table tHistoryChange.      
+        query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);  
         // Add restriction to cChangeId column 
-        query.addRestriction(PlantloreConstants.RESTR_EQ, HistoryRecord.HISTORYCHANGE, null, historyChange , null);
+        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
         
         int resultIdChange = 0;
         try {                   

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-15 09:44:04 UTC (rev 146)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-17 22:11:28 UTC (rev 147)
@@ -94,7 +94,7 @@
            logger.debug(&quot;display rows: &quot;+ view.getTable().getRowCount());      
            if (model.getCurrentFirstRow() &gt; 1) {
                int firstRow = Math.max(model.getCurrentFirstRow()- model.getDisplayRows(), 1);
-               model.processEditResult(firstRow, model.getDisplayRows()); 
+               model.processResult(firstRow, model.getDisplayRows()); 
                if (model.getCurrentFirstRow() &gt; 1){
                }
                view.getTable().setModel(new HistoryTableModel(model));
@@ -119,7 +119,7 @@
            logger.debug(&quot;display rows: &quot;+ model.getDisplayRows());
            logger.debug(&quot;num rows in table (view) &quot;+ view.getTable().getRowCount());              
            if (model.getCurrentFirstRow()+ view.getTable().getRowCount()&lt;=model.getResultRows()) {
-               model.processEditResult(model.getCurrentFirstRow()+ model.getDisplayRows(), view.getTable().getRowCount());
+               model.processResult(model.getCurrentFirstRow()+ model.getDisplayRows(), view.getTable().getRowCount());
                view.getTable().setModel(new HistoryTableModel(model));             
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;
@@ -140,7 +140,7 @@
        public void actionPerformed(ActionEvent actionEvent)
        {    	   
     	   model.setSelectAll(true);
-    	   model.processEditResult(1,model.getResultRows());    	   
+    	   model.processResult(1,model.getResultRows());    	   
     	   view.getTable().setModel(new HistoryTableModel(model));  
        }
    }
@@ -174,7 +174,7 @@
         	   model.commitUpdate();
         	   model.deleteHistoryRecords();
         	   model.searchEditHistory();
-        	   model.processEditResult(1,model.getDisplayRows());
+        	   model.processResult(1,model.getDisplayRows());
         	   view.getTable().setModel(new HistoryTableModel(model));
         	   int resultRows = model.getResultRows();
         	   if (resultRows == 0) {
@@ -184,7 +184,7 @@
                    int to = from + view.getTable().getRowCount() - 1;               
                    view.setCurrentRowsInfo(from + &quot;-&quot; + to);    
         	   }               
-               view.setCountResutl(resultRows);
+                   view.setCountResutl(resultRows);
            } else {
         	   //Button Cancle was press
         	   //neco jako rollback - bude se volat nebo to bude zarizeno tim, ze se nezavola executeUpdate??
@@ -215,7 +215,7 @@
            logger.debug(&quot;New display rows: &quot;+view.getDisplayRows());
            // If neccessary reload search results
            if ((oldValue != view.getDisplayRows()) &amp;&amp; (model.getDisplayRows() &lt;= model.getResultRows())) {
-               model.processEditResult(model.getCurrentFirstRow(), view.getDisplayRows());
+               model.processResult(model.getCurrentFirstRow(), view.getDisplayRows());
                view.getTable().setModel(new HistoryTableModel(model));
                int from = model.getCurrentFirstRow();
                int to = from + view.getTable().getRowCount() - 1;

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistory.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistory.java	2006-04-15 09:44:04 UTC (rev 146)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistory.java	2006-04-17 22:11:28 UTC (rev 147)
@@ -10,10 +10,24 @@
 package net.sf.plantlore.client.history;
 
 import java.rmi.RemoteException;
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.Hashtable;
 import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.record.Author;
+import net.sf.plantlore.common.record.Habitat;
 import net.sf.plantlore.common.record.HistoryChange;
 import net.sf.plantlore.common.record.HistoryRecord;
+import net.sf.plantlore.common.record.Occurrence;
+import net.sf.plantlore.common.record.Phytochorion;
+import net.sf.plantlore.common.record.Plant;
+import net.sf.plantlore.common.record.Publication;
+import net.sf.plantlore.common.record.Territory;
+import net.sf.plantlore.common.record.Village;
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
 import net.sf.plantlore.server.DBLayerException;
@@ -38,17 +52,61 @@
     /** Index of the first record shown in the table */
     private int currentFirstRow;
     /** Information about current display rows*/
-    private String displayRow;
+    private String displayRow;    
     
     //*******Informations about searching Result from database*****//
     /** Result of the search query */
     private int resultId = 0;
     /** List of data (results of a search query) displayed in the table */
-    private ArrayList&lt;HistoryRecord&gt; editHistoryDataList = new ArrayList(); 
-    // informace pro uzivatele o undo
+    private ArrayList&lt;HistoryRecord&gt; historyDataList = new ArrayList();     
+    // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
+    private ArrayList&lt;Object&gt; editObjectList = new ArrayList();
+    // informace pro uzivatele o record undo
     private String messageUndo;
     
+    //*********************Record of history, ... ***************************************//    
+    private Occurrence occurrence;
+    private HistoryRecord historyRecord;
+    private HistoryChange historyChange;
+    private Publication publication;
+    private Author author;
+    private Village village;
+    private Territory territory;
+    private Phytochorion phytochorion;
     
+     //	**************Informations about HistoryRecord*************//	
+    /** Name of the table where value was changed*/
+    private String tableName;  
+    /** Name of the column where value was changed*/
+    private String columnName;
+    /** Unique value identified occurrence */	
+    private Integer occurrenceId;
+    /**Unique value identified record in table where value was changed */
+    private int recordId;
+    /**Unique value identified record before changed */
+    private int oldRecordId;
+    /** Operation whitch was used*/   
+    private int operation;
+    /** Date and time when the reccord was changed*/
+    private java.util.Date when = new Date();	
+    /** Old value of attribute*/    
+    private String oldValue;
+    /** New value of attribute*/
+    private String newValue;
+   /** Name of user who did changed*/
+    private String nameUser;
+    
+    //********************************************************//
+    /** Mapping of entities */
+    private Hashtable&lt;String, Integer&gt; publicationHash;
+    private Hashtable&lt;String, Integer&gt; habitatHash;
+    private Hashtable&lt;String, Integer&gt; occurrenceHash;  
+    private Hashtable&lt;String, Integer&gt; villageHash;
+    private Hashtable&lt;String, Integer&gt; territoryHash;
+    private Hashtable&lt;String, Integer&gt; phytochorionHash;
+    private Hashtable&lt;String, Integer&gt; authorHash;
+    
+    
     /** Creates a new instance of WholeHistory */
     public WholeHistory(DBLayer database) {
           
@@ -110,7 +168,7 @@
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
             int to = Math.min(currentRow, fromTable+count-1);           
             if (to &lt;= 0) {
-            	editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;(); 
+            	historyDataList = new ArrayList&lt;HistoryRecord&gt;(); 
             	setDisplayRows(0);
             	setCurrentDisplayRows(&quot;0-0&quot;);
             } else {
@@ -129,11 +187,11 @@
                     int countResult = objectHistory.length;  
                     logger.debug(&quot;Results retrieved. Count: &quot;+ countResult);
                     // Create storage for the results
-                    this.editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;();
+                    this.historyDataList = new ArrayList&lt;HistoryRecord&gt;();
                     // Cast the results to the HistoryRecord objects
                     for (int i=0; i&lt;countResult; i++ ) {                    							
 						Object[] objHis = (Object[])objectHistory[i];
-                        this.editHistoryDataList.add((HistoryRecord)objHis[0]);
+                        this.historyDataList.add((HistoryRecord)objHis[0]);
                     }                     
                 } catch (DBLayerException e) {                  
                     logger.error(&quot;Processing search results failed: &quot;+e.toString());            
@@ -146,7 +204,845 @@
         }         
     }
     
+    /**
+     *
+     */
+    public void undoToDate(int toResult) {
+        
+        //Inicalization of hashTable
+    	initOccurrenceHash();
+    	initHabitatHash();   
+        initPublicationHash();
+        initAuthorHash();       
+        	
+    	//number of result
+    	//int countResult = this.historyDataList.size();
+    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
+    	//relationship = false;
+    	//editHabitat = false;
+    	
+    	//take from younger record to older record, undo tu selected row
+    	for( int i=0; i &lt; toResult; i++) {
+    		
+    		//init history data 
+    		historyRecord = (HistoryRecord)historyDataList.get(i);    		
+    		historyChange = historyRecord.getHistoryChange();
+    		tableName = historyRecord.getHistoryColumn().getTableName();
+                recordId = historyChange.getRecordId();
+                operation = historyChange.getOperation();
+    		                                                
+               /** 
+                * Pri insertu a editu nedohledavam column --&gt; prvne rozdelit podle operace a pro edit dale rozdelit podle column
+                */
+                if (operation == historyChange.HISTORYCHANGE_INSERT) {
+                    undoInsertDelete(0);
+                } else if (operation == historyChange.HISTORYCHANGE_EDIT || operation == historyChange.HISTORYCHANGE_EDITGROUP) {
+                    undoEdit();
+                } else if (operation == historyChange.HISTORYCHANGE_DELETE) {
+                    undoInsertDelete(1);
+                } else {
+                    logger.error(&quot;Incorrect opreration code: &quot;+ operation);
+                }                
+        }
+    }
+    
+    /**
+     * ??? Habitat - nemuselo by se zaznamenavat cDelete
+     * ??? Phytochorion, Village, Territory - asi bude potreba cDelete, abychom nezobrazovali nektere polozky, co se historii odstrani
+     * delete == 1 ... smazat
+     * delete == 0 ... obnovit
+     */
+    public void undoInsertDelete(int delete) {
+        if (tableName.equals(&quot;Occurrence&quot;)){
+             Object[] object = searchObject(&quot;Occurrence&quot;,recordId);             
+             Occurrence occurrence = (Occurrence)object[delete];
+             occurrence.setDeleted(1);
+      //  } else if (tableName.equals(&quot;Habitat&quot;)) {
+      //       Object[] object = searchObject(&quot;v&quot;,recordId);  
+      //       Habitat habitat = (Habitat)object[delete];
+      //       habitat.setDeleted(1);
+        } else if (tableName.equals(&quot;Publication&quot;)) {
+             Object[] object = searchObject(&quot;Publication&quot;,recordId);  
+             Publication publication = (Publication)object[delete];
+             publication.setDeleted(1);
+        } else if (tableName.equals(&quot;Author&quot;)) {
+             Object[] object = searchObject(&quot;Author&quot;,recordId);   
+             Author author = (Author)object[delete];
+             author.setDeleted(1);
+        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
+             Object[] object = searchObject(&quot;Phytochorion&quot;,recordId);   
+             Phytochorion phytochorion = (Phytochorion)object[delete];             
+             //phytochorion.setDelete(1);
+        } else if (tableName.equals(&quot;Territoriy&quot;)) {
+             Object[] object = searchObject(&quot;Territory&quot;,recordId); 
+             Territory territory = (Territory)object[delete];             
+             //territory.setDelete(1);
+        } else if (tableName.equals(&quot;Village&quot;)) {
+             Object[] object = searchObject(&quot;Village&quot;,recordId); 
+             Village village = (Village)object[delete];             
+             //village.setDelete(1);
+        } else {
+            logger.error(&quot;No table defined&quot;);
+        }
+    }
+    
+    /**
+     *
+     */
+    public void undoEdit() {
+        
+        //init history data about edit of record
+        columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
+        oldRecordId = historyChange.getOldRecordId();                
+        occurrenceId = historyChange.getOccurrence().getId();		           
+        oldValue = historyRecord.getOldValue();
+        
+        if (tableName.equals(&quot;Occurrence&quot;)){
+                undoOccurrence();
+        } else if (tableName.equals(&quot;Habitat&quot;)) {
+                undoHabitat();
+        } else if (tableName.equals(&quot;Publication&quot;)) {
+                undoPublication();
+        } else if (tableName.equals(&quot;Author&quot;)) {
+                undoAuthor();
+        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
+                undoPhytochorion();
+        } else if (tableName.equals(&quot;Territory&quot;)) {
+                undoTerritory();
+        } else if (tableName.equals(&quot;Village&quot;)) {
+                undoVillage();
+        } else {
+            logger.error(&quot;No table defined&quot;);
+        }
+    }
+
+    /**
+     *
+     */
+    public void undoOccurrence() {
+        
+        //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
+        occurrence = historyChange.getOccurrence();
+        
+        boolean objectList = editObjectList.contains(occurrence);
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(occurrence);
+        }
+        logger.debug(&quot;editObjectList: &quot;+objectList);
+        logger.debug(&quot;OccurrenceID: &quot;+occurrence.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+                
+        if (occurrenceId != recordId){
+            logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
+        }
+
+        //Get a specified number of columnName from occurrence mapping.
+        int columnConstant;
+        if (occurrenceHash.containsKey(columnName)) {
+                 columnConstant = (Integer)occurrenceHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+
+        //init Calendar    		
+        Calendar isoDateTime = new GregorianCalendar();
+
+        switch (columnConstant) {
+        case 1: //Taxon  
+            if (oldRecordId &gt; 0 ) {
+                //Select record Plant where id = oldRocordId 
+                Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
+                Plant plant = (Plant)object[0];
+                //Set old value to attribute plantID
+                occurrence.setPlant(plant);
+                logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
+            } else {
+                 logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+            } 
+            break;
+        case 2: //Year	
+            //Set old value to attribute Year          		
+                occurrence.setYearCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
+                //Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
+                break;
+        case 3: //Month 
+                // Set old value to attribute Month 
+                occurrence.setMonthCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
+            break;
+        case 4: //Day	                	
+                // Set old value to attribute Day            		
+                occurrence.setDayCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                break;
+        case 5: //Time 	                		                	
+                // Set old value to attribute Time   
+                Date time = new Date();
+                SimpleDateFormat df = new SimpleDateFormat( &quot;HH:mm:ss.S&quot; );
+                try {
+                        time = df.parse( oldValue );
+                } catch (ParseException e) {
+                        logger.error(&quot;Parse time failed. &quot;+ e);
+                }
+                occurrence.setTimeCollected(time);
+                logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(time);
+                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+            break;
+        case 6: //Source	                	
+                // Set old value to attribute Source 
+                occurrence.setDataSource(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
+                break;
+        case 7: //Herbarium
+                // Set old value to attribute Herbarium
+                occurrence.setHerbarium(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
+            break;
+        case 8: //Note occurrence	
+                // Set old value to attribute Note occurence	                	
+                occurrence.setNote(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
+                break;
+        case 9: //Publication  
+                //Select record Publication where id = oldRocordId 
+                if (oldRecordId &gt; 0){
+                    Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
+                    Publication publication = (Publication)objectPubl[0];
+                    //Set old value to attribute publicationID
+                    occurrence.setPublication(publication);
+                    logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
+                }else {
+                    logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+                }
+            break;
+        default:            
+            logger.error(&quot;No column defined for name &quot;+ columnName);	                   
+        }         
+    }
+        
+    /**
+     *
+     */
+    public void undoHabitat() {
+        
+        //zaznam v ramci, ktereho doslo k editaci tabulky tHabitats
+        occurrence = historyChange.getOccurrence();
+      
+        //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu, proto nam staci nacist
+        //data z tHabitats pres tOccurrence.cHabitatId a nasledne staci zavolat update jen na occurrence
+        boolean objectList = editObjectList.contains(occurrence); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan (editace habitat vzdy v ramci occurrence)
+            editObjectList.add(occurrence);
+        }
+        logger.debug(&quot;editObjectList: &quot;+objectList);
+        logger.debug(&quot;Habitat - OccurrenceID: &quot;+occurrence.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+        // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (habitatHash.containsKey(columnName)) {
+                 columnConstant = (Integer)habitatHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+
+        //informuje o tom, ze byla editovana tabulka tHabitat 
+//        editHabitat = true;
+
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //Quadrant     	                	
+                /* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
+                 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
+                 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
+                 */ 	                		  
+                occurrence.getHabitat().setQuadrant(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {
+                // existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
+                // potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
+                // nebo zda editaci nalezu vznikla vazvba 1:1
+//                relationship = true;
+                } 	                	
+            break;
+        case 2: //Place description 	                	 	                			                		 
+                occurrence.getHabitat().setDescription(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	              	
+                break;
+        case 3:  //Country 	                	 	                			                		 
+                occurrence.getHabitat().setCountry(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+            break;
+        case 4: //Altitude 	                	                			                		 
+                occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+                break;
+        case 5:  //Latitude   	                		                			                		  
+                occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+            break;
+        case 6: //Longitude 	                		                			                		
+                occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+                break;
+        case 7: //Nearest bigger seat   	                	 	                			                		 
+                //Nacteni Village pro nasledny update tHabitat.cNearestVillageId
+                if (oldRecordId != 0){
+                        Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
+                        Village village = (Village)objectVill[0];
+                occurrence.getHabitat().setNearestVillage(village);
+                logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
+                } else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
+                }
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+            break;
+        case 8: //Phytochorion or phytochorion code 	                	             			                		 
+                // Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
+                if (oldRecordId != 0){
+                        Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
+                        Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
+                        occurrence.getHabitat().setPhytochorion(phytochorion);
+                        logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
+                }else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+                }
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+            break; 	               
+        case 9:  //Territory   	                	                			                		  
+                // Nacteni Territory pro nasledny update tHabitat.cTerritory
+                if (oldRecordId != 0){
+                        Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
+                        Territory territory = (Territory)objectTerr[0];
+                        occurrence.getHabitat().setTerritory(territory);
+                        logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
+                }else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
+                }	
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	        	
+            break;
+        case 10: //Note habitat	                		                			                		  
+                occurrence.getHabitat().setNote(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
+                if (operation == historyChange.HISTORYCHANGE_EDIT) {	                		
+//                        relationship = true;
+                } 	
+                break;
+        default:            
+            logger.error(&quot;Habitat - No column defined for name &quot;+ columnName);	                   
+        }  	          
+    }
+    
+    /**
+     *
+     */
+    public void undoPublication() {
+                
+        Object[] object = searchObject(&quot;Publication&quot;, recordId);
+        publication = (Publication)object[0];
+        
+        //test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(publication); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(publication);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;Publication: &quot;+publication.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (publicationHash.containsKey(columnName)) {
+                 columnConstant = (Integer)habitatHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+      
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //CollectionName     	                	
+                publication.setCollectionName(oldValue);	 
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute collectionName.&quot;);                 	
+            break;
+        case 2: //collectionYearPublication	                	 	                			                		 
+                publication.setCollectionYearPublication(Integer.parseInt(oldValue));	          
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute collectionYearPublication.&quot;);                 	             	
+                break;
+         case 3: //journalName	                	 	                			                		 
+                publication.setJournalName(oldValue);	       
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute journalName.&quot;);                 	             	
+                break;
+        case 4: //journalAuthorName	                	 	                			                		 
+                publication.setJournalAuthorName(oldValue);	 
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute journalAuthorName.&quot;);                 	             	
+                break;
+        case 5: //referenceDetail 	                	 	                			                		 
+                publication.setReferenceDetail(oldValue);	                	
+                logger.debug(&quot;Publication - Set selected value for update of attribute referenceDeatail.&quot;);                 	             	
+                break;
+        case 6: //URL 	                	 	                			                		 
+                publication.setUrl(oldValue);	                	
+                logger.debug(&quot;Publication - Set selected value for update of attribute url.&quot;);                 	             	
+                break;
+        default:            
+            logger.error(&quot;Publication - No column defined for name &quot;+ columnName);	                   
+        } 
+    }
+    
+    /**
+     *
+     */
+    public void undoAuthor() {
+        
+       Object[] object = searchObject(&quot;Author&quot;, recordId);
+       author = (Author)object[0];
        
+       //test, zda jiz dany zaznam byl editovan
+       boolean objectList = editObjectList.contains(author); 
+       if (!objectList) {
+       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+           editObjectList.add(author);
+       }
+       logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+       logger.debug(&quot;author: &quot;+author.getId());
+       logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (authorHash.containsKey(columnName)) {
+                 columnConstant = (Integer)authorHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+      
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //wholeName     	                	
+                author.setWholeName(oldValue);	                 
+                logger.debug(&quot;Author - Set selected value for update of attribute WholeName.&quot;);                 	
+            break;
+        case 2: //address	                	 	                			                		 
+                author.setAddress(oldValue);
+                logger.debug(&quot;Author - Set selected value for update of attribute Address.&quot;);                 	             	
+                break;
+         case 3: //mail	                	 	                			                		 
+                author.setEmail(oldValue);	                      
+                logger.debug(&quot;Author - Set selected value for update of attribute Email.&quot;);                 	             	
+                break;
+        case 4: //phoneNumber	                	 	                			                		 
+                author.setPhoneNumber(oldValue);	                
+                logger.debug(&quot;Author - Set selected value for update of attribute PhoneNumber.&quot;);                 	             	
+                break;
+        case 5: //organization 	                	 	                			                		 
+                author.setOrganization(oldValue);                	
+                logger.debug(&quot;Author - Set selected value for update of attribute organization.&quot;);                 	             	
+                break;
+        case 6: //URL 	                	 	                			                		 
+                author.setUrl(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute url.&quot;);                 	             	
+                break;
+        case 7: //role	                	 	                			                		 
+                author.setRole(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute Role.&quot;);                 	             	
+                break;
+        case 8: //note 	                	 	                			                		 
+                author.setNote(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute Note.&quot;);                 	             	
+                break;
+        default:            
+            logger.error(&quot;Author - No column defined for name &quot;+ columnName);	                   
+        } 
+    }
+    
+    /**
+     *
+     */
+    public void undoPhytochorion() {
+        
+        Object[] object = searchObject(&quot;Phytochorion&quot;, recordId);
+        phytochorion = (Phytochorion)object[0];     
+        
+        //test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(phytochorion); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(phytochorion);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;phytochorion: &quot;+phytochorion.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+      
+        if (columnName.equals(&quot;namePhytochorion&quot;)) {
+            phytochorion.setCode(oldValue);	                 
+            logger.debug(&quot;Phytochorion - Set selected value for update of attribute WholeName.&quot;);                 	
+        } else if (columnName.equals(&quot;code&quot;)) {
+             phytochorion.setName(oldValue);
+             logger.debug(&quot;Phytochorion - Set selected value for update of attribute Address.&quot;);                 	             	
+        } else {
+            logger.error(&quot;Phytochorion - No column defined for name &quot;+ columnName);
+        }              
+    }
+    
+    /**
+     *
+     */
+    public void undoVillage() {
+       
+        Object[] object = searchObject(&quot;Village&quot;, recordId);
+        village = (Village)object[0];
+        
+        // test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(village); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(village);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;village: &quot;+village.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Save new value for the column
+        if (columnName.equals(&quot;nameVillage&quot;)) {
+            village.setName(oldValue);	                 
+            logger.debug(&quot;Village - Set selected value for update of attribute Name.&quot;);                 	
+        } else {
+            logger.error(&quot;Village - No column defined for name &quot;+ columnName);	                   
+        }       
+    }
+    
+    /**
+     *
+     */
+    public void undoTerritory() {
+       
+        Object[] object = searchObject(&quot;Territory&quot;, recordId);
+        territory = (Territory)object[0];
+        
+        // test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(territory); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(territory);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;territory: &quot;+territory.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       if (columnName.equals(&quot;nameTerritory&quot;)) {
+           territory.setName(oldValue);	                 
+           logger.debug(&quot;Territory - Set selected value for update of attribute Name.&quot;);                 	 
+       } else {
+           logger.error(&quot;Territory - No column defined for name &quot;+ columnName);	                   
+       }        
+    }
+    
+    /**
+     * 
+     * @param id
+     * @return
+     */
+    public Object[] searchObject(String typeObject, int id) { 
+      
+    	SelectQuery query = null;
+    	if (typeObject.equals(&quot;Occurrence&quot;)){
+            try {
+            	query = database.createQuery(Occurrence.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Occurrence, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Habitat&quot;)){
+            try {
+            	query = database.createQuery(Habitat.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Habitat, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Plant&quot;)){
+            try {
+            	query = database.createQuery(Plant.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Plant, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Author&quot;)){
+            try {
+            	query = database.createQuery(Author.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Author, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Author.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Publication&quot;)){
+            try {
+            	query = database.createQuery(Publication.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Publication, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Publication.ID, null, id , null);
+    	} else if (typeObject.equals(&quot;Village&quot;)){
+            try {
+            	query = database.createQuery(Village.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject()- Village, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Village.ID, null, id, null);
+    	}  else if  (typeObject.equals(&quot;Territory&quot;)){
+            try {
+            	query = database.createQuery(Territory.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject()- Territory, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.ID, null, id , null); 
+    	} else if (typeObject.equals(&quot;Phytochorion&quot;)){
+            try {
+            	query = database.createQuery(Phytochorion.class);	        		        	    
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject()- Phytochorion, createQuery&quot;);       	  
+            }            
+            query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.ID, null, id , null);
+    	} else {
+    		logger.error(&quot;SearchObject() - Incorrect type of object.&quot;);
+    	}
+                        
+        int resultIdPlant = 0;
+        try {                   
+            resultIdPlant = database.executeQuery(query);        
+        } catch (DBLayerException e) {                   
+            logger.error(&quot;Searching &quot; +typeObject+ &quot; failed. Unable to execute search query.&quot;);
+        } catch (RemoteException e) {		 
+     	   System.err.println(&quot;RemoteException- executeQuery &quot; +typeObject);
+ 	} finally {
+     	   logger.debug(&quot;Searching &quot; +typeObject+ &quot; ends successfully&quot;);
+        }         
+
+       Object[] objects = null;
+       Object[] object = null;
+       try {
+       	    // Retrieve selected row interval         	
+            try {
+                 objects = database.more(resultIdPlant, 1, 1);  
+            } catch(RemoteException e) {            	
+                logger.debug(&quot;RemoteException- searchObject, more&quot;);            	
+            }   
+        	object = (Object[])objects[0];           
+       } catch (DBLayerException e) {
+           // Log and set error in case of an exception
+           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());            
+       } finally {     	    
+    	   return object; 	       	          	   
+       }     	        
+    }
+    
+    /**
+     *  ..... pri whole history se bude do promennych occurrence, atd. nacitat vice ruznych objektu s jinym ID
+     *  ....Musim si ty jednotlive objekty pamatovat --&gt; pole objektu, kde budou jednotlive editovane objekty
+     */
+    public void commitUpdate() {
+    	
+    	int count = editObjectList.size();
+    	for (int i=0; i&lt; count; i++) {
+    		try {
+    			logger.debug(&quot;Object for update: &quot;+editObjectList.get(i));
+                database.executeUpdate(editObjectList.get(i));
+	        } catch (RemoteException e) {
+	                logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
+	        } catch (DBLayerException e) {
+	                logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
+	        }
+       }    	
+    }
+    
+    /**
+     *  vycisteni seznamu editovany objektu: 
+     */
+    public void clearEditObjectList() {
+    	editObjectList.clear();
+    }
+       
+    /**
+     * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
+     * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
+     */
+    public void deleteHistory(int toResult) {
+
+    	//count of selected record
+ //   	int count = historyDataList.size();
+    	
+    	//take from younger record to older record
+    	for( int i=0; i &lt; toResult; i++) {
+//    		if (! markListId.contains(i)) {
+//    			continue;
+//    		}    		    		
+    		historyRecord = (HistoryRecord)historyDataList.get(i); 
+    		historyChange = historyRecord.getHistoryChange(); 
+    		
+	    	try {
+				database.executeDelete(historyRecord);
+				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
+			} catch (RemoteException e) {
+				logger.error(&quot;Deleting historyRecord - remoteException. &quot;+e.toString());
+			} catch (DBLayerException e) {
+				logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
+			}
+			int countResult = searchHistoryChangeId(historyChange.getId());			
+			if (countResult == 0) {
+				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
+				//pokud po smazani zaznamu z tHistory jsme nasli alespon jeden zaznam, ktery ma stejny FK na zaznam z tChangeHistory
+				try {
+					database.executeDelete(historyChange);
+					logger.debug(&quot;Deleting historyChange successfully.&quot;);
+				} catch (RemoteException e) {
+					logger.error(&quot;Deleting historyChange - remoteException. &quot;+e.toString());
+				} catch (DBLayerException e) {
+					logger.error(&quot;Deleting historyChange failed. &quot;+e.toString());
+				}
+			} else {
+				logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
+			}
+    	}
+    	//Clear list 
+//    	markListId.clear();
+//    	markItem.clear();
+    } 
+    
+    /**
+     * Zjisteni kolik zaznamu v tabulce tHistory je provazano s konkretnim zaznamem z tHistoryHange 
+     * @param id
+     * @return
+     */
+    public int searchHistoryChangeId(int id){
+    	HistoryChange historyChange = ((HistoryRecord)historyDataList.get(id)).getHistoryChange();
+    	SelectQuery query = null;
+        try {
+        	    query = database.createQuery(HistoryRecord.class);
+        } catch(RemoteException e) {
+        	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
+        }        
+        // Create aliases for table tHistoryChange.      
+        query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);  
+        // Add restriction to cChangeId column 
+        query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
+        
+        int resultIdChange = 0;
+        try {                   
+        	resultIdChange = database.executeQuery(query);        
+        } catch (DBLayerException e) {                   
+            logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
+        } catch (RemoteException e) {		 
+     	   System.err.println(&quot;RemoteException- searchHistoryChangeId(), executeQuery&quot;);
+ 	    } finally {
+     	   logger.debug(&quot;Searching historyChangeId ends successfully.&quot;);
+        }         
+ 	    
+ 	    int countResult = 100;
+ 	    try {
+			countResult = database.getNumRows(resultIdChange);
+			logger.debug(&quot;SearchHistoryChangeId - Number of result: &quot;+countResult);
+		} catch (RemoteException e) {
+			System.err.println(&quot;RemoteException- searchHistoryChangeId(), getNumRows&quot;);
+		}		
+		return countResult;
+    }
+    
+     //***************************//
+    //****Init Hashtable*********//
+    //**************************//
+    
+    private void initOccurrenceHash() {
+    	occurrenceHash = new Hashtable&lt;String, Integer&gt;(9); 
+        occurrenceHash.put(&quot;plantId&quot;,1);
+        occurrenceHash.put(&quot;yearCollected&quot;,2);
+        occurrenceHash.put(&quot;monthCollected&quot;,3);
+        occurrenceHash.put(&quot;dayCollected&quot;,4);
+        occurrenceHash.put(&quot;timeCollected&quot;,5);           
+        occurrenceHash.put(&quot;dataSource&quot;,6);
+        occurrenceHash.put(&quot;herbarium&quot;,7);        
+        occurrenceHash.put(&quot;noteOccurrence&quot;,8);
+        occurrenceHash.put(&quot;publicationId&quot;,9);       
+        //occurrenceHash.put(&quot;metadataId&quot;,10);
+    }    
+    
+    private void initHabitatHash() {
+    	habitatHash = new Hashtable&lt;String, Integer&gt;(11);         
+        habitatHash.put(&quot;quadrant&quot;,1);
+        habitatHash.put(&quot;description&quot;,2);
+        habitatHash.put(&quot;country&quot;,3);
+        habitatHash.put(&quot;altitude&quot;,4);
+        habitatHash.put(&quot;latitude&quot;,5);
+        habitatHash.put(&quot;longitude&quot;,6);      
+        habitatHash.put(&quot;nameVillage&quot;,7);      
+        habitatHash.put(&quot;namePhytochorion&quot;,8);
+        habitatHash.put(&quot;code&quot;,8);
+        habitatHash.put(&quot;nameTerritory&quot;,9);
+        habitatHash.put(&quot;noteHabitat&quot;,10);
+    }    
+    
+    private void initPublicationHash() {
+        publicationHash = new Hashtable&lt;String, Integer&gt;(6);
+        publicationHash.put(&quot;collectionName&quot;,0);
+        publicationHash.put(&quot;collectionYearPublication&quot;,1);
+        publicationHash.put(&quot;journalName&quot;,2);
+        publicationHash.put(&quot;journalAuthorName&quot;,3);
+        publicationHash.put(&quot;referenceDetail&quot;,4);
+        publicationHash.put(&quot;urlPublication&quot;,5);      
+    }
+    
+    private void initAuthorHash() {
+        authorHash = new Hashtable&lt;String, Integer&gt;(8);
+        authorHash.put(&quot;firstName&quot;,0);
+        authorHash.put(&quot;surname&quot;,1);
+        authorHash.put(&quot;organization&quot;,2);
+        authorHash.put(&quot;role&quot;,3);
+        authorHash.put(&quot;address&quot;,4);
+        authorHash.put(&quot;email&quot;,5);
+        authorHash.put(&quot;urlAuthor&quot;,6);
+        authorHash.put(&quot;noteAuthor&quot;,7);        
+    }              
+    
+       
     //****************************//
     //****Get and set metods*****//
     //**************************//
@@ -170,12 +1066,12 @@
         return resultCount;
     }
 
-    public ArrayList&lt;HistoryRecord&gt; getEditHistoryDataList() {
-              return this.editHistoryDataList;		  
+    public ArrayList&lt;HistoryRecord&gt; getHistoryDataList() {
+              return this.historyDataList;		  
        }
 
-     public void setEditHistoryDataList(ArrayList&lt;HistoryRecord&gt; editHistoryDataList) {
-              this.editHistoryDataList = editHistoryDataList;		  
+     public void setHistoryDataList(ArrayList&lt;HistoryRecord&gt; historyDataList) {
+              this.historyDataList = historyDataList;		  
      } 
     
      public String getCurrentDisplayRows() {

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-04-15 09:44:04 UTC (rev 146)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-04-17 22:11:28 UTC (rev 147)
@@ -170,10 +170,27 @@
                view.messageUndoSelection();
            } else {
                logger.debug(&quot;Undo to date - id of selected row: &quot;+ view.tableHistoryList.getSelectedRow());
+               int toResult = view.tableHistoryList.getSelectedRow() + model.getCurrentFirstRow();
+               model.clearEditObjectList();
+               model.undoToDate(toResult);
                int okCancle = view.messageUndo(&quot;model.getMessageUndo()&quot;);      
                if (okCancle == 0){
-                       //Button OK was press
-                       logger.debug(&quot;Button OK was press.&quot;);                       
+                   //Button OK was press
+                   logger.debug(&quot;Button OK was press.&quot;);    
+                   model.commitUpdate();
+                   model.deleteHistory(toResult);
+		    	   model.searchWholeHistoryData();        	
+		    	   model.processResult(1,model.getDisplayRows());
+		    	   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));
+		    	   Integer resultRows = model.getResultRows();
+	        	   if (resultRows == 0) {
+	        		   view.displayedValueLabel.setText(&quot;0-0&quot;); 
+	        	   } else {
+	        		   int from = model.getCurrentFirstRow();
+	                   int to = from + view.tableHistoryList.getRowCount() - 1;               
+	                   view.displayedValueLabel.setText(from + &quot;-&quot; + to);    
+	        	   }               
+	                   view.totalResultValueLabel.setText(resultRows.toString());
                } else {
                        //Button Cancle was press
                        //neco jako rollback - bude se volat nebo to bude zarizeno tim, ze se nezavola executeUpdate??

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-04-15 09:44:04 UTC (rev 146)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-04-17 22:11:28 UTC (rev 147)
@@ -64,7 +64,7 @@
     	
     	logger.debug(&quot;WholeHistory - Init data.&quot;);
     	
-    	editHistoryDataList = model.getEditHistoryDataList();
+    	editHistoryDataList = model.getHistoryDataList();
     	if (editHistoryDataList.size()==0 ){
     		this.data = new Object[0][];
     		return;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000151.html">[Plantlore-dev] [Fwd: Re:plantlore]
</A></li>
	<LI>Next message: <A HREF="000153.html">[Plantlore-dev] r148 - trunk/src/net/sf/plantlore/common
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#152">[ date ]</a>
              <a href="thread.html#152">[ thread ]</a>
              <a href="subject.html#152">[ subject ]</a>
              <a href="author.html#152">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
