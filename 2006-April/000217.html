<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r194 - in trunk/src/net/sf/plantlore: client/authors common middleware server
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r194%20-%20in%20trunk/src/net/sf/plantlore%3A%20client/authors%20common%20middleware%20server&In-Reply-To=%3C200604281713.k3SHDNKq003133%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000216.html">
   <LINK REL="Next"  HREF="000218.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r194 - in trunk/src/net/sf/plantlore: client/authors common middleware server</H1>
    <B>kovo at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r194%20-%20in%20trunk/src/net/sf/plantlore%3A%20client/authors%20common%20middleware%20server&In-Reply-To=%3C200604281713.k3SHDNKq003133%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r194 - in trunk/src/net/sf/plantlore: client/authors common middleware server">kovo at berlios.de
       </A><BR>
    <I>Fri Apr 28 19:13:23 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000216.html">[Plantlore-dev] Upravy v DBLayer
</A></li>
        <LI>Next message: <A HREF="000218.html">[Plantlore-dev] r195 - trunk/src/net/sf/plantlore/config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#217">[ date ]</a>
              <a href="thread.html#217">[ thread ]</a>
              <a href="subject.html#217">[ subject ]</a>
              <a href="author.html#217">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: kovo
Date: 2006-04-28 19:12:59 +0200 (Fri, 28 Apr 2006)
New Revision: 194

Modified:
   trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
   trunk/src/net/sf/plantlore/common/PlantloreConstants.java
   trunk/src/net/sf/plantlore/middleware/DBLayer.java
   trunk/src/net/sf/plantlore/middleware/SelectQuery.java
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
   trunk/src/net/sf/plantlore/server/SelectQueryImplementation.java
Log:
Major DBLayer update. Added history, authentication, sessions and other minor changes.

Modified: trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -12,6 +12,8 @@
 import java.util.Observable;
 import net.sf.plantlore.common.PlantloreConstants;
 import net.sf.plantlore.common.record.Author;
+import net.sf.plantlore.common.record.AuthorOccurrence;
+import net.sf.plantlore.common.record.Occurrence;
 import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.middleware.SelectQuery;
 import net.sf.plantlore.server.DBLayerException;
@@ -37,7 +39,7 @@
     /** Organization of the author */
     private String organization;
     /** Role of the author */
-    private String role;   
+    private String role;
     /** Address of the author */
     private String address;
     /** Phone number of the author */
@@ -55,13 +57,13 @@
     /** Role field used for searching */
     private String searchRole;
     /** Email field used for searching */
-    private String searchEmail;            
+    private String searchEmail;
     /** Flag telling whether a long running operation has already finished */
     private boolean done;
     /** Result of the search query */
     private int resultId = 0;
     /** Constant with default number of rows to display */
-    private static final int DEFAULT_DISPLAY_ROWS = 10;    
+    private static final int DEFAULT_DISPLAY_ROWS = 10;
     /** Actual number of rows to display */
     private int displayRows = DEFAULT_DISPLAY_ROWS;
     /** Data (results of a search query) displayed in the table */
@@ -80,22 +82,22 @@
     public static final int SORT_ORGANIZATION = 2;
     public static final int SORT_ROLE = 3;
     public static final int SORT_EMAIL = 4;
-    public static final int SORT_PHONE = 5;    
-    public static final int SORT_URL = 6;        
-    /** 
+    public static final int SORT_PHONE = 5;
+    public static final int SORT_URL = 6;
+    /**
      *  Creates a new instance of AuthorManager.
      *  @param database Instance of a database management object
      */
     public AuthorManager(DBLayer database) {
         logger = Logger.getLogger(this.getClass().getPackage().getName());
         this.database = database;
-    }    
+    }
     
     /**
      *  Save new author to the database. Information about the author are stored in data fields of this class.
      *  Operation is executed in a separate thread using &lt;code&gt;SwingWorker&lt;/code&gt;. Error is set in case of an exception.
      */
-    public void saveAuthor() {     
+    public void saveAuthor() {
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
                 // The operation is not finished yet
@@ -122,10 +124,10 @@
                     done = true;
                     return null;
                 } catch(RemoteException e) {
-                	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                    System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
                 }
                 logger.info(&quot;Author &quot;+name+&quot; saved successfuly.&quot;);
-                if (isResultAvailable()) {                
+                if (isResultAvailable()) {
                     searchAuthor();
                 }
                 done = true;
@@ -133,7 +135,7 @@
             }
         };
         worker.start();
-    }    
+    }
     
     /**
      *  Delete an author from the database. To-be-deleted author is identified by his ID and is
@@ -143,28 +145,28 @@
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
                 // Operation not finished yet
-                done = false;                
+                done = false;
                 try {
                     // Execute query
-                    database.executeDelete((Author)data.get(getAuthorIndex()));                            
+                    database.executeDelete((Author)data.get(getAuthorIndex()));
                 } catch (DBLayerException e) {
                     // Log and set an error
                     logger.error(&quot;Deleting author failed. Unable to execute delete query.&quot;);
                     setError(e);
-                    // Set operation state to finished                    
-                    done = true;       
+                    // Set operation state to finished
+                    done = true;
                     return null;
                 } catch(RemoteException e) {
-                	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                    System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
                 }
                 // Execute author search - required in order to display up-to-date data in the table of authors
-                searchAuthor();                
+                searchAuthor();
                 // Set operation state to finished
-                done = true;       
+                done = true;
                 return null;
-            }        
+            }
         };
-        worker.start();            
+        worker.start();
     }
     
     public void editAuthor() {
@@ -178,115 +180,133 @@
     public void searchAuthor() {
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
+/*
+                SelectQuery query;
+                Integer qid;
+                Occurrence nalez;
+                try {
+                    query = database.createQuery(Occurrence.class);
+                    query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, 17, null);
+                    qid = database.executeQuery(query);
+                    Object[] vysledky = database.next(qid);
+                    nalez = (Occurrence)vysledky[0];
+                    System.out.println(&quot;dlzka vysledkov: &quot;+vysledky.length);
+                    query = database.createQuery(AuthorOccurrence.class);
+                    query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.OCCURRENCE, null, nalez, null);
+                    query.addRestriction(PlantloreConstants.RESTR_EQ, AuthorOccurrence.ROLE, null, &quot;collect&quot;, null);
+                    qid = database.executeQuery(query);
+                    Object[] vysledky2 = database.next(qid);
+                    AuthorOccurrence autOcc = (AuthorOccurrence)vysledky2[0];
+                    System.out.println(autOcc.getAuthor().getWholeName());
+                } catch(RemoteException e) {
+                    System.err.println(&quot;RemoteException- searchInsertInfo(), createQuery&quot;);
+                } catch (DBLayerException e1) {
+                    System.out.println(&quot;DBLayer exception&quot;);
+                }
+ 
+                query = database.createQuery(Authors.class);
+                query.createAlias(&quot;authorsOccurrences&quot;, &quot;ao&quot;);
+                query.addRestriction(PlantloreConstants.RESTR_EQ, ao.OCCURRENCE, null, occurrence, null);
+ */
                 // Operation not finished yet
-                done = false;                
+                done = false;
                 // Create new Select query
                 SelectQuery query;
                 try {
-					query = database.createQuery(Author.class);
-
-					if (searchName != null)
-						query.addRestriction(PlantloreConstants.RESTR_LIKE,
-								Author.WHOLENAME, null, &quot;%&quot; + searchName + &quot;%&quot;,
-								null);
-					if (searchOrganization != null)
-						query.addRestriction(PlantloreConstants.RESTR_LIKE,
-								Author.ORGANIZATION, null, &quot;%&quot;
-										+ searchOrganization + &quot;%&quot;, null);
-					if (searchRole != null)
-						query
-								.addRestriction(PlantloreConstants.RESTR_LIKE,
-										Author.ROLE, null, &quot;%&quot; + searchRole
-												+ &quot;%&quot;, null);
-					if (searchEmail != null)
-						query.addRestriction(PlantloreConstants.RESTR_LIKE,
-								Author.EMAIL, null, &quot;%&quot; + searchEmail + &quot;%&quot;,
-								null);
-					String field;
-					switch (sortField) {
-					case 1:
-						field = Author.WHOLENAME;
-						break;
-					case 2:
-						field = Author.ORGANIZATION;
-						break;
-					case 3:
-						field = Author.ROLE;
-						break;
-					case 4:
-						field = Author.EMAIL;
-						break;
-					case 5:
-						field = Author.PHONENUMBER;
-						break;
-					case 6:
-						field = Author.URL;
-						break;
-					default:
-						field = Author.WHOLENAME;
-					}
-
-					if (sortDirection == 0) {
-						query.addOrder(PlantloreConstants.DIRECT_ASC, field);
-					} else {
-						query.addOrder(PlantloreConstants.DIRECT_DESC, field);
-					}
-					int resultId = 0;
-					try {
-						// Execute query
-						resultId = database.executeQuery(query);
-					} catch (DBLayerException e) {
-						// Log and set an error
-						logger
-								.error(&quot;Searching authors failed. Unable to execute search query.&quot;);
-						setError(e);
-						// setError(&quot;Searching authors failed. Please contact
-						// your administrator.&quot;);
-					} finally {
-						// Set operation state to finished
-						done = true;
-						// Save the results
-						setResult(resultId);
-					}
-					return resultId;
-				} catch (RemoteException e) {
-					System.err
-							.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
-					return null;
-				}
+                    query = database.createQuery(Author.class);                    
+                    if (searchName != null)
+                        query.addRestriction(PlantloreConstants.RESTR_LIKE, Author.WHOLENAME, null, &quot;%&quot; + searchName + &quot;%&quot;, null);
+                    if (searchOrganization != null)
+                        query.addRestriction(PlantloreConstants.RESTR_LIKE, Author.ORGANIZATION, null, &quot;%&quot; + searchOrganization + &quot;%&quot;, null);
+                    if (searchRole != null)
+                        query.addRestriction(PlantloreConstants.RESTR_LIKE, Author.ROLE, null, &quot;%&quot; + searchRole + &quot;%&quot;, null);
+                    if (searchEmail != null)
+                        query.addRestriction(PlantloreConstants.RESTR_LIKE, Author.EMAIL, null, &quot;%&quot; + searchEmail + &quot;%&quot;, null);
+                    String field;
+                    switch (sortField) {
+                        case 1:
+                            field = Author.WHOLENAME;
+                            break;
+                        case 2:
+                            field = Author.ORGANIZATION;
+                            break;
+                        case 3:
+                            field = Author.ROLE;
+                            break;
+                        case 4:
+                            field = Author.EMAIL;
+                            break;
+                        case 5:
+                            field = Author.PHONENUMBER;
+                            break;
+                        case 6:
+                            field = Author.URL;
+                            break;
+                        default:
+                            field = Author.WHOLENAME;
+                    }
+                    
+                    if (sortDirection == 0) {
+                        query.addOrder(PlantloreConstants.DIRECT_ASC, field);
+                    } else {
+                        query.addOrder(PlantloreConstants.DIRECT_DESC, field);
+                    }
+                    int resultId = 0;
+                    try {
+                        // Execute query
+                        resultId = database.executeQuery(query);
+                    } catch (DBLayerException e) {
+                        // Log and set an error
+                        logger
+                                .error(&quot;Searching authors failed. Unable to execute search query.&quot;);
+                        setError(e);
+                        // setError(&quot;Searching authors failed. Please contact
+                        // your administrator.&quot;);
+                    } finally {
+                        // Set operation state to finished
+                        done = true;
+                        // Save the results
+                        setResult(resultId);
+                    }
+                    return resultId;
+                } catch (RemoteException e) {
+                    System.err
+                            .println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                    return null;
+                }
             }
         };
         worker.start();
     }
-
+    
     /**
-	 * Checks whether an error is set. If yes, notifies observers to display it.
-	 * Finally unsets the error flag.
-	 * 
-	 * @return &lt;code&gt;true&lt;/code&gt; if an error was set (and observers were
-	 *         notified), &lt;code&gt;false&lt;/code&gt; otherwise
-	 */
+     * Checks whether an error is set. If yes, notifies observers to display it.
+     * Finally unsets the error flag.
+     *
+     * @return &lt;code&gt;true&lt;/code&gt; if an error was set (and observers were
+     *         notified), &lt;code&gt;false&lt;/code&gt; otherwise
+     */
     public boolean processErrors() {
         if (this.error != null) {
             setChanged();
-            notifyObservers();        
+            notifyObservers();
             this.error = null;
             return true;
         }
         return false;
     }
-
+    
     /**
-	 * Process results of a search query. Retrieves results using the database
-	 * management object (DBLayer) and stores them in the data field of the
-	 * class. Notifies observers about the changes. Sets an error in case of an
-	 * exception.
-	 * 
-	 * @param from
-	 *            number of the first row to retrieve.
-	 * @param count
-	 *            number of rows to retrieve
-	 */
+     * Process results of a search query. Retrieves results using the database
+     * management object (DBLayer) and stores them in the data field of the
+     * class. Notifies observers about the changes. Sets an error in case of an
+     * exception.
+     *
+     * @param from
+     *            number of the first row to retrieve.
+     * @param count
+     *            number of rows to retrieve
+     */
     public void processResults(int from, int count) {
         if (this.resultId != 0) {
             logger.debug(&quot;Rows in the result: &quot;+getResultRows());
@@ -294,19 +314,19 @@
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
             int to = Math.min(getResultRows(), from+count-1);
             if (to == 0) {
-                this.data = new ArrayList();                
+                this.data = new ArrayList();
             } else {
-                logger.debug(&quot;Retrieving query results: &quot;+from+&quot; - &quot;+to);                
+                logger.debug(&quot;Retrieving query results: &quot;+from+&quot; - &quot;+to);
                 try {
                     // Retrieve selected row interval
-                	Object[] objArray;
-                	try {
-                            // FIXME: Should change all the usages of processResults to use 0 as the index of the forst row
-                            // from-1 and to-1 just temporary
-                            objArray = database.more(resultId, from-1, to-1);
-                	} catch(RemoteException e) {
-                    	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
-                    	return;
+                    Object[] objArray;
+                    try {
+                        // FIXME: Should change all the usages of processResults to use 0 as the index of the forst row
+                        // from-1 and to-1 just temporary
+                        objArray = database.more(resultId, from-1, to-1);
+                    } catch(RemoteException e) {
+                        System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                        return;
                     }
                     logger.debug(&quot;Results retrieved. Count: &quot;+objArray.length);
                     // Create storage for the results
@@ -321,10 +341,10 @@
                     logger.error(&quot;Processing search results failed: &quot;+e.toString());
                     setError(e);
                 }
-                // Update current first displayed row (only if data retrieval was successful). 
+                // Update current first displayed row (only if data retrieval was successful).
                 if (!this.isError()) {
                     // Update current first displayed row
-                    setCurrentFirstRow(from);            
+                    setCurrentFirstRow(from);
                 }
             }
             // Tell observers to update
@@ -350,7 +370,7 @@
         this.setUrl(selectedAuth.getUrl());
         this.setNote(selectedAuth.getNote());
         setChanged();
-        notifyObservers();        
+        notifyObservers();
     }
     
     /**
@@ -368,13 +388,13 @@
     public int getResult() {
         return this.resultId;
     }
-       
+    
     public int getResultRows() {
-    	int result = 0;
+        int result = 0;
         if (resultId != 0) try {
-        	result = database.getNumRows(resultId);
+            result = database.getNumRows(resultId);
         } catch(RemoteException e) {
-        	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+            System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
         }
         return result;
     }
@@ -426,7 +446,7 @@
     /**
      *  Set index of currently selected author. The index is used to locate author record in the data field.
      *  @param index index of currently selected author
-     */    
+     */
     protected void setAuthorIndex(int index) {
         this.authorIndex = index;
     }
@@ -462,7 +482,7 @@
     public void setCurrentFirstRow(int row) {
         this.currentFirstRow = row;
     }
-      
+    
     /**
      *  Indicates whether a long running operation executed in a separate thread has already finished.
      *  @return true if the operation is finished (no operation running), false otherwise
@@ -470,7 +490,7 @@
     public boolean isOperationDone() {
         return this.done;
     }
-            
+    
     /**
      *  Indicate whether result of a search query is available at the momoent
      *  @return true if search query result is available
@@ -489,7 +509,7 @@
     public void setSortField(int field) {
         this.sortField = field;
     }
-
+    
     /**
      *  Set direction of sorting.
      *  @param direction direction of sorting. 0 for ascending, 1 for descending
@@ -497,11 +517,11 @@
     public void setSortDirection(int direction) {
         this.sortDirection = direction;
     }
-
+    
     /**
      *  Set name search field.
      *  @param name name of author to search for
-     */    
+     */
     public void setSearchName(String name) {
         this.searchName = name;
     }
@@ -509,7 +529,7 @@
     /**
      *  Set organization search field.
      *  @param organization organization of author used for searching
-     */    
+     */
     public void setSearchOrganization(String organization) {
         this.searchOrganization = organization;
     }
@@ -517,7 +537,7 @@
     /**
      *  Set role search field.
      *  @param role role of author used for searching
-     */    
+     */
     public void setSearchRole(String role) {
         this.searchRole = role;
     }
@@ -525,7 +545,7 @@
     /**
      *  Set email search field.
      *  @param email email of author used for searching
-     */    
+     */
     public void setSearchEmail(String email) {
         this.searchEmail = email;
     }
@@ -537,7 +557,7 @@
     public String getName() {
         return name;
     }
-
+    
     /**
      *  Set name of the author.
      *  @param name name of the author
@@ -545,7 +565,7 @@
     public void setName(String name) {
         this.name = name;
     }
-
+    
     /**
      *  Get organization of the author.
      *  @return string with the organization of the author
@@ -553,7 +573,7 @@
     public String getOrganization() {
         return organization;
     }
-
+    
     /**
      *  Set organization of the author.
      *  @param organization organization of the author
@@ -561,7 +581,7 @@
     public void setOrganization(String organization) {
         this.organization = organization;
     }
-
+    
     /**
      *  Get role of the author.
      *  @return string with the role of the author
@@ -569,7 +589,7 @@
     public String getRole() {
         return role;
     }
-
+    
     /**
      *  Set role of the author.
      *  @param role role of the author
@@ -577,7 +597,7 @@
     public void setRole(String role) {
         this.role = role;
     }
-
+    
     /**
      *  Get address of the author.
      *  @return string with the address of the author
@@ -585,7 +605,7 @@
     public String getAddress() {
         return address;
     }
-
+    
     /**
      *  Set address of the author.
      *  @param address address of the author
@@ -593,7 +613,7 @@
     public void setAddress(String address) {
         this.address = address;
     }
-
+    
     /**
      *  Get phone number of the author.
      *  @return string with the phone number of the author
@@ -601,7 +621,7 @@
     public String getPhoneNumber() {
         return phoneNumber;
     }
-
+    
     /**
      *  Set phone number of the author.
      *  @param phoneNumber phone number of the author
@@ -609,7 +629,7 @@
     public void setPhoneNumber(String phoneNumber) {
         this.phoneNumber = phoneNumber;
     }
-
+    
     /**
      *  Get email of the author.
      *  @return string with the email of the author
@@ -617,7 +637,7 @@
     public String getEmail() {
         return email;
     }
-
+    
     /**
      *  Set email of the author.
      *  @param email email of the author
@@ -625,7 +645,7 @@
     public void setEmail(String email) {
         this.email = email;
     }
-
+    
     /**
      *  Get URL of the author.
      *  @return string with the URL of the author
@@ -633,7 +653,7 @@
     public String getUrl() {
         return url;
     }
-
+    
     /**
      *  Set URL of the author.
      *  @param url URL of the author
@@ -641,7 +661,7 @@
     public void setUrl(String url) {
         this.url = url;
     }
-
+    
     /**
      *  Get note of the author.
      *  @return string with the note of the author
@@ -649,12 +669,12 @@
     public String getNote() {
         return note;
     }
-
+    
     /**
      *  Set note of the author.
      *  @param note note of the author
      */
     public void setNote(String note) {
         this.note = note;
-    }    
+    }
 }
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/common/PlantloreConstants.java
===================================================================
--- trunk/src/net/sf/plantlore/common/PlantloreConstants.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/common/PlantloreConstants.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -72,6 +72,10 @@
     public static final int DIRECT_ASC            = 60;
     public static final int DIRECT_DESC           = 61;    
             
+    public static final int INSERT                = 1;
+    public static final int UPDATE                = 2;
+    public static final int DELETE                = 3;
+    
     /** Creates a new instance of PlantloreConstants */
     public PlantloreConstants() {
     }

Modified: trunk/src/net/sf/plantlore/middleware/DBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -10,6 +10,7 @@
 import java.io.Serializable;
 import java.rmi.Remote;
 import java.rmi.RemoteException;
+import net.sf.plantlore.common.record.Right;
 import net.sf.plantlore.server.DBLayerException;
 
 /**
@@ -22,7 +23,7 @@
 public interface DBLayer extends Remote, Serializable {
     
     /** Initialize database connection */
-    void initialize(String dbID, String user, String password) throws DBLayerException, RemoteException;
+    Right initialize(String dbID, String user, String password) throws DBLayerException, RemoteException;
     
     public int executeInsert(Object data) throws DBLayerException, RemoteException;
     
@@ -38,10 +39,13 @@
         
     public void close() throws DBLayerException, RemoteException;
     
+    // TODO: Pridat throws DBLayerException
     public SelectQuery createQuery(Class classname) throws RemoteException;
 
     public int executeQuery(SelectQuery query) throws DBLayerException, RemoteException;
     
+    public void closeQuery(SelectQuery query);
+    
     public void shutdown() throws RemoteException;
         
 }

Modified: trunk/src/net/sf/plantlore/middleware/SelectQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/SelectQuery.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/middleware/SelectQuery.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -31,6 +31,8 @@
      */    
     void createAlias(String propertyName, String aliasName)  throws RemoteException;
     
+    void setDistinct() throws RemoteException;
+    
     /**
      *  Add restriction to the constructed criteria. Restrictions are parts of the where condition.
      *

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -1,7 +1,7 @@
 /*
  * HibernateDBLayer.java
  *
- * Created on 18. &#250;nor 2006, 22:31
+ * Created on April 18, 2006, 22:31
  *
  */
 
@@ -13,6 +13,18 @@
 import java.rmi.server.UnicastRemoteObject;
 import java.rmi.server.Unreferenced;
 import java.util.Hashtable;
+import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.record.Author;
+import net.sf.plantlore.common.record.HistoryChange;
+import net.sf.plantlore.common.record.HistoryColumn;
+import net.sf.plantlore.common.record.HistoryRecord;
+import net.sf.plantlore.common.record.Occurrence;
+import net.sf.plantlore.common.record.Phytochorion;
+import net.sf.plantlore.common.record.Publication;
+import net.sf.plantlore.common.record.Right;
+import net.sf.plantlore.common.record.Territory;
+import net.sf.plantlore.common.record.User;
+import net.sf.plantlore.common.record.Village;
 import org.apache.log4j.Logger;
 import org.hibernate.HibernateException;
 import org.hibernate.ScrollableResults;
@@ -30,26 +42,35 @@
  *  
  *  TODO: Nezapominat generovat stub! (rmic net.sf.plantlore.server.HibernateDBLayer)
  *
- *  @author Tom&#225;&#353; Kova&#345;&#237;k (database parts), Erik Kratochv&#237;l (rmi parts)
+ *  @author Tomas Kovarik (database parts), Erik Kratochvil (rmi parts)
  *  @version far from ready!
  */
 public class HibernateDBLayer implements DBLayer, Unreferenced {
     /** Instance of a logger */
     private Logger logger;
     /** Configuration file for Hibernate */
-    private File configFile;   
-    /** Hibernate session */
-    private Session session;
+    private File configFile;
     /** Pool of select queries */        
     private Hashtable&lt;Integer, ScrollableResults&gt; results;
     /** Maximum result ID used */
     private int maxResultId;
     
+    private int maxSessionId;
+    /** Session factory for creating Hibernate sessions */
+    private SessionFactory sessionFactory;    
+    /** List of select queries */
+    private Hashtable&lt;SelectQuery, SelectQuery&gt; queries;    
     
-    private Hashtable&lt;SelectQuery, SelectQuery&gt; queries;
+    private Hashtable&lt;SelectQuery, Session&gt; sessions;
+    /** Authenticated user */
+    private User plantloreUser;
+    /** Rights of the authenticated user */
+    private Right rights;    
     
+    private static final int INITIAL_POOL_SIZE = 8;
     
-    /** Creates a new instance of HibernateDBLayer.
+    /**
+     * Creates a new instance of HibernateDBLayer.
      * 
      *  @param undertaker The object that is responsible for cleanup if the client crashes. 
      */
@@ -61,31 +82,29 @@
     
     /** Creates a new instance of HibernateDBLayer */
     public HibernateDBLayer() {
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-        
-        
-        logger.debug(&quot;      Constructing a new HibernateDBLayer ...&quot;);
-        
-        // Initialize pool of result sets, initial capacity = 8
-        results = new Hashtable&lt;Integer, ScrollableResults&gt;(8); 
+        logger = Logger.getLogger(this.getClass().getPackage().getName());                
+        logger.debug(&quot;      Constructing a new HibernateDBLayer ...&quot;);        
+        // Initialize pool of result sets, initial capacity = INITIAL POOL SIZE
+        results = new Hashtable&lt;Integer, ScrollableResults&gt;(INITIAL_POOL_SIZE); 
         // Initialize maximum result id
-        maxResultId = 0;
-        
-        // Table of all living queries, initial capacity = 8
-        queries = new Hashtable&lt;SelectQuery, SelectQuery&gt;(8);
-        
+        maxResultId = 0;        
+        maxSessionId = 0;
+        // Table of all living queries, initial capacity = INITIAL_POOL_SIZE
+        queries = new Hashtable&lt;SelectQuery, SelectQuery&gt;(INITIAL_POOL_SIZE);        
+        sessions = new Hashtable&lt;SelectQuery, Session&gt;(INITIAL_POOL_SIZE);
         logger.debug(&quot;      completed.&quot;);
     }    
     
     /**
      *  Initialize database connection. Fire up Hibernate and open a session.
+     *  Authenticate user and Load rights of this user
      *  
-     *  FIXME prepracovat initialize tak, aby pouzival zaslane informace &amp; nacitala prava!
-     *  
      *  @throws DBLayerException when the hibernate or database connection cannot be initialized
      */
-    public void initialize(String dbID, String user, String password) throws DBLayerException {
+    public Right initialize(String dbID, String user, String password) throws DBLayerException {
         Configuration cfg;
+        int result = 0;
+        
         // File containing Hibernate configuration
         configFile = new File(&quot;hibernate.cfg.xml&quot;);        
         // Load Hibernate configuration
@@ -95,23 +114,39 @@
             logger.fatal(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());
             throw new DBLayerException(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());            
         }
-
-        //cfg.setProperty(&quot;hibernate.connection.url&quot;, &quot;jdbc:firebirdsql:localhost/3050:c:/Temp/plantloreHIBdata.fdb&quot;);
-        //cfg.setProperty(&quot;hibernate.connection.url&quot;, &quot;jdbc:firebirdsql:localhost/3050:c:/Kovo/DatabaseTest/database/plantlore.fdb&quot;);
-        //cfg.setProperty(&quot;hibernate.connection.url&quot;, &quot;jdbc:firebirdsql:localhost/3050:/mnt/data/temp/plantloreHIBdata.fdb&quot;);
+        // TODO: this should be loaded from a configuration file on the server
+        // We are temporarily using this for DB authetication and user athentication as well
         cfg.setProperty(&quot;hibernate.connection.url&quot;, dbID);
-        //cfg.setProperty(&quot;hibernate.connection.url&quot;, &quot;jdbc:<A HREF="postgresql://localhost:5432/plantlore">postgresql://localhost:5432/plantlore</A>&quot;);
         cfg.setProperty(&quot;hibernate.connection.username&quot;, user);
         cfg.setProperty(&quot;hibernate.connection.password&quot;, password);        
         try {
             // Build session factory
-            SessionFactory sessionFactory = cfg.buildSessionFactory();
-            // Open Session
-            this.session = sessionFactory.openSession();                
+            sessionFactory = cfg.buildSessionFactory();
         } catch (HibernateException e) {
-            logger.fatal(&quot;Cannot create Hibernate session. Details: &quot;+e.getMessage());
-            throw new DBLayerException(&quot;Cannot create Hibernate session. Details: &quot;+e.getMessage());                        
+            logger.fatal(&quot;Cannot build Hibernate session factory. Details: &quot;+e.getMessage());
+            throw new DBLayerException(&quot;Cannot build Hibernate session factory. Details: &quot;+e.getMessage());
         }        
+        // Authenticate user
+        try {
+            SelectQuery sq = this.createQuery(User.class);            
+            sq.addRestriction(PlantloreConstants.RESTR_EQ, User.LOGIN, null, user, null);
+            result = this.executeQuery(sq);
+        } catch (RemoteException e) {
+            logger.fatal(&quot;Cannot load user information. Details: &quot;+e.getMessage());
+        }
+        Object[] userinfo = next(result);
+        if (userinfo == null) {
+            // Authentication failed, close DB connection
+            sessionFactory.close();
+            sessionFactory = null;
+            logger.warn(&quot;Authentication of user &quot;+user+&quot; failed!&quot;);
+            return null;
+        } else {
+            User clientUser = (User)userinfo[0];
+            this.rights = clientUser.getRight();           
+            this.plantloreUser = clientUser;
+        }
+        return rights;
     }    
     
     /**
@@ -122,7 +157,105 @@
      *  @throws DBLayerException when saving data into the database fails
      */
     public int executeInsert(Object data) throws DBLayerException {
+        int recordId, id, result = 0;        
+        String table;
+        HistoryColumn column;
+        
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }        
+        Session session = sessionFactory.openSession();
+        Transaction tx = null;                
+        try {
+            // Begin transaction
+            tx = session.beginTransaction();            
+            // Save item into the database
+            recordId = (Integer)session.save(data);            
+            // Save data to history tables - only for selected tables
+            if ((data instanceof Publication) || (data instanceof Territory) ||
+                (data instanceof Village) || (data instanceof Phytochorion) ||
+                (data instanceof Author) || (data instanceof Occurrence)) {
+                HistoryChange historyChange = new HistoryChange();
+                if (data instanceof Occurrence) {
+                    historyChange.setOccurrence((Occurrence)data);
+                    historyChange.setRecordId(0);
+                    table = PlantloreConstants.ENTITY_OCCURRENCE;
+                } else {
+                    historyChange.setOccurrence(null);
+                    if (data instanceof Publication) {
+                        table = PlantloreConstants.ENTITY_PUBLICATION;
+                    } else if (data instanceof Territory) {
+                        table = PlantloreConstants.ENTITY_TERRITORY;                        
+                    } else if (data instanceof Village) {
+                        table = PlantloreConstants.ENTITY_VILLAGE;                        
+                    } else if (data instanceof Phytochorion) {
+                        table = PlantloreConstants.ENTITY_PHYTOCHORION;                        
+                    } else if (data instanceof Author) {
+                        table = PlantloreConstants.ENTITY_AUTHOR;                        
+                    } else {
+                        table = &quot;&quot;;
+                    }
+                    historyChange.setRecordId(recordId);
+                }
+                historyChange.setOldRecordId(0);
+                historyChange.setOperation(PlantloreConstants.INSERT);
+                historyChange.setWho(this.plantloreUser);
+                historyChange.setWhen(new java.util.Date());
+                
+                // Load record from THistoryColumn table
+                try {
+                    SelectQuery sq = this.createQuery(HistoryColumn.class);
+                    sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
+                    sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
+                    result = this.executeQuery(sq);
+                } catch (RemoteException e) {
+                    logger.fatal(&quot;Cannot load HistoryChange information. Details: &quot;+e.getMessage());
+                }
+                Object[] objCol = next(result);
+                if (objCol == null) {                
+                    logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                    throw new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);                    
+                } else {
+                    column = (HistoryColumn)objCol[0];
+                }                
+                HistoryRecord history = new HistoryRecord();
+                history.setHistoryColumn(column);
+                history.setNewValue(null);
+                history.setOldValue(null);
+                // Save into the database
+                recordId = (Integer)session.save(historyChange);
+                history.setHistoryChange(historyChange);                
+                recordId = (Integer)session.save(history);                
+            }
+            // Commit transaction
+            tx.commit();                                      
+        } catch (HibernateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
+            throw new DBLayerException(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
+        } finally {
+            session.close();
+        }
+        return recordId;
+    }
+
+    /**
+     *  Insert data into the database without modifying history tables
+     *
+     *  @param data data to insert (one of the data holder objects)
+     *  @return identifier (primary key) of the inserted row
+     *  @throws DBLayerException when saving data into the database fails
+     */
+    public int executeInsertHistory(Object data) throws DBLayerException {
         int recordId;        
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }        
+        Session session = sessionFactory.openSession();
         Transaction tx = null;        
         try {
             // Begin transaction
@@ -137,6 +270,8 @@
             }
             logger.fatal(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
             throw new DBLayerException(&quot;Saving record into the database failed. Details: &quot;+e.getMessage());
+        } finally {
+            session.close();
         }
         return recordId;
     }
@@ -148,7 +283,98 @@
      *  @throws DBLayerException when deleting data fails
      */
     public void executeDelete(Object data) throws DBLayerException {
+        String table;
+        int id, result = 0;
+        HistoryColumn column;
+        
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }        
+        Session session = sessionFactory.openSession();        
         Transaction tx = null;
+        // Save records to history if required
+        try {        
+            if ((data instanceof Publication) || (data instanceof Author) || (data instanceof Occurrence)) {
+                HistoryChange historyChange = new HistoryChange();
+                if (data instanceof Occurrence) {
+                    historyChange.setOccurrence((Occurrence)data);
+                    historyChange.setRecordId(0);
+                    table = PlantloreConstants.ENTITY_OCCURRENCE;
+                } else {
+                    historyChange.setOccurrence(null);
+                    if (data instanceof Publication) {
+                        id = ((Publication)data).getId();
+                        table = PlantloreConstants.ENTITY_PUBLICATION;
+                    } else if (data instanceof Author) {
+                        id = ((Author)data).getId();
+                        table = PlantloreConstants.ENTITY_AUTHOR;                        
+                    } else {
+                        id = 0;
+                        table = &quot;&quot;;
+                    }
+                    historyChange.setRecordId(id);
+                }
+                historyChange.setOldRecordId(0);
+                historyChange.setOperation(PlantloreConstants.DELETE);
+                historyChange.setWho(this.plantloreUser);
+                historyChange.setWhen(new java.util.Date());
+                
+                // Load record from THistoryColumn table
+                try {
+                    SelectQuery sq = this.createQuery(HistoryColumn.class);
+                    sq.addRestriction(PlantloreConstants.RESTR_EQ, HistoryColumn.TABLENAME, null, table, null);
+                    sq.addRestriction(PlantloreConstants.RESTR_IS_NULL, HistoryColumn.COLUMNNAME, null, null, null);
+                    result = this.executeQuery(sq);
+                } catch (RemoteException e) {
+                    logger.fatal(&quot;Cannot load HistoryChange information. Details: &quot;+e.getMessage());
+                }
+                Object[] objCol = next(result);
+                if (objCol == null) {                
+                    logger.error(&quot;tHistoryColumn doesn't contain required data&quot;);
+                    throw new DBLayerException(&quot;tHistoryColumn doesn't contain required data&quot;);                    
+                } else {
+                    column = (HistoryColumn)objCol[0];
+                }                
+                HistoryRecord history = new HistoryRecord();
+                history.setHistoryChange(historyChange);
+                history.setHistoryColumn(column);
+                history.setNewValue(null);
+                history.setOldValue(null);
+                // Save into the database
+                session.save(historyChange);
+                session.save(history);                
+            }        
+            // Save the data itself
+            tx = session.beginTransaction();
+            // Save item into the database
+            session.delete(data);
+            // Commit transaction
+            tx.commit();                                      
+        } catch (HibernateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
+            throw new DBLayerException(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
+        } finally {
+            session.close();
+        }
+    }
+
+    /**
+     *  Delete data from the database without modifying history tables
+     *
+     *  @param data data we want to delete (must be one of the holder objects)
+     *  @throws DBLayerException when deleting data fails
+     */
+    public void executeDeleteHistory(Object data) throws DBLayerException {
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }
+        Session session = sessionFactory.openSession();        
+        Transaction tx = null;
         try {
             tx = session.beginTransaction();
             // Save item into the database
@@ -161,6 +387,8 @@
             }
             logger.fatal(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
             throw new DBLayerException(&quot;Deleting record from the database failed. Details: &quot;+e.getMessage());
+        } finally {
+            session.close();
         }
     }
     
@@ -171,8 +399,15 @@
      *  @throws DBLayerException when updating data fails
      */
     public void executeUpdate(Object data) throws DBLayerException {
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }
+        Session session = sessionFactory.openSession();
         Transaction tx = null;
         try {
+            // Save data into history tables if required
+            // TODO
             tx = session.beginTransaction();
             // Save item into the database
             session.update(data);
@@ -184,8 +419,40 @@
             }
             logger.fatal(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
             throw new DBLayerException(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
-        }                
+        } finally {
+            session.close();
+        }
     }
+
+    /**
+     *  Update data in the database without modifying history tables.
+     *
+     *  @param data to update (must be one of the holder objects)
+     *  @throws DBLayerException when updating data fails
+     */
+    public void executeUpdateHistory(Object data) throws DBLayerException {
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }
+        Session session = sessionFactory.openSession();
+        Transaction tx = null;
+        try {
+            tx = session.beginTransaction();
+            // Save item into the database
+            session.update(data);
+            // Commit transaction
+            tx.commit();                                      
+        } catch (HibernateException e) {
+            if (tx != null) {
+                tx.rollback();
+            }
+            logger.fatal(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
+            throw new DBLayerException(&quot;Updating record in the database failed. Details: &quot;+e.getMessage());
+        } finally {
+            session.close();
+        }
+    }
     
     /**
      *  Get more rows from the current result set.
@@ -285,11 +552,15 @@
      *  @throws DBLayerException when closing session fails
      */
     public void close() throws DBLayerException {    
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }        
         try {
-            session.close();
+            sessionFactory.close();
         } catch (HibernateException e) {
-            logger.fatal(&quot;Cannot close session&quot;);
-            throw new DBLayerException(&quot;Cannot close session&quot;);            
+            logger.fatal(&quot;Cannot close session factory&quot;);
+            throw new DBLayerException(&quot;Cannot close session factory&quot;);            
         }
     }
     
@@ -300,7 +571,13 @@
      *  @return an instance of &lt;code&gt;SelectQuery&lt;/code&gt; used for building a query by client
      *
      */
+    // TODO: Pridat throws DBLayerException
     public SelectQuery createQuery(Class classname) throws RemoteException {
+        if (sessionFactory == null) {
+            logger.warn(&quot;SessionFactory not avilable&quot;);
+            // throw new DBLayerException(&quot;SessionFactory not available&quot;);
+        }
+        Session session = sessionFactory.openSession();
         SelectQuery query = new SelectQueryImplementation(session.createCriteria(classname)), 
         	stub = query;
         
@@ -308,7 +585,7 @@
         	stub = (SelectQuery) UnicastRemoteObject.exportObject(query); 
         
         queries.put(stub, query);
-        
+        sessions.put(stub, session);
         return stub;
     }    
     
@@ -319,7 +596,7 @@
      *  @throws DBLayerException when selecting records from the database fails
      */
     public int executeQuery(SelectQuery query) throws DBLayerException {
-    	
+
     	SelectQuery selectQuery = queries.remove(query);
     	if(selectQuery == null) throw new DBLayerException(&quot;You can only pass queries created by this DBLayer!&quot;);
     	
@@ -333,9 +610,8 @@
     	if(sq == null) logger.fatal(&quot;Class cast failed. Why the fuck?!&quot;);
     	
         Transaction tx = null;        
-        ScrollableResults res;
-        
-        
+        ScrollableResults res;        
+        Session session = sessions.get(query);
         try {
             tx = session.beginTransaction();
             // Execute detached criteria query
@@ -351,17 +627,16 @@
         }
         // Update current maximum result id and save the results
         maxResultId++; 
-        /* FIXME: NIKDE NENI maxResultId-- nebo tak neco, to je ficura nebo BUG?
-         * Si predstav, ze hypoteticky by nekdo drzel resultid = 0 dlouho, a mezitim 
-         * by se nekomu povedlo vykonat ty 4miliardy dotazu (nemusi to bejt uplne
-         * za vlasy pritazeny, kdyz budou v db statisice zaznamu) a dostal by se  s tim
-         * resultid zase na nulu. ale resultid = 0 uz v hashtable je, takze by to vratilo
-         * spatne...
-         */
         results.put(maxResultId, res);
         return maxResultId;
     }
     
+    public void closeQuery(SelectQuery query) {
+        Session session = sessions.get(query);
+        session.close();
+        sessions.remove(query);
+    }
+    
     /**
      * This method is intended for final cleanup. &lt;b&gt;Do not call this method yourself!
      * The proper way for you to get rid of a DBLayer is to call DBLayer.destroy() method!&lt;/b&gt;

Modified: trunk/src/net/sf/plantlore/server/SelectQueryImplementation.java
===================================================================
--- trunk/src/net/sf/plantlore/server/SelectQueryImplementation.java	2006-04-27 19:25:10 UTC (rev 193)
+++ trunk/src/net/sf/plantlore/server/SelectQueryImplementation.java	2006-04-28 17:12:59 UTC (rev 194)
@@ -14,6 +14,7 @@
 
 import org.hibernate.Criteria;
 import org.hibernate.FetchMode;
+import org.hibernate.criterion.CriteriaSpecification;
 import org.hibernate.criterion.Order;
 import org.hibernate.criterion.Projections;
 import org.hibernate.criterion.Restrictions;
@@ -60,6 +61,10 @@
         criteria.createAlias(propertyName, aliasName);
     }
     
+    public void setDistinct() {
+        criteria.setResultTransformer(CriteriaSpecification.DISTINCT_ROOT_ENTITY);
+    }
+    
     /**
      *  Add restriction to the constructed criteria. Restrictions are parts of the where condition.
      *  


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000216.html">[Plantlore-dev] Upravy v DBLayer
</A></li>
	<LI>Next message: <A HREF="000218.html">[Plantlore-dev] r195 - trunk/src/net/sf/plantlore/config
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#217">[ date ]</a>
              <a href="thread.html#217">[ thread ]</a>
              <a href="subject.html#217">[ subject ]</a>
              <a href="author.html#217">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
