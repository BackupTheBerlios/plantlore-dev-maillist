<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r169 - in trunk/src/net/sf/plantlore/client: . history
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r169%20-%20in%20trunk/src/net/sf/plantlore/client%3A%20.%20history&In-Reply-To=%3C200604211530.k3LFUxcT017854%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000180.html">
   <LINK REL="Next"  HREF="000182.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r169 - in trunk/src/net/sf/plantlore/client: . history</H1>
    <B>lada at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r169%20-%20in%20trunk/src/net/sf/plantlore/client%3A%20.%20history&In-Reply-To=%3C200604211530.k3LFUxcT017854%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r169 - in trunk/src/net/sf/plantlore/client: . history">lada at berlios.de
       </A><BR>
    <I>Fri Apr 21 17:30:59 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000180.html">[Plantlore-dev] r168 - in trunk/src/net/sf/plantlore: client/login l10n server server/manager
</A></li>
        <LI>Next message: <A HREF="000182.html">[Plantlore-dev]Fwd:Re:data - export/import - aktualizace tPlants
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#181">[ date ]</a>
              <a href="thread.html#181">[ thread ]</a>
              <a href="subject.html#181">[ subject ]</a>
              <a href="author.html#181">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: lada
Date: 2006-04-21 17:30:58 +0200 (Fri, 21 Apr 2006)
New Revision: 169

Removed:
   trunk/src/net/sf/plantlore/client/history/WholeHistory.java
Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
Log:
Integrate of the models of both history (History + WholeHistory = History).

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -24,7 +24,7 @@
 import javax.swing.ListSelectionModel;
 import javax.swing.event.ListSelectionEvent;
 import javax.swing.event.ListSelectionListener;
-import net.sf.plantlore.client.history.WholeHistory;
+import net.sf.plantlore.client.history.History;
 import net.sf.plantlore.client.history.WholeHistoryCtrl;
 import net.sf.plantlore.client.history.WholeHistoryView;
 import net.sf.plantlore.common.record.Author;
@@ -35,7 +35,6 @@
 import net.sf.plantlore.client.authors.AuthorManager;
 import net.sf.plantlore.client.authors.AuthorManagerCtrl;
 import net.sf.plantlore.client.authors.AuthorManagerView;
-import net.sf.plantlore.client.history.History;
 import net.sf.plantlore.client.history.HistoryCtrl;
 import net.sf.plantlore.client.history.HistoryView;
 import net.sf.plantlore.client.login.Login;
@@ -73,7 +72,7 @@
     HistoryCtrl historyCtrl;
     
     //History of &quot;database&quot; 
-    WholeHistory wholeHistoryModel;
+    History wholeHistoryModel;
     WholeHistoryView wholeHistoryView;
     WholeHistoryCtrl wholeHistoryCtrl;
     
@@ -401,7 +400,7 @@
             //toto volani historie nebude v menu, ale jako tlacitko pro vybrany zaznam        
             //o vybranem zaznamu predame informace, ktere chceme o nem v historii zobrazit
             //jmeno rosliny, jmeno autora a lokaci a idOccurrences
-            
+                                   
             historyModel = new History(model.getDatabase(),&quot;Adis Abeba&quot;, &quot;Lada&quot;, &quot;Praha v&#253;chod&quot;, 1);
             historyView = new HistoryView(historyModel, view, true);
             historyCtrl = new HistoryCtrl(historyModel, historyView);
@@ -414,7 +413,7 @@
         {
             System.out.println(&quot;Whole history - Undo selected&quot;);
             
-            wholeHistoryModel = new WholeHistory(model.getDatabase());
+            wholeHistoryModel = new History(model.getDatabase());
             wholeHistoryView = new WholeHistoryView(wholeHistoryModel, view, true);
             wholeHistoryCtrl = new WholeHistoryCtrl(wholeHistoryModel, wholeHistoryView);
             wholeHistoryView.setVisible(true); 

Modified: trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/DetailsHistoryView.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -18,7 +18,7 @@
     /**
      * Creates new form DetailsHistoryView
      */
-    public DetailsHistoryView(WholeHistory model, javax.swing.JDialog parent, boolean modal) {
+    public DetailsHistoryView(History model, javax.swing.JDialog parent, boolean modal) {
         super(parent, modal);
         setDefaultCloseOperation(JDialog.HIDE_ON_CLOSE);
         initComponents();        

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -1,6 +1,12 @@
-/**
- * 
+/*
+ * History.java
+ *
+ * Created on 14. duben 2006, 15:43
+ *
+ * To change this template, choose Tools | Template Manager
+ * and open the template in the editor.
  */
+
 package net.sf.plantlore.client.history;
 
 import java.rmi.RemoteException;
@@ -12,36 +18,30 @@
 import java.util.GregorianCalendar;
 import java.util.HashSet;
 import java.util.Hashtable;
-import java.util.Observable;
-
-import net.sf.plantlore.middleware.DBLayer;
-import net.sf.plantlore.server.DBLayerException;
-import net.sf.plantlore.middleware.SelectQuery;
 import net.sf.plantlore.common.PlantloreConstants;
+import net.sf.plantlore.common.record.Author;
 import net.sf.plantlore.common.record.Habitat;
+import net.sf.plantlore.common.record.HistoryChange;
+import net.sf.plantlore.common.record.HistoryRecord;
 import net.sf.plantlore.common.record.Occurrence;
 import net.sf.plantlore.common.record.Phytochorion;
 import net.sf.plantlore.common.record.Plant;
 import net.sf.plantlore.common.record.Publication;
 import net.sf.plantlore.common.record.Territory;
-import net.sf.plantlore.common.record.HistoryRecord;
-import net.sf.plantlore.common.record.HistoryChange;
 import net.sf.plantlore.common.record.Village;
-
-
+import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.middleware.SelectQuery;
+import net.sf.plantlore.server.DBLayerException;
 import org.apache.log4j.Logger;
 
-
 /**
- * @author Lada Oberreiterova
  *
+ * @author Lada
  */
-public class History extends Observable {
-
-    /** Instance of a logger */
-    private Logger logger;   
-    /** Exception with details about an error */
-    private DBLayerException error = null;
+public class History {
+    
+      /** Instance of a logger */
+    private Logger logger;      
     /** Instance of a database management object */
     private DBLayer database;   
     /** Constant with default number of rows to display */
@@ -51,13 +51,19 @@
     /** Index of the first record shown in the table */
     private int currentFirstRow;
     /** Information about current display rows*/
-    private String displayRow;
+    private String displayRow;    
     
     //*******Informations about searching Result from database*****//
     /** Result of the search query */
     private int resultId = 0;
     /** List of data (results of a search query) displayed in the table */
-    private ArrayList&lt;HistoryRecord&gt; editHistoryDataList = new ArrayList();    
+    private ArrayList&lt;HistoryRecord&gt; historyDataList = new ArrayList();     
+    // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
+    private ArrayList&lt;Object&gt; editObjectList = new ArrayList();
+    // informace pro uzivatele o record undo
+    private String messageUndo;
+
+    //************************************pro historii jednoho nalezu*********************/
     //seznam id vsech oznacenych polozek
     private HashSet markListId = new HashSet();
     //Seznam Item + maxIdItem (nejstarsi oznacene id pro dany Item=sloupec)
@@ -68,15 +74,18 @@
     private boolean relationship;
     //Informuje o tom zda doslo k editaci polozky z tabulky tHabitat
     private boolean editHabitat;
-    //zprava pro uzivatele
-    private String messageUndo;
     
-    //*********************Record of history ***************************************//    
+    //*********************Record of history, ... ***************************************//    
     private Occurrence occurrence;
     private HistoryRecord historyRecord;
     private HistoryChange historyChange;
-	
-    //	**************Informations about HistoryRecord*************//	
+    private Publication publication;
+    private Author author;
+    private Village village;
+    private Territory territory;
+    private Phytochorion phytochorion;
+    
+     //	**************Informations about HistoryRecord*************//	
     /** Name of the table where value was changed*/
     private String tableName;  
     /** Name of the column where value was changed*/
@@ -94,10 +103,10 @@
     /** Old value of attribute*/    
     private String oldValue;
     /** New value of attribute*/
-    private String newValue;
-    /** Name of user who did changed*/
+    //private String newValue;
+   /** Name of user who did changed*/
     private String nameUser;
-	
+    
     //**************Informations about occurrences***************//
     /** Name of plant for specified occurrenc*/
     private String namePlant;
@@ -105,14 +114,31 @@
     private String nameAuthor;
     /** Informaciton about location for specified occurrenc*/
     private String location;
-
-     //********************************************************//
-     /** Mapping of entities */
+    
+    //********************************************************//
+    /** Mapping of entities */
+    private Hashtable&lt;String, Integer&gt; publicationHash;
     private Hashtable&lt;String, Integer&gt; habitatHash;
     private Hashtable&lt;String, Integer&gt; occurrenceHash;  
+    private Hashtable&lt;String, Integer&gt; authorHash;
     
+    
+    /**
+     * Creates a new instance of History - history of whole database
+     */
+    public History(DBLayer database) {
+          
+       logger = Logger.getLogger(this.getClass().getPackage().getName());	 
+       this.database = database;
+       
+       //nacist vsechny data z historie --&gt;bez podminky, jen je seradit podle casu
+       searchWholeHistoryData();
+       //opet funkci pro vyzadani si dat postupne
+       processResult(1, displayRows);
+    }
+    
     /**  
-     *  Creates a new instance of History 
+     *  Creates a new instance of History - history of specific occurrence 
      *  @param database Instance of a database management object
      *  @param namePlant Name of plant for specified occurrence
      *  @param nameAuthor Name of author for specified occurrence
@@ -190,7 +216,8 @@
 	   //Process results of a search &quot;edit&quot; query 
 	   processResult(1,displayRows);
     }	
-
+    
+    
     /**
      *  Searches for information about data entries concerned with specified occurrence.   
      */
@@ -250,7 +277,7 @@
             // Execute query                    
             resultIdEdit = database.executeQuery(query); 
             // Save &quot;edit&quot; history data
-            setEditResult(resultIdEdit);
+            setResultId(resultIdEdit);
         } catch (DBLayerException e) {
             // Log and set an error                   
             logger.error(&quot;Searching history data with condition 'operation = edit' failed. Unable to execute search query.&quot;);           
@@ -288,23 +315,55 @@
         }       
     }
     
+    /**
+     *
+     */
+    public void searchWholeHistoryData() {
+        
+        //Create new Select query
+        SelectQuery query = null;       
+
+    	//  Select data from tHistory table
+        try {
+			query = database.createQuery(HistoryRecord.class);
+			// Create aliases for table tHistoryChange.
+			query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);
+			// sort by date/time
+			query.addOrder(PlantloreConstants.DIRECT_DESC, &quot;hc.when&quot;);
+		} catch (RemoteException e) {
+                System.err.println(&quot;RemoteException- searchWholeHistoryData(), createQuery&quot;);
+        }
+                
+    	
+        int resultId = 0;
+        try {
+            // Execute query                    
+            resultId = database.executeQuery(query);
+            // Save &quot;edit&quot; history data
+            setResultId(resultId);    
+        } catch (DBLayerException e) {                            
+            logger.error(&quot;Searching whole history data failed. Unable to execute search query.&quot;);           
+        } catch (RemoteException e) { 		   
+     	   System.err.println(&quot;RemoteException- searchWholeHistoryData(), executeQuery&quot;);
+        }          
+    }
     
-    /**
+   /**
      * Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field of the class. 
      * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
      * @param count number of rows to retrieve 
      */
     public void processResult(int fromTable, int count) {
-    	
-    	if (this.resultId != 0) {
-    		int currentRow = getResultRows();
+        
+        if (this.resultId != 0) {
+            int currentRow = getResultRows();
             logger.debug(&quot;Rows in the result: &quot;+currentRow);
             logger.debug(&quot;Max available rows: &quot;+(fromTable+count-1));
            
             // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
             int to = Math.min(currentRow, fromTable+count-1);           
             if (to &lt;= 0) {
-            	editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;(); 
+            	historyDataList = new ArrayList&lt;HistoryRecord&gt;(); 
             	setDisplayRows(0);
             	setCurrentDisplayRows(&quot;0-0&quot;);
             } else {
@@ -316,18 +375,18 @@
                  	try {
                  		objectHistory = database.more(this.resultId, 1, to);  
                  	} catch(RemoteException e) {
-                     	System.err.println(&quot;RemoteException- processResult, more&quot;);
-                     	logger.debug(&quot;RemoteException- processResult, more&quot;);
+                     	System.err.println(&quot;RemoteException- processEditResult, more&quot;);
+                     	logger.debug(&quot;RemoteException- processEditResult, more&quot;);
                      	return;
                      }                   
                     int countResult = objectHistory.length;  
                     logger.debug(&quot;Results retrieved. Count: &quot;+ countResult);
                     // Create storage for the results
-                    this.editHistoryDataList = new ArrayList&lt;HistoryRecord&gt;();
+                    this.historyDataList = new ArrayList&lt;HistoryRecord&gt;();
                     // Cast the results to the HistoryRecord objects
                     for (int i=0; i&lt;countResult; i++ ) {                    							
 						Object[] objHis = (Object[])objectHistory[i];
-                        this.editHistoryDataList.add((HistoryRecord)objHis[0]);
+                        this.historyDataList.add((HistoryRecord)objHis[0]);
                     }           
                     //Update current first displayed row (only if data retrieval was successful)
                     setCurrentFirstRow(fromTable); 
@@ -337,18 +396,636 @@
             }
         }         
     }
+    
+    /**
+     *
+     */
+    public void undoToDate(int toResult) {
+        
+        //Inicalization of hashTable
+    	initOccurrenceHash();
+    	initHabitatHash();   
+        initPublicationHash();
+        initAuthorHash();       
+        	
+    	//number of result
+    	//int countResult = this.historyDataList.size();
+    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
+    	//relationship = false;
+    	//editHabitat = false;
+    	
+    	//take from younger record to older record, undo tu selected row
+    	for( int i=0; i &lt; toResult; i++) {
+    		
+    		//init history data 
+    		historyRecord = (HistoryRecord)historyDataList.get(i);    		
+    		historyChange = historyRecord.getHistoryChange();
+    		tableName = historyRecord.getHistoryColumn().getTableName();
+                recordId = historyChange.getRecordId();
+                operation = historyChange.getOperation();
+    		                                                
+               /** 
+                * Pri insertu a editu nedohledavam column --&gt; prvne rozdelit podle operace a pro edit dale rozdelit podle column
+                */
+                if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
+                    undoInsertDelete(0);
+                } else if (operation == HistoryChange.HISTORYCHANGE_EDIT || operation == HistoryChange.HISTORYCHANGE_EDITGROUP) {
+                    undoEdit();
+                } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
+                    undoInsertDelete(1);
+                } else {
+                    logger.error(&quot;Incorrect opreration code: &quot;+ operation);
+                }                
+        }
+    }
+    
+    /**
+     *  Volani UNDO z historie pro jeden nalez
+     */
+    public void undoSelected() {
+    	
+    	// Inicalization of hashTable
+    	initOccurrenceHash();
+    	initHabitatHash();    	  
+        	
+    	//number of result
+    	int countResult = getResultRows();
+    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
+    	relationship = false;
+    	editHabitat = false;
+    	
+    	//take from younger record to older record
+    	for( int i=0; i &lt; countResult; i++) {
+    		if (! markListId.contains(i)) {
+    			continue;
+    		}
+    		
+    		// init history data about edit of record
+    		historyRecord = (HistoryRecord)historyDataList.get(i);    		
+    		historyChange = historyRecord.getHistoryChange();
+    		tableName = historyRecord.getHistoryColumn().getTableName();    		  		    			           
+            recordId = historyChange.getRecordId();           	   
+            operation = historyChange.getOperation();
        
+            
+            //zavolani funkce, ktera undo pro operaci edit
+            undoEdit();    		
+    	}
+    	//generated information form user
+    	generateMessageUndo();
+    }
+    
+    /**
+     * ??? Habitat - nemuselo by se zaznamenavat cDelete
+     * ??? Phytochorion, Village, Territory - asi bude potreba cDelete, abychom nezobrazovali nektere polozky, co se historii odstrani
+     * delete == 1 ... smazat
+     * delete == 0 ... obnovit
+     */
+    public void undoInsertDelete(int delete) {
+        if (tableName.equals(&quot;Occurrence&quot;)){
+             Object[] object = searchObject(&quot;Occurrence&quot;,recordId);             
+             Occurrence occurrence = (Occurrence)object[delete];
+             occurrence.setDeleted(1);
+      //  } else if (tableName.equals(&quot;Habitat&quot;)) {
+      //       Object[] object = searchObject(&quot;v&quot;,recordId);  
+      //       Habitat habitat = (Habitat)object[delete];
+      //       habitat.setDeleted(1);
+        } else if (tableName.equals(&quot;Publication&quot;)) {
+             Object[] object = searchObject(&quot;Publication&quot;,recordId);  
+             Publication publication = (Publication)object[delete];
+             publication.setDeleted(1);
+        } else if (tableName.equals(&quot;Author&quot;)) {
+             Object[] object = searchObject(&quot;Author&quot;,recordId);   
+             Author author = (Author)object[delete];
+             author.setDeleted(1);
+        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
+             Object[] object = searchObject(&quot;Phytochorion&quot;,recordId);   
+             Phytochorion phytochorion = (Phytochorion)object[delete];             
+             //phytochorion.setDelete(1);
+        } else if (tableName.equals(&quot;Territoriy&quot;)) {
+             Object[] object = searchObject(&quot;Territory&quot;,recordId); 
+             Territory territory = (Territory)object[delete];             
+             //territory.setDelete(1);
+        } else if (tableName.equals(&quot;Village&quot;)) {
+             Object[] object = searchObject(&quot;Village&quot;,recordId); 
+             Village village = (Village)object[delete];             
+             //village.setDelete(1);
+        } else {
+            logger.error(&quot;No table defined&quot;);
+        }
+    }
+    
+    /**
+     *
+     */
+    public void undoEdit() {
+        
+        //init history data about edit of record
+        columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
+        oldRecordId = historyChange.getOldRecordId();                
+        occurrenceId = historyChange.getOccurrence().getId();		           
+        oldValue = historyRecord.getOldValue();
+        
+        if (tableName.equals(&quot;Occurrence&quot;)){
+                undoOccurrence();
+        } else if (tableName.equals(&quot;Habitat&quot;)) {
+                undoHabitat();
+        } else if (tableName.equals(&quot;Publication&quot;)) {
+                undoPublication();
+        } else if (tableName.equals(&quot;Author&quot;)) {
+                undoAuthor();
+        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
+                undoPhytochorion();
+        } else if (tableName.equals(&quot;Territory&quot;)) {
+                undoTerritory();
+        } else if (tableName.equals(&quot;Village&quot;)) {
+                undoVillage();
+        } else {
+            logger.error(&quot;No table defined&quot;);
+        }
+    }
 
     /**
+     *
+     */
+    public void undoOccurrence() {
+        
+        //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
+        occurrence = historyChange.getOccurrence();
+        
+        boolean objectList = editObjectList.contains(occurrence);
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(occurrence);
+        }
+        logger.debug(&quot;editObjectList: &quot;+objectList);
+        logger.debug(&quot;OccurrenceID: &quot;+occurrence.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+                
+        if (occurrenceId != recordId){
+            logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
+        }
+
+        //Get a specified number of columnName from occurrence mapping.
+        int columnConstant;
+        if (occurrenceHash.containsKey(columnName)) {
+                 columnConstant = (Integer)occurrenceHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+
+        //init Calendar    		
+        Calendar isoDateTime = new GregorianCalendar();
+
+        switch (columnConstant) {
+        case 1: //Taxon  
+            if (oldRecordId &gt; 0 ) {
+                //Select record Plant where id = oldRocordId 
+                Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
+                Plant plant = (Plant)object[0];
+                //Set old value to attribute plantID
+                occurrence.setPlant(plant);
+                logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
+            } else {
+                 logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+            } 
+            break;
+        case 2: //Year	
+            //Set old value to attribute Year          		
+                occurrence.setYearCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
+                //Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
+                break;
+        case 3: //Month 
+                // Set old value to attribute Month 
+                occurrence.setMonthCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
+            break;
+        case 4: //Day	                	
+                // Set old value to attribute Day            		
+                occurrence.setDayCollected(Integer.parseInt(oldValue));
+                logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(occurrence.getTimeCollected());
+                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+                break;
+        case 5: //Time 	                		                	
+                // Set old value to attribute Time   
+                Date time = new Date();
+                SimpleDateFormat df = new SimpleDateFormat( &quot;HH:mm:ss.S&quot; );
+                try {
+                        time = df.parse( oldValue );
+                } catch (ParseException e) {
+                        logger.error(&quot;Parse time failed. &quot;+ e);
+                }
+                occurrence.setTimeCollected(time);
+                logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
+                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
+                isoDateTime.setTime(time);
+                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
+                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
+            break;
+        case 6: //Source	                	
+                // Set old value to attribute Source 
+                occurrence.setDataSource(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
+                break;
+        case 7: //Herbarium
+                // Set old value to attribute Herbarium
+                occurrence.setHerbarium(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
+            break;
+        case 8: //Note occurrence	
+                // Set old value to attribute Note occurence	                	
+                occurrence.setNote(oldValue);
+                logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
+                break;
+        case 9: //Publication  
+                //Select record Publication where id = oldRocordId 
+                if (oldRecordId &gt; 0){
+                    Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
+                    Publication publication = (Publication)objectPubl[0];
+                    //Set old value to attribute publicationID
+                    occurrence.setPublication(publication);
+                    logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
+                }else {
+                    logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+                }
+            break;
+        default:            
+            logger.error(&quot;No column defined for name &quot;+ columnName);	                   
+        }         
+    }
+        
+    /**
+     *
+     */
+    public void undoHabitat() {
+        
+        //zaznam v ramci, ktereho doslo k editaci tabulky tHabitats
+        occurrence = historyChange.getOccurrence();
+      
+        //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu, proto nam staci nacist
+        //data z tHabitats pres tOccurrence.cHabitatId a nasledne staci zavolat update jen na occurrence
+        boolean objectList = editObjectList.contains(occurrence); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan (editace habitat vzdy v ramci occurrence)
+            editObjectList.add(occurrence);
+        }
+        logger.debug(&quot;editObjectList: &quot;+objectList);
+        logger.debug(&quot;Habitat - OccurrenceID: &quot;+occurrence.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+        // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (habitatHash.containsKey(columnName)) {
+                 columnConstant = (Integer)habitatHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+
+        //informuje o tom, ze byla editovana tabulka tHabitat 
+        editHabitat = true;
+
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //Quadrant     	                	
+                /* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
+                 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
+                 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
+                 */ 	                		  
+                occurrence.getHabitat().setQuadrant(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
+	                // existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
+	                // potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
+	                // nebo zda editaci nalezu vznikla vazvba 1:1
+	                relationship = true;
+                } 	                	
+            break;
+        case 2: //Place description 	                	 	                			                		 
+                occurrence.getHabitat().setDescription(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	              	
+                break;
+        case 3:  //Country 	                	 	                			                		 
+                occurrence.getHabitat().setCountry(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	
+            break;
+        case 4: //Altitude 	                	                			                		 
+                occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	
+                break;
+        case 5:  //Latitude   	                		                			                		  
+                occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	
+            break;
+        case 6: //Longitude 	                		                			                		
+                occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
+                logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	
+                break;
+        case 7: //Nearest bigger seat   	                	 	                			                		 
+                //Nacteni Village pro nasledny update tHabitat.cNearestVillageId
+                if (oldRecordId != 0){
+                        Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
+                        Village village = (Village)objectVill[0];
+                occurrence.getHabitat().setNearestVillage(village);
+                logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
+                } else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
+                }
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                       relationship = true;
+                } 	
+            break;
+        case 8: //Phytochorion or phytochorion code 	                	             			                		 
+                // Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
+                if (oldRecordId != 0){
+                        Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
+                        Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
+                        occurrence.getHabitat().setPhytochorion(phytochorion);
+                        logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
+                }else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
+                }
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	
+            break; 	               
+        case 9:  //Territory   	                	                			                		  
+                // Nacteni Territory pro nasledny update tHabitat.cTerritory
+                if (oldRecordId != 0){
+                        Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
+                        Territory territory = (Territory)objectTerr[0];
+                        occurrence.getHabitat().setTerritory(territory);
+                        logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
+                }else {
+                        logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
+                }	
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                        relationship = true;
+                } 	        	
+            break;
+        case 10: //Note habitat	                		                			                		  
+                occurrence.getHabitat().setNote(oldValue);		                	
+                logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
+                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
+                       relationship = true;
+                } 	
+                break;
+        default:            
+            logger.error(&quot;Habitat - No column defined for name &quot;+ columnName);	                   
+        }  	          
+    }
+    
+    /**
+     *
+     */
+    public void undoPublication() {
+                
+        Object[] object = searchObject(&quot;Publication&quot;, recordId);
+        publication = (Publication)object[0];
+        
+        //test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(publication); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(publication);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;Publication: &quot;+publication.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (publicationHash.containsKey(columnName)) {
+                 columnConstant = (Integer)habitatHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+      
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //CollectionName     	                	
+                publication.setCollectionName(oldValue);	 
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute collectionName.&quot;);                 	
+            break;
+        case 2: //collectionYearPublication	                	 	                			                		 
+                publication.setCollectionYearPublication(Integer.parseInt(oldValue));	          
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute collectionYearPublication.&quot;);                 	             	
+                break;
+         case 3: //journalName	                	 	                			                		 
+                publication.setJournalName(oldValue);	       
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute journalName.&quot;);                 	             	
+                break;
+        case 4: //journalAuthorName	                	 	                			                		 
+                publication.setJournalAuthorName(oldValue);	 
+                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
+                logger.debug(&quot;Publication - Set selected value for update of attribute journalAuthorName.&quot;);                 	             	
+                break;
+        case 5: //referenceDetail 	                	 	                			                		 
+                publication.setReferenceDetail(oldValue);	                	
+                logger.debug(&quot;Publication - Set selected value for update of attribute referenceDeatail.&quot;);                 	             	
+                break;
+        case 6: //URL 	                	 	                			                		 
+                publication.setUrl(oldValue);	                	
+                logger.debug(&quot;Publication - Set selected value for update of attribute url.&quot;);                 	             	
+                break;
+        default:            
+            logger.error(&quot;Publication - No column defined for name &quot;+ columnName);	                   
+        } 
+    }
+    
+    /**
+     *
+     */
+    public void undoAuthor() {
+        
+       Object[] object = searchObject(&quot;Author&quot;, recordId);
+       author = (Author)object[0];
+       
+       //test, zda jiz dany zaznam byl editovan
+       boolean objectList = editObjectList.contains(author); 
+       if (!objectList) {
+       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+           editObjectList.add(author);
+       }
+       logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+       logger.debug(&quot;author: &quot;+author.getId());
+       logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Get a specified number of columnName from habitat mapping.
+        int columnConstant;
+        if (authorHash.containsKey(columnName)) {
+                 columnConstant = (Integer)authorHash.get(columnName); 
+        } else {
+             columnConstant = 0;
+        }        	    			
+      
+        // Save new value for the column        		
+        switch (columnConstant) {
+        case 1:  //wholeName     	                	
+                author.setWholeName(oldValue);	                 
+                logger.debug(&quot;Author - Set selected value for update of attribute WholeName.&quot;);                 	
+            break;
+        case 2: //address	                	 	                			                		 
+                author.setAddress(oldValue);
+                logger.debug(&quot;Author - Set selected value for update of attribute Address.&quot;);                 	             	
+                break;
+         case 3: //mail	                	 	                			                		 
+                author.setEmail(oldValue);	                      
+                logger.debug(&quot;Author - Set selected value for update of attribute Email.&quot;);                 	             	
+                break;
+        case 4: //phoneNumber	                	 	                			                		 
+                author.setPhoneNumber(oldValue);	                
+                logger.debug(&quot;Author - Set selected value for update of attribute PhoneNumber.&quot;);                 	             	
+                break;
+        case 5: //organization 	                	 	                			                		 
+                author.setOrganization(oldValue);                	
+                logger.debug(&quot;Author - Set selected value for update of attribute organization.&quot;);                 	             	
+                break;
+        case 6: //URL 	                	 	                			                		 
+                author.setUrl(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute url.&quot;);                 	             	
+                break;
+        case 7: //role	                	 	                			                		 
+                author.setRole(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute Role.&quot;);                 	             	
+                break;
+        case 8: //note 	                	 	                			                		 
+                author.setNote(oldValue);	                	
+                logger.debug(&quot;Author - Set selected value for update of attribute Note.&quot;);                 	             	
+                break;
+        default:            
+            logger.error(&quot;Author - No column defined for name &quot;+ columnName);	                   
+        } 
+    }
+    
+    /**
+     *
+     */
+    public void undoPhytochorion() {
+        
+        Object[] object = searchObject(&quot;Phytochorion&quot;, recordId);
+        phytochorion = (Phytochorion)object[0];     
+        
+        //test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(phytochorion); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(phytochorion);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;phytochorion: &quot;+phytochorion.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+      
+        if (columnName.equals(&quot;namePhytochorion&quot;)) {
+            phytochorion.setCode(oldValue);	                 
+            logger.debug(&quot;Phytochorion - Set selected value for update of attribute WholeName.&quot;);                 	
+        } else if (columnName.equals(&quot;code&quot;)) {
+             phytochorion.setName(oldValue);
+             logger.debug(&quot;Phytochorion - Set selected value for update of attribute Address.&quot;);                 	             	
+        } else {
+            logger.error(&quot;Phytochorion - No column defined for name &quot;+ columnName);
+        }              
+    }
+    
+    /**
+     *
+     */
+    public void undoVillage() {
+       
+        Object[] object = searchObject(&quot;Village&quot;, recordId);
+        village = (Village)object[0];
+        
+        // test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(village); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(village);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;village: &quot;+village.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       // Save new value for the column
+        if (columnName.equals(&quot;nameVillage&quot;)) {
+            village.setName(oldValue);	                 
+            logger.debug(&quot;Village - Set selected value for update of attribute Name.&quot;);                 	
+        } else {
+            logger.error(&quot;Village - No column defined for name &quot;+ columnName);	                   
+        }       
+    }
+    
+    /**
+     *
+     */
+    public void undoTerritory() {
+       
+        Object[] object = searchObject(&quot;Territory&quot;, recordId);
+        territory = (Territory)object[0];
+        
+        // test, zda jiz dany zaznam byl editovan
+        boolean objectList = editObjectList.contains(territory); 
+        if (!objectList) {
+        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
+            editObjectList.add(territory);
+        }
+        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
+        logger.debug(&quot;territory: &quot;+territory.getId());
+        logger.debug(&quot;columnName: &quot;+columnName);
+        
+       if (columnName.equals(&quot;nameTerritory&quot;)) {
+           territory.setName(oldValue);	                 
+           logger.debug(&quot;Territory - Set selected value for update of attribute Name.&quot;);                 	 
+       } else {
+           logger.error(&quot;Territory - No column defined for name &quot;+ columnName);	                   
+       }        
+    }
+    
+    /**
      * 
      * @param id
      * @return
      */
     public Object[] searchObject(String typeObject, int id) { 
-    	
+      
     	SelectQuery query = null;
-    	if (typeObject.equals(&quot;Habitat&quot;)){
-    		try {
+    	if (typeObject.equals(&quot;Occurrence&quot;)){
+            try {
+            	query = database.createQuery(Occurrence.class);
+            	query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, id , null);
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Occurrence, createQuery&quot;);       	  
+            }            
+            
+    	} else if (typeObject.equals(&quot;Habitat&quot;)){
+            try {
             	query = database.createQuery(Habitat.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, id , null);
             } catch(RemoteException e) {
@@ -356,30 +1033,39 @@
             }            
             
     	} else if (typeObject.equals(&quot;Plant&quot;)){
-    		try {
+            try {
             	query = database.createQuery(Plant.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.ID, null, id , null);
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject() - Plant, createQuery&quot;);       	  
             }            
+            
+    	} else if (typeObject.equals(&quot;Author&quot;)){
+            try {
+            	query = database.createQuery(Author.class);
+            	query.addRestriction(PlantloreConstants.RESTR_EQ, Author.ID, null, id , null);
+            } catch(RemoteException e) {
+            	    System.err.println(&quot;RemoteException, searchObject() - Author, createQuery&quot;);       	  
+            }            
+            
     	} else if (typeObject.equals(&quot;Publication&quot;)){
-    		try {
+            try {
             	query = database.createQuery(Publication.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Publication.ID, null, id , null);
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject() - Publication, createQuery&quot;);       	  
             }            
-           
+            
     	} else if (typeObject.equals(&quot;Village&quot;)){
-    		try {
+            try {
             	query = database.createQuery(Village.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Village.ID, null, id, null);
             } catch(RemoteException e) {
             	    System.err.println(&quot;RemoteException, searchObject()- Village, createQuery&quot;);       	  
             }            
-         
+            
     	}  else if  (typeObject.equals(&quot;Territory&quot;)){
-    		try {
+            try {
             	query = database.createQuery(Territory.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.ID, null, id , null);
             } catch(RemoteException e) {
@@ -387,7 +1073,7 @@
             }            
              
     	} else if (typeObject.equals(&quot;Phytochorion&quot;)){
-    		try {
+            try {
             	query = database.createQuery(Phytochorion.class);
             	query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.ID, null, id , null);
             } catch(RemoteException e) {
@@ -405,347 +1091,66 @@
             logger.error(&quot;Searching &quot; +typeObject+ &quot; failed. Unable to execute search query.&quot;);
         } catch (RemoteException e) {		 
      	   System.err.println(&quot;RemoteException- executeQuery &quot; +typeObject);
- 	    }        
-
- 	   Object[] objects = null;
- 	   Object[] object = null;
+ 	} 
+       Object[] objects = null;
+       Object[] object = null;
        try {
        	    // Retrieve selected row interval         	
-        	try {
-        		objects = database.more(resultIdPlant, 1, 1);  
-        	} catch(RemoteException e) {            	
-            	logger.debug(&quot;RemoteException- searchObject, more&quot;);            	
+            try {
+                 objects = database.more(resultIdPlant, 1, 1);  
+            } catch(RemoteException e) {            	
+                logger.debug(&quot;RemoteException- searchObject, more&quot;);            	
             }   
         	object = (Object[])objects[0];           
        } catch (DBLayerException e) {
            // Log and set error in case of an exception
-           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());               
+           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());            
        }     	    
-       return object; 	       	          	          	       
+        return object; 	       	          	   
+           	        
     }
     
- 
     /**
-     * UNDO - funce projde oznacene zaznamy a nastavi stare hodnoty
-     * Pokud dojde zmenou k ovlivneni vice nalezu, tak o tom informuje uzivatele
+     *  ..... pri whole history se bude do promennych occurrence, atd. nacitat vice ruznych objektu s jinym ID
+     *  ....Musim si ty jednotlive objekty pamatovat --&gt; pole objektu, kde budou jednotlive editovane objekty
      */
-    public void updateOlderChanges()
-    {    	
-    	    	
-    	//Inicalization of hashTable
-    	initOccurrenceHash();
-    	initHabitatHash();    	  
-        	
-    	//number of result
-    	int countResult = getEditResult();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
-    	relationship = false;
-    	editHabitat = false;
+    public void commitUpdate() {
     	
-    	//take from younger record to older record
-    	for( int i=0; i &lt; countResult; i++) {
-    		if (! markListId.contains(i)) {
-    			continue;
-    		}
-    		
-    		//init history data about edit of record
-    		historyRecord = (HistoryRecord)editHistoryDataList.get(i);    		
-    		historyChange = historyRecord.getHistoryChange();
-    		tableName = historyRecord.getHistoryColumn().getTableName();
-    		columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
-            oldRecordId = historyChange.getOldRecordId();
-            recordId = historyChange.getRecordId();
-            occurrenceId = historyChange.getOccurrence().getId();		   
-            operation = historyChange.getOperation();
-            oldValue = historyRecord.getOldValue();
-						
-    		if (tableName.equals(&quot;Occurrence&quot;)){  
-    			if (occurrenceId != recordId){
-    				logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
-    			}
-    			
-                        //Get a specified number of columnName from occurrence mapping.
-                        int columnConstant;
-                        if (occurrenceHash.containsKey(columnName)) {
-                                 columnConstant = (Integer)occurrenceHash.get(columnName); 
-                        } else {
-                             columnConstant = 0;
-                        }        	    			
-    			  
-    			//init Calendar    		
-    			Calendar isoDateTime = new GregorianCalendar();
-    			
-    			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
-    			logger.debug(&quot;ColumnName: &quot;+ columnName);
-    			logger.debug(&quot;OldValue: &quot;+ oldValue);    			     			
-    			
-    			switch (columnConstant) {
-	                case 1: //Taxon  
-	                	if (oldRecordId &gt; 0 ) {
-                                    //Select record Plant where id = oldRocordId 
-                                    Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
-                                    Plant plant = (Plant)object[0];
-                                    //Set old value to attribute plantID
-                                    occurrence.setPlant(plant);
-                                    logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
-                                    }else {
-                                            logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-                                    }
-	                    break;
-	                case 2: //Year	
-                	    //Set old value to attribute Year          		
-	                	occurrence.setYearCollected(Integer.parseInt(oldValue));
-	                	logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
-	                	//Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
-                		isoDateTime.setTime(occurrence.getTimeCollected());
-                		isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
-                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
-	                	break;
-	                case 3: //Month 
-	                	// Set old value to attribute Month 
-                		occurrence.setMonthCollected(Integer.parseInt(oldValue));
-                		logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
-                		// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                		isoDateTime.setTime(occurrence.getTimeCollected());
-                		isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
-                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
-	                    break;
-	                case 4: //Day	                	
-                		// Set old value to attribute Day            		
-	                	occurrence.setDayCollected(Integer.parseInt(oldValue));
-	                	logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
-	                	// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-	                	isoDateTime.setTime(occurrence.getTimeCollected());
-                		isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
-                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
-	                	break;
-	                case 5: //Time 	                		                	
-                		// Set old value to attribute Time   
-	                	Date time = new Date();
-	                	SimpleDateFormat df = new SimpleDateFormat( &quot;HH:mm:ss.S&quot; );
-	                	try {
-							time = df.parse( oldValue );
-						} catch (ParseException e) {
-							logger.error(&quot;Parse time failed. &quot;+ e);
-						}
-						occurrence.setTimeCollected(time);
-                		logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
-                		// Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-	                	isoDateTime.setTime(time);
-                		isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
-                		occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
-	                    break;
-	                case 6: //Source	                	
-	                	// Set old value to attribute Source 
-	                	occurrence.setDataSource(oldValue);
-	                	logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
-	                	break;
-	                case 7: //Herbarium
-	                	// Set old value to attribute Herbarium
-                		occurrence.setHerbarium(oldValue);
-                		logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
-	                    break;
-	                case 8: //Note occurrence	
-	                	// Set old value to attribute Note occurence	                	
-                		occurrence.setNote(oldValue);
-                		logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
-	                	break;
-	                case 9: //Publication  
-	                	//Select record Publication where id = oldRocordId 
-	                	if (oldRecordId &gt; 0){
-		                	Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
-		                	Publication publication = (Publication)objectPubl[0];
-		                	//Set old value to attribute publicationID
-		                	occurrence.setPublication(publication);
-		                	logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
-		    			}else {
-		    				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-		    			}
-	                    break;
-	                default:            
-	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-    			}  	
-    		} else if (tableName.equals(&quot;Habitat&quot;) || tableName.equals(&quot;Village&quot;)
-    				   || tableName.equals(&quot;Territory&quot;) || tableName.equals(&quot;Phytochorion&quot;)){
-    			
-                // Get a specified number of columnName from habitat mapping.
-                int columnConstant;
-                if (habitatHash.containsKey(columnName)) {
-                         columnConstant = (Integer)habitatHash.get(columnName); 
-    	        } else {
-    	             columnConstant = 0;
-    	        }        	    			
-    			  
-    			//informuje o tom, ze byla editovana tabulka tHabitat 
-    			editHabitat = true;                       
-    			
-    			logger.debug(&quot;ColumnConstant: &quot;+ columnConstant);
-    			logger.debug(&quot;ColumnName: &quot;+ columnName);
-    			logger.debug(&quot;OldValue: &quot;+ oldValue);  
-    			
-    			
-    			// Save new value for the column        		
-     			switch (columnConstant) {
- 	                case 1:  //Quadrant     	                	
-                		/* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
-                		 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
-                		 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
-                		 */ 	                		  
-                		occurrence.getHabitat().setQuadrant(oldValue);		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
-	                		// existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
-	                		// potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
-	                		// nebo zda editaci nalezu vznikla vazvba 1:1
-	                		relationship = true;                                                                            
-	                	} 	                	
- 	                    break;
- 	                case 2: //Place description 	                	 	                			                		 
-                		occurrence.getHabitat().setDescription(oldValue);		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                         
-	                	} 	              	
- 	                	break;
- 	                case 3:  //Country 	                	 	                			                		 
-                		occurrence.getHabitat().setCountry(oldValue);		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                          
-	                	} 	
- 	                    break;
- 	                case 4: //Altitude 	                	                			                		 
-                		occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                          
-	                	} 	
- 	                	break;
- 	                case 5:  //Latitude   	                		                			                		  
-                		occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                        
-	                	} 	
- 	                    break;
- 	                case 6: //Longitude 	                		                			                		
-                		occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                         
-	                	} 	
- 	                	break;
- 	                case 7: //Nearest bigger seat   	                	 	                			                		 
-                		//Nacteni Village pro nasledny update tHabitat.cNearestVillageId
-            			if (oldRecordId != 0){
-            				Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
-                			Village village = (Village)objectVill[0];
-    	                	occurrence.getHabitat().setNearestVillage(village);
-    	                	logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
-            			} else {
-            				logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
-            			}
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                        
-	                	} 	
- 	                    break;
- 	                case 8: //Phytochorion or phytochorion code 	                	             			                		 
-                		// Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
- 	                	if (oldRecordId != 0){
-	            			Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
-	            			Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
-		                	occurrence.getHabitat().setPhytochorion(phytochorion);
-		                	logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
- 	                	}else {
-            				logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-            			}
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                        
-	                	} 	
- 	                    break; 	               
-	                case 9:  //Territory   	                	                			                		  
-                		// Nacteni Territory pro nasledny update tHabitat.cTerritory
-	                	if (oldRecordId != 0){
-	            			Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
-	            			Territory territory = (Territory)objectTerr[0];
-		                	occurrence.getHabitat().setTerritory(territory);
-		                	logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
-	                	}else {
-            				logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
-            			}	
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                      
-	                	} 	        	
-	                    break;
-	                case 10: //Note habitat	                		                			                		  
-                		occurrence.getHabitat().setNote(oldValue);		                	
-	                	logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
-	                	if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-	                		relationship = true;                                        
-	                	} 	
-	                	break;
- 	                default:            
- 	                    logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-     			}  	    		
-    		} else {
-    			logger.error(&quot;No table defined&quot;);
-    		}    			    		
-    	}
- 
-    	//informovat uzivatele, co bude provedeno (viz seznam markLIstId, markItem) a dat mu volbu, zda ano ci ne... zde je nutne, aby fungovalo spravne 
-    	//executeUpdate, aby k update doslo az po jeho zavolani....!!!!
-    	//zavolat delete na vsechny vracene polozky Historiie - projit seznam s ID
-    	//v tabulce tOccurrences by se meli aktualizovat polozky cUpdateWhen a cUpdatewho na uzivatele a cas, ktery zavolal undo
-    	//zavolat znovu dotaz do db, aby se aktualizovaly vysledky ... createQuery, atd.
-    	
-    	//vygenerovani zpravy pro uzivatele    	
-    	generateMessageUndo();
+    	int count = editObjectList.size();
+    	for (int i=0; i&lt; count; i++) {
+    		try {
+    			logger.debug(&quot;Object for update: &quot;+editObjectList.get(i));
+                database.executeUpdate(editObjectList.get(i));
+	        } catch (RemoteException e) {
+	                logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
+	        } catch (DBLayerException e) {
+	                logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
+	        }
+       }    	
     }
     
-    public void generateMessageUndo() {    	
-    	messageUndo = &quot;Budou provedeny n&#225;sleduj&#237;c&#237; zm&#283;ny:\n&quot;;      
-    	int count = markItem.size();
-    	for (int i=0; i&lt;count; i++) {
-    		Object[] itemList = (Object[])(markItem.get(i));
-    		String item = (String)itemList[0];
-    		Integer maxId = (Integer)itemList[1];      		
-    		oldValue = ((HistoryRecord)editHistoryDataList.get(maxId)).getOldValue(); 
-    		messageUndo = messageUndo + item + &quot; --&gt; &quot; + oldValue + &quot;\n&quot;;
-    	}
-    	if (!relationship &amp;&amp; editHabitat) {
-    		logger.debug(relationship);
-    		logger.debug(editHabitat);
-    		messageUndo = &quot;\n&quot; + messageUndo + &quot;Tyto zm&#283;ny ovlivn&#237; v&#237;ce n&#225;lez&#367;.\n&quot;;
-    	}
+    /**
+     *  vycisteni seznamu editovany objektu: 
+     */
+    public void clearEditObjectList() {
+    	editObjectList.clear();
     }
-    
-    public void commitUpdate() {
-    	try {
-			database.executeUpdate(occurrence);
-		} catch (RemoteException e) {
-			logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
-		} catch (DBLayerException e) {
-			logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
-		}
-    }
-  
+       
     /**
      * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
      * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
      */
-    public void deleteHistoryRecords() {
-
-    	//count of selected record
-    	int count = editHistoryDataList.size();
-    	
+    public void deleteHistory(int toResult, boolean typeHistory) {
+   	
     	//take from younger record to older record
-    	for( int i=0; i &lt; count; i++) {
-    		if (! markListId.contains(i)) {
-    			continue;
+    	for( int i=0; i &lt; toResult; i++) {
+    		if (typeHistory &amp;&amp; !markListId.contains(i)) {
+    			logger.debug(&quot;History of one occurence: &quot;+markListId.contains(i));
+    			continue;    			
     		}    		    		
-    		historyRecord = (HistoryRecord)editHistoryDataList.get(i); 
-    		historyChange = historyRecord.getHistoryChange();    		
-        	
+    		historyRecord = (HistoryRecord)historyDataList.get(i); 
+    		historyChange = historyRecord.getHistoryChange(); 
+    		
 	    	try {
 				database.executeDelete(historyRecord);
 				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
@@ -769,10 +1174,10 @@
 			} else {
 				logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
 			}
-    	}
-    	//Clear list 
+    	}    	
+		//Clear list 
     	markListId.clear();
-    	markItem.clear();
+    	markItem.clear();    		
     } 
     
     /**
@@ -780,8 +1185,7 @@
      * @param id
      * @return
      */
-    public int searchHistoryChangeId(int id){
-    	
+    public int searchHistoryChangeId(int id){    	
     	SelectQuery query = null;
         try {
         	    query = database.createQuery(HistoryRecord.class);
@@ -791,7 +1195,7 @@
                 query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
         } catch(RemoteException e) {
         	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
-        }     
+        }        
         
         
         int resultIdChange = 0;
@@ -801,8 +1205,8 @@
             logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
         } catch (RemoteException e) {		 
      	   System.err.println(&quot;RemoteException- searchHistoryChangeId(), executeQuery&quot;);
- 	    }        
- 	    
+ 	    } 
+        
  	    int countResult = 100;
  	    try {
 			countResult = database.getNumRows(resultIdChange);
@@ -813,6 +1217,22 @@
 		return countResult;
     }
     
+    public void generateMessageUndo() {    	
+    	messageUndo = &quot;Budou provedeny n&#225;sleduj&#237;c&#237; zm&#283;ny:\n&quot;;      
+    	int count = markItem.size();
+    	for (int i=0; i&lt;count; i++) {
+    		Object[] itemList = (Object[])(markItem.get(i));
+    		String item = (String)itemList[0];
+    		Integer maxId = (Integer)itemList[1];      		
+    		oldValue = ((HistoryRecord)historyDataList.get(maxId)).getOldValue(); 
+    		messageUndo = messageUndo + item + &quot; --&gt; &quot; + oldValue + &quot;\n&quot;;
+    	}
+    	if (!relationship &amp;&amp; editHabitat) {
+    		logger.debug(relationship);
+    		logger.debug(editHabitat);
+    		messageUndo = &quot;\n&quot; + messageUndo + &quot;Tyto zm&#283;ny ovlivn&#237; v&#237;ce n&#225;lez&#367;.\n&quot;;
+    	}
+    }
     
      //***************************//
     //****Init Hashtable*********//
@@ -847,7 +1267,29 @@
         habitatHash.put(&quot;noteHabitat&quot;,10);
     }    
     
-   
+    private void initPublicationHash() {
+        publicationHash = new Hashtable&lt;String, Integer&gt;(6);
+        publicationHash.put(&quot;collectionName&quot;,0);
+        publicationHash.put(&quot;collectionYearPublication&quot;,1);
+        publicationHash.put(&quot;journalName&quot;,2);
+        publicationHash.put(&quot;journalAuthorName&quot;,3);
+        publicationHash.put(&quot;referenceDetail&quot;,4);
+        publicationHash.put(&quot;urlPublication&quot;,5);      
+    }
+    
+    private void initAuthorHash() {
+        authorHash = new Hashtable&lt;String, Integer&gt;(8);
+        authorHash.put(&quot;firstName&quot;,0);
+        authorHash.put(&quot;surname&quot;,1);
+        authorHash.put(&quot;organization&quot;,2);
+        authorHash.put(&quot;role&quot;,3);
+        authorHash.put(&quot;address&quot;,4);
+        authorHash.put(&quot;email&quot;,5);
+        authorHash.put(&quot;urlAuthor&quot;,6);
+        authorHash.put(&quot;noteAuthor&quot;,7);        
+    }              
+    
+       
     //****************************//
     //****Get and set metods*****//
     //**************************//
@@ -883,85 +1325,51 @@
 		  this.markItem = markItem;		  
 	 } 
     
-    public ArrayList&lt;HistoryRecord&gt; getEditHistoryDataList() {
-		  return this.editHistoryDataList;		  
-	   }
-
-	 public void setEditHistoryDataList(ArrayList&lt;HistoryRecord&gt; editHistoryDataList) {
-		  this.editHistoryDataList = editHistoryDataList;		  
-	 } 
     
-     public String getCurrentDisplayRows() {
-		  return this.displayRow;		  
-	   }
-
-	 public void setCurrentDisplayRows(String displayRow) {
-		  this.displayRow = displayRow;		  
-	 } 
-     
-     public String getMessageUndo() {
-		  return this.messageUndo;		  
-	   }
-
-	 public void setMessageUndo(String messageUndo) {
-		  this.messageUndo = messageUndo;		  
-	 } 
-    
-    /**
-     *  Set result of a database operation. This is used only for search operations.
-     *  @param int 
-     */
-    public void setEditResult(int resultIdEdit) {
-        this.resultId = resultIdEdit;
+    //id vysledku po vyhledavani v db
+    public void setResultId(int resultId) {
+        this.resultId = resultId;
     }
     
-    /**
-     *  Get results of last database operation. This is used only for search operations.
-     *  @return 
-     */
-    public int getEditResult() {
+    public int getResultId() {
         return this.resultId;
     }
-       
+    
     public int getResultRows() {
-    	int resultCount = 0;
+        int resultCount = 0;
         if (resultId != 0) try {
-        	resultCount = database.getNumRows(resultId);        	
+                resultCount = database.getNumRows(resultId);        	
         } catch(RemoteException e) {
-        	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
         }
         return resultCount;
     }
+
+    public ArrayList&lt;HistoryRecord&gt; getHistoryDataList() {
+              return this.historyDataList;		  
+       }
+
+     public void setHistoryDataList(ArrayList&lt;HistoryRecord&gt; historyDataList) {
+              this.historyDataList = historyDataList;		  
+     } 
     
-    /**
-     *  Set an error flag (message).
-     *  @param msg  message explaining the error which occured
-     */
-    public void setError(DBLayerException e) {
-        this.error = e;
-    }
-    
-    /**
-     *  Checks whether an error flag is set.
-     *  return true if an error occured and error message is available, false otherwise
-     */
-    public boolean isError() {
-        if (this.error != null) {
-            return true;
-        } else {
-            return false;
-        }
-    }
-    
-    /**
-     *  Get error message for the error which occured
-     *  @return message explaining the error which occured
-     */
-    public DBLayerException getError() {
-        return this.error;
-    }
-    
-    /**
+     public String getCurrentDisplayRows() {
+		  return this.displayRow;		  
+	   }
+
+     public void setCurrentDisplayRows(String displayRow) {
+              this.displayRow = displayRow;		  
+     } 
+     
+     public String getMessageUndo() {
+		  return this.messageUndo;		  
+	   }
+
+     public void setMessageUndo(String messageUndo) {
+              this.messageUndo = messageUndo;		  
+     } 
+     
+         /**
      *  Get index of the first row currently displayed in the list of record changes. This is an index in the results returned by a search query.
      *  @return index of the first row currently displayed in the list of history
      */
@@ -993,111 +1401,31 @@
         this.displayRows = rows;
     }
     
-   public String getNamePlant() {
+    public String getNamePlant() {
 		  return this.namePlant;
 	   }
 
-   public void setNamePlant(String namePlant) {
+    public void setNamePlant(String namePlant) {
 		  this.namePlant = namePlant;
-	}    
-   
-   public String getNameAuthor() {
+	}   
+    
+    public String getNameAuthor() {
 		  return this.nameAuthor;
 	   }
 
-   public void setNameAuthor(String nameAuthor) {
-	  this.nameAuthor = nameAuthor;
-   } 
-   
-   public String getLocation() {
+	 public void setNameAuthor(String nameAuthor) {
+		  this.nameAuthor = nameAuthor;
+	 } 
+	 
+	 public String getLocation() {
 		  return this.location;
 	   }
-
-   public void setLocation(String location) {
+	
+	 public void setLocation(String location) {
 		  this.location = location;
 	}    
-   
-    /**
-	*   Get name of the table where value was changed
-	*   @return of the table where value was changed	
-	*/
-   public String getTableName() {
-	  return this.tableName;
-   }
 
-   /**
-	*   Set name of the table where value was changed
-	*   @param tableName string containing of the table where value was changed
-	*/
-   public void setTableName(String tableName) {
-	  this.tableName = tableName;
-   }
-
-   /**
-   *   Get name of the column where value was changed
-   *   @return  name of the column where value was changed
-   */
-  public String getColumnName() {
-	 return this.columnName;
-  }
-
-  /**
-   *   Set  name of the column where value was changed
-   *   @param columnName string containing  name of the column where value was changed
-   */
-  public void setColumnName(String columnName) {
-	 this.columnName = columnName;
-  }
 	/**
-	 *   Get identifier of the occurrence whitch was changed
-	 *   @return foreign identifier of the occurrence whitch was changed
-	 */
-	public int getOccurrenceId() {
-	   return this.occurrenceId;
-	}
-
-	/**
-	 *   Set identifier of the occurrence whitch was changed
-	 *   @param occurrenceId identifier of the occurrence whitch was changed
-	 */
-	public void setOccurrenceId(int occurrenceId) {
-	   this.occurrenceId= occurrenceId;
-	}	
-	
-   /**
-	 *   Get identifier of the record whitch was changed
-	 *   @return identifier of the record whitch was changed
-	 */
-	public int getId() {
-	   return this.recordId;
-	}
-
-	/**
-	 *   Set identifier of the record whitch was changed
-	 *   @param recordId string containing identifier of the record whitch was changed
-	 */
-	public void setId(int recordId) {
-	   this.recordId = recordId;
-	}
-	  
-	/**
-	*   Get operation whitch was used
-	*   @return operation whitch was used
-	*/
-	public int getOperation() {
-	  return this.operation;
-	}
-
-	/**
-	*   Set operation whitch was used
-	*   @param operation string containing operation whitch was used 
-	*/
-	public void setOperation(int operation) {
-	  this.operation = operation;
-	}
-	 
-	   
-	/**
 	*   Get date and time when the reccord was changed
 	*   @return date and time when the reccord was changed
 	*/         
@@ -1129,35 +1457,4 @@
 	  this.nameUser = nameUser;
     }  
     
-	/**
-	*   Get old value of atribute whitch was changed
-	*   @return old value of atribute whitch was changed
-	*/
-    public String getOldValue() {
-	  return this.oldValue;
-    }
-
-    /**
-	*   Set old value of atribute whitch was changed
-	*   @param oldValue string containing old value of atribute whitch was changed
-	*/
-    public void setOldValue(String oldValue) {
-	  this.oldValue = oldValue;
-    }
-	   
-	 /**
-	*   Get new value of atribute whitch was changed
-	*   @return new value of atribute whitch was changed 
-	*/
-    public String getNewValue() {
-	  return this.newValue;
-    }
-
-    /**
-	*   Set new value of atribute whitch was changed
-	*   @param newValue string containing new value of atribute whitch was changed
-	*/
-    public void setNewValue(String newValue) {
-	  this.newValue = newValue;
-    }    
 }

Modified: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -158,14 +158,14 @@
    class undoSelectedButtonListener implements ActionListener {
        public void actionPerformed(ActionEvent actionEvent)
        {    	   
-           model.updateOlderChanges();            
+           model.undoSelected();            
            int okCancle = view.messageUndo(model.getMessageUndo());
            logger.debug(&quot;button &quot;+okCancle);
            if (okCancle == 0){
         	   //Button OK was press
         	   logger.debug(&quot;Button OK was press.&quot;);
         	   model.commitUpdate();
-        	   model.deleteHistoryRecords();
+        	   model.deleteHistory(model.getResultRows(), true);
         	   model.searchEditHistory();
         	   model.processResult(1,model.getDisplayRows());
         	   view.getTable().setModel(new HistoryTableModel(model));

Modified: trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -65,7 +65,7 @@
     	
     	logger.debug(&quot;Init data.&quot;);
     	
-    	editHistoryDataList = model.getEditHistoryDataList();
+    	editHistoryDataList = model.getHistoryDataList();
     	if (editHistoryDataList.size()==0 ){
     		this.data = new Object[0][];
     		return;
@@ -183,7 +183,7 @@
      *
      */
     public void initMarkAllItem() {    	
-    	editHistoryDataList = model.getEditHistoryDataList();    	
+    	editHistoryDataList = model.getHistoryDataList();    	
     	int countResult = editHistoryDataList.size();    	
     	for (int i=0; i &lt; countResult; i++) {      		    		    	
     		String item = L10n.getString(((HistoryRecord)editHistoryDataList.get(i)).getHistoryColumn().getColumnName());
@@ -200,7 +200,7 @@
      */
     public void updateMarkListId() {
     	markListId = new HashSet();
-    	editHistoryDataList = model.getEditHistoryDataList();
+    	editHistoryDataList = model.getHistoryDataList();
     	markItem = model.getMarkItem();
     	int countResult = editHistoryDataList.size();    	
     	for (int i=0; i &lt; countResult; i++) {  

Deleted: trunk/src/net/sf/plantlore/client/history/WholeHistory.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistory.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistory.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -1,1120 +0,0 @@
-/*
- * WholeHistory.java
- *
- * Created on 14. duben 2006, 15:43
- *
- * To change this template, choose Tools | Template Manager
- * and open the template in the editor.
- */
-
-package net.sf.plantlore.client.history;
-
-import java.rmi.RemoteException;
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.Date;
-import java.util.GregorianCalendar;
-import java.util.Hashtable;
-import net.sf.plantlore.common.PlantloreConstants;
-import net.sf.plantlore.common.record.Author;
-import net.sf.plantlore.common.record.Habitat;
-import net.sf.plantlore.common.record.HistoryChange;
-import net.sf.plantlore.common.record.HistoryRecord;
-import net.sf.plantlore.common.record.Occurrence;
-import net.sf.plantlore.common.record.Phytochorion;
-import net.sf.plantlore.common.record.Plant;
-import net.sf.plantlore.common.record.Publication;
-import net.sf.plantlore.common.record.Territory;
-import net.sf.plantlore.common.record.Village;
-import net.sf.plantlore.middleware.DBLayer;
-import net.sf.plantlore.middleware.SelectQuery;
-import net.sf.plantlore.server.DBLayerException;
-import org.apache.log4j.Logger;
-
-/**
- *
- * @author Lada
- */
-public class WholeHistory {
-    
-      /** Instance of a logger */
-    private Logger logger;      
-    /** Instance of a database management object */
-    private DBLayer database;   
-    /** Constant with default number of rows to display */
-    private static final int DEFAULT_DISPLAY_ROWS = 6;    
-    /** Actual number of rows to display */
-    private int displayRows = DEFAULT_DISPLAY_ROWS;   
-    /** Index of the first record shown in the table */
-    private int currentFirstRow;
-    /** Information about current display rows*/
-    private String displayRow;    
-    
-    //*******Informations about searching Result from database*****//
-    /** Result of the search query */
-    private int resultId = 0;
-    /** List of data (results of a search query) displayed in the table */
-    private ArrayList&lt;HistoryRecord&gt; historyDataList = new ArrayList();     
-    // seznam editovanych objektu (potrebny pro hromadne potvrzeni update)
-    private ArrayList&lt;Object&gt; editObjectList = new ArrayList();
-    // informace pro uzivatele o record undo
-    private String messageUndo;
-    
-    //*********************Record of history, ... ***************************************//    
-    private Occurrence occurrence;
-    private HistoryRecord historyRecord;
-    private HistoryChange historyChange;
-    private Publication publication;
-    private Author author;
-    private Village village;
-    private Territory territory;
-    private Phytochorion phytochorion;
-    
-     //	**************Informations about HistoryRecord*************//	
-    /** Name of the table where value was changed*/
-    private String tableName;  
-    /** Name of the column where value was changed*/
-    private String columnName;
-    /** Unique value identified occurrence */	
-    private Integer occurrenceId;
-    /**Unique value identified record in table where value was changed */
-    private int recordId;
-    /**Unique value identified record before changed */
-    private int oldRecordId;
-    /** Operation whitch was used*/   
-    private int operation;
-    /** Date and time when the reccord was changed*/
-    //private java.util.Date when = new Date();	
-    /** Old value of attribute*/    
-    private String oldValue;
-    /** New value of attribute*/
-    //private String newValue;
-   /** Name of user who did changed*/
-    //private String nameUser;
-    
-    //********************************************************//
-    /** Mapping of entities */
-    private Hashtable&lt;String, Integer&gt; publicationHash;
-    private Hashtable&lt;String, Integer&gt; habitatHash;
-    private Hashtable&lt;String, Integer&gt; occurrenceHash;  
-    private Hashtable&lt;String, Integer&gt; authorHash;
-    
-    
-    /** Creates a new instance of WholeHistory */
-    public WholeHistory(DBLayer database) {
-          
-       logger = Logger.getLogger(this.getClass().getPackage().getName());	 
-       this.database = database;
-       
-       //nacist vsechny data z historie --&gt;bez podminky, jen je seradit podle casu
-       searchWholeHistoryData();
-       //opet funkci pro vyzadani si dat postupne
-       processResult(1, displayRows);
-    }
-    
-    /**
-     *
-     */
-    public void searchWholeHistoryData() {
-        
-        //Create new Select query
-        SelectQuery query = null;       
-
-    	//  Select data from tHistory table
-        try {
-			query = database.createQuery(HistoryRecord.class);
-			// Create aliases for table tHistoryChange.
-			query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);
-			// sort by date/time
-			query.addOrder(PlantloreConstants.DIRECT_DESC, &quot;hc.when&quot;);
-		} catch (RemoteException e) {
-                System.err.println(&quot;RemoteException- searchWholeHistoryData(), createQuery&quot;);
-        }
-                
-    	
-        int resultId = 0;
-        try {
-            // Execute query                    
-            resultId = database.executeQuery(query);
-            // Save &quot;edit&quot; history data
-            setResultId(resultId);    
-        } catch (DBLayerException e) {                            
-            logger.error(&quot;Searching whole history data failed. Unable to execute search query.&quot;);           
-        } catch (RemoteException e) { 		   
-     	   System.err.println(&quot;RemoteException- searchWholeHistoryData(), executeQuery&quot;);
-        }          
-    }
-    
-   /**
-     * Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field of the class. 
-     * @param fromTable number of the first row to show in table. Number of the first row to retraieve is 1.
-     * @param count number of rows to retrieve 
-     */
-    public void processResult(int fromTable, int count) {
-        
-        if (this.resultId != 0) {
-            int currentRow = getResultRows();
-            logger.debug(&quot;Rows in the result: &quot;+currentRow);
-            logger.debug(&quot;Max available rows: &quot;+(fromTable+count-1));
-           
-            // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
-            int to = Math.min(currentRow, fromTable+count-1);           
-            if (to &lt;= 0) {
-            	historyDataList = new ArrayList&lt;HistoryRecord&gt;(); 
-            	setDisplayRows(0);
-            	setCurrentDisplayRows(&quot;0-0&quot;);
-            } else {
-                logger.debug(&quot;Retrieving query results: 1 - &quot;+to);
-                setCurrentDisplayRows(fromTable+ &quot;-&quot; + to);
-                try {                	 
-                     // Retrieve selected row interval 
-                	Object[] objectHistory;
-                 	try {
-                 		objectHistory = database.more(this.resultId, 1, to);  
-                 	} catch(RemoteException e) {
-                     	System.err.println(&quot;RemoteException- processEditResult, more&quot;);
-                     	logger.debug(&quot;RemoteException- processEditResult, more&quot;);
-                     	return;
-                     }                   
-                    int countResult = objectHistory.length;  
-                    logger.debug(&quot;Results retrieved. Count: &quot;+ countResult);
-                    // Create storage for the results
-                    this.historyDataList = new ArrayList&lt;HistoryRecord&gt;();
-                    // Cast the results to the HistoryRecord objects
-                    for (int i=0; i&lt;countResult; i++ ) {                    							
-						Object[] objHis = (Object[])objectHistory[i];
-                        this.historyDataList.add((HistoryRecord)objHis[0]);
-                    }           
-                    //Update current first displayed row (only if data retrieval was successful)
-                    setCurrentFirstRow(fromTable); 
-                } catch (DBLayerException e) {                  
-                    logger.error(&quot;Processing search results failed: &quot;+e.toString());            
-                }             
-            }
-        }         
-    }
-    
-    /**
-     *
-     */
-    public void undoToDate(int toResult) {
-        
-        //Inicalization of hashTable
-    	initOccurrenceHash();
-    	initHabitatHash();   
-        initPublicationHash();
-        initAuthorHash();       
-        	
-    	//number of result
-    	//int countResult = this.historyDataList.size();
-    	// Pomocne hodnoty pro zjisteni zda zmena ovlivni vice nalezu
-    	//relationship = false;
-    	//editHabitat = false;
-    	
-    	//take from younger record to older record, undo tu selected row
-    	for( int i=0; i &lt; toResult; i++) {
-    		
-    		//init history data 
-    		historyRecord = (HistoryRecord)historyDataList.get(i);    		
-    		historyChange = historyRecord.getHistoryChange();
-    		tableName = historyRecord.getHistoryColumn().getTableName();
-                recordId = historyChange.getRecordId();
-                operation = historyChange.getOperation();
-    		                                                
-               /** 
-                * Pri insertu a editu nedohledavam column --&gt; prvne rozdelit podle operace a pro edit dale rozdelit podle column
-                */
-                if (operation == HistoryChange.HISTORYCHANGE_INSERT) {
-                    undoInsertDelete(0);
-                } else if (operation == HistoryChange.HISTORYCHANGE_EDIT || operation == HistoryChange.HISTORYCHANGE_EDITGROUP) {
-                    undoEdit();
-                } else if (operation == HistoryChange.HISTORYCHANGE_DELETE) {
-                    undoInsertDelete(1);
-                } else {
-                    logger.error(&quot;Incorrect opreration code: &quot;+ operation);
-                }                
-        }
-    }
-    
-    /**
-     * ??? Habitat - nemuselo by se zaznamenavat cDelete
-     * ??? Phytochorion, Village, Territory - asi bude potreba cDelete, abychom nezobrazovali nektere polozky, co se historii odstrani
-     * delete == 1 ... smazat
-     * delete == 0 ... obnovit
-     */
-    public void undoInsertDelete(int delete) {
-        if (tableName.equals(&quot;Occurrence&quot;)){
-             Object[] object = searchObject(&quot;Occurrence&quot;,recordId);             
-             Occurrence occurrence = (Occurrence)object[delete];
-             occurrence.setDeleted(1);
-      //  } else if (tableName.equals(&quot;Habitat&quot;)) {
-      //       Object[] object = searchObject(&quot;v&quot;,recordId);  
-      //       Habitat habitat = (Habitat)object[delete];
-      //       habitat.setDeleted(1);
-        } else if (tableName.equals(&quot;Publication&quot;)) {
-             Object[] object = searchObject(&quot;Publication&quot;,recordId);  
-             Publication publication = (Publication)object[delete];
-             publication.setDeleted(1);
-        } else if (tableName.equals(&quot;Author&quot;)) {
-             Object[] object = searchObject(&quot;Author&quot;,recordId);   
-             Author author = (Author)object[delete];
-             author.setDeleted(1);
-        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
-             Object[] object = searchObject(&quot;Phytochorion&quot;,recordId);   
-             Phytochorion phytochorion = (Phytochorion)object[delete];             
-             //phytochorion.setDelete(1);
-        } else if (tableName.equals(&quot;Territoriy&quot;)) {
-             Object[] object = searchObject(&quot;Territory&quot;,recordId); 
-             Territory territory = (Territory)object[delete];             
-             //territory.setDelete(1);
-        } else if (tableName.equals(&quot;Village&quot;)) {
-             Object[] object = searchObject(&quot;Village&quot;,recordId); 
-             Village village = (Village)object[delete];             
-             //village.setDelete(1);
-        } else {
-            logger.error(&quot;No table defined&quot;);
-        }
-    }
-    
-    /**
-     *
-     */
-    public void undoEdit() {
-        
-        //init history data about edit of record
-        columnName = historyRecord.getHistoryColumn().getColumnName();    		    			
-        oldRecordId = historyChange.getOldRecordId();                
-        occurrenceId = historyChange.getOccurrence().getId();		           
-        oldValue = historyRecord.getOldValue();
-        
-        if (tableName.equals(&quot;Occurrence&quot;)){
-                undoOccurrence();
-        } else if (tableName.equals(&quot;Habitat&quot;)) {
-                undoHabitat();
-        } else if (tableName.equals(&quot;Publication&quot;)) {
-                undoPublication();
-        } else if (tableName.equals(&quot;Author&quot;)) {
-                undoAuthor();
-        } else if (tableName.equals(&quot;Phytochorion&quot;)) {
-                undoPhytochorion();
-        } else if (tableName.equals(&quot;Territory&quot;)) {
-                undoTerritory();
-        } else if (tableName.equals(&quot;Village&quot;)) {
-                undoVillage();
-        } else {
-            logger.error(&quot;No table defined&quot;);
-        }
-    }
-
-    /**
-     *
-     */
-    public void undoOccurrence() {
-        
-        //zaznam v ramci, ktereho doslo k editaci tabulky tOccurrences
-        occurrence = historyChange.getOccurrence();
-        
-        boolean objectList = editObjectList.contains(occurrence);
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add(occurrence);
-        }
-        logger.debug(&quot;editObjectList: &quot;+objectList);
-        logger.debug(&quot;OccurrenceID: &quot;+occurrence.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-                
-        if (occurrenceId != recordId){
-            logger.error(&quot;Inccorect information in history tables --&gt; occurrenceId != recordId ... Incorrect identifier of Occurrence.&quot;);
-        }
-
-        //Get a specified number of columnName from occurrence mapping.
-        int columnConstant;
-        if (occurrenceHash.containsKey(columnName)) {
-                 columnConstant = (Integer)occurrenceHash.get(columnName); 
-        } else {
-             columnConstant = 0;
-        }        	    			
-
-        //init Calendar    		
-        Calendar isoDateTime = new GregorianCalendar();
-
-        switch (columnConstant) {
-        case 1: //Taxon  
-            if (oldRecordId &gt; 0 ) {
-                //Select record Plant where id = oldRocordId 
-                Object[] object = searchObject(&quot;Plant&quot;,oldRecordId);
-                Plant plant = (Plant)object[0];
-                //Set old value to attribute plantID
-                occurrence.setPlant(plant);
-                logger.debug(&quot;Set selected value for update of attribute Taxon.&quot;);	
-            } else {
-                 logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-            } 
-            break;
-        case 2: //Year	
-            //Set old value to attribute Year          		
-                occurrence.setYearCollected(Integer.parseInt(oldValue));
-                logger.debug(&quot;Set selected value for update of attribute Year.&quot;);
-                //Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	                		
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(Integer.parseInt(oldValue),occurrence.getMonthCollected(),occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());	                	              	            	
-                break;
-        case 3: //Month 
-                // Set old value to attribute Month 
-                occurrence.setMonthCollected(Integer.parseInt(oldValue));
-                logger.debug(&quot;Set selected value for update of attribute Month.&quot;);
-                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), Integer.parseInt(oldValue), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());              		
-            break;
-        case 4: //Day	                	
-                // Set old value to attribute Day            		
-                occurrence.setDayCollected(Integer.parseInt(oldValue));
-                logger.debug(&quot;Set selected value for update of attribute Day.&quot;);
-                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(occurrence.getTimeCollected());
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), Integer.parseInt(oldValue));
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
-                break;
-        case 5: //Time 	                		                	
-                // Set old value to attribute Time   
-                Date time = new Date();
-                SimpleDateFormat df = new SimpleDateFormat( &quot;HH:mm:ss.S&quot; );
-                try {
-                        time = df.parse( oldValue );
-                } catch (ParseException e) {
-                        logger.error(&quot;Parse time failed. &quot;+ e);
-                }
-                occurrence.setTimeCollected(time);
-                logger.debug(&quot;Set selected value for update of attribute Time.&quot;);
-                // Update attribute isoDateTimeBegin (Year + Mont + Day + Time)		                	
-                isoDateTime.setTime(time);
-                isoDateTime.set(occurrence.getYearCollected(), occurrence.getMonthCollected(), occurrence.getDayCollected());
-                occurrence.setIsoDateTimeBegin(isoDateTime.getTime());
-            break;
-        case 6: //Source	                	
-                // Set old value to attribute Source 
-                occurrence.setDataSource(oldValue);
-                logger.debug(&quot;Set selected value for update of attribute DataSource.&quot;);		                	            	
-                break;
-        case 7: //Herbarium
-                // Set old value to attribute Herbarium
-                occurrence.setHerbarium(oldValue);
-                logger.debug(&quot;Set selected value for update of attribute Herbarium.&quot;);	                		          
-            break;
-        case 8: //Note occurrence	
-                // Set old value to attribute Note occurence	                	
-                occurrence.setNote(oldValue);
-                logger.debug(&quot;Set selected value for update of attribute NoteOccurrence.&quot;);	                		        	
-                break;
-        case 9: //Publication  
-                //Select record Publication where id = oldRocordId 
-                if (oldRecordId &gt; 0){
-                    Object[] objectPubl = searchObject(&quot;Publication&quot;,oldRecordId);
-                    Publication publication = (Publication)objectPubl[0];
-                    //Set old value to attribute publicationID
-                    occurrence.setPublication(publication);
-                    logger.debug(&quot;Set selected value for update of attribute Publication.&quot;);
-                }else {
-                    logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-                }
-            break;
-        default:            
-            logger.error(&quot;No column defined for name &quot;+ columnName);	                   
-        }         
-    }
-        
-    /**
-     *
-     */
-    public void undoHabitat() {
-        
-        //zaznam v ramci, ktereho doslo k editaci tabulky tHabitats
-        occurrence = historyChange.getOccurrence();
-      
-        //K editaci tabulky tHabitats dojde jen v pripade editace nejakeho konkretniho nalezu, proto nam staci nacist
-        //data z tHabitats pres tOccurrence.cHabitatId a nasledne staci zavolat update jen na occurrence
-        boolean objectList = editObjectList.contains(occurrence); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan (editace habitat vzdy v ramci occurrence)
-            editObjectList.add(occurrence);
-        }
-        logger.debug(&quot;editObjectList: &quot;+objectList);
-        logger.debug(&quot;Habitat - OccurrenceID: &quot;+occurrence.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-        // Get a specified number of columnName from habitat mapping.
-        int columnConstant;
-        if (habitatHash.containsKey(columnName)) {
-                 columnConstant = (Integer)habitatHash.get(columnName); 
-        } else {
-             columnConstant = 0;
-        }        	    			
-
-        //informuje o tom, ze byla editovana tabulka tHabitat 
-//        editHabitat = true;
-
-        // Save new value for the column        		
-        switch (columnConstant) {
-        case 1:  //Quadrant     	                	
-                /* pokud doslo ke zmene vazeb mezi tHabitats a tOccurrences z 1:N na 1:1, tak v tOccurrences.cHabitatId
-                 * bude jiz vzdy ulozeno id nove insertovany zaznamu do tHabitats a nikdy uz nedojde k jeho zmene, tzn.
-                 * vazba mezi tabulkami pro dany nalez jiz bude na vzdy 1:1 
-                 */ 	                		  
-                occurrence.getHabitat().setQuadrant(oldValue);		                	
-                logger.debug(&quot;Set selected value for update of attribute Quadrant.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {
-                // existuji dva edity EDIT (ovlivni jeden nalez) a EDITGROUP (ovlivni vice nalezu)
-                // potrebujeme zjistit, zda pro dany nalez je vazeba mezi tHabitats a tOccurrences vzdy 1:N
-                // nebo zda editaci nalezu vznikla vazvba 1:1
-//                relationship = true;
-                } 	                	
-            break;
-        case 2: //Place description 	                	 	                			                		 
-                occurrence.getHabitat().setDescription(oldValue);		                	
-                logger.debug(&quot;Set selected value for update of attribute Description.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	              	
-                break;
-        case 3:  //Country 	                	 	                			                		 
-                occurrence.getHabitat().setCountry(oldValue);		                	
-                logger.debug(&quot;Set selected value for update of attribute Country.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-            break;
-        case 4: //Altitude 	                	                			                		 
-                occurrence.getHabitat().setAltitude(Double.parseDouble(oldValue));		                	
-                logger.debug(&quot;Set selected value for update of attribute Altitude.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-                break;
-        case 5:  //Latitude   	                		                			                		  
-                occurrence.getHabitat().setLatitude(Double.parseDouble(oldValue));		                	
-                logger.debug(&quot;Set selected value for update of attribute Latitude.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-            break;
-        case 6: //Longitude 	                		                			                		
-                occurrence.getHabitat().setLongitude(Double.parseDouble(oldValue));		                	
-                logger.debug(&quot;Set selected value for update of attribute Longitude.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-                break;
-        case 7: //Nearest bigger seat   	                	 	                			                		 
-                //Nacteni Village pro nasledny update tHabitat.cNearestVillageId
-                if (oldRecordId != 0){
-                        Object[] objectVill = searchObject(&quot;Village&quot;,oldRecordId);
-                        Village village = (Village)objectVill[0];
-                occurrence.getHabitat().setNearestVillage(village);
-                logger.debug(&quot;Set selected value for update of attribute NearesVillage.&quot;);
-                } else {
-                        logger.error(&quot;UNDO - Incorrect oldRecordId for Village.&quot;);
-                }
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-            break;
-        case 8: //Phytochorion or phytochorion code 	                	             			                		 
-                // Nacteni Phytochorion pro nasledny update tHabitat.cPhytochorionId
-                if (oldRecordId != 0){
-                        Object[] objectPhyt = searchObject(&quot;Phytochorion&quot;,oldRecordId);
-                        Phytochorion phytochorion = (Phytochorion)objectPhyt[0];
-                        occurrence.getHabitat().setPhytochorion(phytochorion);
-                        logger.debug(&quot;Set selected value for update of attribute Phytochorion.&quot;);
-                }else {
-                        logger.error(&quot;UNDO - Incorrect oldRecordId for Phytochoria.&quot;);
-                }
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-            break; 	               
-        case 9:  //Territory   	                	                			                		  
-                // Nacteni Territory pro nasledny update tHabitat.cTerritory
-                if (oldRecordId != 0){
-                        Object[] objectTerr = searchObject(&quot;Territory&quot;,oldRecordId);
-                        Territory territory = (Territory)objectTerr[0];
-                        occurrence.getHabitat().setTerritory(territory);
-                        logger.debug(&quot;Set selected value for update of attribute Territory.&quot;);
-                }else {
-                        logger.error(&quot;UNDO - Incorrect oldRecordId for Territory.&quot;);
-                }	
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	        	
-            break;
-        case 10: //Note habitat	                		                			                		  
-                occurrence.getHabitat().setNote(oldValue);		                	
-                logger.debug(&quot;Set selected value for update of attribute Note.&quot;);
-                if (operation == HistoryChange.HISTORYCHANGE_EDIT) {	                		
-//                        relationship = true;
-                } 	
-                break;
-        default:            
-            logger.error(&quot;Habitat - No column defined for name &quot;+ columnName);	                   
-        }  	          
-    }
-    
-    /**
-     *
-     */
-    public void undoPublication() {
-                
-        Object[] object = searchObject(&quot;Publication&quot;, recordId);
-        publication = (Publication)object[0];
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains(publication); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add(publication);
-        }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;Publication: &quot;+publication.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
-        int columnConstant;
-        if (publicationHash.containsKey(columnName)) {
-                 columnConstant = (Integer)habitatHash.get(columnName); 
-        } else {
-             columnConstant = 0;
-        }        	    			
-      
-        // Save new value for the column        		
-        switch (columnConstant) {
-        case 1:  //CollectionName     	                	
-                publication.setCollectionName(oldValue);	 
-                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
-                logger.debug(&quot;Publication - Set selected value for update of attribute collectionName.&quot;);                 	
-            break;
-        case 2: //collectionYearPublication	                	 	                			                		 
-                publication.setCollectionYearPublication(Integer.parseInt(oldValue));	          
-                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
-                logger.debug(&quot;Publication - Set selected value for update of attribute collectionYearPublication.&quot;);                 	             	
-                break;
-         case 3: //journalName	                	 	                			                		 
-                publication.setJournalName(oldValue);	       
-                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
-                logger.debug(&quot;Publication - Set selected value for update of attribute journalName.&quot;);                 	             	
-                break;
-        case 4: //journalAuthorName	                	 	                			                		 
-                publication.setJournalAuthorName(oldValue);	 
-                publication.setReferenceCitation(publication.getCollectionName()+&quot;, &quot;+publication.getCollectionYearPublication()+ &quot;, &quot;+publication.getJournalName()+&quot;, &quot;+publication.getJournalAuthorName());
-                logger.debug(&quot;Publication - Set selected value for update of attribute journalAuthorName.&quot;);                 	             	
-                break;
-        case 5: //referenceDetail 	                	 	                			                		 
-                publication.setReferenceDetail(oldValue);	                	
-                logger.debug(&quot;Publication - Set selected value for update of attribute referenceDeatail.&quot;);                 	             	
-                break;
-        case 6: //URL 	                	 	                			                		 
-                publication.setUrl(oldValue);	                	
-                logger.debug(&quot;Publication - Set selected value for update of attribute url.&quot;);                 	             	
-                break;
-        default:            
-            logger.error(&quot;Publication - No column defined for name &quot;+ columnName);	                   
-        } 
-    }
-    
-    /**
-     *
-     */
-    public void undoAuthor() {
-        
-       Object[] object = searchObject(&quot;Author&quot;, recordId);
-       author = (Author)object[0];
-       
-       //test, zda jiz dany zaznam byl editovan
-       boolean objectList = editObjectList.contains(author); 
-       if (!objectList) {
-       	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-           editObjectList.add(author);
-       }
-       logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-       logger.debug(&quot;author: &quot;+author.getId());
-       logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Get a specified number of columnName from habitat mapping.
-        int columnConstant;
-        if (authorHash.containsKey(columnName)) {
-                 columnConstant = (Integer)authorHash.get(columnName); 
-        } else {
-             columnConstant = 0;
-        }        	    			
-      
-        // Save new value for the column        		
-        switch (columnConstant) {
-        case 1:  //wholeName     	                	
-                author.setWholeName(oldValue);	                 
-                logger.debug(&quot;Author - Set selected value for update of attribute WholeName.&quot;);                 	
-            break;
-        case 2: //address	                	 	                			                		 
-                author.setAddress(oldValue);
-                logger.debug(&quot;Author - Set selected value for update of attribute Address.&quot;);                 	             	
-                break;
-         case 3: //mail	                	 	                			                		 
-                author.setEmail(oldValue);	                      
-                logger.debug(&quot;Author - Set selected value for update of attribute Email.&quot;);                 	             	
-                break;
-        case 4: //phoneNumber	                	 	                			                		 
-                author.setPhoneNumber(oldValue);	                
-                logger.debug(&quot;Author - Set selected value for update of attribute PhoneNumber.&quot;);                 	             	
-                break;
-        case 5: //organization 	                	 	                			                		 
-                author.setOrganization(oldValue);                	
-                logger.debug(&quot;Author - Set selected value for update of attribute organization.&quot;);                 	             	
-                break;
-        case 6: //URL 	                	 	                			                		 
-                author.setUrl(oldValue);	                	
-                logger.debug(&quot;Author - Set selected value for update of attribute url.&quot;);                 	             	
-                break;
-        case 7: //role	                	 	                			                		 
-                author.setRole(oldValue);	                	
-                logger.debug(&quot;Author - Set selected value for update of attribute Role.&quot;);                 	             	
-                break;
-        case 8: //note 	                	 	                			                		 
-                author.setNote(oldValue);	                	
-                logger.debug(&quot;Author - Set selected value for update of attribute Note.&quot;);                 	             	
-                break;
-        default:            
-            logger.error(&quot;Author - No column defined for name &quot;+ columnName);	                   
-        } 
-    }
-    
-    /**
-     *
-     */
-    public void undoPhytochorion() {
-        
-        Object[] object = searchObject(&quot;Phytochorion&quot;, recordId);
-        phytochorion = (Phytochorion)object[0];     
-        
-        //test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains(phytochorion); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add(phytochorion);
-        }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;phytochorion: &quot;+phytochorion.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-      
-        if (columnName.equals(&quot;namePhytochorion&quot;)) {
-            phytochorion.setCode(oldValue);	                 
-            logger.debug(&quot;Phytochorion - Set selected value for update of attribute WholeName.&quot;);                 	
-        } else if (columnName.equals(&quot;code&quot;)) {
-             phytochorion.setName(oldValue);
-             logger.debug(&quot;Phytochorion - Set selected value for update of attribute Address.&quot;);                 	             	
-        } else {
-            logger.error(&quot;Phytochorion - No column defined for name &quot;+ columnName);
-        }              
-    }
-    
-    /**
-     *
-     */
-    public void undoVillage() {
-       
-        Object[] object = searchObject(&quot;Village&quot;, recordId);
-        village = (Village)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains(village); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add(village);
-        }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;village: &quot;+village.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-       // Save new value for the column
-        if (columnName.equals(&quot;nameVillage&quot;)) {
-            village.setName(oldValue);	                 
-            logger.debug(&quot;Village - Set selected value for update of attribute Name.&quot;);                 	
-        } else {
-            logger.error(&quot;Village - No column defined for name &quot;+ columnName);	                   
-        }       
-    }
-    
-    /**
-     *
-     */
-    public void undoTerritory() {
-       
-        Object[] object = searchObject(&quot;Territory&quot;, recordId);
-        territory = (Territory)object[0];
-        
-        // test, zda jiz dany zaznam byl editovan
-        boolean objectList = editObjectList.contains(territory); 
-        if (!objectList) {
-        	//pridani objektu do listu - informace o tom, ze byl dany objekt editovan
-            editObjectList.add(territory);
-        }
-        logger.debug(&quot;editObjectList.contains: &quot;+objectList);
-        logger.debug(&quot;territory: &quot;+territory.getId());
-        logger.debug(&quot;columnName: &quot;+columnName);
-        
-       if (columnName.equals(&quot;nameTerritory&quot;)) {
-           territory.setName(oldValue);	                 
-           logger.debug(&quot;Territory - Set selected value for update of attribute Name.&quot;);                 	 
-       } else {
-           logger.error(&quot;Territory - No column defined for name &quot;+ columnName);	                   
-       }        
-    }
-    
-    /**
-     * 
-     * @param id
-     * @return
-     */
-    public Object[] searchObject(String typeObject, int id) { 
-      
-    	SelectQuery query = null;
-    	if (typeObject.equals(&quot;Occurrence&quot;)){
-            try {
-            	query = database.createQuery(Occurrence.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Occurrence.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject() - Occurrence, createQuery&quot;);       	  
-            }            
-            
-    	} else if (typeObject.equals(&quot;Habitat&quot;)){
-            try {
-            	query = database.createQuery(Habitat.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Habitat.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject() - Habitat, createQuery&quot;);       	  
-            }            
-            
-    	} else if (typeObject.equals(&quot;Plant&quot;)){
-            try {
-            	query = database.createQuery(Plant.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Plant.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject() - Plant, createQuery&quot;);       	  
-            }            
-            
-    	} else if (typeObject.equals(&quot;Author&quot;)){
-            try {
-            	query = database.createQuery(Author.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Author.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject() - Author, createQuery&quot;);       	  
-            }            
-            
-    	} else if (typeObject.equals(&quot;Publication&quot;)){
-            try {
-            	query = database.createQuery(Publication.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Publication.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject() - Publication, createQuery&quot;);       	  
-            }            
-            
-    	} else if (typeObject.equals(&quot;Village&quot;)){
-            try {
-            	query = database.createQuery(Village.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Village.ID, null, id, null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject()- Village, createQuery&quot;);       	  
-            }            
-            
-    	}  else if  (typeObject.equals(&quot;Territory&quot;)){
-            try {
-            	query = database.createQuery(Territory.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Territory.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject()- Territory, createQuery&quot;);       	  
-            }            
-             
-    	} else if (typeObject.equals(&quot;Phytochorion&quot;)){
-            try {
-            	query = database.createQuery(Phytochorion.class);
-            	query.addRestriction(PlantloreConstants.RESTR_EQ, Phytochorion.ID, null, id , null);
-            } catch(RemoteException e) {
-            	    System.err.println(&quot;RemoteException, searchObject()- Phytochorion, createQuery&quot;);       	  
-            }            
-            
-    	} else {
-    		logger.error(&quot;SearchObject() - Incorrect type of object.&quot;);
-    	}
-                        
-        int resultIdPlant = 0;
-        try {                   
-            resultIdPlant = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching &quot; +typeObject+ &quot; failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- executeQuery &quot; +typeObject);
- 	} 
-       Object[] objects = null;
-       Object[] object = null;
-       try {
-       	    // Retrieve selected row interval         	
-            try {
-                 objects = database.more(resultIdPlant, 1, 1);  
-            } catch(RemoteException e) {            	
-                logger.debug(&quot;RemoteException- searchObject, more&quot;);            	
-            }   
-        	object = (Object[])objects[0];           
-       } catch (DBLayerException e) {
-           // Log and set error in case of an exception
-           logger.error(&quot;Processing search &quot; +typeObject+ &quot; results failed: &quot;+e.toString());            
-       }     	    
-        return object; 	       	          	   
-           	        
-    }
-    
-    /**
-     *  ..... pri whole history se bude do promennych occurrence, atd. nacitat vice ruznych objektu s jinym ID
-     *  ....Musim si ty jednotlive objekty pamatovat --&gt; pole objektu, kde budou jednotlive editovane objekty
-     */
-    public void commitUpdate() {
-    	
-    	int count = editObjectList.size();
-    	for (int i=0; i&lt; count; i++) {
-    		try {
-    			logger.debug(&quot;Object for update: &quot;+editObjectList.get(i));
-                database.executeUpdate(editObjectList.get(i));
-	        } catch (RemoteException e) {
-	                logger.error(&quot;CommitUpdate - RemoteException: &quot;+e.toString());
-	        } catch (DBLayerException e) {
-	                logger.error(&quot;CommitUpdate - DBLayerException: &quot;+e.toString());
-	        }
-       }    	
-    }
-    
-    /**
-     *  vycisteni seznamu editovany objektu: 
-     */
-    public void clearEditObjectList() {
-    	editObjectList.clear();
-    }
-       
-    /**
-     * Projde oznacene zaznamy a postupne je smaze z tabulek historie.
-     * Pri mazani z tabulky tHistoryChange overi, zda na dany zaznam neni vice vazeb.
-     */
-    public void deleteHistory(int toResult) {
-
-    	//count of selected record
- //   	int count = historyDataList.size();
-    	
-    	//take from younger record to older record
-    	for( int i=0; i &lt; toResult; i++) {
-//    		if (! markListId.contains(i)) {
-//    			continue;
-//    		}    		    		
-    		historyRecord = (HistoryRecord)historyDataList.get(i); 
-    		historyChange = historyRecord.getHistoryChange(); 
-    		
-	    	try {
-				database.executeDelete(historyRecord);
-				logger.debug(&quot;Deleting historyRecord successfully. Number of result: &quot;+i);
-			} catch (RemoteException e) {
-				logger.error(&quot;Deleting historyRecord - remoteException. &quot;+e.toString());
-			} catch (DBLayerException e) {
-				logger.error(&quot;Deleting historyRecord failed. &quot;+e.toString());
-			}
-			int countResult = searchHistoryChangeId(historyChange.getId());			
-			if (countResult == 0) {
-				//samzat zaznam z tabulky tHistoryChange - muzeme protoze neexistuji dalsi FK z tHistory.cChngeId
-				//pokud po smazani zaznamu z tHistory jsme nasli alespon jeden zaznam, ktery ma stejny FK na zaznam z tChangeHistory
-				try {
-					database.executeDelete(historyChange);
-					logger.debug(&quot;Deleting historyChange successfully.&quot;);
-				} catch (RemoteException e) {
-					logger.error(&quot;Deleting historyChange - remoteException. &quot;+e.toString());
-				} catch (DBLayerException e) {
-					logger.error(&quot;Deleting historyChange failed. &quot;+e.toString());
-				}
-			} else {
-				logger.debug(&quot;Exist other record in the table tHistory, whitch has the same value of attribute cChangeId.&quot;);
-			}
-    	}
-    	//Clear list 
-//    	markListId.clear();
-//    	markItem.clear();
-    } 
-    
-    /**
-     * Zjisteni kolik zaznamu v tabulce tHistory je provazano s konkretnim zaznamem z tHistoryHange 
-     * @param id
-     * @return
-     */
-    public int searchHistoryChangeId(int id){    	
-    	SelectQuery query = null;
-        try {
-        	    query = database.createQuery(HistoryRecord.class);
-        	    // Create aliases for table tHistoryChange.      
-                query.createAlias(&quot;historyChange&quot;, &quot;hc&quot;);  
-                // Add restriction to cChangeId column 
-                query.addRestriction(PlantloreConstants.RESTR_EQ, &quot;hc.id&quot;, null, id , null);
-        } catch(RemoteException e) {
-        	    System.err.println(&quot;RemoteException- searchHistoryChangeId(), createQuery&quot;);       	  
-        }        
-        
-        
-        int resultIdChange = 0;
-        try {                   
-        	resultIdChange = database.executeQuery(query);        
-        } catch (DBLayerException e) {                   
-            logger.error(&quot;Searching historyChangeId failed. Unable to execute search query.&quot;);
-        } catch (RemoteException e) {		 
-     	   System.err.println(&quot;RemoteException- searchHistoryChangeId(), executeQuery&quot;);
- 	    } 
-        
- 	    int countResult = 100;
- 	    try {
-			countResult = database.getNumRows(resultIdChange);
-			logger.debug(&quot;SearchHistoryChangeId - Number of result: &quot;+countResult);
-		} catch (RemoteException e) {
-			System.err.println(&quot;RemoteException- searchHistoryChangeId(), getNumRows&quot;);
-		}		
-		return countResult;
-    }
-    
-     //***************************//
-    //****Init Hashtable*********//
-    //**************************//
-    
-    private void initOccurrenceHash() {
-    	occurrenceHash = new Hashtable&lt;String, Integer&gt;(9); 
-        occurrenceHash.put(&quot;plantId&quot;,1);
-        occurrenceHash.put(&quot;yearCollected&quot;,2);
-        occurrenceHash.put(&quot;monthCollected&quot;,3);
-        occurrenceHash.put(&quot;dayCollected&quot;,4);
-        occurrenceHash.put(&quot;timeCollected&quot;,5);           
-        occurrenceHash.put(&quot;dataSource&quot;,6);
-        occurrenceHash.put(&quot;herbarium&quot;,7);        
-        occurrenceHash.put(&quot;noteOccurrence&quot;,8);
-        occurrenceHash.put(&quot;publicationId&quot;,9);       
-        //occurrenceHash.put(&quot;metadataId&quot;,10);
-    }    
-    
-    private void initHabitatHash() {
-    	habitatHash = new Hashtable&lt;String, Integer&gt;(11);         
-        habitatHash.put(&quot;quadrant&quot;,1);
-        habitatHash.put(&quot;description&quot;,2);
-        habitatHash.put(&quot;country&quot;,3);
-        habitatHash.put(&quot;altitude&quot;,4);
-        habitatHash.put(&quot;latitude&quot;,5);
-        habitatHash.put(&quot;longitude&quot;,6);      
-        habitatHash.put(&quot;nameVillage&quot;,7);      
-        habitatHash.put(&quot;namePhytochorion&quot;,8);
-        habitatHash.put(&quot;code&quot;,8);
-        habitatHash.put(&quot;nameTerritory&quot;,9);
-        habitatHash.put(&quot;noteHabitat&quot;,10);
-    }    
-    
-    private void initPublicationHash() {
-        publicationHash = new Hashtable&lt;String, Integer&gt;(6);
-        publicationHash.put(&quot;collectionName&quot;,0);
-        publicationHash.put(&quot;collectionYearPublication&quot;,1);
-        publicationHash.put(&quot;journalName&quot;,2);
-        publicationHash.put(&quot;journalAuthorName&quot;,3);
-        publicationHash.put(&quot;referenceDetail&quot;,4);
-        publicationHash.put(&quot;urlPublication&quot;,5);      
-    }
-    
-    private void initAuthorHash() {
-        authorHash = new Hashtable&lt;String, Integer&gt;(8);
-        authorHash.put(&quot;firstName&quot;,0);
-        authorHash.put(&quot;surname&quot;,1);
-        authorHash.put(&quot;organization&quot;,2);
-        authorHash.put(&quot;role&quot;,3);
-        authorHash.put(&quot;address&quot;,4);
-        authorHash.put(&quot;email&quot;,5);
-        authorHash.put(&quot;urlAuthor&quot;,6);
-        authorHash.put(&quot;noteAuthor&quot;,7);        
-    }              
-    
-       
-    //****************************//
-    //****Get and set metods*****//
-    //**************************//
-    
-    //id vysledku po vyhledavani v db
-    public void setResultId(int resultId) {
-        this.resultId = resultId;
-    }
-    
-    public int getResultId() {
-        return this.resultId;
-    }
-    
-    public int getResultRows() {
-        int resultCount = 0;
-        if (resultId != 0) try {
-                resultCount = database.getNumRows(resultId);        	
-        } catch(RemoteException e) {
-                System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
-        }
-        return resultCount;
-    }
-
-    public ArrayList&lt;HistoryRecord&gt; getHistoryDataList() {
-              return this.historyDataList;		  
-       }
-
-     public void setHistoryDataList(ArrayList&lt;HistoryRecord&gt; historyDataList) {
-              this.historyDataList = historyDataList;		  
-     } 
-    
-     public String getCurrentDisplayRows() {
-		  return this.displayRow;		  
-	   }
-
-     public void setCurrentDisplayRows(String displayRow) {
-              this.displayRow = displayRow;		  
-     } 
-     
-     public String getMessageUndo() {
-		  return this.messageUndo;		  
-	   }
-
-     public void setMessageUndo(String messageUndo) {
-              this.messageUndo = messageUndo;		  
-     } 
-     
-         /**
-     *  Get index of the first row currently displayed in the list of record changes. This is an index in the results returned by a search query.
-     *  @return index of the first row currently displayed in the list of history
-     */
-    public int getCurrentFirstRow() {
-        return this.currentFirstRow;
-    }
-    
-    /**
-     *  Set index of the forst row currently displayed in the list of record changes. This is an index in the results returned by a search query.
-     *  @param row index of the first row currently displayed in the list of history
-     */
-    public void setCurrentFirstRow(int row) {
-        this.currentFirstRow = row;
-    }    
-
-    /**
-     *  Get number of rows to be displayed on one page.
-     *  @return number of rows to be displayed per page
-     */
-    public int getDisplayRows() {
-        return this.displayRows;
-    }
-    
-    /**
-     *  Set number of rows to be displayed on one page
-     *  @param rows number of rows ro be displayed per page
-     */
-    public void setDisplayRows(int rows) {
-        this.displayRows = rows;
-    }
-    
-}

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryCtrl.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -21,11 +21,11 @@
 public class WholeHistoryCtrl {
    
     private Logger logger;
-    private WholeHistory model;
+    private History model;
     private WholeHistoryView view;
     
     /** Creates a new instance of WholeHistoryCtrl */
-    public WholeHistoryCtrl(WholeHistory model, WholeHistoryView view) {
+    public WholeHistoryCtrl(History model, WholeHistoryView view) {
       
         logger = Logger.getLogger(this.getClass().getPackage().getName());        
         this.model = model;
@@ -175,7 +175,7 @@
                    //Button OK was press
                    logger.debug(&quot;Button OK was press.&quot;);    
                    model.commitUpdate();
-                   model.deleteHistory(toResult);
+                   model.deleteHistory(toResult, false);
 		    	   model.searchWholeHistoryData();        	
 		    	   model.processResult(1,model.getDisplayRows());
 		    	   view.tableHistoryList.setModel(new WholeHistoryTableModel(model));

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryTableModel.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -24,7 +24,7 @@
     //Logger
     private Logger logger;
     // History model
-    private WholeHistory model; 
+    private History model; 
     private ArrayList&lt;HistoryRecord&gt; editHistoryDataList;
     
     /** Names of the columns */
@@ -40,7 +40,7 @@
     public final static int NEW_VALUE = 5;
     
     /** Creates a new instance of WholeHistoryTableModel */
-    public WholeHistoryTableModel(WholeHistory model) {
+    public WholeHistoryTableModel(History model) {
         logger = Logger.getLogger(this.getClass().getPackage().getName());
     	this.model = model;        
     	initColumns();    	

Modified: trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-04-21 13:18:23 UTC (rev 168)
+++ trunk/src/net/sf/plantlore/client/history/WholeHistoryView.java	2006-04-21 15:30:58 UTC (rev 169)
@@ -20,12 +20,12 @@
 public class WholeHistoryView extends javax.swing.JDialog implements Observer{
     
     //Whole History model
-    private WholeHistory model;  
+    private History model;  
     //data
     private Object[][] data;
     
     /** Creates new form WholeHistoryView */
-    public WholeHistoryView(WholeHistory model, java.awt.Frame parent, boolean modal) {
+    public WholeHistoryView(History model, java.awt.Frame parent, boolean modal) {
         
         super(parent, modal);
         this.model = model;


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000180.html">[Plantlore-dev] r168 - in trunk/src/net/sf/plantlore: client/login l10n server server/manager
</A></li>
	<LI>Next message: <A HREF="000182.html">[Plantlore-dev]Fwd:Re:data - export/import - aktualizace tPlants
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#181">[ date ]</a>
              <a href="thread.html#181">[ thread ]</a>
              <a href="subject.html#181">[ subject ]</a>
              <a href="author.html#181">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
