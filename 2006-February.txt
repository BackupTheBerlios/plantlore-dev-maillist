From Lada at berlios.de  Mon Feb 13 09:54:58 2006
From: Lada at berlios.de (Lada at berlios.de)
Date: Mon, 13 Feb 2006 09:54:58 +0100
Subject: [Plantlore-dev] r20 - trunk/analysis/biocase
Message-ID: <200602130854.k1D8sw5b027971@sheep.berlios.de>

Author: Lada
Date: 2006-02-13 09:54:46 +0100 (Mon, 13 Feb 2006)
New Revision: 20

Modified:
   trunk/analysis/biocase/BioCASE.doc
Log:
Update document about BioCASE

Modified: trunk/analysis/biocase/BioCASE.doc
===================================================================
(Binary files differ)



From fraktalek at berlios.de  Mon Feb 13 16:41:42 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Mon, 13 Feb 2006 16:41:42 +0100
Subject: [Plantlore-dev] r21 - trunk/analysis/database
Message-ID: <200602131541.k1DFfgEU027332@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-13 16:41:40 +0100 (Mon, 13 Feb 2006)
New Revision: 21

Modified:
   trunk/analysis/database/Posis DB modelu.doc
Log:
A few typos corrected.



Modified: trunk/analysis/database/Posis DB modelu.doc
===================================================================
(Binary files differ)



From fraktalek at berlios.de  Mon Feb 13 18:12:42 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Mon, 13 Feb 2006 18:12:42 +0100
Subject: [Plantlore-dev] r22 - in trunk/analysis: biocase database
Message-ID: <200602131712.k1DHCg1a005302@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-13 18:12:40 +0100 (Mon, 13 Feb 2006)
New Revision: 22

Modified:
   trunk/analysis/biocase/BioCASE.doc
   trunk/analysis/database/Posis DB modelu.doc
Log:
Changed formatting, added TOCs, translated a few things, corrected typos.


Modified: trunk/analysis/biocase/BioCASE.doc
===================================================================
(Binary files differ)

Modified: trunk/analysis/database/Posis DB modelu.doc
===================================================================
(Binary files differ)



From Lada at berlios.de  Mon Feb 13 19:29:16 2006
From: Lada at berlios.de (Lada at berlios.de)
Date: Mon, 13 Feb 2006 19:29:16 +0100
Subject: [Plantlore-dev] r23 - trunk/analysis/biocase
Message-ID: <200602131829.k1DITGeY009420@sheep.berlios.de>

Author: Lada
Date: 2006-02-13 19:29:11 +0100 (Mon, 13 Feb 2006)
New Revision: 23

Modified:
   trunk/analysis/biocase/BioCASE.doc
Log:
Update BioCASE.doc

Modified: trunk/analysis/biocase/BioCASE.doc
===================================================================
(Binary files differ)



From kovo at berlios.de  Tue Feb 14 07:48:36 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Tue, 14 Feb 2006 07:48:36 +0100
Subject: [Plantlore-dev] r24 - trunk/documentation
Message-ID: <200602140648.k1E6macQ003756@sheep.berlios.de>

Author: kovo
Date: 2006-02-14 07:48:07 +0100 (Tue, 14 Feb 2006)
New Revision: 24

Added:
   trunk/documentation/CodingStyle.odt
   trunk/documentation/CodingStyle.pdf
Log:
Plantlore specific coding style guidelines

Added: trunk/documentation/CodingStyle.odt
===================================================================
(Binary files differ)


Property changes on: trunk/documentation/CodingStyle.odt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/documentation/CodingStyle.pdf
===================================================================
(Binary files differ)


Property changes on: trunk/documentation/CodingStyle.pdf
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From fraktalek at berlios.de  Tue Feb 14 16:43:51 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 14 Feb 2006 16:43:51 +0100
Subject: [Plantlore-dev] r25 - trunk/documentation
Message-ID: <200602141543.k1EFhpZJ031586@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-14 16:43:51 +0100 (Tue, 14 Feb 2006)
New Revision: 25

Added:
   trunk/documentation/Zprava o stavu projektu.odt
Log:
Added a yearly project report in czech.



Added: trunk/documentation/Zprava o stavu projektu.odt
===================================================================
(Binary files differ)


Property changes on: trunk/documentation/Zprava o stavu projektu.odt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream



From fraktalek at berlios.de  Tue Feb 14 18:44:39 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 14 Feb 2006 18:44:39 +0100
Subject: [Plantlore-dev] r26 - in trunk: analysis analysis/biocase analysis/database documentation
Message-ID: <200602141744.k1EHidgf030326@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-14 18:44:24 +0100 (Tue, 14 Feb 2006)
New Revision: 26

Added:
   trunk/analysis/biocase/BioCASE.odt
   trunk/analysis/database/Popis DB modelu.odt
Removed:
   trunk/analysis/biocase/BioCASE.doc
Modified:
   trunk/analysis/analysis_requirements_business.sxw
   trunk/analysis/database/Posis DB modelu.doc
   trunk/analysis/uc.odt
   trunk/documentation/Zprava o stavu projektu.odt
Log:
Changes in documentation


Modified: trunk/analysis/analysis_requirements_business.sxw
===================================================================
(Binary files differ)

Deleted: trunk/analysis/biocase/BioCASE.doc
===================================================================
(Binary files differ)

Added: trunk/analysis/biocase/BioCASE.odt
===================================================================
(Binary files differ)


Property changes on: trunk/analysis/biocase/BioCASE.odt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Added: trunk/analysis/database/Popis DB modelu.odt
===================================================================
(Binary files differ)


Property changes on: trunk/analysis/database/Popis DB modelu.odt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/analysis/database/Posis DB modelu.doc
===================================================================
(Binary files differ)

Modified: trunk/analysis/uc.odt
===================================================================
(Binary files differ)

Modified: trunk/documentation/Zprava o stavu projektu.odt
===================================================================
(Binary files differ)



From fraktalek at berlios.de  Tue Feb 14 18:46:12 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 14 Feb 2006 18:46:12 +0100
Subject: [Plantlore-dev] r27 - trunk/analysis/database
Message-ID: <200602141746.k1EHkClH031582@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-14 18:46:11 +0100 (Tue, 14 Feb 2006)
New Revision: 27

Removed:
   trunk/analysis/database/Posis DB modelu.doc
Log:
Deleted description of the database model in doc format.
Added it in OpenOffice format in previous commit.


Deleted: trunk/analysis/database/Posis DB modelu.doc
===================================================================
(Binary files differ)



From fraktalek at berlios.de  Tue Feb 14 21:43:33 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 14 Feb 2006 21:43:33 +0100
Subject: [Plantlore-dev] r28 - in trunk: analysis src/net/sf/plantlore/client src/net/sf/plantlore/common src/net/sf/plantlore/l10n
Message-ID: <200602142043.k1EKhXUQ018337@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-14 21:43:31 +0100 (Tue, 14 Feb 2006)
New Revision: 28

Added:
   trunk/analysis/architektura systemu.odt
Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/AppCoreView.java
   trunk/src/net/sf/plantlore/client/OverviewTableModel.java
   trunk/src/net/sf/plantlore/client/Plantlore.java
   trunk/src/net/sf/plantlore/client/Settings.java
   trunk/src/net/sf/plantlore/common/ComponentAdjust.java
   trunk/src/net/sf/plantlore/common/StatusBarManager.java
   trunk/src/net/sf/plantlore/l10n/L10n.java
Log:
Added a document in czech about the system architecture.
Also added and updated a few JavaDocs.


Added: trunk/analysis/architektura systemu.odt
===================================================================
(Binary files differ)


Property changes on: trunk/analysis/architektura systemu.odt
___________________________________________________________________
Name: svn:mime-type
   + application/octet-stream

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -23,8 +23,10 @@
 import net.sf.plantlore.client.authors.AuthorManagerView;
 import org.apache.log4j.Logger;
 
-/**
+/** Application core controller.
  *
+ * Creates and sets listeners for components in <code>AppCoreView</code>.
+ *
  * @author Jakub
  */
 public class AppCoreCtrl

Modified: trunk/src/net/sf/plantlore/client/AppCoreView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreView.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/client/AppCoreView.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -37,6 +37,11 @@
 
 /** Application core view
  *
+ * Creates the main application window and its contents like data overview, menu,
+ * toolbars, etc.
+ * Listeners of the components are set by the <code>AppCoreCtrl</code> class.
+ * Sets itself as observer of AppCore.
+ *
  * @author Jakub
  */
 public class AppCoreView implements Observer
@@ -79,6 +84,9 @@
     {
     }
 
+    /** Calls all the constructing init methods.
+     *
+     */
     public void init()
     {
         initFrame();
@@ -131,6 +139,9 @@
     }
 
 
+    /** Constructs the main toolbar.
+     *
+     */
     private void initMainToolBar()
     {
         mainToolBar = new JToolBar();
@@ -147,6 +158,9 @@
         sbm.add(searchButton, "Search for records");
     }
     
+    /** Constructs the main status bar and initializes the <code>sbm StatusBarManager</code> appropriately.
+     *
+     */
     private void initStatusBar() 
     {
         JPanel panel = new JPanel();
@@ -159,6 +173,9 @@
         sbm.setDefaultText(L10n.getString("statusReady"));
     }
     
+    /** Constructs the data overview and adds it to the <code>mainPane</code>.
+     *
+     */
     private void initOverview()
     {
         overview = new JTable(new OverviewTableModel());
@@ -193,6 +210,9 @@
         sbm.add(recordsPerPage, "Number of records per page");
     }
     
+    /** Returns the main window <code>StatusBarManager</code>.
+     *
+     */
     public StatusBarManager getSBM() 
     {
         return sbm;
@@ -236,18 +256,30 @@
         helpAbout.addActionListener(al);
     }
 
+    /** Adds a listener to the main window frame.
+     *
+     */
     public void addWindowListener(WindowAdapter wa) {
         frame.addWindowListener(wa);
     }
 
+    /** Adds a listener to the Author manager menu item.
+     *
+     */
     public void addDataAuthorsListener(ActionListener a1) {
         dataAuthors.addActionListener(a1);
     }
     
+    /** Adds a listener to the Publication manager menu item.
+     *
+     */
     public void addDataPublicationsListener(ActionListener al) {
         dataPublications.addActionListener(al);
     }    
     
+    /** Returns the frame of the main window.
+     *
+     */
     protected JFrame getFrame() {
         return this.frame;
     }     

Modified: trunk/src/net/sf/plantlore/client/OverviewTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/OverviewTableModel.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/client/OverviewTableModel.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -9,7 +9,7 @@
 
 import javax.swing.table.AbstractTableModel;
 
-/**
+/** Implements a table model for the main data overview.
  *
  * @author Jakub
  */

Modified: trunk/src/net/sf/plantlore/client/Plantlore.java
===================================================================
--- trunk/src/net/sf/plantlore/client/Plantlore.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/client/Plantlore.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -16,7 +16,7 @@
 import org.apache.log4j.BasicConfigurator;
 import org.apache.log4j.Logger;
 
-/**
+/** The main class of Plantlore. This is where all begins.
  *
  * @author Jakub
  */

Modified: trunk/src/net/sf/plantlore/client/Settings.java
===================================================================
--- trunk/src/net/sf/plantlore/client/Settings.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/client/Settings.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -13,6 +13,9 @@
 
 /** Model for the Settings MVC
  *
+ * Processes all Preferences set in Plantlore.
+ * Loads them and stores them as well.
+ *
  * @author Jakub
  */
 public class Settings

Modified: trunk/src/net/sf/plantlore/common/ComponentAdjust.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ComponentAdjust.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/common/ComponentAdjust.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -12,7 +12,9 @@
 import java.util.Iterator;
 import javax.swing.JComponent;
 
-/**
+/** The purpose of ComponentAdjust is to ease manual creation of swing dialogs.
+ * You can add your components to an instance of this class and then adjust their
+ * width by calling setMaxWidth() method.
  *
  * @author Jakub
  */
@@ -35,15 +37,27 @@
         list = new ArrayList();
     }
     
+    /** Adds a JComponent to the internal list of components.
+     *
+     * You can then adjust the components properties by calling one of the
+     * set methods of this class.
+     *
+     */
     public void add(JComponent c) {
         list.add(c);
         computed = false;
     }
     
+    /** Clears the list of added components.
+     *
+     */
     public void clear() {
         list.clear();
     }
     
+    /** Computes minimum, maximum and average widht and height of stored components.
+     *
+     */
     private void compute() {
         JComponent c;
         Dimension d;
@@ -68,6 +82,10 @@
         computed = true;
     }//compute()
     
+    /** Sets the preferred width of all stored components to the maximum width
+     * of these components.
+     *
+     */
     public void setMaxWidth() {
         JComponent c;
         if (!computed)

Modified: trunk/src/net/sf/plantlore/common/StatusBarManager.java
===================================================================
--- trunk/src/net/sf/plantlore/common/StatusBarManager.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/common/StatusBarManager.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -15,8 +15,13 @@
 import java.util.WeakHashMap;
 import javax.swing.JLabel;
 
-/**
- * This class is based on MouseOverHintManager from Improving your Java GUI with status-bar hints
+/** Status bar convenience class.
+ *
+ * To be more precise this class implements a mouse listener which after receiving
+ * mouseEntered or mouseExited events changes the text of the JLabel that was given
+ * to this class in constructor.
+ *
+ * This class is based on MouseOverHintManager from "Improving your Java GUI with status-bar hints"
  * on builder.com
  *
  * @author Jakub
@@ -27,7 +32,9 @@
     private Map map;
     private String defaultText;
     
-    /** Creates a new instance of StatusBarManager */
+    /** Creates a new instance of StatusBarManager.
+     * Sets the JLabel to be changed on mouseEntered and mouseExited events.
+     */
     public StatusBarManager(JLabel status)
     {
         this.statusLabel = status;
@@ -35,12 +42,19 @@
         defaultText = "";
     }
 
+    /** Adds a component and text that should be displayed on the JLabel when mouse enters the component.
+     *
+     */
     public void add(Component component, String text) 
     {
         component.addMouseListener(this);
         map.put(component, text);
     }
 
+    /** Sets the text that should be displayed when mouse pointer doesn't hover
+     * over one of the added components.
+     *
+     */
     public void setDefaultText(String text) 
     {
         defaultText = text;
@@ -58,12 +72,19 @@
     {
     }
 
+    /** Sets the JLabel to the text associated to the component that was the
+     * source of this event.
+     *
+     */
     public void mouseEntered(MouseEvent mouseEvent)
     {
         String text = (String) map.get(mouseEvent.getSource());
         statusLabel.setText(text);
     }
 
+    /** Sets the JLabel to the default text set by setDefaultText().
+     *
+     */
     public void mouseExited(MouseEvent mouseEvent)
     {
         statusLabel.setText(defaultText);

Modified: trunk/src/net/sf/plantlore/l10n/L10n.java
===================================================================
--- trunk/src/net/sf/plantlore/l10n/L10n.java	2006-02-14 17:46:11 UTC (rev 27)
+++ trunk/src/net/sf/plantlore/l10n/L10n.java	2006-02-14 20:43:31 UTC (rev 28)
@@ -15,8 +15,11 @@
 import java.util.prefs.Preferences;
 import org.apache.log4j.Logger;
 
-/**
+/** Looks after the Plantlore localization.
  *
+ * Gets proper text strings from the resources according to the default or set
+ * locale. Tries to take the locale from the stored Preferences.
+ *
  * @author Jakub
  */
 public class L10n



From fraktalek at berlios.de  Tue Feb 14 23:31:39 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 14 Feb 2006 23:31:39 +0100
Subject: [Plantlore-dev] r29 - trunk/documentation
Message-ID: <200602142231.k1EMVddI020964@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-14 23:31:39 +0100 (Tue, 14 Feb 2006)
New Revision: 29

Modified:
   trunk/documentation/Zprava o stavu projektu.odt
Log:
Changes according to Kovo and Lada.



Modified: trunk/documentation/Zprava o stavu projektu.odt
===================================================================
(Binary files differ)



From discontinuum at gmail.com  Sat Feb 18 12:17:20 2006
From: discontinuum at gmail.com (Erik Kratochvil)
Date: Sat, 18 Feb 2006 12:17:20 +0100
Subject: [Plantlore-dev] Java RMI - jak si to stoji
Message-ID: <f4dc39b90602180317g1c8a03bcvba4d5cdbbc9669b@mail.gmail.com>

Zdravim vsechny, protoze to vypada, ze (skoro) nic nedelam, musim se
podelit o svoje poznatky o RMI.

Po dlouhym zkoumani jsem - doufam - trochu porozumel podivnostem
javovsky implementace. Co je problem?

Pokud napiseme PL a rozdistribuuje se, v podstate zadnej problem
nebude - vsichni budou mit aktualni verzi a bude to pohoda.

Problem nastane v okamziku, kdy nekdo "neco" zmeni - ono neco je
konkretni implementace nektereho z objektu, ktery prochazi pres
DBLayer interface, napr. QueryResult nebo DBLayerException.

<mala odbocka>
Definice: codebase je neco jako remote classpath, tj. kdyz nemas k
dispozici tridy z classpath, zkus jeste codebase (tj. codebase by melo
byt misto, kde se nachazi tridy, ktere klient nebo server nema a
potrebuje pro beh). Pisu to sem proto, ze ne vsichni cetli ten RMI
priklad a ve vykladu dal ten termin pouzivam, tak abyste se nedivili,
co to kecam.
</mala odbocka>

Proc je to problem: RMI totiz potrebuje, aby ty tridy, ktery si ma
posilat mezi klientem a serverem, meli k dispozici oba: jak klient,
tak server, a navic, aby je meli oba ve "stejne verzi" (minimalne
treba musi mit stejnou hash). To je problem, protoze v pripade, ze se
neco zmeni, si server/klient (proste ten, kdo ten objekt vidi poprve),
pokusi tridy neznameho objektu opatrit. Prave to "opatrit si tridy" je
dost problem.

Normalne bych cekal, ze RMI bude natolik chytry, aby si ty tridy
neznamejch objektu dokazalo poslat samo. No, to sem se teda mejlil!
Pri posilani/prijimani nastupuje masinerie javy zahrnujici
SecurityManager/Policy. Bohuzel se zadnym *jednoduchym* zpusobem neda
zaridit, aby si napr. klient automaticky obstaral tridy ze serveru.
Bavime se o tridach, ne o stubech remote objektu - ty totiz posila ten
rmiregistry, tam problem neni.

Na to, aby si klient umel vzit ze serveru tridy, musi je server
zpristupnit bud na >> ftp nebo webserveru <<, jinak to nejde. Klient
si pak tridy umi stahnout, pokud ma nastavenou codebase na ten
http/ftp server, tj. musi vedet, *kde* si je ma stahnout.

Hledal sem, jak se to da obejit, zda nelze to RMI prinutit, aby to
nejak chytre provedlo samo, ale nikde nic. A uz na to jebu.

Cili: pokud zmenime neco na serveru (coz je i celkem rozumny, ze se
casem na serveru implementace nejakejch inkriminovanejch trid zmeni),
automaticky s tim serverem prestanou komunikovat *vsichni*
neaktualizovani klienti (u tech lokalnich by se to dalo jednoducho
ojebat), POKUD ovsem nebudeme chtit, aby si teda klienti umeli sami
spravne stahovat novy kod ze serveru (to lze napsat teda celkem
rozumne, je ale teda zapotrebi mit spustenej nejakej ten http server,
aby si z nej ten klient kod stahl).

Opacna situace muze nastat ovsem taky - upravi se napr. implementace
SelectQuery. Protoze SelectQuery je vyraben na klientovi, musi se
tudiz rozsirit jeho trida mezi klienty. Problem je, kdyz se takovy
klient pokusi pripojit k serveru, ktery "novy" SelectQuery nezna ->
aby ho mohl zkonstruovat, potrebuje si ho stahnout, no a mame presne
to, co pred chvilkou, jenze klienta a server jsou ted v obracene
pozici. Tzn. http server by "obcas" musel bezet i na klientovi, aby si
z neho server mohl stahnout pozadovany tridy. ZDE je ale takovej
neprijemnej hacek - protoze to stahovani je "automaticky" (=resi si ho
RMI), musi to RMI vedet, KDE teda ten klient ma ten server, aby si
mohlo tridy stahnout. Pak bude asi potreba umet si modifikovat
codebase dynamicky, cimz by se dalo RMI snad rict, kde muze ty tridy
najit (je to nechutny, protoze serveru by sakra melo bejt jedno, kde
klient bezi, ne si zjistovat jeho adresu a navic jeste patrat, kde mu
tam bezi http server, aby si mohl prijit pro ty tridy).

Nuze, jak vidite, java RMI tezce zklamalo. Misto nakyho chytryho
posilani trid mezi dvema VM sme se dockali jenom prijemnyho stahovani
stubu. Pro stahovani trid mezi remote VM je teda nutny pouzit jeste
nejakou berlicku, ten http server.

Otazka je: chceme mit takovy to chytry chovani, nebo se spolehneme na
to, ze se vsichni "nejak" dostanou k aktualizacim a nainstaluji si je?

Rekl bych, ze lze spolehat na technickou nezdatnost prirodovedcu a
tudiz z tohohle pohledu je to chytry chovani nezbytny.

Otazka se meni na: ma chytry chovani smysl, kdyz to stejne bude behat
vetsinou izolovane?

Tady je taky odpoved celkem jasna: ma, protoze myslime do budoucna na
dalsi vyuziti.

Zbejva teda posledni otazka a to Jak vyresit ten problem se
stahovanim? Reseni jsou 2:
a) klient i server budou mit k disposici http server (existuje
malinkatej http server od sunu delanej presne a pouze pro tenhle
ucel),
b) zkusit to nejak obejit pomoci vlastnich classloaderu nebo nejakyho
aktualizacniho API

Vyhody pristupu
a) jsou na to priklady, chodi to, sun to tak zamejslel (a navrhl)
b) neni potreba zadny extra server, aktualizace se stahnou automaticky
samy a hladce se prejde na pouzivani novych trid

Nevyhody pristupu
a) poustet servery a hledat je na klientovi/serveru (nezkousel jsem to
programovat, bude to vopruz - ve vsech prikladech totiz vsichni
vzdycky vi, KDE PRESNE bude bezet klient i server, proto neni s
nastavenim codebase problem)
b) muze se ukazat neresitelny (rekurentni dotazy pri aktualizaci
aktualizacniho api)nebo neprijemy - minimalne proto, ze to neni nikde
popsany, muselo by se to nejak vyzkoumat a otestovat (coz sezere dost
casu).

Rad bych dostal nejaky vyjadreni, abych vedel, jak to mam dal resit -
tj. co zjistit, jak funguje, napsat priklad apod. Minimalne bych rad
videl alespon odpoved typu: nic o tom netusim, klidnes ten vyklad mohl
mit spanelsky, rozhodni si to sam.



FAQ

1. Jak to ovlivni mou tridu, tj. tridu, co prave pisu?

 No, to je jeste otazka, ja doufam, ze by to zadnej vliv mit nemelo,
ale to RMI uz me nekolikrat prekvapilo, takze ... no takze doufam, ze
sem si vybral ty neprijemny prekvapeni a zbyly jen ty prijemny ;)))

2. Nevysereme se na to RMI radsi?

 No to zase neee, protoze takhle to za nas porad aspon resi posilani
objektu a celkem jednoduchej pristup k serveru.

3. A bude se ta implementace nejak menit?

 No ted asi ne, ale jestli na to nekdo sahne, tak se pak bude divit,
ze mu to obcas nejede :)

4. A tos delal celej tejden jo?!

 Jo!


From discontinuum at gmail.com  Sat Feb 18 15:30:44 2006
From: discontinuum at gmail.com (Erik Kratochvil)
Date: Sat, 18 Feb 2006 15:30:44 +0100
Subject: [Plantlore-dev] Re: Java RMI - jak si to stoji
In-Reply-To: <f4dc39b90602180317g1c8a03bcvba4d5cdbbc9669b@mail.gmail.com>
References: <f4dc39b90602180317g1c8a03bcvba4d5cdbbc9669b@mail.gmail.com>
Message-ID: <f4dc39b90602180630g4f6b71efw4d9045efa244a1d8@mail.gmail.com>

No dobre, trochu sem to dorozmyslel a zda se, ze sem asi mel nejakou
temnou chvilku ;)

Proc vlastne by se mely takovy aktualizace vubec delat?

Proti tomu uvazovanymu pouziti mluvi bezpecnost - klient si
preprogramuje tridu a timhle mechanismem by ji mohl vnutit serveru ==
security risk jako prase... (naopak zase nejakej zaskodnickej server
by mohl vnutit neco klientum, no hruuzaa).

Nechal sem se nejak unest moznostma toho RMI, myslim, ze uplne
postacujici bude, kdyz nechame uzivatele se starat o aktualizace
"tradicnim zpusobem" (tj. stahni si novou verzi).

Uf, radsi uz nepremejslim.


From kovo at berlios.de  Sat Feb 18 20:34:31 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:34:31 +0100
Subject: [Plantlore-dev] r30 - trunk/src/net/sf/plantlore/common
Message-ID: <200602181934.k1IJYVCo008932@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:34:30 +0100 (Sat, 18 Feb 2006)
New Revision: 30

Modified:
   trunk/src/net/sf/plantlore/common/ProgressDialog.java
Log:
Center the dialog on the screen

Modified: trunk/src/net/sf/plantlore/common/ProgressDialog.java
===================================================================
--- trunk/src/net/sf/plantlore/common/ProgressDialog.java	2006-02-14 22:31:39 UTC (rev 29)
+++ trunk/src/net/sf/plantlore/common/ProgressDialog.java	2006-02-18 19:34:30 UTC (rev 30)
@@ -56,6 +56,7 @@
                 
         progress.setDefaultCloseOperation(JDialog.DO_NOTHING_ON_CLOSE);
         progress.setSize(320,40);                
+        progress.setLocationRelativeTo(null);        
         
         container = progress.getContentPane();
         container.setLayout(new GridBagLayout());        



From kovo at berlios.de  Sat Feb 18 20:39:58 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:39:58 +0100
Subject: [Plantlore-dev] r31 - trunk/src/net/sf/plantlore/common
Message-ID: <200602181939.k1IJdwxQ010092@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:39:56 +0100 (Sat, 18 Feb 2006)
New Revision: 31

Modified:
   trunk/src/net/sf/plantlore/common/PlantloreHelp.java
Log:
Added constants with help mapping for Author manager

Modified: trunk/src/net/sf/plantlore/common/PlantloreHelp.java
===================================================================
--- trunk/src/net/sf/plantlore/common/PlantloreHelp.java	2006-02-18 19:34:30 UTC (rev 30)
+++ trunk/src/net/sf/plantlore/common/PlantloreHelp.java	2006-02-18 19:39:56 UTC (rev 31)
@@ -24,6 +24,10 @@
     // File containing Java Help settings
     private static final String HELPFILE = "jhelpset.hs";
     
+    // Constants with help for author manager section
+    public static final String AUTHOR_MANAGER_GENERAL = "";
+    public static final String AUTHOR_MANAGER_ADD = "";
+    
     /** Creates a new instance of PlantloreHelp */
     public PlantloreHelp() {
         



From kovo at berlios.de  Sat Feb 18 20:50:19 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:50:19 +0100
Subject: [Plantlore-dev] r32 - in trunk/src/net/sf/plantlore/common: . record
Message-ID: <200602181950.k1IJoJPO013675@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:50:17 +0100 (Sat, 18 Feb 2006)
New Revision: 32

Added:
   trunk/src/net/sf/plantlore/common/record/
   trunk/src/net/sf/plantlore/common/record/AuthorRecord.java
   trunk/src/net/sf/plantlore/common/record/OccurenceRecord.java
   trunk/src/net/sf/plantlore/common/record/PlantRecord.java
   trunk/src/net/sf/plantlore/common/record/PublicationRecord.java
   trunk/src/net/sf/plantlore/common/record/UserRecord.java
Log:
Moving holder objects to common package (as they are used by various parts of application)

Added: trunk/src/net/sf/plantlore/common/record/AuthorRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/AuthorRecord.java	2006-02-18 19:39:56 UTC (rev 31)
+++ trunk/src/net/sf/plantlore/common/record/AuthorRecord.java	2006-02-18 19:50:17 UTC (rev 32)
@@ -0,0 +1,213 @@
+/*
+ * AuthorRecord.java
+ *
+ * Created on 16. leden 2006, 2:32
+ *
+ */
+
+package net.sf.plantlore.common.record;
+
+/**
+ *  Data holder object containing information about an author
+ *
+ *  @author Tomas Kovarik
+ *  @version 0.1, Jan 16, 2006
+ */
+public class AuthorRecord {
+    /** Parameters of the author */
+    private int id;
+    private String firstName;
+    private String surname;
+    private String organization;
+    private String role;
+    private String address;
+    private String phoneNumber;
+    private String email;
+    private String url;
+    private String note;
+    
+    /** Creates a new instance of AuthorRecord */
+    public AuthorRecord() {
+        
+    }
+    
+    /**
+     *   Set unique id of the author
+     *   @param id unique id of the author
+     *   @see getID
+     */
+    public void setID(int id) {
+        this.id = id;
+    }
+    
+    /**
+     *   Get unique id of the author
+     *   @return int unique id of the user
+     *   @see setID
+     */
+    public int getID() {
+        return this.id;
+    }
+    
+    /**
+     *   Get first name of the author
+     *   @return string containing the first name of the author
+     *   @see setFirstName
+     */
+    public String getFirstName() {
+        return this.firstName;
+    }
+    
+    /**
+     *   Set first name of the author
+     *   @param firstName string containing the first name of the author
+     *   @see getFirstName
+     */
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+    
+    /**
+     *   Get surname of the author
+     *   @return string containing surname of the author
+     *   @see setSurname
+     */
+    public String getSurname() {
+        return this.surname;
+    }
+    
+    /**
+     *   Set surname of the author
+     *   @param surname string containing surname of the author
+     *   @see getSurname
+     */
+    public void setSurname(String surname) {
+        this.surname = surname;
+    }
+    
+    /**
+     *   Set organization the author belongs to
+     *   @param organization string containing organization the author belongs to
+     *   @see getOrganization
+     */
+    public void setOrganization(String organization) {
+        this.organization = organization;
+    }
+    
+    /**
+     *   Get organization the author belongs to
+     *   @return string containing organization the author belongs to
+     *   @see setOrganization
+     */
+    public String getOrganization() {
+        return this.organization;
+    }
+    
+    /**
+     *   Set role of the author
+     *   @param role string containing role of the author
+     *   @see getRole
+     */
+    public void setRole(String role) {
+        this.role = role;
+    }
+    
+    /**
+     *   Get role of the author
+     *   @return string representation of author's role
+     *   @see setRole
+     */
+    public String getRole() {
+        return this.role;
+    }
+    
+    /**
+     *   Get address of the author
+     *   @return string containing address of the author
+     *   @see setAddress
+     */
+    public String getAddress() {
+        return this.address;
+    }
+    
+    /**
+     *   Set address of the author
+     *   @param address string containing address of the author
+     *   @see getAddress
+     */
+    public void setAddress(String address) {
+        this.address = address;
+    }
+    
+    /**
+     *   Get phone number of the author
+     *   @return string containing phone number of the author
+     *   @see setPhoneNumber
+     */
+    public String getPhoneNumber() {
+        return this.phoneNumber;
+    }
+    
+    /**
+     *   Set email of the author
+     *   @param phoneNumber string containing phone number of the author
+     *   @see getPhoneNumber
+     */
+    public void setPhoneNumber(String phoneNumber) {
+        this.phoneNumber = phoneNumber;
+    }
+    
+    /**
+     *   Get email of the author
+     *   @return string containing email of the author
+     *   @see setEmail
+     */
+    public String getEmail() {
+        return this.email;
+    }
+    
+    /**
+     *   Set email of the author
+     *   @param email string containing email of the author
+     *   @see getEmail
+     */
+    public void setEmail(String email) {
+        this.email = email;
+    }
+    
+    /**
+     *   Get URL of the author
+     *   @return URL of the author's webpage
+     *   @see setUrl
+     */
+    public String getUrl() {
+        return this.url;
+    }
+    
+    /**
+     *   Set URL of the author
+     *   @param url URL of the author's webpage
+     *   @see getUrl
+     */
+    public void setUrl(String url) {
+        this.url = url;
+    }
+    
+    /**
+     *   Get note about the author
+     *   @return string containing note about the author
+     *   @see setNote
+     */
+    public String getNote() {
+        return this.note;
+    }
+    
+    /**
+     *   Set note about the author
+     *   @param contact string containing note about the author
+     *   @see getNote
+     */
+    public void setNote(String note) {
+        this.note = note;
+    }
+}

Added: trunk/src/net/sf/plantlore/common/record/OccurenceRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/OccurenceRecord.java	2006-02-18 19:39:56 UTC (rev 31)
+++ trunk/src/net/sf/plantlore/common/record/OccurenceRecord.java	2006-02-18 19:50:17 UTC (rev 32)
@@ -0,0 +1,606 @@
+/*
+ * OccurenceRecord.java
+ *
+ * Created on 23. leden 2006, 21:46
+ *
+ */
+
+package net.sf.plantlore.common.record;
+
+import java.util.ArrayList;
+import java.util.Date;
+
+/**
+ *  Data holder object containing information about an occurence
+ *
+ *  @author Jakub Kotowski
+ *  @author Tomas Kovarik
+ *  @version 0.1, Feb 7, 2006
+ */
+public class OccurenceRecord
+{
+    /*******************************/    
+    /* Fields of TOCCURENCES table */
+    /*******************************/
+    private int occurenceId;
+    private String globalUniqueIdentifier;
+    private int yearCollected;
+    private int monthCollected;
+    private int dayCollected;
+    private java.util.Date timeCollected;
+    private String dateSource;
+    private PublicationRecord publication;      // Holder object
+    private String herbarium;
+    private ArrayList authors;                  // ArrayList of holder objects
+    private java.util.Date createWhen;
+    private UserRecord createdWho;              // Holder object
+    private java.util.Date updateWhen;
+    private UserRecord updatedWho;              // Holder object
+    private java.util.Date isoDateTimeBegin;
+    private String unitIdDb;
+    private String unitValue;
+    private String note;
+        
+    /*******************************/    
+    /* Fields of TMETADATA table */
+    /*******************************/
+    private int metadataId;
+    private String technicalContactName;
+    private String technicalContactAddress;
+    private String technicalContactEmail;
+    private String contentContactName;
+    private String contentContactAddress;
+    private String contentContactEmail;
+    private String dataSetTitle;
+    private String dataSetDetails;
+    private String sourceInstitutionId;
+    private String sourceId;
+    private String ownerOrganizationAbbrev;
+    private String language;
+    private String recordBasis;
+    private java.util.Date dateCreate;
+    private java.util.Date dateModified;
+
+    
+    /*******************************/    
+    /* Fields of TPLANTS table */
+    /*******************************/
+    private int plantId;
+    private String surveyTaxId;
+    private String adoptedName;
+    private String czechName;
+    private String publishableName;
+    private String genus;
+    private String scientificNameAuthor;
+    private String synonyms;
+    private String plantNote;
+
+    /*******************************/    
+    /* Fields of THABITATS table */
+    /*******************************/
+    private int habitatId;
+    private String quadrant;
+    private String description;
+    private String country;
+    private double altitude;
+    private double latitude;
+    private double longitude;
+    private String habitatNote;    
+
+    /*******************************/    
+    /* Fields of TVILLAGES table */
+    /*******************************/
+    private int villageId;
+    private String villageName;
+    
+    /*******************************/    
+    /* Fields of TPHYTOCHORIA table */
+    /*******************************/
+    private int phytochoriaId;
+    private String phytochoriaCode;
+    private String phytochoriaName;
+    
+    /*******************************/    
+    /* Fields of TTERRITORIES table */
+    /*******************************/
+    private int territoryId;
+    private String territoryName;
+       
+        
+    /** Creates a new instance of OccurenceRecord */
+    public OccurenceRecord() {
+    }
+
+    
+    /*******************************/    
+    /* TOCCURENCES getters/setters */
+    /*******************************/    
+    
+    public int getoccurenceId() {
+        return occurenceId;
+    }
+
+    public void setoccurenceId(int occurenceId) {
+        this.occurenceId = occurenceId;
+    }
+
+    public String getGlobalUniqueIdentifier() {
+        return globalUniqueIdentifier;
+    }
+
+    public void setGlobalUniqueIdentifier(String globalUniqueIdentifier) {
+        this.globalUniqueIdentifier = globalUniqueIdentifier;
+    }
+
+    public int getYearCollected() {
+        return yearCollected;
+    }
+
+    public void setYearCollected(int yearCollected) {
+        this.yearCollected = yearCollected;
+    }
+
+    public int getMonthCollected() {
+        return monthCollected;
+    }
+
+    public void setMonthCollected(int monthCollected) {
+        this.monthCollected = monthCollected;
+    }
+
+    public int getDayCollected() {
+        return dayCollected;
+    }
+
+    public void setDayCollected(int dayCollected) {
+        this.dayCollected = dayCollected;
+    }
+
+    public java.util.Date getTimeCollected() {
+        return timeCollected;
+    }
+
+    public void setTimeCollected(java.util.Date timeCollected) {
+        this.timeCollected = timeCollected;
+    }
+
+    public String getDateSource() {
+        return dateSource;
+    }
+
+    public void setDateSource(String dateSource) {
+        this.dateSource = dateSource;
+    }
+
+    public PublicationRecord getPublication() {
+        return publication;
+    }
+
+    public void setPublication(PublicationRecord publication) {
+        this.publication = publication;
+    }
+
+    public String getHerbarium() {
+        return herbarium;
+    }
+
+    public void setHerbarium(String herbarium) {
+        this.herbarium = herbarium;
+    }
+
+    public ArrayList getAuthors() {
+        return authors;
+    }
+
+    public void setAuthors(ArrayList authors) {
+        this.authors = authors;
+    }
+
+    public java.util.Date getCreateWhen() {
+        return createWhen;
+    }
+
+    public void setCreateWhen(java.util.Date createWhen) {
+        this.createWhen = createWhen;
+    }
+
+    public UserRecord getCreatedWho() {
+        return createdWho;
+    }
+
+    public void setCreatedWho(UserRecord createdWho) {
+        this.createdWho = createdWho;
+    }
+
+    public java.util.Date getUpdateWhen() {
+        return updateWhen;
+    }
+
+    public void setUpdateWhen(java.util.Date updateWhen) {
+        this.updateWhen = updateWhen;
+    }
+
+    public UserRecord getUpdatedWho() {
+        return updatedWho;
+    }
+
+    public void setUpdatedWho(UserRecord updatedWho) {
+        this.updatedWho = updatedWho;
+    }
+
+    public java.util.Date getIsoDateTimeBegin() {
+        return isoDateTimeBegin;
+    }
+
+    public void setIsoDateTimeBegin(java.util.Date isoDateTimeBegin) {
+        this.isoDateTimeBegin = isoDateTimeBegin;
+    }
+
+    public String getUnitIdDb() {
+        return unitIdDb;
+    }
+
+    public void setUnitIdDb(String unitIdDb) {
+        this.unitIdDb = unitIdDb;
+    }
+
+    public String getUnitValue() {
+        return unitValue;
+    }
+
+    public void setUnitValue(String unitValue) {
+        this.unitValue = unitValue;
+    }
+
+    public String getNote() {
+        return note;
+    }
+
+    public void setNote(String note) {
+        this.note = note;
+    }
+
+    /*******************************/    
+    /* TMETADATA getters/setters   */
+    /*******************************/    
+    
+    public int getmetadataId() {
+        return metadataId;
+    }
+
+    public void setmetadataId(int metadataId) {
+        this.metadataId = metadataId;
+    }
+
+    public String getTechnicalContactName() {
+        return technicalContactName;
+    }
+
+    public void setTechnicalContactName(String technicalContactName) {
+        this.technicalContactName = technicalContactName;
+    }
+
+    public String getTechnicalContactAddress() {
+        return technicalContactAddress;
+    }
+
+    public void setTechnicalContactAddress(String technicalContactAddress) {
+        this.technicalContactAddress = technicalContactAddress;
+    }
+
+    public String getTechnicalContactEmail() {
+        return technicalContactEmail;
+    }
+
+    public void setTechnicalContactEmail(String technicalContactEmail) {
+        this.technicalContactEmail = technicalContactEmail;
+    }
+
+    public String getContentContactName() {
+        return contentContactName;
+    }
+
+    public void setContentContactName(String contentContactName) {
+        this.contentContactName = contentContactName;
+    }
+
+    public String getContentContactAddress() {
+        return contentContactAddress;
+    }
+
+    public void setContentContactAddress(String contentContactAddress) {
+        this.contentContactAddress = contentContactAddress;
+    }
+
+    public String getContentContactEmail() {
+        return contentContactEmail;
+    }
+
+    public void setContentContactEmail(String contentContactEmail) {
+        this.contentContactEmail = contentContactEmail;
+    }
+
+    public String getDataSetTitle() {
+        return dataSetTitle;
+    }
+
+    public void setDataSetTitle(String dataSetTitle) {
+        this.dataSetTitle = dataSetTitle;
+    }
+
+    public String getDataSetDetails() {
+        return dataSetDetails;
+    }
+
+    public void setDataSetDetails(String dataSetDetails) {
+        this.dataSetDetails = dataSetDetails;
+    }
+
+    public String getSourceInstitutionId() {
+        return sourceInstitutionId;
+    }
+
+    public void setSourceInstitutionId(String sourceInstitutionId) {
+        this.sourceInstitutionId = sourceInstitutionId;
+    }
+
+    public String getSourceId() {
+        return sourceId;
+    }
+
+    public void setSourceId(String sourceId) {
+        this.sourceId = sourceId;
+    }
+
+    public String getOwnerOrganizationAbbrev() {
+        return ownerOrganizationAbbrev;
+    }
+
+    public void setOwnerOrganizationAbbrev(String ownerOrganizationAbbrev) {
+        this.ownerOrganizationAbbrev = ownerOrganizationAbbrev;
+    }
+
+    public String getLanguage() {
+        return language;
+    }
+
+    public void setLanguage(String language) {
+        this.language = language;
+    }
+
+    public String getRecordBasis() {
+        return recordBasis;
+    }
+
+    public void setRecordBasis(String recordBasis) {
+        this.recordBasis = recordBasis;
+    }
+
+    public java.util.Date getDateCreate() {
+        return dateCreate;
+    }
+
+    public void setDateCreate(java.util.Date dateCreate) {
+        this.dateCreate = dateCreate;
+    }
+
+    public java.util.Date getDateModified() {
+        return dateModified;
+    }
+
+    public void setDateModified(java.util.Date dateModified) {
+        this.dateModified = dateModified;
+    }
+
+    /*******************************/    
+    /* TPLANTS getters/setters     */
+    /*******************************/
+    
+    public int getPlantId() {
+        return plantId;
+    }
+
+    public void setPlantId(int plantId) {
+        this.plantId = plantId;
+    }
+
+    public String getSurveyTaxId() {
+        return surveyTaxId;
+    }
+
+    public void setSurveyTaxId(String surveyTaxId) {
+        this.surveyTaxId = surveyTaxId;
+    }
+
+    public String getAdoptedName() {
+        return adoptedName;
+    }
+
+    public void setAdoptedName(String adoptedName) {
+        this.adoptedName = adoptedName;
+    }
+
+    public String getCzechName() {
+        return czechName;
+    }
+
+    public void setCzechName(String czechName) {
+        this.czechName = czechName;
+    }
+
+    public String getPublishableName() {
+        return publishableName;
+    }
+
+    public void setPublishableName(String publishableName) {
+        this.publishableName = publishableName;
+    }
+
+    public String getGenus() {
+        return genus;
+    }
+
+    public void setGenus(String genus) {
+        this.genus = genus;
+    }
+
+    public String getScientificNameAuthor() {
+        return scientificNameAuthor;
+    }
+
+    public void setScientificNameAuthor(String scientificNameAuthor) {
+        this.scientificNameAuthor = scientificNameAuthor;
+    }
+
+    public String getSynonyms() {
+        return synonyms;
+    }
+
+    public void setSynonyms(String synonyms) {
+        this.synonyms = synonyms;
+    }
+
+    public String getPlantNote() {
+        return plantNote;
+    }
+
+    public void setPlantNote(String plantNote) {
+        this.plantNote = plantNote;
+    }
+
+    /*******************************/    
+    /* THABITATS getters/setters   */
+    /*******************************/
+    
+    public int getHabitatId() {
+        return habitatId;
+    }
+
+    public void setHabitatId(int habitatId) {
+        this.habitatId = habitatId;
+    }
+
+    public String getQuadrant() {
+        return quadrant;
+    }
+
+    public void setQuadrant(String quadrant) {
+        this.quadrant = quadrant;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public String getCountry() {
+        return country;
+    }
+
+    public void setCountry(String country) {
+        this.country = country;
+    }
+
+    public double getAltitude() {
+        return altitude;
+    }
+
+    public void setAltitude(double altitude) {
+        this.altitude = altitude;
+    }
+
+    public double getLatitude() {
+        return latitude;
+    }
+
+    public void setLatitude(double latitude) {
+        this.latitude = latitude;
+    }
+
+    public double getLongitude() {
+        return longitude;
+    }
+
+    public void setLongitude(double longitude) {
+        this.longitude = longitude;
+    }
+
+    public String getHabitatNote() {
+        return habitatNote;
+    }
+
+    public void setHabitatNote(String habitatNote) {
+        this.habitatNote = habitatNote;
+    }
+
+    /*******************************/    
+    /* TVILLAGES getters/setters   */
+    /*******************************/
+    
+    public int getVillageId() {
+        return villageId;
+    }
+
+    public void setVillageId(int villageId) {
+        this.villageId = villageId;
+    }
+
+    public String getVillageName() {
+        return villageName;
+    }
+
+    public void setVillageName(String villageName) {
+        this.villageName = villageName;
+    }
+
+    /********************************/    
+    /* TPHYTOCHORIA getters/setters */
+    /********************************/
+    
+    public int getPhytochoriaId() {
+        return phytochoriaId;
+    }
+
+    public void setPhytochoriaId(int phytochoriaId) {
+        this.phytochoriaId = phytochoriaId;
+    }
+
+    public String getPhytochoriaCode() {
+        return phytochoriaCode;
+    }
+
+    public void setPhytochoriaCode(String phytochoriaCode) {
+        this.phytochoriaCode = phytochoriaCode;
+    }
+
+    public String getPhytochoriaName() {
+        return phytochoriaName;
+    }
+
+    public void setPhytochoriaName(String phytochoriaName) {
+        this.phytochoriaName = phytochoriaName;
+    }
+
+    /********************************/    
+    /* TTERRITORIES getters/setters */
+    /********************************/
+    
+    public int getTerritoryId() {
+        return territoryId;
+    }
+
+    public void setTerritoryId(int territoryId) {
+        this.territoryId = territoryId;
+    }
+
+    public String getTerritoryName() {
+        return territoryName;
+    }
+
+    public void setTerritoryName(String territoryName) {
+        this.territoryName = territoryName;
+    }    
+}

Added: trunk/src/net/sf/plantlore/common/record/PlantRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/PlantRecord.java	2006-02-18 19:39:56 UTC (rev 31)
+++ trunk/src/net/sf/plantlore/common/record/PlantRecord.java	2006-02-18 19:50:17 UTC (rev 32)
@@ -0,0 +1,77 @@
+/*
+ * PlantRecord.java
+ *
+ * Created on 16. leden 2006, 2:32
+ *
+ */
+
+package net.sf.plantlore.common.record;
+
+/**
+ *  Data holder object containing information about a plant
+ *
+ *  @author Tomas Kovarik
+ *  @version 0.1, Jan 16, 2006
+ */
+public class PlantRecord {
+    // Paraneters of the plant
+    private int id;
+    private String adoptedName;
+    private String czechName;
+    private String publishableName;
+    private String abbreviation;
+    private String note;
+    
+    /** Creates a new instance of PlantRecord */
+    public PlantRecord() {
+        
+    }
+    
+    public void setID(int id) {
+        this.id = id;
+    }
+    
+    public int getID() {
+        return this.id;
+    }
+    
+    public void setAdoptedName(String adoptedName) {
+        this.adoptedName = adoptedName;
+    }
+    
+    public String getAdoptedName() {
+        return this.adoptedName;
+    }
+    
+    public void setCzechName(String czechName) {
+        this.czechName = czechName;
+    }
+    
+    public String getCzechName() {
+        return this.czechName;
+    }
+    
+    public void setPublishableName(String publishableName) {
+        this.publishableName = publishableName;
+    }
+    
+    public String getPublishableName() {
+        return this.publishableName;
+    }
+    
+    public void setAbbreviation(String abbreviation) {
+        this.abbreviation = abbreviation;
+    }
+    
+    public String getAbbreviation() {
+        return this.abbreviation;
+    }
+    
+    public void setNote(String note) {
+        this.note = note;
+    }
+    
+    public String getNote() {
+        return this.note;
+    }
+}

Added: trunk/src/net/sf/plantlore/common/record/PublicationRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/PublicationRecord.java	2006-02-18 19:39:56 UTC (rev 31)
+++ trunk/src/net/sf/plantlore/common/record/PublicationRecord.java	2006-02-18 19:50:17 UTC (rev 32)
@@ -0,0 +1,68 @@
+/*
+ * PublicationRecord.java
+ *
+ * Created on 16. leden 2006, 2:32
+ *
+ */
+
+package net.sf.plantlore.common.record;
+
+/**
+ *  Data holder object containing information about a publication
+ *
+ *  @author Tomas Kovarik
+ *  @version 0.1, Jan 16, 2006
+ */
+public class PublicationRecord {
+    // Parameters of the publication
+    private int id;
+    private String collectionName;
+    private int publicationYear;
+    private String journalName;
+    private String journalAuthor;
+    
+    /** Creates a new instance of PublicationRecord */
+    public PublicationRecord() {
+        
+    }
+    
+    public void setID(int id) {
+        this.id = id;
+    }
+    
+    public int getID() {
+        return this.id;
+    }
+    
+    public void setCollectionName(String collectionName) {
+        this.collectionName = collectionName;
+    }
+    
+    public String getCollectionName() {
+        return this.collectionName;
+    }
+    
+    public void setPublicationYear(int publicationYear) {
+        this.publicationYear = publicationYear;
+    }
+    
+    public int getPublicationYear() {
+        return this.publicationYear;
+    }
+    
+    public void setJournalName(String journalName) {
+        this.journalName = journalName;
+    }
+    
+    public String getJournalName() {
+        return this.journalName;
+    }
+    
+    public void setJournalAuthor(String journalAuthor) {
+        this.journalAuthor = journalAuthor;
+    }
+    
+    public String getJournalAuthor() {
+        return this.journalAuthor;
+    }
+}

Added: trunk/src/net/sf/plantlore/common/record/UserRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/common/record/UserRecord.java	2006-02-18 19:39:56 UTC (rev 31)
+++ trunk/src/net/sf/plantlore/common/record/UserRecord.java	2006-02-18 19:50:17 UTC (rev 32)
@@ -0,0 +1,251 @@
+/*
+ * UserRecord.java
+ *
+ * Created on 16. leden 2006, 2:32
+ *
+ */
+
+package net.sf.plantlore.common.record;
+
+/**
+ *  Data holder object containing information about a user
+ *
+ *  @author Tomas Kovarik
+ *  @version 0.1, Jan 16, 2006
+ */
+public class UserRecord {
+    /** Parameters of the user */
+    private int id;
+    private String login;
+    private String firstName;
+    private String surname;
+    private String email;
+    private String address;
+    private java.util.Date whenCreated;
+    private java.util.Date whenDropped;
+    private String note;
+    private int exportRight;
+    private int importRight;
+    private String role;
+    
+    /** Creates a new instance of UserRecord */
+    public UserRecord() {
+        
+    }
+    
+    /**
+     *   Get user id
+     *   @return id of the user
+     *   @see setID
+     */
+    public int getID() {
+        return this.id;
+    }
+    
+    /**
+     *   Set user id
+     *   @param id   id of the user
+     *   @see getID
+     */
+    public void setID(int id) {
+        this.id = id;
+    }
+    
+    /**
+     *   Get login name of the user
+     *   @return login name of the user
+     *   @see setLogin
+     */
+    public String getLogin() {
+        return this.login;
+    }
+    
+    /**
+     *   Set login name of the user
+     *   @param login string containing login name of the user
+     *   @see getLogin
+     */
+    public void setLogin(String login) {
+        this.login = login;
+    }
+    
+    /**
+     *   Get first name of the user
+     *   @return string containing the first name of the user
+     *   @see setFirstName
+     */
+    public String getFirstName() {
+        return this.firstName;
+    }
+    
+    /**
+     *   Set first name of the user
+     *   @param firstName string containing the first name of the user
+     *   @see getFirstName
+     */
+    public void setFirstName(String firstName) {
+        this.firstName = firstName;
+    }
+    
+    /**
+     *   Get surname of the user
+     *   @return string containing surname of the user
+     *   @see setSurname
+     */
+    public String getSurname() {
+        return this.surname;
+    }
+    
+    /**
+     *   Set surname of the user
+     *   @param surname string containing surname of the user
+     *   @see getSurname
+     */
+    public void setSurname(String surname) {
+        this.surname = surname;
+    }
+    
+    /**
+     *   Get email of the user
+     *   @return string containing email of the user
+     *   @see setEmail
+     */
+    public String getEmail() {
+        return this.email;
+    }
+    
+    /**
+     *   Set email of the user
+     *   @param contact string containing email of the user
+     *   @see getEmail
+     */
+    public void setEmail(String email) {
+        this.email = email;
+    }
+    
+    /**
+     *   Get address of the user
+     *   @return string containing address of the user
+     *   @see setAddress
+     */
+    public String getAddress() {
+        return this.address;
+    }
+    
+    /**
+     *   Set address of the user
+     *   @param contact string containing address of the user
+     *   @see getAddress
+     */
+    public void setAddress(String address) {
+        this.address = address;
+    }
+    
+    /**
+     *   Get date when the user was created
+     *   @return date when the user was added to the system
+     *   @see setWhenCreated
+     */
+    public java.util.Date getWhenCreated() {
+        return this.whenCreated;
+    }
+    
+    /**
+     *   Set date when the user was created
+     *   @param whenCreated date when the user was added to the system
+     *   @see getWhenCreated
+     */
+    public void setWhenCreated(java.util.Date whenCreated) {
+        this.whenCreated = whenCreated;
+    }
+    
+    /**
+     *   Get date when the user was droped
+     *   @return date when the user was deleted from the system
+     *   @see setWhenDropped
+     */
+    public java.util.Date getWhenDropped() {
+        return this.whenDropped;
+    }
+    
+    /**
+     *   Set date when the user was droped
+     *   @param whenDropped date when the user was deleted from the system
+     *   @see getWhenDropped
+     */
+    public void setWhenDropped(java.util.Date whenDropped) {
+        this.whenDropped = whenDropped;
+    }
+    
+    /**
+     *   Get note about the user
+     *   @return string containing note about the user
+     *   @see setNote
+     */
+    public String getNote() {
+        return this.note;
+    }
+    
+    /**
+     *   Set note about the user
+     *   @param contact string containing note about the user
+     *   @see getNote
+     */
+    public void setNote(String note) {
+        this.note = note;
+    }
+    
+    /**
+     *  Get the information about the export right of the user
+     *  @return information about the export right of the user
+     *  @see setExportRight
+     */
+    public int getExportRight() {
+        return this.exportRight;
+    }
+    
+    /**
+     *   Set the information about the export right of the user
+     *   @param exportRight information about the export right of the user
+     *   @see getExportRight
+     */
+    public void setExportRight(int exportRight) {
+        this.exportRight = exportRight;
+    }
+    
+    /**
+     *  Get the information about the import right of the user
+     *  @return information about the import right of the user
+     *  @see setImportRight
+     */
+    public int getImportRight() {
+        return this.importRight;
+    }
+    
+    /**
+     *   Set the information about the imoprt right of the user
+     *   @param importRight information about the import right of the user
+     *   @see getImportRight
+     */
+    public void setImportRight(int importRight) {
+        this.importRight = importRight;
+    }
+    
+    /**
+     *  Get role of the user
+     *  @return String representation of the role of the user
+     *  @see setRole
+     */
+    public String getRole() {
+        return this.role;
+    }
+    
+    /**
+     *   Set the role of the user
+     *   @param role String representation of the role of the user
+     *   @see getRole
+     */
+    public void setRole(String role) {
+        this.role = role;
+    }
+}



From kovo at berlios.de  Sat Feb 18 20:56:48 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:56:48 +0100
Subject: [Plantlore-dev] r34 - in trunk/src/net/sf/plantlore/client/dblayer: . query
Message-ID: <200602181956.k1IJumrP014914@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:55:58 +0100 (Sat, 18 Feb 2006)
New Revision: 34

Added:
   trunk/src/net/sf/plantlore/client/dblayer/query/
   trunk/src/net/sf/plantlore/client/dblayer/query/DeleteQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/query/InsertQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/query/Query.java
   trunk/src/net/sf/plantlore/client/dblayer/query/SelectQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/query/UpdateQuery.java
Log:
Moved query objects to a separate subpackage. All query objects now implement common Query interface.

Added: trunk/src/net/sf/plantlore/client/dblayer/query/DeleteQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/query/DeleteQuery.java	2006-02-18 19:53:26 UTC (rev 33)
+++ trunk/src/net/sf/plantlore/client/dblayer/query/DeleteQuery.java	2006-02-18 19:55:58 UTC (rev 34)
@@ -0,0 +1,129 @@
+/*
+ * DeleteQuery.java
+ *
+ * Created on 15. leden 2006, 13:56
+ *
+ */
+
+package net.sf.plantlore.client.dblayer.query;
+
+import java.util.ArrayList;
+import net.sf.plantlore.client.dblayer.DBLayerException;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import org.apache.log4j.Logger;
+
+/**
+ * Object holding parameters of delete query
+ *
+ * @author Tomas Kovarik
+ * @version 0.1, Jan 15, 2006
+ */
+public class DeleteQuery implements Query {
+    /** Type of data we are working with. For the list of types see DBmapping class */
+    private int type;
+    /** List of triples for the WHERE part of the query */
+    private ArrayList whereList;
+    /** Instance of DBMapping object */
+    private DBMapping dbmap;
+    /** Instance of a logger */
+    private Logger logger;
+    
+    /**
+     * Create a new instance of DeleteQuery. Initializes empty <code>whereList</code> array.
+     */
+    public DeleteQuery() {
+        whereList = new ArrayList();
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Create new instance of the DeleteQuery. Initializes <code>whereList</code> with the given values
+     *
+     *  @param type         type of data we are working with
+     *  @param whereList    List of triples for the WHERE clause
+     *  @throws DBLayetException in case the given type was not found in the DBMapping class
+     */
+    public DeleteQuery(int type, ArrayList where) throws DBLayerException {
+        this.whereList = where;
+        setType(type);
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Add an item (triplet) to the list of triples for the WHERE part of the query
+     *
+     *  @param field    name of the field (left operand)
+     *  @param operator operator connecting operands
+     *  @param value    value of the field (right operand)
+     */
+    public void addWhere(String field, String operator, String value) {
+        String[] triple = {new String(field), new String(operator), new String(value) };
+        whereList.add(triple);
+    }
+    
+    /**
+     *  Set the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @param type Type of data we are working with
+     *  @throws DBLayerException in case the given type was not found in the DBMapping class
+     */
+    public void setType(int type) {
+        this.type = type;
+    }
+    
+    /**
+     *  Get the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @return Type of data we are working with
+     */
+    public int getType() {
+        return this.type;
+    }
+    
+    /**
+     *  Transform data in this object to the SQL query.
+     *
+     *  @return String with the SQL query constructed from the data stored in the object
+     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
+     */
+    public String toSQL() throws DBLayerException {
+        StringBuffer sql;
+        StringBuffer where;
+        String from;
+        String fieldName;
+        String[] triple;
+        
+        // Initialize StringBuffers
+        sql = new StringBuffer();
+        where = new StringBuffer();
+        // Get the name of the table from which we want to delete records
+        from = dbmap.getTableName(this.type);
+        // Construct the WHERE clasue
+        for (int i=0;i<whereList.size();i++) {
+            if (i>0) {
+                where.append(" AND ");
+            }
+            triple = (String[])whereList.get(i);
+            fieldName = dbmap.getFieldName(triple[0], this.type);
+            where.append(fieldName);
+            where.append(" ");
+            where.append(triple[1]);
+            where.append(" ");
+            where.append("'"+triple[2]+"'");
+        }
+        // Construct SQL query
+        sql.append("DELETE FROM ");
+        sql.append(from);
+        sql.append(" WHERE ");
+        sql.append(where);
+        
+        logger.debug(sql.toString());
+        return sql.toString();
+    }
+    
+    public void addOrderby(String field, String direction) { }    
+
+    public void addData(String field, String value) { }
+}

Added: trunk/src/net/sf/plantlore/client/dblayer/query/InsertQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/query/InsertQuery.java	2006-02-18 19:53:26 UTC (rev 33)
+++ trunk/src/net/sf/plantlore/client/dblayer/query/InsertQuery.java	2006-02-18 19:55:58 UTC (rev 34)
@@ -0,0 +1,135 @@
+/*
+ * InsertQuery.java
+ *
+ * Created on 15. leden 2006, 13:56
+ *
+ */
+
+package net.sf.plantlore.client.dblayer.query;
+
+import java.util.ArrayList;
+import net.sf.plantlore.client.dblayer.DBLayerException;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import org.apache.log4j.Logger;
+
+/**
+ * Object hodling parameters of an insert query
+ *
+ * @author Tomas Kovarik
+ * @versionm 0.1, Jan 15, 2006
+ */
+public class InsertQuery implements Query {
+    /** Type of data we are working with. For the list of types see DBmapping class */
+    private int type;
+    // Array of tuples containing the data we want to insert
+    private ArrayList data;
+    /** Instance of DBMapping object */
+    private DBMapping dbmap;
+    /** Instance of a logger */
+    private Logger logger;
+    
+    /**
+     * Create a new instance of InsertQuery. Initializes empty <code>data</code> array.
+     */
+    public InsertQuery() {
+        data = new ArrayList();
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Create new instance of the InsertQuery. Initializes <code>data</code> array with the given values
+     *
+     *  @param type     type of data we are working with
+     *  @param data     List of tuples containing values to insert
+     *  @throws DBLayetException in case the given type was not found in the DBMapping class
+     */
+    public InsertQuery(int type, ArrayList insertData) throws DBLayerException {
+        this.data = insertData;
+        setType(type);
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Add an item (tuple) to the list of values which will be inserted
+     *
+     *  @param field    name of the field (column)
+     *  @param value    value of the field (column)
+     */
+    public void addData(String field, String value) {
+        String[] tuple = {new String(field), new String(value) };
+        data.add(tuple);
+    }
+    
+    /**
+     *  Set the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @param type Type of data we are working with
+     */
+    public void setType(int type) {
+        this.type = type;
+    }
+    
+    /**
+     *  Get the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @return Type of data we are working with
+     */
+    public int getType() {
+        return this.type;
+    }
+    
+    /**
+     *  Transform data in this object to the SQL query.
+     *
+     *  @return String with the SQL query constructed from the data stored in the object
+     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
+     */
+    public String toSQL() throws DBLayerException {
+        StringBuffer sql;
+        StringBuffer insertFields;
+        StringBuffer insertData;
+        String into;
+        String fieldName;
+        String[] tuple;
+        
+        // Initialize StringBuffers
+        sql = new StringBuffer();
+        insertFields = new StringBuffer();
+        insertData = new StringBuffer();
+        // Get the name of the table into which we will insert data
+        into = dbmap.getTableName(this.type);
+        // Construct part of the query with the data
+        for (int i=0;i<data.size();i++) {
+            if (i>0) {
+                insertFields.append(", ");
+                insertData.append(", ");
+            }
+            tuple = (String[])data.get(i);
+            fieldName = dbmap.getFieldName(tuple[0], this.type);
+            insertFields.append(fieldName);
+            // TODO: Rewrite adding quotes to the queries
+            if (i>0) {
+                insertData.append("'"+tuple[1]+"'");
+            } else {
+                insertData.append(tuple[1]);                
+            }
+        }
+        // Construct SQL query
+        sql.append("INSERT INTO ");
+        sql.append(into);
+        sql.append(" (");
+        sql.append(insertFields);
+        sql.append(") VALUES (");
+        sql.append(insertData);
+        sql.append(")");
+        
+        logger.debug(sql.toString());
+        return sql.toString();
+    }
+    
+    public void addOrderby(String field, String direction) { }        
+    
+    public void addWhere(String field, String operator, String value) { }
+}

Added: trunk/src/net/sf/plantlore/client/dblayer/query/Query.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/query/Query.java	2006-02-18 19:53:26 UTC (rev 33)
+++ trunk/src/net/sf/plantlore/client/dblayer/query/Query.java	2006-02-18 19:55:58 UTC (rev 34)
@@ -0,0 +1,20 @@
+package net.sf.plantlore.client.dblayer.query;
+
+import java.io.Serializable;
+
+import net.sf.plantlore.client.dblayer.DBLayerException;
+
+public interface Query extends Serializable {
+	
+	void addData(String field, String value);
+	
+	void addWhere(String field, String operator, String value);
+	
+	void addOrderby(String field, String direction);
+	
+	void setType(int type);
+	
+	int getType();
+	
+	String toSQL() throws DBLayerException;
+}

Added: trunk/src/net/sf/plantlore/client/dblayer/query/SelectQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/query/SelectQuery.java	2006-02-18 19:53:26 UTC (rev 33)
+++ trunk/src/net/sf/plantlore/client/dblayer/query/SelectQuery.java	2006-02-18 19:55:58 UTC (rev 34)
@@ -0,0 +1,164 @@
+/*
+ * SelectQuery.java
+ *
+ * Created on 15. leden 2006, 13:55
+ *
+ */
+
+package net.sf.plantlore.client.dblayer.query;
+
+import java.util.ArrayList;
+import net.sf.plantlore.client.dblayer.DBLayerException;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import org.apache.log4j.Logger;
+
+/**
+ * Object holding parameters of a select query.
+ *
+ * @author Tomas Kovarik
+ * @version 0.1, Jan 15, 2006
+ */
+public class SelectQuery implements Query {
+    /** Type of data we are working with. For the list of types see DBmapping class */
+    private int type;
+    /** List of triples for the WHERE part of the query */
+    private ArrayList whereList;
+    /** List of tuples for the ORDER BY part of the query */
+    private ArrayList orderbyList;
+    /** Instance of DBMapping object */
+    private DBMapping dbmap;
+    /** Instance of a logger */
+    private Logger logger;
+    
+    /**
+     * Create a new instance of SelectQuery. Initializes empty <code>whereList</code> and <code>orderbyList</code>
+     */
+    public SelectQuery() {
+        this.whereList = new ArrayList();
+        this.orderbyList = new ArrayList();
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Create new instance of the SelectQuery. Initializes <code>whereList</code> and <code>orderbyList</code>
+     *  with the given values
+     *
+     *  @param type     type of data we are working with
+     *  @param where    List of triples for the WHERE part of the query
+     *  @param orderby  List of tuples for the ORDER BY part of the query
+     *  @throws DBLayerException in case the given type was not found in the DBMapping class
+     */
+    public SelectQuery(int type, ArrayList where, ArrayList orderby) throws DBLayerException {
+        this.whereList = where;
+        this.orderbyList = orderby;
+        setType(type);
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Add an item (triplet) to the list of triples for the WHERE part of the query
+     *
+     *  @param field    name of the field (left operand)
+     *  @param operator operator connecting operands
+     *  @param value    value of the field (right operand)
+     */
+    public void addWhere(String field, String operator, String value) {
+        String[] triple = {new String(field), new String(operator), new String(value) };
+        whereList.add(triple);
+    }
+    
+    /**
+     *  Add an item (tuple) to the list of tuples for the ORDER BY part of the query
+     *
+     *  @param field    name of the field for sorting
+     *  @param value    direction of sorting (<code>ASC</code> or <code>DESC</code>)
+     */
+    public void addOrderby(String field, String direction) {
+        String[] tuple = { new String(field), new String(direction) };
+        orderbyList.add(tuple);
+    }
+    
+    /**
+     *  Set the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @param type Type of data we are working with
+     */
+    public void setType(int type) {
+        this.type = type;
+    }
+    
+    /**
+     *  Get the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @return Type of data we are working with
+     */
+    public int getType() {
+        return this.type;
+    }
+    
+    /**
+     *  Transform data in this object to the SQL query.
+     *
+     *  @return String with the SQL query constructed from the data stored in the object
+     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
+     */
+    public String toSQL() throws DBLayerException{
+        StringBuffer sql;
+        String from;
+        StringBuffer where;
+        StringBuffer orderby;
+        String fieldName;
+        String[] triple;
+        String[] tuple;
+        
+        // Initialize StringBuffers
+        where = new StringBuffer();
+        sql = new StringBuffer();
+        orderby = new StringBuffer();
+        // Get the table names we will be working with
+        from = dbmap.getTableName(this.type);
+        // Construct WHERE clause
+        for (int i=0;i<whereList.size();i++) {
+            if (i>0) {
+                where.append(" AND ");
+            }
+            triple = (String[])whereList.get(i);
+            fieldName = dbmap.getFieldName(triple[0], this.type);
+            where.append(fieldName);
+            where.append(" ");
+            where.append(triple[1]);
+            where.append(" ");
+            where.append("'"+triple[2]+"'");
+        }
+        // Construct orderby clause
+        orderby.append(" ORDER BY ");
+        for (int i=0;i<orderbyList.size();i++) {
+            if (i>0) {
+                orderby.append(", ");
+            }
+            tuple = (String[])orderbyList.get(i);
+            fieldName = dbmap.getFieldName(tuple[0], this.type);
+            orderby.append(fieldName);
+            orderby.append(" ");
+            orderby.append(tuple[1]);
+        }
+        // Construct SQL query
+        sql.append("SELECT * FROM ");
+        sql.append(from);
+        if (whereList.size() != 0) {
+            sql.append(" WHERE ");
+            sql.append(where);
+        }
+        if (orderbyList.size() != 0) {
+            sql.append(" ");
+            sql.append(orderby);
+        }
+        
+        logger.debug(sql.toString());
+        return sql.toString();
+    }
+    
+    public void addData(String field, String value) { }
+}

Added: trunk/src/net/sf/plantlore/client/dblayer/query/UpdateQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/query/UpdateQuery.java	2006-02-18 19:53:26 UTC (rev 33)
+++ trunk/src/net/sf/plantlore/client/dblayer/query/UpdateQuery.java	2006-02-18 19:55:58 UTC (rev 34)
@@ -0,0 +1,159 @@
+/*
+ * UpdateQuery.java
+ *
+ * Created on 15. leden 2006, 13:56
+ *
+ */
+
+package net.sf.plantlore.client.dblayer.query;
+
+import java.util.ArrayList;
+import net.sf.plantlore.client.dblayer.DBLayerException;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import org.apache.log4j.Logger;
+
+/**
+ * Object holding parameters of delte query
+ *
+ * @author Tomas Kovarik
+ * @version 0.1, Jan 15, 2006
+ */
+public class UpdateQuery implements Query {
+    /** Type of data we are working with. For the list of types see DBmapping class */
+    private int type;
+    /** List of triples for the WHERE part of the query */
+    private ArrayList whereList;
+    // Array of tuples containing the data we want to insert
+    private ArrayList data;
+    /** Instance of DBMapping object */
+    private DBMapping dbmap;
+    /** Instance of a logger */
+    private Logger logger;
+    
+    /**
+     * Creates a new instance of UpdateQuery. Initializes empty <code>whereList</code> and <code>data</code> array.
+     */
+    public UpdateQuery() {
+        whereList = new ArrayList();
+        data = new ArrayList();
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+        
+    }
+    
+    /**
+     *  Create new instance of the DeleteQuery. Initializes <code>whereList</code> and <code>data</code> with the given values
+     *
+     *  @param type         type of data we are working with
+     *  @param whereList    List of triples for the WHERE clause
+     *  @param updateData   List of tuples with the updated data
+     *  @throws DBLayetException in case the given type was not found in the DBMapping class
+     */
+    public UpdateQuery(int type, ArrayList where, ArrayList updateData) throws DBLayerException {
+        this.whereList = where;
+        this.data = updateData;
+        setType(type);
+        dbmap = new DBMapping();
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
+    }
+    
+    /**
+     *  Add an item (triplet) to the list of triples for the WHERE part of the query
+     *
+     *  @param field    name of the field (left operand)
+     *  @param operator operator connecting operands
+     *  @param value    value of the field (right operand)
+     */
+    public void addWhere(String field, String operator, String value) {
+        String[] triple = {new String(field), new String(operator), new String(value) };
+        whereList.add(triple);
+    }
+    
+    /**
+     *  Add an item (tuple) to the list of values which will be updated
+     *
+     *  @param field    name of the field (column)
+     *  @param value    value of the field (column)
+     */
+    public void addData(String field, String value) {
+        String[] tuple = {new String(field), new String(value) };
+        data.add(tuple);
+    }
+    
+    /**
+     *  Set the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @param type Type of data we are working with
+     */
+    public void setType(int type) {
+        this.type = type;
+    }
+    
+    /**
+     *  Get the type of data we are working with. For the list of types see DBmapping class.
+     *
+     *  @return Type of data we are working with
+     */
+    public int getType() {
+        return this.type;
+    }
+    
+    /**
+     *  Transform data in this object to the SQL query.
+     *
+     *  @return String with the SQL query constructed from the data stored in the object
+     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
+     */
+    public String toSQL() throws DBLayerException {
+        StringBuffer sql;
+        String table;
+        StringBuffer where;
+        StringBuffer update;
+        String fieldName;
+        String[] triple;
+        String[] tuple;
+        
+        // Initialize StringBuffers
+        where = new StringBuffer();
+        sql = new StringBuffer();
+        update = new StringBuffer();
+        // Get the name of the table we want to update
+        table = dbmap.getTableName(this.type);
+        // Construct WHERE clause
+        for (int i=0;i<whereList.size();i++) {
+            if (i>0) {
+                where.append(" AND ");
+            }
+            triple = (String[])whereList.get(i);
+            fieldName = dbmap.getFieldName(triple[0], this.type);
+            where.append(fieldName);
+            where.append(" ");
+            where.append(triple[1]);
+            where.append(" ");
+            where.append("'"+triple[2]+"'");
+        }
+        // Construct swction of the query containing updated data
+        for (int i=0;i<data.size();i++) {
+            if (i>0) {
+                update.append(", ");
+            }
+            tuple = (String[])data.get(i);
+            fieldName = dbmap.getFieldName(tuple[0], this.type);
+            update.append(fieldName);
+            update.append(" = ");
+            update.append("'"+tuple[1]+"'");
+        }
+        // Construct whole SQL query
+        sql.append("UPDATE ");
+        sql.append(table);
+        sql.append(" SET ");
+        sql.append(update);
+        sql.append(" ");
+        sql.append(where);
+        
+        logger.debug(sql.toString());
+        return sql.toString();
+    }
+    
+    public void addOrderby(String field, String direction) { }
+}



From kovo at berlios.de  Sat Feb 18 20:58:22 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:58:22 +0100
Subject: [Plantlore-dev] r35 - in trunk/src/net/sf/plantlore/client/dblayer: . result
Message-ID: <200602181958.k1IJwMiT015457@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:58:04 +0100 (Sat, 18 Feb 2006)
New Revision: 35

Added:
   trunk/src/net/sf/plantlore/client/dblayer/result/
   trunk/src/net/sf/plantlore/client/dblayer/result/QueryResult.java
   trunk/src/net/sf/plantlore/client/dblayer/result/Result.java
Log:
Moved QueryResult to a separate subpackage. QueryResult now implements common Result interface.

Added: trunk/src/net/sf/plantlore/client/dblayer/result/QueryResult.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/result/QueryResult.java	2006-02-18 19:55:58 UTC (rev 34)
+++ trunk/src/net/sf/plantlore/client/dblayer/result/QueryResult.java	2006-02-18 19:58:04 UTC (rev 35)
@@ -0,0 +1,76 @@
+/*
+ * QueryResult.java
+ *
+ * Created on 14. leden 2006, 23:22
+ *
+ */
+
+package net.sf.plantlore.client.dblayer.result;
+
+/**
+ * Storage class for information about the results of a query.
+ *
+ * @author Tomas Kovarik
+ * @version 0.1, Jan 14, 2006
+ */
+public class QueryResult implements Result {
+    /** Unique identification of the result */
+    private int resultID;
+    /** Number of rows in the result / affected by the operation */
+    private int numRows;
+    /** Result code of the operation */
+    private int operationResult;
+    /** Type of the operation (entity which is in the result) */
+    private int type;
+    
+    /**
+     * Creates a new instance of QueryResult
+     *
+     * @param resultID          Unique identification of the result
+     * @param numRows           Number of rows in the result / affected by the operation
+     * @param operationResult   Result code of the operation
+     * @param type              Type of the operation
+     */
+    public QueryResult(int resultID, int numRows, int operationResult, int type) {
+        this.resultID = resultID;
+        this.numRows = numRows;
+        this.operationResult = operationResult;
+        this.type = type;
+    }
+    
+    /**
+     * Return unique ID of the result represented by this object
+     *
+     * @return Unique ID of the result
+     */
+    public int getResultID() {
+        return this.resultID;
+    }
+    
+    /**
+     * Return number of rows in the result (either number of selected or affected rows)
+     *
+     * @return Number of rows in the result
+     */
+    public int getNumRows() {
+        return this.numRows;
+    }
+    
+    /**
+     * Return result code of the operation (of the executed query)
+     *
+     * @return Code of the operation result
+     */
+    public int getOperationResult() {
+        return this.operationResult;
+    }
+    
+    /**
+     * Return type of the operation (entity returned by thye query)
+     *
+     * @return String type of the operation
+     */
+    public int getType() {
+        return this.type;
+    }
+}

Added: trunk/src/net/sf/plantlore/client/dblayer/result/Result.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/result/Result.java	2006-02-18 19:55:58 UTC (rev 34)
+++ trunk/src/net/sf/plantlore/client/dblayer/result/Result.java	2006-02-18 19:58:04 UTC (rev 35)
@@ -0,0 +1,15 @@
+package net.sf.plantlore.client.dblayer.result;
+
+import java.io.Serializable;
+
+public interface Result extends Serializable {
+	
+	int getResultID();
+	
+	int getNumRows();
+	
+	int getOperationResult();
+	
+	int getType();
+
+}



From kovo at berlios.de  Sat Feb 18 21:01:31 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 21:01:31 +0100
Subject: [Plantlore-dev] r36 - trunk/src/net/sf/plantlore/client/dblayer
Message-ID: <200602182001.k1IK1V7f015843@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 21:00:31 +0100 (Sat, 18 Feb 2006)
New Revision: 36

Modified:
   trunk/src/net/sf/plantlore/client/dblayer/DBLayer.java
Log:
Updated to work with the modified package structure and new interfaces (Query, Result)

Modified: trunk/src/net/sf/plantlore/client/dblayer/DBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/DBLayer.java	2006-02-18 19:58:04 UTC (rev 35)
+++ trunk/src/net/sf/plantlore/client/dblayer/DBLayer.java	2006-02-18 20:00:31 UTC (rev 36)
@@ -7,7 +7,9 @@
 
 package net.sf.plantlore.client.dblayer;
 
-import java.sql.SQLException;
+import java.rmi.Remote;
+import net.sf.plantlore.client.dblayer.query.Query;
+import net.sf.plantlore.client.dblayer.result.Result;
 
 /**
  * Interface for database access.
@@ -15,30 +17,21 @@
  * @author Tomas Kovarik
  * @version 0.1, Jan 14, 2006
  */
-public interface DBLayer {
+public interface DBLayer extends Remote {
     
     /** Initialize database connection */
     void initialize() throws DBLayerException;
     
-    /** Execute SELECT query */
-    QueryResult executeQuery(SelectQuery query) throws DBLayerException;
-    
-    /** Execute INSERT query */
-    QueryResult executeQuery(InsertQuery query) throws DBLayerException;
-    
-    /** Execute UPDATE query */
-    QueryResult executeQuery(UpdateQuery query) throws DBLayerException;
-    
-    /** Execute DELETE query */
-    QueryResult executeQuery(DeleteQuery query) throws DBLayerException;
-    
+    /** Execute query */
+    Result executeQuery(Query query) throws DBLayerException;
+       
     /** Retrieve an interval of rows from the result */
-    public Object[] more(QueryResult QRes, int from, int to) throws DBLayerException;
+    public Object[] more(Result QRes, int from, int to) throws DBLayerException;
     
     /** Retrieve next row from the result */
-    public Object next(QueryResult QRes) throws DBLayerException;
+    public Object next(Result QRes) throws DBLayerException;
     
     /** Close the result */
-    public void close(QueryResult QRes) throws DBLayerException;
+    public void close(Result QRes) throws DBLayerException;
     
 }



From kovo at berlios.de  Sat Feb 18 21:02:49 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 21:02:49 +0100
Subject: [Plantlore-dev] r37 - trunk/src/net/sf/plantlore/client/dblayer
Message-ID: <200602182002.k1IK2nf2016376@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 21:02:46 +0100 (Sat, 18 Feb 2006)
New Revision: 37

Modified:
   trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java
Log:
Added constants for record types (record types - Author, Plant etc.) are now identified with integer constants.

Modified: trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java	2006-02-18 20:00:31 UTC (rev 36)
+++ trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java	2006-02-18 20:02:46 UTC (rev 37)
@@ -26,10 +26,16 @@
     private Hashtable PUBLICATION;
     private Hashtable METADATA;
     private Hashtable HABITAT;
-    private Hashtable OCCURRENCE;
+    private Hashtable OCCURRENCE;                
     
-    /** List of available types / entities*/
-    private HashSet TYPES;
+    public static final int USERRECORD = 1;
+    public static final int AUTHORRECORD = 2;
+    public static final int PLANTRECORD = 3;
+    public static final int PUBLICATIONRECORD = 4;
+    public static final int METADATARECORD = 5;
+    public static final int HABITATRECORD = 6;    
+    public static final int OCCURENCERECORD = 7;        
+    
     /** List of tables for available entities*/
     private String AUTHOR_TABLES = "TAUTHORS";
     private String USER_TABLES = "TUSER, TRIGHT";
@@ -53,49 +59,35 @@
         initMetadata();
         initHabitat();
         initOccurrence();
-        initTypes();
     }
-    
+        
     /**
-     *  Method for checking whether given type is in the list of avaliable types
-     *
-     *  @param type String representation of the type (entity)
-     *  @return <code>true</code> if the given type is in the list of available types, <code>false</code> otherwise
-     */
-    public boolean checkType(String type) {
-        if (TYPES.contains(type)) {
-            return true;
-        } else {
-            return false;
-        }
-    }
-    
-    /**
      *  Return list of the tables involved for the given type.
      *
-     *  @param type String representation of the type (entity)
+     *  @param type type of the record (entity)
      *  @return String representation of the tables, multiple tables are separated with a comma. Every table comes with an
      *          alias equal to the table name
      *  @throws DBLayerException in case no table is defined for the given type
      */
-    public String getTableName(String type) throws DBLayerException {
-        if (type.equals("USER")) {
-            return this.USER_TABLES;
-        } else if (type.equals("AUTHOR")) {
-            return this.AUTHOR_TABLES;
-        } else if (type.equals("PLANT")) {
-            return this.PLANT_TABLES;
-        } else if (type.equals("PUBLICATION")) {
-            return this.PUBLICATION_TABLES;
-        } else if (type.equals("METADATA")) {
-            return this.METADATA_TABLES;
-        } else if (type.equals("HABITAT")) {
-            return this.HABITAT_TABLES;
-        } else if (type.equals("OCCURRENCE")) {
-            return this.OCCURENCE_TABLES;
-        } else {
-            logger.error("No table defined for type '"+type+"'");
-            throw new DBLayerException("No table defined for type '"+type+"'");
+    public String getTableName(int type) throws DBLayerException {
+        switch (type) {
+            case USERRECORD:
+                return this.USER_TABLES;                
+            case AUTHORRECORD:
+                return this.AUTHOR_TABLES;                
+            case PLANTRECORD:
+                return this.PLANT_TABLES;                
+            case PUBLICATIONRECORD:
+                return this.PUBLICATION_TABLES;                
+            case METADATARECORD:
+                return this.METADATA_TABLES;                
+            case HABITATRECORD:
+                return this.HABITAT_TABLES;                
+            case OCCURENCERECORD:
+                return this.OCCURENCE_TABLES;                            
+            default:
+                logger.error("No table defined for type "+type);
+                throw new DBLayerException("No table defined for type "+type);                
         }
     }
     
@@ -103,33 +95,42 @@
      *  Get the name of the database column represented by the given key in the mapping.
      *
      *  @param key  Key to look for in the mapping
-     *  @param type String representation of the type (entity)
+     *  @param type type of the record (entity)
      *  @throws DBLayerException in case that wrong type is given or the specified key could not be found
      */
-    public String getFieldName(String key, String type) throws DBLayerException {
+    public String getFieldName(String key, int type) throws DBLayerException {
         String value;
-        
-        if (type.equals("USER")) {
-            value = getUserField(key);
-        } else if (type.equals("AUTHOR")) {
-            value = getAuthorField(key);
-        } else if (type.equals("PLANT")) {
-            value = getPlantField(key);
-        } else if (type.equals("PUBLICATION")) {
-            value = getPublicationField(key);
-        } else if (type.equals("METADATA")) {
-            value = getMetadataField(key);
-        } else if (type.equals("HABITAT")) {
-            value = getHabitatField(key);
-        } else if (type.equals("OCCURRENCE")) {
-            value = getOccurrenceField(key);
-        } else {
-            logger.error("No fields defined for type '"+type+"'");
-            throw new DBLayerException("No fields defined for type '"+type+"'");
+
+        switch (type) {
+            case USERRECORD:
+                value = getUserField(key);
+                break;
+            case AUTHORRECORD:
+                value = getAuthorField(key);
+                break;
+            case PLANTRECORD:
+                value = getPlantField(key);
+                break;
+            case PUBLICATIONRECORD:
+                value = getPublicationField(key);
+                break;
+            case METADATARECORD:
+                value = getMetadataField(key);
+                break;
+            case HABITATRECORD:
+                value = getHabitatField(key);
+                break;
+            case OCCURENCERECORD:
+                value = getOccurrenceField(key);
+                break;
+            default:            
+                logger.error("No fields defined for type "+type);
+                throw new DBLayerException("No fields defined for type "+type);
         }
+
         if (value == null) {
-            logger.error("Key '"+key+"' not found in DB mapping for type '"+type+"'");
-            throw new DBLayerException("Key '"+key+"' not found in DB mapping for type '"+type+"'");
+            logger.error("Key '"+key+"' not found in DB mapping for type "+type);
+            throw new DBLayerException("Key '"+key+"' not found in DB mapping for type "+type);
         }
         return value;
     }
@@ -346,22 +347,6 @@
         OCCURRENCE.put("createdwho","TOCCURRENCES.CCREATEWHO");
         OCCURRENCE.put("updatedwhen","TOCCURRENCES.CUPDATEWHEN");
         OCCURRENCE.put("updatedwho","TOCCURRENCES.CUPDATEWHO");
-        OCCURRENCE.put("note","TOCCURRENCES.CNOTE");
-        
-        
-    }
-    
-    /**
-     *  Initialization of the mapping of types.
-     */
-    private void initTypes() {
-        TYPES = new HashSet();
-        TYPES.add("USER");
-        TYPES.add("AUTHOR");
-        TYPES.add("PLANT");
-        TYPES.add("PUBLICATION");
-        TYPES.add("METADATA");
-        TYPES.add("HABITAT");
-        TYPES.add("OCCURRENCE");
-    }
+        OCCURRENCE.put("note","TOCCURRENCES.CNOTE");                
+    }    
 }



From kovo at berlios.de  Sat Feb 18 21:04:07 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 21:04:07 +0100
Subject: [Plantlore-dev] r38 - trunk/src/net/sf/plantlore/client/dblayer
Message-ID: <200602182004.k1IK47WX017225@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 21:04:05 +0100 (Sat, 18 Feb 2006)
New Revision: 38

Modified:
   trunk/src/net/sf/plantlore/client/dblayer/FirebirdDBLayer.java
Log:
Updated to work with the modified package structure and new interfaces (Query, Result). Updated to use new constants for record types (Author, Plant etc.)

Modified: trunk/src/net/sf/plantlore/client/dblayer/FirebirdDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/FirebirdDBLayer.java	2006-02-18 20:02:46 UTC (rev 37)
+++ trunk/src/net/sf/plantlore/client/dblayer/FirebirdDBLayer.java	2006-02-18 20:04:05 UTC (rev 38)
@@ -15,7 +15,14 @@
 import java.sql.Statement;
 import java.util.Hashtable;
 import org.apache.log4j.Logger;
+import net.sf.plantlore.client.dblayer.result.*;
+import net.sf.plantlore.client.dblayer.query.*;
+import net.sf.plantlore.common.record.AuthorRecord;
+import net.sf.plantlore.common.record.PlantRecord;
+import net.sf.plantlore.common.record.PublicationRecord;
+import net.sf.plantlore.common.record.UserRecord;
 
+
 /**
  * Implementation of Firebird database connection, sending queries and retrieving results from the
  * database. Connects directly to the FirebirdSQL database server, connection is not encrypted or
@@ -85,7 +92,17 @@
             throw new DBLayerException("Unable to connect to the DB server");
         }
     }
+
     
+    public Result executeQuery(Query query) throws DBLayerException {
+    	if(query instanceof SelectQuery) return execute((SelectQuery)query);
+    	if(query instanceof InsertQuery) return execute((InsertQuery)query);
+    	if(query instanceof UpdateQuery) return execute((UpdateQuery)query);
+    	if(query instanceof DeleteQuery) return execute((DeleteQuery)query);
+    	
+    	throw new DBLayerException("Unknown query type.");
+    }    
+    
     /**
      *  Executes SQL SELECT query.
      *
@@ -93,7 +110,7 @@
      *  @return result of the query execution
      *  @throws DBLayerException when execution of the query fails
      */
-    public QueryResult executeQuery(SelectQuery query) throws DBLayerException {
+    public Result execute(SelectQuery query) throws DBLayerException {
         ResultSet rs;
         Statement st;
         int numrows, key;
@@ -126,7 +143,7 @@
      *  @return result of the query execution
      *  @throws DBLayerException when execution of the query fails
      */
-    public QueryResult executeQuery(InsertQuery query) throws DBLayerException {
+    public Result execute(InsertQuery query) throws DBLayerException {
         Statement st;
         int numrows;
         
@@ -150,7 +167,7 @@
      *  @return result of the query execution
      *  @throws DBLayerException when execution of the query fails
      */
-    public QueryResult executeQuery(UpdateQuery query) throws DBLayerException {
+    public Result execute(UpdateQuery query) throws DBLayerException {
         Statement st;
         int numrows;
         
@@ -174,7 +191,7 @@
      *  @return result of the query execution
      *  @throws DBLayerException when execution of the query fails
      */
-    public QueryResult executeQuery(DeleteQuery query) throws DBLayerException {
+    public Result execute(DeleteQuery query) throws DBLayerException {
         Statement st;
         int numrows;
         
@@ -193,7 +210,10 @@
     
     /**
      *  Retrieves selected rows from the given result. Returns data from the ResultSet identified by the given
-     *  QueryResult object. Retrieves an interval of rows including rows on positions "from" and "to".
+     *  QueryResult object. Retrieves an interval of rows including rows on positions "from" and "to". Value of 
+     *  "to" must be greater or equal to the value of "from", "from" must be greater than zero and "to" must be 
+     *  less than or equal to the number of rows in the result set. In case any of the conditions is not met, 
+     *  exception is thrown
      *  Results are returned as an array of objects (type <code>Object[]</code>). To use the results, you
      *  have to cast it to the correct type of data holder objects.
      *
@@ -204,23 +224,32 @@
      *  @throws         In case illegal or invalid arguments (range from - to) are provided
      *  @see            next()
      */
-    public Object[] more(QueryResult QRes, int from, int to) throws DBLayerException {
+    public Object[] more(Result QRes, int from, int to) throws DBLayerException {
         // Check validity of arguments
         if (from>to) {
             logger.error("Cannot read rows from "+from+" to "+to+" because from > to");
             throw new DBLayerException("Cannot read rows from "+from+" to "+to+" because from > to");
         }
+        if (from < 1) {
+            logger.error("Cannot read rows starting at the given index: "+from);
+            throw new DBLayerException("Cannot read rows starting at the given index: "+from);            
+        }
         // Get the ResultSet object from the result
         ResultSet rs = (ResultSet)results.get(QRes.getResultID());
         int numRows = QRes.getNumRows();
         // Check whether we have enough rows in the result
-        if (to >= numRows) {
+        if (to > numRows) {
             logger.error("Result doesn't have enough rows. Number of rows: "+numRows);
             throw new DBLayerException("Result doesn't have enough rows. Number of rows: "+numRows);
         }
-        // Move ResultSet to the first row we want to read
+        // Move ResultSet to the first row we want to read. In case we want to read the first row,
+        // move the pointer before the first row, else move it to the given position
         try {
-            rs.absolute(from);
+            if (from > 1) {
+                rs.absolute(from-1);
+            } else {
+                rs.beforeFirst();
+            }
         } catch (SQLException e) {
             logger.error("Cannot move ResultSet to the given row: "+from);
             throw new DBLayerException("Cannot move ResultSet to the given row: "+from);
@@ -243,7 +272,7 @@
      *                  are no more rows in the result.
      *  @throws DBLayerException in case database error occured
      */
-    public Object next(QueryResult QRes) throws DBLayerException {
+    public Object next(Result QRes) throws DBLayerException {
         ResultSet rs = (ResultSet)results.get(QRes.getResultID());
         
         // In case no more rows are available, return null
@@ -257,18 +286,20 @@
         }
         
         // Read data from the result according to the type of the result
-        String type = QRes.getType();
-        if (type.equals("USER")) {
-            return getUserRow(rs);
-        } else if (type.equals("AUTHOR")) {
-            return getAuthorRow(rs);
-        } else if (type.equals("PLANT")) {
-            return getPlantRow(rs);
-        } else if (type.equals("PUBLICATION")) {
-            return getPublicationRow(rs);
-        } else {
-            // TODO: If given type is not defined, raise exception
-            return null;
+        int type = QRes.getType();
+        switch (type) {
+            case DBMapping.USERRECORD:          
+                return getUserRow(rs);
+            case DBMapping.AUTHORRECORD:        
+                return getAuthorRow(rs);
+            case DBMapping.PLANTRECORD:
+                return getPlantRow(rs);                
+            case DBMapping.PUBLICATIONRECORD:
+                return getPublicationRow(rs);                
+            case DBMapping.OCCURENCERECORD:
+                return getOccurenceRow(rs);                                
+            default:
+                return null;
         }
     }
     
@@ -280,7 +311,7 @@
      *  @param QRes identifier of the result we want to close
      *  @throws DBLayerException in case close operation on the connection failed
      */
-    public void close(QueryResult QRes) throws DBLayerException {
+    public void close(Result QRes) throws DBLayerException {
         try {
             conn.close();
         } catch (SQLException e) {
@@ -405,4 +436,9 @@
         
         return pr;
     }
+    
+    private Object getOccurenceRow(ResultSet rs) throws DBLayerException {
+        // TODO: IMPLEMENT
+        return null;
+    }
 }



From kovo at berlios.de  Sat Feb 18 21:08:52 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 21:08:52 +0100
Subject: [Plantlore-dev] r40 - trunk/src/net/sf/plantlore/client
Message-ID: <200602182008.k1IK8q8d019722@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 21:08:50 +0100 (Sat, 18 Feb 2006)
New Revision: 40

Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
Log:
Updated to work with new package structure and new record constants

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-18 20:05:29 UTC (rev 39)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-18 20:08:50 UTC (rev 40)
@@ -15,12 +15,15 @@
 import net.sf.plantlore.client.dblayer.DBLayer;
 import net.sf.plantlore.client.dblayer.DBLayerException;
 import net.sf.plantlore.client.dblayer.FirebirdDBLayer;
-import net.sf.plantlore.client.dblayer.PlantRecord;
-import net.sf.plantlore.client.dblayer.QueryResult;
-import net.sf.plantlore.client.dblayer.SelectQuery;
+import net.sf.plantlore.common.record.PlantRecord;
+import net.sf.plantlore.client.dblayer.result.QueryResult;
+import net.sf.plantlore.client.dblayer.result.Result;
+import net.sf.plantlore.client.dblayer.query.SelectQuery;
+import net.sf.plantlore.client.dblayer.query.Query;
 import net.sf.plantlore.client.authors.AuthorManager;
 import net.sf.plantlore.client.authors.AuthorManagerCtrl;
 import net.sf.plantlore.client.authors.AuthorManagerView;
+import net.sf.plantlore.client.dblayer.DBMapping;
 import org.apache.log4j.Logger;
 
 /** Application core controller.
@@ -87,11 +90,11 @@
                 System.out.println("Exception while initializing DBLayer: "+ex.getMessage());
                 ex.printStackTrace();
             }
-            SelectQuery sq = new SelectQuery();
+            Query sq = new SelectQuery();
             try
             {
-                sq.setType("PLANT");
-                QueryResult qr = dbl.executeQuery(sq);
+                sq.setType(DBMapping.PLANTRECORD);
+                Result qr = dbl.executeQuery(sq);
                 System.out.println("There are "+qr.getNumRows()+" plants in the db.");
                 PlantRecord p = (PlantRecord) dbl.next(qr);
                 do {



From kovo at berlios.de  Sat Feb 18 20:53:46 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 20:53:46 +0100
Subject: [Plantlore-dev] r33 - trunk/src/net/sf/plantlore/client/authors
Message-ID: <200602181953.k1IJrkjL014590@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 20:53:26 +0100 (Sat, 18 Feb 2006)
New Revision: 33

Modified:
   trunk/src/net/sf/plantlore/client/authors/AddAuthorCtrl.java
   trunk/src/net/sf/plantlore/client/authors/AddAuthorView.java
   trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
   trunk/src/net/sf/plantlore/client/authors/AuthorManagerCtrl.java
   trunk/src/net/sf/plantlore/client/authors/AuthorManagerView.java
Log:
Major update of the Author manager, updated to use  modified package structure.

Modified: trunk/src/net/sf/plantlore/client/authors/AddAuthorCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AddAuthorCtrl.java	2006-02-18 19:50:17 UTC (rev 32)
+++ trunk/src/net/sf/plantlore/client/authors/AddAuthorCtrl.java	2006-02-18 19:53:26 UTC (rev 33)
@@ -11,8 +11,11 @@
 import java.awt.event.ActionListener;
 import java.awt.event.FocusEvent;
 import java.awt.event.FocusListener;
+import java.beans.PropertyChangeEvent;
+import java.beans.PropertyChangeListener;
 import net.sf.plantlore.common.PlantloreHelp;
 import javax.swing.Timer;
+import net.sf.plantlore.client.authors.AuthorManagerCtrl.RoleFieldPropertyChangeListener;
 import net.sf.plantlore.common.ProgressDialog;
 
 /**
@@ -20,37 +23,52 @@
  * @author Tomas Kovarik
  */
 public class AddAuthorCtrl {
-    
-    AuthorManager model;
-    AddAuthorView view;
+    /** Model of the Author manager MVC */
+    private AuthorManager model;
+    /** View for adding authors in Autho mManager */
+    private AddAuthorView view;
+    /** Timer used to check for the end of long running tasks */
     private Timer timer;
+    /** Instance of progress dialog */
     private ProgressDialog progress;
     
-    /** Creates a new instance of AddAuthorCtrl */
+    /** 
+     *  Creates a new instance of AddAuthorCtrl 
+     *
+     *  @param addModel Model of the Author manager MVC
+     *  @param addView View for adding authors in Author manager
+     */
     public AddAuthorCtrl(AuthorManager addModel, AddAuthorView addView) {
+        // Save instance of view and model
         this.model = addModel;
         this.view = addView;
+        // Add listeners for buttons and fields
         view.closeBtnAddActionListener(new CloseButtonListener());
         view.helpBtnAddActionListener(new HelpButtonListener());
         view.saveBtnAddActionListener(new SaveAuthorButtonListener());        
-        view.firstNameAddFocusListener(new FirstNameFieldFocusListener());
-        view.surnameAddFocusListener(new SurnameFieldFocusListener());
-        view.organizationAddFocusListener(new OrganizationFieldFocusListener());
-        view.roleAddFocusListener(new RoleFieldFocusListener());
+        view.firstNameAddPropertyChangeListener(new FirstNameFieldPropertyChangeListener());
+        view.surnameAddPropertyChangeListener(new SurnameFieldPropertyChangeListener());
+        view.organizationAddPropertyChangeListener(new OrganizationFieldPropertyChangeListener());
+        view.roleAddPropertyChangeListener(new RoleFieldPropertyChangeListener());
         view.addressAddFocusListener(new AddressAreaFocusListener());
-        view.phoneNumberAddFocusListener(new PhoneFieldFocusListener());
-        view.emailAddFocusListener(new EmailFieldFocusListener());
-        view.urlAddFocusListener(new UrlFieldFocusListener());
-        view.noteAddFocusListener(new NoteAreaFocusListener());        
-        
-        // Create a timer
+        view.phoneNumberAddPropertyChangeListener(new PhoneFieldPropertyChangeListener());
+        view.emailAddPropertyChangeListener(new EmailFieldPropertyChangeListener());
+        view.urlAddPropertyChangeListener(new UrlFieldPropertyChangeListener());
+        view.noteAddFocusListener(new NoteAreaFocusListener());                
+        // Create a timer to check for the end of long running task
         timer = new Timer(100, new ActionListener() {
             public void actionPerformed(ActionEvent evt) {
                 if (model.isOperationDone() == true) {
                     timer.stop();
-                    System.out.println("closing progressbar...");
+                    // Close progress bar dialog
                     progress.close();
                     view.setDialogEnabled(true);                    
+                    if (model.processErrors() == false) {    
+                        if (model.isResultAvailable()) {   
+                            System.out.println("current first row: "+model.getCurrentFirstRow());
+                            model.processResults(model.getCurrentFirstRow(), model.getDisplayRows());                        
+                        }
+                    }
                 }
             }
         });        
@@ -72,12 +90,13 @@
     class HelpButtonListener implements ActionListener {
         public void actionPerformed(ActionEvent e) {
             // Display help viewer            
-            PlantloreHelp.showHelp("Main.AuthorManager");            
+            PlantloreHelp.showHelp(PlantloreHelp.AUTHOR_MANAGER_GENERAL);            
         }
     }
     
     /**
-     * ActionListener class controlling the <b>Save author</b> button on the form.
+     * ActionListener class controlling the <b>Save author</b> button on the form. Checks whether all the required fields 
+     * have been set and calls model to save the data when the button is clicked.
      */    
     class SaveAuthorButtonListener implements ActionListener {
         public void actionPerformed(ActionEvent e) {            
@@ -86,60 +105,59 @@
                 view.checkNonEmpty("organization") && view.checkNonEmpty("role") &&
                 view.checkNonEmpty("address") && view.checkNonEmpty("phone") &&
                 view.checkNonEmpty("email") && view.checkNonEmpty("url")) {
-                
+                // Save the author data
                 model.saveAuthor();                
-
+                // Disable the dialog while saving author
                 view.setDialogEnabled(false);                                
                 timer.start();                
                 // Display dialog with progress bar
                 progress = new ProgressDialog(view.getDialog(), true);
                 progress.show();
-                
+                // Close the add dialog when save finished
                 view.close();
             }
         }
     }        
 
-    class FirstNameFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>first name</b> field in the model with data from the form.
+     */
+    class FirstNameFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setFirstName(view.getFirstName());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }
     
-    class SurnameFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>surname</b> field in the model with data from the form.
+     */
+    class SurnameFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setSurname(view.getSurname());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }
     
-    class OrganizationFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>organization</b> field in the model with data from the form.
+     */
+    class OrganizationFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setOrganization(view.getOrganization());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }    
     
-    class RoleFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>role</b> field in the model with data from the form.
+     */
+    class RoleFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setRole(view.getRole());
         }        
+    }    
 
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
-    }    
-    
+    /**
+     *  FocusListener class for updating <b>address</b> field in the model with data from the form.
+     */    
     class AddressAreaFocusListener implements FocusListener {
         public void focusLost(FocusEvent e) {
             model.setAddress(view.getAddress());
@@ -150,36 +168,36 @@
         }
     }        
     
-    class PhoneFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>phone number</b> field in the model with data from the form.
+     */
+    class PhoneFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setPhoneNumber(view.getPhoneNumber());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }        
     
-    class EmailFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>email</b> field in the model with data from the form.
+     */
+    class EmailFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setEmail(view.getEmail());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }        
     
-    class UrlFieldFocusListener implements FocusListener {
-        public void focusLost(FocusEvent e) {
+    /**
+     *  PropertyChangeListener class for updating <b>URL</b> field in the model with data from the form.
+     */
+    class UrlFieldPropertyChangeListener implements PropertyChangeListener {
+        public void propertyChange(PropertyChangeEvent e) {
             model.setUrl(view.getUrl());
         }        
-
-        public void focusGained(FocusEvent e) {
-            // Empty
-        }
     }            
 
+    /**
+     *  FocusListener class for updating <b>note</b> field in the model with data from the form.
+     */
     class NoteAreaFocusListener implements FocusListener {
         public void focusLost(FocusEvent e) {
             model.setNote(view.getNote());
@@ -189,4 +207,4 @@
             // Empty
         }
     }                
-}
+}
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/client/authors/AddAuthorView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AddAuthorView.java	2006-02-18 19:50:17 UTC (rev 32)
+++ trunk/src/net/sf/plantlore/client/authors/AddAuthorView.java	2006-02-18 19:53:26 UTC (rev 33)
@@ -12,6 +12,7 @@
 import java.awt.GridBagLayout;
 import java.awt.event.ActionListener;
 import java.awt.event.FocusListener;
+import java.beans.PropertyChangeListener;
 import java.util.Observable;
 import java.util.Observer;
 import javax.swing.JButton;
@@ -25,14 +26,22 @@
 /**
  *
  * @author Tomas Kovarik
+ * @version 0.1, 4.2. 2006
  */
 public class AddAuthorView implements Observer {
-
+    /** Model of the Author manager MVC */
     private AuthorManager model;    
+    /** Dialog window */
     private JDialog addAuthDialog;
+    /** Content pane of the addAuthDialog */
     private Container container;    
     
-    /** Creates a new instance of AddAuthorView */
+    /** 
+     *  Creates a new instance of AddAuthorView 
+     *
+     *  @param authModel Model of the Author manger MVC
+     *  @param owner parent of this dialog window
+     */
     public AddAuthorView(AuthorManager authModel, JDialog owner) {
         this.model = authModel;
         this.model.addObserver(this); 
@@ -41,16 +50,21 @@
         addAuthDialog = new JDialog(owner, "Add New Author", true);
         addAuthDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
         addAuthDialog.setSize(320,240);
-
+        addAuthDialog.setLocationRelativeTo(owner);        
         container = addAuthDialog.getContentPane();
         container.setLayout(new GridBagLayout());
+        // Initialize components on the form
         initComponents();        
         
     }
 
+    /**
+     *  Initialize components on the form.
+     */
     private void initComponents() {
         GridBagConstraints gridBagConstraints;
         
+        // Labels
         nameLabel = new JLabel();
         surnameLabel = new JLabel();
         organizationLabel = new JLabel();
@@ -62,6 +76,7 @@
         noteLabel = new JLabel();
         requiredLabel = new JLabel();
         
+        // Text fields
         nameField = new JFormattedTextField();
         surnameField = new JFormattedTextField();
         organizationField = new JFormattedTextField();
@@ -70,15 +85,19 @@
         emailField = new JFormattedTextField();
         urlField = new JFormattedTextField();
         
+        // Text areas
         addressScrollPane = new JScrollPane();
         addressArea = new JTextArea();
         noteScrollPane = new JScrollPane();
         noteArea = new JTextArea();
-                
+        
+        // Buttons
         saveBtn = new JButton();
         closeBtn = new JButton();
         helpBtn = new JButton();
         
+        // ------------------------- LABELS ------------------------
+        
         // Add label with the first name
         nameLabel.setText("First name: ");
         gridBagConstraints = new GridBagConstraints();
@@ -170,6 +189,8 @@
         gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;        
         container.add(requiredLabel, gridBagConstraints);                        
         
+        // ------------------------- FIELDS ------------------------        
+        
         // Add field for name
         gridBagConstraints = new java.awt.GridBagConstraints();
         gridBagConstraints.gridx = 1;
@@ -178,6 +199,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        nameField.setValue("");
         container.add(nameField, gridBagConstraints);
 
         // Add field for surname
@@ -188,6 +210,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        surnameField.setValue("");        
         container.add(surnameField, gridBagConstraints);
 
         // Add field for organization
@@ -198,6 +221,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        organizationField.setValue("");        
         container.add(organizationField, gridBagConstraints);
         
         // Add field for role
@@ -208,6 +232,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        roleField.setValue("");        
         container.add(roleField, gridBagConstraints);
                
         // Add field for phone
@@ -218,6 +243,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        phoneField.setValue("");        
         container.add(phoneField, gridBagConstraints);
 
         // Add field for email
@@ -228,6 +254,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        emailField.setValue("");        
         container.add(emailField, gridBagConstraints);
 
         // Add field for url
@@ -238,8 +265,11 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.weightx = 0.5;        
         gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        urlField.setValue("");        
         container.add(urlField, gridBagConstraints);        
         
+        // ------------------------- TEXT AREAS ------------------------        
+        
         // Add ScrollPane for the address
         gridBagConstraints = new java.awt.GridBagConstraints();
         gridBagConstraints.gridx = 1;
@@ -271,6 +301,8 @@
         noteScrollPane.add(noteArea);                
         noteScrollPane.setViewportView(noteArea);                        
         
+        // ------------------------- BUTTONS ------------------------        
+        
         // Add "Save Author" button
         saveBtn.setText("Save Author");
         gridBagConstraints = new java.awt.GridBagConstraints();
@@ -308,6 +340,12 @@
         container.add(helpBtn, gridBagConstraints);                
     }
     
+    /**
+     *  Check whether given compulsory field is blank. If it is, display appropriate message and give this field focus.
+     *
+     *  @param field string identifier of the field. possible values are: <i>name, surname, organization, role, address, phone, email, url, note</i>
+     *  @return true if the field is non-empty, false otherwise
+     */
     public boolean checkNonEmpty(String field) {
         if (field.equals("name") && (nameField.getText().length() == 0)) {
             JOptionPane.showMessageDialog(addAuthDialog, "Name of the author is a compulsory field. Please fill it in.", "Missing compulsory field", JOptionPane.ERROR_MESSAGE);
@@ -357,65 +395,100 @@
         return true;
     }
     
+    /**
+     *  Set the size and visibility of this dialog
+     */
     public void show() {
         addAuthDialog.setSize(400,450);        
         addAuthDialog.setVisible(true);
     }               
 
+    /**
+     *  Enable/disable this dialog
+     *
+     *  @param enabled specifies whether dialog should be enabled or disabled
+     */
     public void setDialogEnabled(boolean enabled) {
         addAuthDialog.setEnabled(enabled);
     }
     
+    /**
+     *  Return instance of this dialog
+     */
     public JDialog getDialog() {
         return this.addAuthDialog;
     }
     
+    /**
+     *  Update contents of the fields on the form according to the data in the model. This method is called when model notifies its observers.
+     */
     public void update(Observable o, Object arg) {
-        
+        // Load form fields with data from the model
+        this.nameField.setValue(model.getFirstName());
+        this.surnameField.setValue(model.getSurname());
+        this.organizationField.setValue(model.getOrganization());
+        this.roleField.setValue(model.getRole());
+        this.addressArea.setText(model.getAddress());
+        this.phoneField.setValue(model.getPhoneNumber());
+        this.emailField.setValue(model.getEmail());
+        this.urlField.setValue(model.getUrl());
+        this.noteArea.setText(model.getNote());
     }
     
+    /**
+     *  Add ActionListener for the <b>close</b> button
+     */
     public void closeBtnAddActionListener(ActionListener al) {
         closeBtn.addActionListener(al);
     }
     
+    /**
+     *  Add ActionListener for the <b>help</b> button
+     */
     public void helpBtnAddActionListener(ActionListener al) {
         helpBtn.addActionListener(al);
     }
-    
+
+    /**
+     *  Add ActionListener for the <b>save</b> button
+     */    
     public void saveBtnAddActionListener(ActionListener al) {
         saveBtn.addActionListener(al);
     }    
         
-    void firstNameAddFocusListener(FocusListener fl) {
-        nameField.addFocusListener(fl);
+    /**
+     *  Add PropertyChangeListener for the <b>first name</b> field
+     */
+    void firstNameAddPropertyChangeListener(PropertyChangeListener pcl) {
+        nameField.addPropertyChangeListener(pcl);
     }
     
-    void surnameAddFocusListener(FocusListener fl) {
-        surnameField.addFocusListener(fl);
+    void surnameAddPropertyChangeListener(PropertyChangeListener pcl) {
+        surnameField.addPropertyChangeListener(pcl);
     }    
     
-    void organizationAddFocusListener(FocusListener fl) {
-        organizationField.addFocusListener(fl);
+    void organizationAddPropertyChangeListener(PropertyChangeListener pcl) {
+        organizationField.addPropertyChangeListener(pcl);
     }    
     
-    void roleAddFocusListener(FocusListener fl) {
-        roleField.addFocusListener(fl);
+    void roleAddPropertyChangeListener(PropertyChangeListener pcl) {
+        roleField.addPropertyChangeListener(pcl);
     }    
     
     void addressAddFocusListener(FocusListener fl) {
         addressArea.addFocusListener(fl);
     }    
 
-    void phoneNumberAddFocusListener(FocusListener fl) {
-        phoneField.addFocusListener(fl);
+    void phoneNumberAddPropertyChangeListener(PropertyChangeListener pcl) {
+        phoneField.addPropertyChangeListener(pcl);
     }
     
-    void emailAddFocusListener(FocusListener fl) {
-        emailField.addFocusListener(fl);
+    void emailAddPropertyChangeListener(PropertyChangeListener pcl) {
+        emailField.addPropertyChangeListener(pcl);
     }    
     
-    void urlAddFocusListener(FocusListener fl) {
-        urlField.addFocusListener(fl);
+    void urlAddPropertyChangeListener(PropertyChangeListener pcl) {
+        urlField.addPropertyChangeListener(pcl);
     }    
     
     void noteAddFocusListener(FocusListener fl) {
@@ -427,19 +500,20 @@
     }
     
     public String getFirstName() {
-        return nameField.getText();        
+        System.out.println("Getting first name: "+nameField.getValue());
+        return (String)nameField.getValue();                
     }
     
     public String getSurname() {
-        return surnameField.getText();        
+        return (String)surnameField.getValue();        
     }
     
     public String getOrganization() {
-        return organizationField.getText();        
+        return (String)organizationField.getValue();        
     }
     
     public String getRole() {
-        return roleField.getText();        
+        return (String)roleField.getValue();        
     }
     
     public String getAddress() {
@@ -447,15 +521,15 @@
     }    
     
     public String getPhoneNumber() {
-        return phoneField.getText();        
+        return (String)phoneField.getValue();        
     }    
     
     public String getEmail() {
-        return emailField.getText();        
+        return (String)emailField.getValue();        
     }    
     
     public String getUrl() {
-        return urlField.getText();        
+        return (String)urlField.getValue();        
     }    
     
     public String getNote() {

Modified: trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-02-18 19:50:17 UTC (rev 32)
+++ trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-02-18 19:53:26 UTC (rev 33)
@@ -9,13 +9,15 @@
 
 import java.util.ArrayList;
 import java.util.Observable;
-import net.sf.plantlore.client.dblayer.AuthorRecord;
+import net.sf.plantlore.common.record.AuthorRecord;
 import net.sf.plantlore.client.dblayer.DBLayer;
 import net.sf.plantlore.client.dblayer.DBLayerException;
-import net.sf.plantlore.client.dblayer.DeleteQuery;
-import net.sf.plantlore.client.dblayer.InsertQuery;
-import net.sf.plantlore.client.dblayer.QueryResult;
-import net.sf.plantlore.client.dblayer.SelectQuery;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import net.sf.plantlore.client.dblayer.query.DeleteQuery;
+import net.sf.plantlore.client.dblayer.query.InsertQuery;
+import net.sf.plantlore.client.dblayer.query.Query;
+import net.sf.plantlore.client.dblayer.result.Result;
+import net.sf.plantlore.client.dblayer.query.SelectQuery;
 import net.sf.plantlore.common.SwingWorker;
 import org.apache.log4j.Logger;
 
@@ -28,121 +30,151 @@
 public class AuthorManager extends Observable {
     /** Instance of a logger */
     private Logger logger;
-    /** Error message to be displayed */
-    private String errorMsg = null;
+    /** Exception with details about an error */
+    private DBLayerException error = null;
+    /** Instance of a database management object */
     private DBLayer database;
+    /** First name of the author */
     private String firstName;
+    /** Sutname of the author */
     private String surname;
+    /** Organization of the author */
     private String organization;
-    private String role;    
+    /** Role of the author */
+    private String role;   
+    /** Address of the author */
     private String address;
+    /** Phone number of the author */
     private String phoneNumber;
+    /** Email of the author */
     private String email;
+    /** URL of the author */
     private String url;
+    /** Note of the author */
     private String note;
+    /** Name field used for searching */
+    private String searchName;
+    /** Organization field used for searching */
+    private String searchOrganization;
+    /** Role field used for searching */
+    private String searchRole;
+    /** Email field used for searching */
+    private String searchEmail;            
+    /** Flag telling whether a long running operation has already finished */
     private boolean done;
-    private QueryResult queryResult;
+    /** Result of the search query */
+    private Result queryResult;
+    /** Constant with default number of rows to display */
     private static final int DEFAULT_DISPLAY_ROWS = 10;    
+    /** Actual number of rows to display */
     private int displayRows = DEFAULT_DISPLAY_ROWS;
+    /** Data (results of a search query) displayed in the table */
     private ArrayList data;
+    /** Index of the first record shown in the table */
     private int currentFirstRow;
+    /** Index of currently selected author in the table */
     private int authorIndex;
+    /** Field to be used for sorting search query results */
+    private int sortField = SORT_NAME;
+    /** Direction of sorting. 0 = ASC, 1 = DESC. Default is ASC */
+    private int sortDirection = 0;
     
-    /** Creates a new instance of AuthorManager */
+    /** Constants used for identification of fields for sorting */
+    public static final int SORT_NAME = 1;
+    public static final int SORT_ORGANIZATION = 2;
+    public static final int SORT_ROLE = 3;
+    public static final int SORT_EMAIL = 4;
+    public static final int SORT_PHONE = 5;    
+    public static final int SORT_URL = 6;        
+    /** 
+     *  Creates a new instance of AuthorManager.
+     *  @param database Instance of a database management object
+     */
     public AuthorManager(DBLayer database) {
-        logger = Logger.getLogger(this.getClass().getPackage().getName());        
+        logger = Logger.getLogger(this.getClass().getPackage().getName());
         this.database = database;
     }    
     
     /**
      *  Save new author to the database. Information about the author are stored in data fields of this class.
-     *  Operation is executed in a separate thread using <code>SwingWorker</code>
+     *  Operation is executed in a separate thread using <code>SwingWorker</code>. Error is set in case of an exception.
      */
     public void saveAuthor() {     
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
+                // The operation is not finished yet
                 done = false;
                 // Create new Insert query
-                InsertQuery q = new InsertQuery();
+                InsertQuery query = new InsertQuery();
                 // Set type of data we want to insert
-                try {
-                    q.setType("AUTHOR");
-                } catch (DBLayerException e) {
-                    // TODO: update
-                    System.out.println("ERROR: "+e);
-                    done = true;
-                    return 0;
-                }
-                // XXX: temporary delay to show that progress bar works
-/*                try {
-                    System.out.println("going to sleep...");
-                    Thread.sleep(5000);
-                    System.out.println("waking up...");                    
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
- */
-                // --- End of temporary code ---
-                
+                query.setType(DBMapping.AUTHORRECORD);
                 // Fill query with information about the author
-                q.addData("id", "gen_id(GEN_TAUTHORS, 1)");
-                q.addData("firstname", firstName);
-                q.addData("surname", surname);        
-                q.addData("organization", organization);                
-                q.addData("role", role);
-                q.addData("address", address);        
-                q.addData("phonenumber", phoneNumber);                
-                q.addData("email", email);                
-                q.addData("url", url);                        
-                q.addData("note", note);                        
-                QueryResult QRes = null;
+                query.addData("id", "gen_id(GEN_TAUTHORS, 1)");
+                query.addData("firstname", firstName);
+                query.addData("surname", surname);        
+                query.addData("organization", organization);                
+                query.addData("role", role);
+                query.addData("address", address);        
+                query.addData("phonenumber", phoneNumber);                
+                query.addData("email", email);                
+                query.addData("url", url);                        
+                query.addData("note", note);                        
+                Result QRes = null;
                 // Execute query
                 try {
-                    QRes = database.executeQuery(q);        
+                    // Execute query
+                    QRes = database.executeQuery(query);        
                 } catch (DBLayerException e) {
-                    // TODO: update
-                    System.out.println("ERROR: "+e);            
+                    // Log and set an error
+                    logger.error("Saving author failed. Unable to execute insert query");
+                    setError(e);
+                    // Set operation state to finished
                     done = true;
-                    return 0;
+                    return null;
                 }         
-                // TODO: update
-                if (QRes != null) {
-                    System.out.println("Success: "+QRes.getNumRows());
+                logger.info("Author "+firstName+" "+surname+" saved successfuly.");
+                if (isResultAvailable()) {                
+                    searchAuthor();
                 }
                 done = true;
-                return 1;
+                return QRes;
             }
         };
         worker.start();
     }    
     
+    /**
+     *  Delete an author from the database. To-be-deleted author is identified by his ID and is
+     *  retrieved based on the value of <code>authorIndex</code> field. Error is set in case of an exception.
+     */
     public void deleteAuthor() {
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
-                // perform delete
+                // Operation not finished yet
                 done = false;
-                // Create new Insert query
+                // Create new Delete query
                 DeleteQuery query = new DeleteQuery();
                 // Set type of data we want to delete
-                try {
-                    query.setType("AUTHOR");
-                } catch (DBLayerException e) {
-                    // TODO: update
-                    System.out.println("ERROR: "+e);
-                    done = true;
-                    return null;
-                }
+                query.setType(DBMapping.AUTHORRECORD);
+                // Set criteria - which authors to delete
                 query.addWhere("id", "=", ((AuthorRecord)data.get(getAuthorIndex())).getID()+"");
-                QueryResult qRes = null;
+                Result qRes = null;
                 try {
-                    qRes = database.executeQuery(query);        
+                    // Execute query
+                    qRes = database.executeQuery(query);                            
                 } catch (DBLayerException e) {
-                    logger.error("Deleting author failed");
-                    setError("Deleting author failed. Please contact your administrator.");
-                } finally {
+                    // Log and set an error
+                    logger.error("Deleting author failed. Unable to execute delete query.");
+                    setError(e);
+                    // Set operation state to finished                    
                     done = true;       
-                    return qRes;                    
-                }      
+                    return qRes;                                        
+                }
+                // Execute author search - required in order to display up-to-date data in the table of authors
+                searchAuthor();                
+                // Set operation state to finished
+                done = true;       
+                return qRes;                    
             }        
         };
         worker.start();            
@@ -154,47 +186,62 @@
     
     /**
      *  Search for authors in the database. Criteria for search are stored in data fields of this class.
-     *  Operation is executed in a separate thread using <code>SwingWorker</code>
+     *  Operation is executed in a separate thread using <code>SwingWorker</code>. Error is set in case of an exception
      */
     public void searchAuthor() {
         final SwingWorker worker = new SwingWorker() {
             public Object construct() {
+                // Operation not finished yet
                 done = false;                
                 // Create new Select query
-                SelectQuery query = new SelectQuery();
-                try {
-                    query.setType("AUTHOR");
-                } catch (DBLayerException e) {
-                    System.out.println("ERROR: "+e);
-                    done = true;
-                    return null;
+                Query query = new SelectQuery();
+                query.setType(DBMapping.AUTHORRECORD);
+                // Set search criteria
+                if (searchName != null)
+                    query.addWhere("firstname", "LIKE", "%"+searchName+"%");
+                if (searchOrganization != null) 
+                    query.addWhere("organization", "LIKE", "%"+searchOrganization+"%");
+                if (searchRole != null)
+                    query.addWhere("role", "LIKE", "%"+searchRole+"%");
+                if (searchEmail != null) 
+                    query.addWhere("email", "LKE", "%"+searchEmail+"%");
+                
+                String field;
+                switch (sortField) {
+                    case 1: field = "firstname";
+                            break;
+                    case 2: field = "organization";
+                            break;
+                    case 3: field = "role";
+                            break;
+                    case 4: field = "email";
+                            break;
+                    case 5: field = "phone";
+                            break;                            
+                    case 6: field = "url";
+                            break;          
+                    default:field = "firstname";
                 }
-/*                                
-                try {
-                    System.out.println("going to sleep...");
-                    Thread.sleep(5000);
-                    System.out.println("waking up...");                    
-                } catch (Exception e) {
-                    e.printStackTrace();
-                }
- */
-                if (firstName != null)
-                    query.addWhere("firstname", "LIKE", "%"+firstName+"%");
-                if (organization != null) 
-                    query.addWhere("organization", "LIKE", "%"+organization+"%");
-                if (role != null)
-                    query.addWhere("role", "LIKE", "%"+role+"%");
-                if (email != null) 
-                    query.addWhere("email", "LIKE", "%"+email+"%");
                 
-                QueryResult qRes = null;
+                if (sortDirection == 0) {
+                    query.addOrderby(field, "ASC");                
+                } else {
+                    query.addOrderby(field, "DESC");                                    
+                }                                                                        
+                
+                Result qRes = null;
                 try {
+                    // Execute query
                     qRes = database.executeQuery(query);        
                 } catch (DBLayerException e) {
-                    logger.error("Searching authors failed");
-                    setError("Searching authors failed. Please contact your administrator.");
+                    // Log and set an error                   
+                    logger.error("Searching authors failed. Unable to execute search query.");
+                    setError(e);
+                    // setError("Searching authors failed. Please contact your administrator.");
                 } finally {
+                    // Set operation state to finished
                     done = true;                    
+                    // Save the results
                     setResult(qRes);
                     return qRes;                    
                 }      
@@ -203,107 +250,185 @@
         worker.start();
     }
 
+    /**
+     *  Checks whether an error is set. If yes, notifies observers to display it. Finally unsets the error flag.
+     *  @return <code>true</code> if an error was set (and observers were notified), <code>false</code> otherwise
+     */
     public boolean processErrors() {
-        if (this.errorMsg != null) {
-            logger.debug("Notifying observers about an error");
+        if (this.error != null) {
             setChanged();
             notifyObservers();        
-            this.errorMsg = null;
+            this.error = null;
             return true;
         }
         return false;
     }
 
+    /**
+     *  Process results of a search query. Retrieves results using the database management object (DBLayer) and stores them in the data field
+     *  of the class. Notifies observers about the changes. Sets an error in case of an exception.
+     *
+     *  @param from number of the first row to retrieve.
+     *  @param count number of rows to retrieve 
+     */
     public void processResults(int from, int count) {
         if (this.queryResult != null) {
             logger.debug("Rows in the result: "+this.queryResult.getNumRows());
             logger.debug("Max available rows: "+(from+count-1));
+            // Find out how many rows we can retrieve - it cannot be more than number of rows in the result
             int to = Math.min(this.queryResult.getNumRows(), from+count-1);
-            logger.debug("Retrieving query results: "+from+" - "+to);
-            try {
-                Object[] objArray = database.more(this.queryResult, from-1, to-1);                
-                logger.debug("Results retrieved. Count: "+objArray.length);
-                this.data = new ArrayList(objArray.length);
-                for (int i=0;i<objArray.length;i++) {
-                    this.data.add((AuthorRecord)objArray[i]);
+            if (to == 0) {
+                this.data = new ArrayList();                
+            } else {
+                logger.debug("Retrieving query results: "+from+" - "+to);
+                try {
+                    // Retrieve selected row interval
+                    Object[] objArray = database.more(this.queryResult, from, to);                
+                    logger.debug("Results retrieved. Count: "+objArray.length);
+                    // Create storage for the results
+                    this.data = new ArrayList(objArray.length);
+                    // Cast the results to the AuthorRecord objects
+                    for (int i=0;i<objArray.length;i++) {
+                        this.data.add((AuthorRecord)objArray[i]);
+                    }
+                } catch (DBLayerException e) {
+                    // Log and set error in case of an exception
+                    logger.error("Processing search results failed: "+e.toString());
+                    setError(e);
                 }
-            } catch (DBLayerException e) {
-                logger.error("Processing search results failed: "+e.toString());
-                this.setError("Searching authors failed. Please contact your administrator.");
+                // Update current first displayed row (only if data retrieval was successful). 
+                if (!this.isError()) {
+                    // Update current first displayed row
+                    setCurrentFirstRow(from);            
+                }
             }
-            // Update current first displayed row (only if data retrieval was successful)
-            if (!this.isError()) {
-                // Update current first displayed row
-                setCurrentFirstRow(from);            
-            }
             // Tell observers to update
             setChanged();
             notifyObservers();
             // Clean error flag (if it was set)
-            this.errorMsg = null;
+            this.error = null;
         }
     }
     
-    public void setResult(QueryResult qRes) {
+    /**
+     *  Load fields with information about selected author (specified by the value of <code>authorIndex</code> field).
+     *  Notify observers about this change. This is used to load a form when editing authors.
+     */
+    public void loadAuthor() {
+        AuthorRecord selectedAuth = (AuthorRecord)data.get(this.getAuthorIndex());
+        this.setFirstName(selectedAuth.getFirstName());
+        this.setSurname(selectedAuth.getSurname());
+        this.setOrganization(selectedAuth.getOrganization());
+        this.setRole(selectedAuth.getRole());
+        this.setAddress(selectedAuth.getAddress());
+        this.setEmail(selectedAuth.getEmail());
+        this.setPhoneNumber(selectedAuth.getPhoneNumber());
+        this.setUrl(selectedAuth.getUrl());
+        this.setNote(selectedAuth.getNote());
+        setChanged();
+        notifyObservers();        
+    }
+    
+    /**
+     *  Set result of a database operation. This is used only for search operations.
+     *  @param qRes <code>QueryResult</code> object with the details about the result of a database operation
+     */
+    public void setResult(Result qRes) {
         this.queryResult = qRes;
     }
     
-    public QueryResult getResult() {
+    /**
+     *  Get results of last database operation. This is used only for search operations.
+     *  @return <code>QueryResult</code> object with the details about the result of last database operation
+     */
+    public Result getResult() {
         return this.queryResult;
     }
-    
-    public void setError(String msg) {
-        this.errorMsg = msg;
+        
+    /**
+     *  Set an error flag (message).
+     *  @param msg  message explaining the error which occured
+     */
+    public void setError(DBLayerException e) {
+        this.error = e;
     }
     
+    /**
+     *  Checks whether an error flag is set.
+     *  return true if an error occured and error message is available, false otherwise
+     */
     public boolean isError() {
-        if (this.errorMsg != null) {
+        if (this.error != null) {
             return true;
         } else {
             return false;
         }
     }
     
-    public String getErrorMessage() {
-        return this.errorMsg;
+    /**
+     *  Get error message for the error which occured
+     *  @return message explaining the error which occured
+     */
+    public DBLayerException getError() {
+        return this.error;
     }
-        
+    
+    /**
+     *  Get data returned by the last search query. Returns only currently displayed data.
+     *  @return data returned by the last search query
+     */
     public ArrayList getData() {
         return this.data;
     }
     
+    /**
+     *  Get index of currently selected author. The index is used to locate author record in the data field.
+     *  @return index of currently selected author
+     */
     protected int getAuthorIndex() {
         return this.authorIndex;
     }
     
+    /**
+     *  Set index of currently selected author. The index is used to locate author record in the data field.
+     *  @param index index of currently selected author
+     */    
     protected void setAuthorIndex(int index) {
         this.authorIndex = index;
     }
     
+    /**
+     *  Get number of rows to be displayed on one page.
+     *  @return number of rows to be displayed per page
+     */
     public int getDisplayRows() {
         return this.displayRows;
     }
     
+    /**
+     *  Set number of rows to be displayed on one page
+     *  @param rows number of rows ro be displayed per page
+     */
     public void setDisplayRows(int rows) {
         this.displayRows = rows;
     }
     
+    /**
+     *  Get index of the first row currently displayed in the list of authors. This is an index in the results returned by a search query.
+     *  @return index of the first row currently displayed in the list of authors
+     */
     public int getCurrentFirstRow() {
         return this.currentFirstRow;
     }
     
+    /**
+     *  Set index of the forst row currently displayed in the list of authors. This is an index in the results returned by a search query.
+     *  @param row index of the first row currently displayed in the list of authors
+     */
     public void setCurrentFirstRow(int row) {
         this.currentFirstRow = row;
     }
-    
-    public void removeAuthorRecord() {
-        // Remove record from the search results
-        this.data.remove(this.getAuthorIndex());
-        // Force observers to reflect the data changes
-        setChanged();
-        notifyObservers();        
-    }    
-    
+      
     /**
      *  Indicates whether a long running operation executed in a separate thread has already finished.
      *  @return true if the operation is finished (no operation running), false otherwise
@@ -311,8 +436,67 @@
     public boolean isOperationDone() {
         return this.done;
     }
-        
+            
     /**
+     *  Indicate whether result of a search query is available at the momoent
+     *  @return true if search query result is available
+     */
+    public boolean isResultAvailable() {
+        if (this.queryResult != null) {
+            return true;
+        }
+        return false;
+    }
+    
+    /**
+     *  Set field used for sorting results of the search query.
+     *  @param field numeric identificator of the field used for sorting
+     */
+    public void setSortField(int field) {
+        this.sortField = field;
+    }
+
+    /**
+     *  Set direction of sorting.
+     *  @param direction direction of sorting. 0 for ascending, 1 for descending
+     */
+    public void setSortDirection(int direction) {
+        this.sortDirection = direction;
+    }
+
+    /**
+     *  Set name search field.
+     *  @param name name of author to search for
+     */    
+    public void setSearchName(String name) {
+        this.searchName = name;
+    }
+    
+    /**
+     *  Set organization search field.
+     *  @param organization organization of author used for searching
+     */    
+    public void setSearchOrganization(String organization) {
+        this.searchOrganization = organization;
+    }
+    
+    /**
+     *  Set role search field.
+     *  @param role role of author used for searching
+     */    
+    public void setSearchRole(String role) {
+        this.searchRole = role;
+    }
+    
+    /**
+     *  Set email search field.
+     *  @param email email of author used for searching
+     */    
+    public void setSearchEmail(String email) {
+        this.searchEmail = email;
+    }
+    
+    /**
      *  Get first name of the author.
      *  @return string with the first name of the author
      */
@@ -328,66 +512,130 @@
         this.firstName = firstName;
     }
 
+    /**
+     *  Get surname of the author.
+     *  @return string with the surname of the author
+     */
     public String getSurname() {
         return surname;
     }
 
+    /**
+     *  Set surname of the author.
+     *  @param surname surname of the author
+     */
     public void setSurname(String surname) {
         this.surname = surname;
     }
 
+    /**
+     *  Get organization of the author.
+     *  @return string with the organization of the author
+     */
     public String getOrganization() {
         return organization;
     }
 
+    /**
+     *  Set organization of the author.
+     *  @param organization organization of the author
+     */
     public void setOrganization(String organization) {
         this.organization = organization;
     }
 
+    /**
+     *  Get role of the author.
+     *  @return string with the role of the author
+     */
     public String getRole() {
         return role;
     }
 
+    /**
+     *  Set role of the author.
+     *  @param role role of the author
+     */
     public void setRole(String role) {
         this.role = role;
     }
 
+    /**
+     *  Get address of the author.
+     *  @return string with the address of the author
+     */
     public String getAddress() {
         return address;
     }
 
+    /**
+     *  Set address of the author.
+     *  @param address address of the author
+     */
     public void setAddress(String address) {
         this.address = address;
     }
 
+    /**
+     *  Get phone number of the author.
+     *  @return string with the phone number of the author
+     */
     public String getPhoneNumber() {
         return phoneNumber;
     }
 
+    /**
+     *  Set phone number of the author.
+     *  @param phoneNumber phone number of the author
+     */
     public void setPhoneNumber(String phoneNumber) {
         this.phoneNumber = phoneNumber;
     }
 
+    /**
+     *  Get email of the author.
+     *  @return string with the email of the author
+     */
     public String getEmail() {
         return email;
     }
 
+    /**
+     *  Set email of the author.
+     *  @param email email of the author
+     */
     public void setEmail(String email) {
         this.email = email;
     }
 
+    /**
+     *  Get URL of the author.
+     *  @return string with the URL of the author
+     */
     public String getUrl() {
         return url;
     }
 
+    /**
+     *  Set URL of the author.
+     *  @param url URL of the author
+     */
     public void setUrl(String url) {
         this.url = url;
     }
 
+    /**
+     *  Get note of the author.
+     *  @return string with the note of the author
+     */
     public String getNote() {
         return note;
     }
 
+    /**
+     *  Set note of the author.
+     *  @param note note of the author
+     */
     public void setNote(String note) {
         this.note = note;
     }    

Modified: trunk/src/net/sf/plantlore/client/authors/AuthorManagerCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AuthorManagerCtrl.java	2006-02-18 19:50:17 UTC (rev 32)
+++ trunk/src/net/sf/plantlore/client/authors/AuthorManagerCtrl.java	2006-02-18 19:53:26 UTC (rev 33)
@@ -9,6 +9,8 @@
 
 import java.awt.event.ActionEvent;
 import java.awt.event.ActionListener;
+import java.awt.event.FocusEvent;
+import java.awt.event.FocusListener;
 import java.beans.PropertyChangeEvent;
 import java.beans.PropertyChangeListener;
 import net.sf.plantlore.common.*;
@@ -47,6 +49,7 @@
         view.addBtnAddActionListener(new AddAuthorButtonListener());
         view.searchBtnAddActionlistener(new SearchAuthorButtonListener());
         view.deleteBtnAddActionListener(new DeleteAuthorButtonListener());
+        view.editBtnAddActionListener(new EditAuthorButtonListener());
         view.previousBtnAddActionListener(new PreviousButtonListener());
         view.nextBtnAddActionListener(new NextButtonListener());        
         // Add PropertyChange listeners to fields in search box
@@ -56,6 +59,8 @@
         view.emailAddPropertyChangeListener(new EmailFieldPropertyChangeListener());                
         // Add PropertyChange listener for the field with number of records to show
         view.rowsAddPropertyChangeListener(new RowsPropertyChangeListener());
+        view.sortAddFocusListener(new SortComboFocusListener());
+        view.sortDirectionAddFocusListener(new SortDirectionRadioFocusListener());
         // Create a timer for search operation
         timerSearch = new Timer(TIMER_FREQUENCY, new ActionListener() {
             public void actionPerformed(ActionEvent evt) {
@@ -66,9 +71,12 @@
                     view.setDialogEnabled(true);    // Enable view dialog                
                     // Check for errors which might have occured. If none occured, tell model to process the result
                     if (model.processErrors() == false) {
-                        // Display first n rows (n = model.getDisplayRows())
-                        model.processResults(1, model.getDisplayRows());
-                        model.setCurrentFirstRow(1);
+                        if (model.getResult().getNumRows() == 0) {
+                            view.showSearchInfoMessage();
+                        }
+                        model.setCurrentFirstRow(1);                                                    
+                        // Display first n rows (n = model.getDisplayRows())                        
+                        model.processResults(1, model.getDisplayRows());                        
                     }
                 }
             }
@@ -83,8 +91,19 @@
                     view.setDialogEnabled(true);    // Enable view dialog                
                     // Check for errors which might have occured. If none occured, tell model to process the result
                     if (model.processErrors() == false) {
-                        // Update table with authors - remove deleted author
-                        model.removeAuthorRecord();
+                        // Update curent first row so that it is not greater than number of rows in the result
+                        // (this happens in case the last record in the list has been deleted and it was set as 
+                        // the current first row)
+                        if (model.getCurrentFirstRow() > model.getResult().getNumRows()) {                           
+                            int row = model.getCurrentFirstRow()-model.getDisplayRows();
+                            if (row < 1) {
+                                model.setCurrentFirstRow(1);                                
+                            } else {
+                                model.setCurrentFirstRow(row);                                                                
+                            }
+                        }
+                        // Update table with authors - remove deleted author                        
+                        model.processResults(model.getCurrentFirstRow(), model.getDisplayRows());
                     }
                 }
             }
@@ -107,7 +126,7 @@
     class HelpButtonListener implements ActionListener {
         public void actionPerformed(ActionEvent e) {
             // Display help viewer            
-            PlantloreHelp.showHelp("Main.AuthorManager");            
+            PlantloreHelp.showHelp(PlantloreHelp.AUTHOR_MANAGER_ADD);            
         }
     }
     
@@ -129,7 +148,16 @@
      */    
     class EditAuthorButtonListener implements ActionListener {
         public void actionPerformed(ActionEvent e) {
-            // Not implmeneted yet
+            int index = view.getSelectedAuthor();
+            if (index == -1) {
+                view.selectRowMsg();
+                return;
+            }             
+            AddAuthorView addAuthView = new AddAuthorView(model, view.getFrame());
+            AddAuthorCtrl addAuthCtrl = new AddAuthorCtrl(model, addAuthView);            
+            model.setAuthorIndex(index);
+            model.loadAuthor();
+            addAuthView.show();
         }
     }
     
@@ -183,7 +211,7 @@
             }
         }
     }        
-    
+            
     class PreviousButtonListener implements ActionListener {    
         public void actionPerformed(ActionEvent e) {
             // Call processResults only if we don't see the first page (should not happen, button should be disabled)
@@ -196,20 +224,52 @@
     
     class NextButtonListener implements ActionListener {    
         public void actionPerformed(ActionEvent e) {
-            // Call processResults only if we don't see the last page (should not happen, button should be desabled)
-            if (model.getCurrentFirstRow()+view.getDisplayRows()<model.getResult().getNumRows()) {
+            // Call processResults only if we don't see the last page (should not happen, button should be disabled)
+            logger.debug("current first row: "+model.getCurrentFirstRow());
+            logger.debug("num rows in the result: "+model.getResult().getNumRows());            
+            logger.debug("display rows: "+view.getDisplayRows());
+            if (model.getCurrentFirstRow()+view.getDisplayRows()<=model.getResult().getNumRows()) {
                 model.processResults(model.getCurrentFirstRow()+view.getDisplayRows(), view.getDisplayRows());                                
             }
         }
     }    
     
     /**
+     *  Focus listener for the <strong>sort combobox</strong> at the search panel. After losing focus automaticaly 
+     *  stores value of the field to model.
+     */
+    class SortComboFocusListener implements FocusListener {
+        public void focusLost(FocusEvent e) {
+            model.setSortField(view.getSortField());
+        }        
+
+        public void focusGained(FocusEvent e) {
+            // Empty
+        }
+    }    
+    
+    /**
+     *  Focus listener for the <strong>sort combobox</strong> at the search panel. After losing focus automaticaly 
+     *  stores value of the field to model.
+     */
+    class SortDirectionRadioFocusListener implements FocusListener {
+        public void focusLost(FocusEvent e) {
+            model.setSortDirection(view.getSortDirection());
+        }        
+
+        public void focusGained(FocusEvent e) {
+            // Empty
+        }
+    }                
+    
+    /**
      *  PropertyChange listener for the <strong>name field</strong> at the search panel. After losing focus automaticaly 
      *  stores value of the field to model object.
      */
     class NameFieldPropertyChangeListener implements PropertyChangeListener {
         public void propertyChange(PropertyChangeEvent e) {
-            model.setFirstName(view.getName());
+            model.setSearchName(view.getName());
+            System.out.println("Name set: "+view.getName());
         }        
     }
 
@@ -219,7 +279,7 @@
      */    
     class OrganizationFieldPropertyChangeListener implements PropertyChangeListener {
         public void propertyChange(PropertyChangeEvent e) {
-            model.setOrganization(view.getOrganization());
+            model.setSearchOrganization(view.getOrganization());
         }        
     }    
 
@@ -229,7 +289,7 @@
      */    
     class RoleFieldPropertyChangeListener implements PropertyChangeListener {
         public void propertyChange(PropertyChangeEvent e) {
-            model.setRole(view.getRole());
+            model.setSearchRole(view.getRole());
         }        
     }    
 
@@ -239,7 +299,7 @@
      */        
     class EmailFieldPropertyChangeListener implements PropertyChangeListener {
         public void propertyChange(PropertyChangeEvent e) {
-            model.setEmail(view.getEmail());
+            model.setSearchEmail(view.getEmail());
         }        
     }        
     
@@ -258,9 +318,11 @@
             }
             // Set new value in the model
             model.setDisplayRows(view.getDisplayRows());
+            logger.debug("New display rows: "+view.getDisplayRows());
             // If neccessary reload search results
             if ((oldValue != view.getDisplayRows()) && (model.getDisplayRows() <= model.getResult().getNumRows())) {
                 model.processResults(model.getCurrentFirstRow(), view.getDisplayRows());
+                logger.debug("Search results reloaded. First row: "+model.getCurrentFirstRow()+"; Display rows: "+view.getDisplayRows());
             }
         }        
     }            

Modified: trunk/src/net/sf/plantlore/client/authors/AuthorManagerView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AuthorManagerView.java	2006-02-18 19:50:17 UTC (rev 32)
+++ trunk/src/net/sf/plantlore/client/authors/AuthorManagerView.java	2006-02-18 19:53:26 UTC (rev 33)
@@ -1,5 +1,5 @@
-/*
- * AuthorManagerView.java
+
+/* AuthorManagerView.java
  *
  * Created on 15. leden 2006, 2:04
  *
@@ -8,6 +8,7 @@
 package net.sf.plantlore.client.authors;
 
 import java.awt.Container;
+import java.awt.Dimension;
 import java.awt.GridBagLayout;
 import java.util.Observer;
 import java.util.Observable; 
@@ -16,16 +17,21 @@
 import javax.swing.JPanel;
 import java.awt.GridBagConstraints;
 import java.awt.event.ActionListener;
+import java.awt.event.FocusListener;
 import java.beans.PropertyChangeListener;
 import java.util.ArrayList;
+import javax.swing.ButtonGroup;
+import javax.swing.DefaultComboBoxModel;
 import javax.swing.JButton;
+import javax.swing.JComboBox;
 import javax.swing.JFormattedTextField;
 import javax.swing.JLabel;
 import javax.swing.JOptionPane;
+import javax.swing.JRadioButton;
 import javax.swing.JScrollPane;
 import javax.swing.JTable;
 import javax.swing.table.DefaultTableModel;
-import net.sf.plantlore.client.dblayer.AuthorRecord;
+import net.sf.plantlore.common.record.AuthorRecord;
 
 /**
  *
@@ -49,6 +55,7 @@
         // Create new modal dialog
         authDialog = new JDialog(owner, "Author Manager", true);
         authDialog.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);
+        authDialog.setLocationRelativeTo(null);
         authDialog.setSize(320,240);
 
         container = authDialog.getContentPane();
@@ -61,16 +68,19 @@
                 
         listPanel = new JPanel();
         searchPanel = new JPanel();
+        sortPanel = new JPanel();
         closeBtn = new JButton();
         helpBtn = new JButton();
         nameLabel = new JLabel();
         organizationLabel = new JLabel();
         roleLabel = new JLabel();
         emailLabel = new JLabel();
+        sortLabel = new JLabel();
         nameField = new JFormattedTextField();
         organizationField = new JFormattedTextField();
         roleField = new JFormattedTextField();
         emailField = new JFormattedTextField();
+        sortCombo = new JComboBox();
         listTable = new JTable();
         listScrollPane = new JScrollPane();
         addBtn = new JButton();
@@ -81,9 +91,21 @@
         searchBtn = new JButton();
         totalRowsDescLabel = new JLabel();
         totalRowsLabel = new JLabel();
+        currentRowsLabel = new JLabel();
+        displayedLabel = new JLabel();
         displayRowsLabel = new JLabel();
         rowsField = new JFormattedTextField();        
-                        
+        ascRadio = new JRadioButton();
+        descRadio = new JRadioButton();
+        sortButtonGroup = new ButtonGroup();
+        
+        String[] sortFields = {"Name", "Organization", "Role", "Email", "Phone number", "URL"};
+        sortCombo.setModel(new DefaultComboBoxModel(sortFields));
+        
+        sortButtonGroup.add(ascRadio);
+        sortButtonGroup.add(descRadio);
+        sortButtonGroup.setSelected(ascRadio.getModel(), true);
+        
         listPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(" List of authors "));
         listPanel.setLayout(new java.awt.GridBagLayout());        
         
@@ -111,6 +133,20 @@
         gridBagConstraints.fill = GridBagConstraints.HORIZONTAL;
         container.add(searchPanel, gridBagConstraints);        
         
+        sortPanel.setBorder(javax.swing.BorderFactory.createTitledBorder(" Sorting "));
+        sortPanel.setLayout(new java.awt.GridBagLayout());        
+        
+        // Add panel with sorting criteria
+        gridBagConstraints = new GridBagConstraints();
+        gridBagConstraints.gridx = 4;
+        gridBagConstraints.gridy = 0;
+        gridBagConstraints.gridheight = 3;
+        gridBagConstraints.insets = new java.awt.Insets(-5, 5, 5, 5);                
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;        
+        gridBagConstraints.fill = GridBagConstraints.BOTH;   
+        searchPanel.add(sortPanel, gridBagConstraints);
+        
+        
         // Add close button
         closeBtn.setText("Close");
         gridBagConstraints = new java.awt.GridBagConstraints();
@@ -152,7 +188,7 @@
         gridBagConstraints.gridy = 0;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
         gridBagConstraints.insets = new java.awt.Insets(0, 10, 7, 5);
-        searchPanel.add(roleLabel, gridBagConstraints);
+        searchPanel.add(roleLabel, gridBagConstraints);        
 
         emailLabel.setText("Email:");
         gridBagConstraints = new java.awt.GridBagConstraints();
@@ -161,6 +197,14 @@
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
         gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 5);
         searchPanel.add(emailLabel, gridBagConstraints);        
+                
+        sortLabel.setText("Sort by:");
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 0;
+        gridBagConstraints.gridy = 0;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
+        gridBagConstraints.insets = new java.awt.Insets(5, 5, 0, 5);
+        sortPanel.add(sortLabel, gridBagConstraints);                
         
         // Add fields to the search panel        
         gridBagConstraints = new java.awt.GridBagConstraints();
@@ -168,7 +212,7 @@
         gridBagConstraints.gridy = 0;
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
-        gridBagConstraints.weightx = 0.5;
+        gridBagConstraints.weightx = 0.7;
         gridBagConstraints.insets = new java.awt.Insets(0, 0, 10, 0);
         nameField.setValue("");
         searchPanel.add(nameField, gridBagConstraints);
@@ -178,6 +222,7 @@
         gridBagConstraints.gridy = 1;
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gridBagConstraints.weightx = 0.7;        
         organizationField.setValue("");        
         searchPanel.add(organizationField, gridBagConstraints);
 
@@ -187,6 +232,7 @@
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
         gridBagConstraints.insets = new java.awt.Insets(0, 0, 10, 5);
+        gridBagConstraints.weightx = 0.3;        
         roleField.setValue("");        
         searchPanel.add(roleField, gridBagConstraints);
 
@@ -195,18 +241,44 @@
         gridBagConstraints.gridy = 1;
         gridBagConstraints.fill = java.awt.GridBagConstraints.HORIZONTAL;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
-        gridBagConstraints.weightx = 0.5;
+        gridBagConstraints.weightx = 0.3;
         gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
         emailField.setValue("");        
         searchPanel.add(emailField, gridBagConstraints);
+
+        // Add ComboBox with the list of fields for sorting
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 1;
+        gridBagConstraints.gridy = 0;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
+        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 5);
+        sortCombo.setPreferredSize(new Dimension(150,20));
+        sortPanel.add(sortCombo, gridBagConstraints);        
         
+        // Add RadioButtons for ascending / descending sort
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 1;
+        gridBagConstraints.gridy = 1;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
+        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 0);
+        ascRadio.setText("Ascending");
+        sortPanel.add(ascRadio, gridBagConstraints);        
+
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 1;
+        gridBagConstraints.gridy = 2;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.NORTHWEST;
+        gridBagConstraints.insets = new java.awt.Insets(0, 0, 0, 0);
+        descRadio.setText("Descending");
+        sortPanel.add(descRadio, gridBagConstraints);        
+       
         // Add search button to the search panel
         searchBtn.setText("Search Authors");
         gridBagConstraints = new java.awt.GridBagConstraints();
         gridBagConstraints.gridx = 3;
         gridBagConstraints.gridy = 2;
         gridBagConstraints.anchor = java.awt.GridBagConstraints.SOUTHEAST;
-        gridBagConstraints.insets = new java.awt.Insets(10, 5, 10, 5);
+        gridBagConstraints.insets = new java.awt.Insets(5, 5, 10, 5);
         searchPanel.add(searchBtn, gridBagConstraints);        
         
         // Add ScrollPane for the listTable        
@@ -223,14 +295,6 @@
         listScrollPane.setPreferredSize(new java.awt.Dimension(500, 100));                        
         listPanel.add(listScrollPane, gridBagConstraints);                        
         
-        // Add table to listScrollPane
-/*        listTable.setModel(new DefaultTableModel(
-            new Object [][] { },
-            new String [] {
-                "Name", "Organization", "Role", "Phone number", "Email", "URL"
-            }
-        ));        
- */
         listScrollPane.add(listTable);                
         listScrollPane.setViewportView(listTable);        
         
@@ -313,6 +377,23 @@
         gridBagConstraints.insets = new java.awt.Insets(0, 150, 0, 5);
         listPanel.add(totalRowsLabel, gridBagConstraints);                        
         
+        // Add labels showing number of rows in the result
+        currentRowsLabel.setText("Currently displayed:");
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 3;
+        gridBagConstraints.gridy = 1;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gridBagConstraints.insets = new java.awt.Insets(0, 10, 0, 5);
+        listPanel.add(currentRowsLabel, gridBagConstraints);                
+
+        displayedLabel.setText("---");
+        gridBagConstraints = new java.awt.GridBagConstraints();
+        gridBagConstraints.gridx = 3;
+        gridBagConstraints.gridy = 1;
+        gridBagConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gridBagConstraints.insets = new java.awt.Insets(0, 135, 0, 5);
+        listPanel.add(displayedLabel, gridBagConstraints);                        
+        
         // Add label and text field with the number of rows to display
         displayRowsLabel.setText("Rows to display:");
         gridBagConstraints = new java.awt.GridBagConstraints();
@@ -330,7 +411,7 @@
         rowsField.setMinimumSize(new java.awt.Dimension(50, 20));        
         rowsField.setPreferredSize(new java.awt.Dimension(50, 20));                
         rowsField.setValue(model.getDisplayRows());
-        listPanel.add(rowsField, gridBagConstraints);                
+        listPanel.add(rowsField, gridBagConstraints);                         
         
         authDialog.pack();
     }
@@ -370,7 +451,7 @@
     public void update(Observable obs, Object obj) {       
         // Check whether we have some kind of error to display
         if (model.isError()) {
-            showErrorMessage(model.getErrorMessage());
+//            showErrorMessage(model.getErrorMessage());            
             return;
         } else {
             displayResults(model.getData());
@@ -397,12 +478,14 @@
         } else {
             previousBtn.setEnabled(false);
         }
-        // set the status of the "Next" button        
+        // Set the status of the "Next" button        
         if (model.getResult().getNumRows() >= (model.getDisplayRows()+model.getCurrentFirstRow())) {
             nextBtn.setEnabled(true);
         } else {
             nextBtn.setEnabled(false);            
         }
+        int to = Math.min(model.getCurrentFirstRow()+model.getDisplayRows()-1, model.getResult().getNumRows());
+        displayedLabel.setText(model.getCurrentFirstRow()+" - "+to);
     }
     
     public void closeBtnAddActionListener(ActionListener al) {
@@ -439,7 +522,7 @@
     
     
     public void show() {
-        authDialog.setSize(750,600);
+        authDialog.setSize(800,600);
         authDialog.setLocationRelativeTo(null);
         authDialog.setVisible(true);
     }
@@ -453,7 +536,6 @@
     }
     
     public String getName() {
-        System.out.println("Name: "+nameField.getValue());
         return (String)nameField.getValue();
     }
 
@@ -477,6 +559,34 @@
         this.rowsField.setValue(value);
     }    
     
+    public int getSortField() {        
+        int field;
+        switch (this.sortCombo.getSelectedIndex()) {
+            case 0: field = AuthorManager.SORT_NAME;
+                    break;
+            case 1: field = AuthorManager.SORT_ORGANIZATION;
+                    break;
+            case 2: field = AuthorManager.SORT_ROLE;
+                    break;
+            case 3: field = AuthorManager.SORT_EMAIL;
+                    break;
+            case 4: field = AuthorManager.SORT_PHONE;
+                    break;
+            case 5: field = AuthorManager.SORT_URL;
+                    break;                    
+            default:field = AuthorManager.SORT_NAME;
+        }
+        return field;
+    }
+    
+    public int getSortDirection() {
+        if (this.sortButtonGroup.isSelected(this.ascRadio.getModel()) == true) {
+            return 0;
+        } else {
+            return 1;
+        }
+    }
+    
     void nameAddPropertyChangeListener(PropertyChangeListener pcl) {
         nameField.addPropertyChangeListener(pcl);
     }
@@ -497,6 +607,15 @@
         rowsField.addPropertyChangeListener(pcl);
     }        
 
+    void sortAddFocusListener(FocusListener fl) {
+        sortCombo.addFocusListener(fl);
+    }
+    
+    void sortDirectionAddFocusListener(FocusListener fl) {
+        ascRadio.addFocusListener(fl);
+        descRadio.addFocusListener(fl);
+    }
+    
     public boolean confirmDelete() {
         // JOptionPane results: 0 = Yes, 1 = No
         int res = JOptionPane.showConfirmDialog(this.authDialog, "Do you really want to delete selected author?", 
@@ -515,16 +634,23 @@
         JOptionPane.showMessageDialog(this.authDialog, "Please select at least one author from the list",
                                       "Select author", JOptionPane.WARNING_MESSAGE);        
     }
+
+    public void showSearchInfoMessage() {
+        JOptionPane.showMessageDialog(this.authDialog, "No authors with the given attributes were found. Please modify search criteria.",
+                                      "No search results", JOptionPane.INFORMATION_MESSAGE);                
+    }
     
     // Swing components on the form
     JPanel listPanel;
     JPanel searchPanel;
+    JPanel sortPanel;
     JButton closeBtn;
     JButton helpBtn;
     JLabel nameLabel;
     JLabel organizationLabel;
     JLabel roleLabel;
     JLabel emailLabel;
+    JLabel sortLabel;
     JFormattedTextField nameField;
     JFormattedTextField organizationField;    
     JFormattedTextField roleField;
@@ -539,6 +665,12 @@
     JLabel totalRowsDescLabel;
     JLabel totalRowsLabel;
     JLabel displayRowsLabel;
+    JLabel currentRowsLabel;
+    JLabel displayedLabel;
     JFormattedTextField rowsField;            
-    JScrollPane listScrollPane;
+    JScrollPane listScrollPane;    
+    JComboBox sortCombo;
+    JRadioButton ascRadio;
+    JRadioButton descRadio;
+    ButtonGroup sortButtonGroup;
 }



From kovo at berlios.de  Sat Feb 18 21:06:09 2006
From: kovo at berlios.de (kovo at berlios.de)
Date: Sat, 18 Feb 2006 21:06:09 +0100
Subject: [Plantlore-dev] r39 - trunk/src/net/sf/plantlore/client/dblayer
Message-ID: <200602182006.k1IK6938017948@sheep.berlios.de>

Author: kovo
Date: 2006-02-18 21:05:29 +0100 (Sat, 18 Feb 2006)
New Revision: 39

Removed:
   trunk/src/net/sf/plantlore/client/dblayer/AuthorRecord.java
   trunk/src/net/sf/plantlore/client/dblayer/DeleteQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/InsertQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/OccurenceRecord.java
   trunk/src/net/sf/plantlore/client/dblayer/PlantRecord.java
   trunk/src/net/sf/plantlore/client/dblayer/PublicationRecord.java
   trunk/src/net/sf/plantlore/client/dblayer/QueryResult.java
   trunk/src/net/sf/plantlore/client/dblayer/SelectQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/UpdateQuery.java
   trunk/src/net/sf/plantlore/client/dblayer/UserRecord.java
Log:
Holder objects moved to common package. *Query and QueryResult objects moved to subpackages.

Deleted: trunk/src/net/sf/plantlore/client/dblayer/AuthorRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/AuthorRecord.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/AuthorRecord.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,213 +0,0 @@
-/*
- * AuthorRecord.java
- *
- * Created on 16. leden 2006, 2:32
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-/**
- *  Data holder object containing information about an author
- *
- *  @author Tomas Kovarik
- *  @version 0.1, Jan 16, 2006
- */
-public class AuthorRecord {
-    /** Parameters of the author */
-    private int id;
-    private String firstName;
-    private String surname;
-    private String organization;
-    private String role;
-    private String address;
-    private String phoneNumber;
-    private String email;
-    private String url;
-    private String note;
-    
-    /** Creates a new instance of AuthorRecord */
-    public AuthorRecord() {
-        
-    }
-    
-    /**
-     *   Set unique id of the author
-     *   @param id unique id of the author
-     *   @see getID
-     */
-    public void setID(int id) {
-        this.id = id;
-    }
-    
-    /**
-     *   Get unique id of the author
-     *   @return int unique id of the user
-     *   @see setID
-     */
-    public int getID() {
-        return this.id;
-    }
-    
-    /**
-     *   Get first name of the author
-     *   @return string containing the first name of the author
-     *   @see setFirstName
-     */
-    public String getFirstName() {
-        return this.firstName;
-    }
-    
-    /**
-     *   Set first name of the author
-     *   @param firstName string containing the first name of the author
-     *   @see getFirstName
-     */
-    public void setFirstName(String firstName) {
-        this.firstName = firstName;
-    }
-    
-    /**
-     *   Get surname of the author
-     *   @return string containing surname of the author
-     *   @see setSurname
-     */
-    public String getSurname() {
-        return this.surname;
-    }
-    
-    /**
-     *   Set surname of the author
-     *   @param surname string containing surname of the author
-     *   @see getSurname
-     */
-    public void setSurname(String surname) {
-        this.surname = surname;
-    }
-    
-    /**
-     *   Set organization the author belongs to
-     *   @param organization string containing organization the author belongs to
-     *   @see getOrganization
-     */
-    public void setOrganization(String organization) {
-        this.organization = organization;
-    }
-    
-    /**
-     *   Get organization the author belongs to
-     *   @return string containing organization the author belongs to
-     *   @see setOrganization
-     */
-    public String getOrganization() {
-        return this.organization;
-    }
-    
-    /**
-     *   Set role of the author
-     *   @param role string containing role of the author
-     *   @see getRole
-     */
-    public void setRole(String role) {
-        this.role = role;
-    }
-    
-    /**
-     *   Get role of the author
-     *   @return string representation of author's role
-     *   @see setRole
-     */
-    public String getRole() {
-        return this.role;
-    }
-    
-    /**
-     *   Get address of the author
-     *   @return string containing address of the author
-     *   @see setAddress
-     */
-    public String getAddress() {
-        return this.address;
-    }
-    
-    /**
-     *   Set address of the author
-     *   @param address string containing address of the author
-     *   @see getAddress
-     */
-    public void setAddress(String address) {
-        this.address = address;
-    }
-    
-    /**
-     *   Get phone number of the author
-     *   @return string containing phone number of the author
-     *   @see setPhoneNumber
-     */
-    public String getPhoneNumber() {
-        return this.phoneNumber;
-    }
-    
-    /**
-     *   Set email of the author
-     *   @param phoneNumber string containing phone number of the author
-     *   @see getPhoneNumber
-     */
-    public void setPhoneNumber(String phoneNumber) {
-        this.phoneNumber = phoneNumber;
-    }
-    
-    /**
-     *   Get email of the author
-     *   @return string containing email of the author
-     *   @see setEmail
-     */
-    public String getEmail() {
-        return this.email;
-    }
-    
-    /**
-     *   Set email of the author
-     *   @param email string containing email of the author
-     *   @see getEmail
-     */
-    public void setEmail(String email) {
-        this.email = email;
-    }
-    
-    /**
-     *   Get URL of the author
-     *   @return URL of the author's webpage
-     *   @see setUrl
-     */
-    public String getUrl() {
-        return this.url;
-    }
-    
-    /**
-     *   Set URL of the author
-     *   @param url URL of the author's webpage
-     *   @see getUrl
-     */
-    public void setUrl(String url) {
-        this.url = url;
-    }
-    
-    /**
-     *   Get note about the author
-     *   @return string containing note about the author
-     *   @see setNote
-     */
-    public String getNote() {
-        return this.note;
-    }
-    
-    /**
-     *   Set note about the author
-     *   @param contact string containing note about the author
-     *   @see getNote
-     */
-    public void setNote(String note) {
-        this.note = note;
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/DeleteQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/DeleteQuery.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/DeleteQuery.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,128 +0,0 @@
-/*
- * DeleteQuery.java
- *
- * Created on 15. leden 2006, 13:56
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-import java.util.ArrayList;
-import org.apache.log4j.Logger;
-
-/**
- * Object holding parameters of delete query
- *
- * @author Tomas Kovarik
- * @version 0.1, Jan 15, 2006
- */
-public class DeleteQuery {
-    /** Type of data we are working with. For the list of types see DBmapping class */
-    private String type;
-    /** List of triples for the WHERE part of the query */
-    private ArrayList whereList;
-    /** Instance of DBMapping object */
-    private DBMapping dbmap;
-    /** Instance of a logger */
-    private Logger logger;
-    
-    /**
-     * Create a new instance of DeleteQuery. Initializes empty <code>whereList</code> array.
-     */
-    public DeleteQuery() {
-        whereList = new ArrayList();
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Create new instance of the DeleteQuery. Initializes <code>whereList</code> with the given values
-     *
-     *  @param type         type of data we are working with
-     *  @param whereList    List of triples for the WHERE clause
-     *  @throws DBLayetException in case the given type was not found in the DBMapping class
-     */
-    public DeleteQuery(String type, ArrayList where) throws DBLayerException {
-        this.whereList = where;
-        setType(type);
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Add an item (triplet) to the list of triples for the WHERE part of the query
-     *
-     *  @param field    name of the field (left operand)
-     *  @param operator operator connecting operands
-     *  @param value    value of the field (right operand)
-     */
-    public void addWhere(String field, String operator, String value) {
-        String[] triple = {new String(field), new String(operator), new String(value) };
-        whereList.add(triple);
-    }
-    
-    /**
-     *  Set the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @param type Type of data we are working with
-     *  @throws DBLayerException in case the given type was not found in the DBMapping class
-     */
-    public void setType(String type) throws DBLayerException {
-        if (dbmap.checkType(type)) {
-            this.type = type;
-        } else {
-            logger.error("Type '"+type+"' not found in DB mapping");
-            throw new DBLayerException("Type '"+type+"' not found in DB mapping");
-        }
-    }
-    
-    /**
-     *  Get the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @return Type of data we are working with
-     */
-    public String getType() {
-        return this.type;
-    }
-    
-    /**
-     *  Transform data in this object to the SQL query.
-     *
-     *  @return String with the SQL query constructed from the data stored in the object
-     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
-     */
-    public String toSQL() throws DBLayerException {
-        StringBuffer sql;
-        StringBuffer where;
-        String from;
-        String fieldName;
-        String[] triple;
-        
-        // Initialize StringBuffers
-        sql = new StringBuffer();
-        where = new StringBuffer();
-        // Get the name of the table from which we want to delete records
-        from = dbmap.getTableName(this.type);
-        // Construct the WHERE clasue
-        for (int i=0;i<whereList.size();i++) {
-            if (i>0) {
-                where.append(" AND ");
-            }
-            triple = (String[])whereList.get(i);
-            fieldName = dbmap.getFieldName(triple[0], this.type);
-            where.append(fieldName);
-            where.append(" ");
-            where.append(triple[1]);
-            where.append(" ");
-            where.append("'"+triple[2]+"'");
-        }
-        // Construct SQL query
-        sql.append("DELETE FROM ");
-        sql.append(from);
-        sql.append(" WHERE ");
-        sql.append(where);
-        
-        logger.debug(sql.toString());
-        return sql.toString();
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/InsertQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/InsertQuery.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/InsertQuery.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,135 +0,0 @@
-/*
- * InsertQuery.java
- *
- * Created on 15. leden 2006, 13:56
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-import java.util.ArrayList;
-import org.apache.log4j.Logger;
-
-/**
- * Object hodling parameters of an insert query
- *
- * @author Tomas Kovarik
- * @versionm 0.1, Jan 15, 2006
- */
-public class InsertQuery {
-    /** Type of data we are working with. For the list of types see DBmapping class */
-    private String type;
-    // Array of tuples containing the data we want to insert
-    private ArrayList data;
-    /** Instance of DBMapping object */
-    private DBMapping dbmap;
-    /** Instance of a logger */
-    private Logger logger;
-    
-    /**
-     * Create a new instance of InsertQuery. Initializes empty <code>data</code> array.
-     */
-    public InsertQuery() {
-        data = new ArrayList();
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Create new instance of the InsertQuery. Initializes <code>data</code> array with the given values
-     *
-     *  @param type     type of data we are working with
-     *  @param data     List of tuples containing values to insert
-     *  @throws DBLayetException in case the given type was not found in the DBMapping class
-     */
-    public InsertQuery(String type, ArrayList insertData) throws DBLayerException {
-        this.data = insertData;
-        setType(type);
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Add an item (tuple) to the list of values which will be inserted
-     *
-     *  @param field    name of the field (column)
-     *  @param value    value of the field (column)
-     */
-    public void addData(String field, String value) {
-        String[] tuple = {new String(field), new String(value) };
-        data.add(tuple);
-    }
-    
-    /**
-     *  Set the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @param type Type of data we are working with
-     *  @throws DBLayerException in case the given type was not found in the DBMapping class
-     */
-    public void setType(String type) throws DBLayerException {
-        if (dbmap.checkType(type)) {
-            this.type = type;
-        } else {
-            logger.error("Type '"+type+"' not found in DB mapping");
-            throw new DBLayerException("Type '"+type+"' not found in DB mapping");
-        }
-    }
-    
-    /**
-     *  Get the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @return Type of data we are working with
-     */
-    public String getType() {
-        return this.type;
-    }
-    
-    /**
-     *  Transform data in this object to the SQL query.
-     *
-     *  @return String with the SQL query constructed from the data stored in the object
-     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
-     */
-    public String toSQL() throws DBLayerException {
-        StringBuffer sql;
-        StringBuffer insertFields;
-        StringBuffer insertData;
-        String into;
-        String fieldName;
-        String[] tuple;
-        
-        // Initialize StringBuffers
-        sql = new StringBuffer();
-        insertFields = new StringBuffer();
-        insertData = new StringBuffer();
-        // Get the name of the table into which we will insert data
-        into = dbmap.getTableName(this.type);
-        // Construct part of the query with the data
-        for (int i=0;i<data.size();i++) {
-            if (i>0) {
-                insertFields.append(", ");
-                insertData.append(", ");
-            }
-            tuple = (String[])data.get(i);
-            fieldName = dbmap.getFieldName(tuple[0], this.type);
-            insertFields.append(fieldName);
-            // TODO: Rewrite adding quotes to the queries
-            if (i>0) {
-                insertData.append("'"+tuple[1]+"'");
-            } else {
-                insertData.append(tuple[1]);                
-            }
-        }
-        // Construct SQL query
-        sql.append("INSERT INTO ");
-        sql.append(into);
-        sql.append(" (");
-        sql.append(insertFields);
-        sql.append(") VALUES (");
-        sql.append(insertData);
-        sql.append(")");
-        
-        logger.debug(sql.toString());
-        return sql.toString();
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/OccurenceRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/OccurenceRecord.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/OccurenceRecord.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,179 +0,0 @@
-/*
- * OccurenceRecord.java
- *
- * Created on 23. leden 2006, 21:46
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-import java.util.ArrayList;
-import java.util.Date;
-
-/**
- *
- * @author Jakub
- */
-public class OccurenceRecord
-{
-    private int id;
-    private String recordDbId;
-    private String recordId;
-    private int year;
-    private int month;
-    private int day;
-    private Date time;
-    //private Date isoDateTime;
-    //private String DateSource;
-    private String herbarium;
-    private Date createdWhen;
-    private UserRecord createdWho; //?
-    private Date updatedWhen;
-    private UserRecord updatedWho; //?
-    private String note;
-    
-    /** we must not forget create better setters
-     *       - or at least think about it more
-     *
-     */
-    private AuthorRecord[] authorRecords; //?
-    
-    
-    
-    /** Creates a new instance of OccurenceRecord */
-    public OccurenceRecord()
-    {
-    }
-
-    public String getRecordDbId()
-    {
-        return recordDbId;
-    }
-
-    public void setRecordDbId(String recordDbId)
-    {
-        this.recordDbId = recordDbId;
-    }
-
-    public String getRecordId()
-    {
-        return recordId;
-    }
-
-    public void setRecordId(String recordId)
-    {
-        this.recordId = recordId;
-    }
-
-    public int getYear()
-    {
-        return year;
-    }
-
-    public void setYear(int year)
-    {
-        this.year = year;
-    }
-
-    public int getMonth()
-    {
-        return month;
-    }
-
-    public void setMonth(int month)
-    {
-        this.month = month;
-    }
-
-    public int getDay()
-    {
-        return day;
-    }
-
-    public void setDay(int day)
-    {
-        this.day = day;
-    }
-
-    public Date getTime()
-    {
-        return time;
-    }
-
-    public void setTime(Date time)
-    {
-        this.time = time;
-    }
-
-    public String getHerbarium()
-    {
-        return herbarium;
-    }
-
-    public void setHerbarium(String herbarium)
-    {
-        this.herbarium = herbarium;
-    }
-
-    public Date getCreatedWhen()
-    {
-        return createdWhen;
-    }
-
-    public void setCreatedWhen(Date createdWhen)
-    {
-        this.createdWhen = createdWhen;
-    }
-
-    public UserRecord getCreatedWho()
-    {
-        return createdWho;
-    }
-
-    public void setCreatedWho(UserRecord createdWho)
-    {
-        this.createdWho = createdWho;
-    }
-
-    public Date getUpdatedWhen()
-    {
-        return updatedWhen;
-    }
-
-    public void setUpdatedWhen(Date updatedWhen)
-    {
-        this.updatedWhen = updatedWhen;
-    }
-
-    public UserRecord getUpdatedWho()
-    {
-        return updatedWho;
-    }
-
-    public void setUpdatedWho(UserRecord updatedWho)
-    {
-        this.updatedWho = updatedWho;
-    }
-
-    public String getNote()
-    {
-        return note;
-    }
-
-    public void setNote(String note)
-    {
-        this.note = note;
-    }
-
-    public AuthorRecord[] getAuthorRecords()
-    {
-        return authorRecords;
-    }
-
-    public void setAuthorRecords(AuthorRecord[] authorRecords)
-    {
-        this.authorRecords = authorRecords;
-    }
-
-    
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/PlantRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/PlantRecord.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/PlantRecord.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,77 +0,0 @@
-/*
- * PlantRecord.java
- *
- * Created on 16. leden 2006, 2:32
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-/**
- *  Data holder object containing information about a plant
- *
- *  @author Tomas Kovarik
- *  @version 0.1, Jan 16, 2006
- */
-public class PlantRecord {
-    // Paraneters of the plant
-    private int id;
-    private String adoptedName;
-    private String czechName;
-    private String publishableName;
-    private String abbreviation;
-    private String note;
-    
-    /** Creates a new instance of PlantRecord */
-    public PlantRecord() {
-        
-    }
-    
-    public void setID(int id) {
-        this.id = id;
-    }
-    
-    public int getID() {
-        return this.id;
-    }
-    
-    public void setAdoptedName(String adoptedName) {
-        this.adoptedName = adoptedName;
-    }
-    
-    public String getAdoptedName() {
-        return this.adoptedName;
-    }
-    
-    public void setCzechName(String czechName) {
-        this.czechName = czechName;
-    }
-    
-    public String getCzechName() {
-        return this.czechName;
-    }
-    
-    public void setPublishableName(String publishableName) {
-        this.publishableName = publishableName;
-    }
-    
-    public String getPublishableName() {
-        return this.publishableName;
-    }
-    
-    public void setAbbreviation(String abbreviation) {
-        this.abbreviation = abbreviation;
-    }
-    
-    public String getAbbreviation() {
-        return this.abbreviation;
-    }
-    
-    public void setNote(String note) {
-        this.note = note;
-    }
-    
-    public String getNote() {
-        return this.note;
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/PublicationRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/PublicationRecord.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/PublicationRecord.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,68 +0,0 @@
-/*
- * PublicationRecord.java
- *
- * Created on 16. leden 2006, 2:32
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-/**
- *  Data holder object containing information about a publication
- *
- *  @author Tomas Kovarik
- *  @version 0.1, Jan 16, 2006
- */
-public class PublicationRecord {
-    // Parameters of the publication
-    private int id;
-    private String collectionName;
-    private int publicationYear;
-    private String journalName;
-    private String journalAuthor;
-    
-    /** Creates a new instance of PublicationRecord */
-    public PublicationRecord() {
-        
-    }
-    
-    public void setID(int id) {
-        this.id = id;
-    }
-    
-    public int getID() {
-        return this.id;
-    }
-    
-    public void setCollectionName(String collectionName) {
-        this.collectionName = collectionName;
-    }
-    
-    public String getCollectionName() {
-        return this.collectionName;
-    }
-    
-    public void setPublicationYear(int publicationYear) {
-        this.publicationYear = publicationYear;
-    }
-    
-    public int getPublicationYear() {
-        return this.publicationYear;
-    }
-    
-    public void setJournalName(String journalName) {
-        this.journalName = journalName;
-    }
-    
-    public String getJournalName() {
-        return this.journalName;
-    }
-    
-    public void setJournalAuthor(String journalAuthor) {
-        this.journalAuthor = journalAuthor;
-    }
-    
-    public String getJournalAuthor() {
-        return this.journalAuthor;
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/QueryResult.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/QueryResult.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/QueryResult.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,76 +0,0 @@
-/*
- * QueryResult.java
- *
- * Created on 14. leden 2006, 23:22
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-/**
- * Storage class for information about the results of a query.
- *
- * @author Tomas Kovarik
- * @version 0.1, Jan 14, 2006
- */
-public class QueryResult {
-    /** Unique identification of the result */
-    private int resultID;
-    /** Number of rows in the result / affected by the operation */
-    private int numRows;
-    /** Result code of the operation */
-    private int operationResult;
-    /** Type of the operation (entity which is in the result) */
-    private String type;
-    
-    /**
-     * Creates a new instance of QueryResult
-     *
-     * @param resultID          Unique identification of the result
-     * @param numRows           Number of rows in the result / affected by the operation
-     * @param operationResult   Result code of the operation
-     * @param type              Type of the operation
-     */
-    public QueryResult(int resultID, int numRows, int operationResult, String type) {
-        this.resultID = resultID;
-        this.numRows = numRows;
-        this.operationResult = operationResult;
-        this.type = type;
-    }
-    
-    /**
-     * Return unique ID of the result represented by this object
-     *
-     * @return Unique ID of the result
-     */
-    public int getResultID() {
-        return this.resultID;
-    }
-    
-    /**
-     * Return number of rows in the result (either number of selected or affected rows)
-     *
-     * @return Number of rows in the result
-     */
-    public int getNumRows() {
-        return this.numRows;
-    }
-    
-    /**
-     * Return result code of the operation (of the executed query)
-     *
-     * @return Code of the operation result
-     */
-    public int getOperationResult() {
-        return this.operationResult;
-    }
-    
-    /**
-     * Return type of the operation (entity returned by thye query)
-     *
-     * @return String type of the operation
-     */
-    public String getType() {
-        return this.type;
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/SelectQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/SelectQuery.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/SelectQuery.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,165 +0,0 @@
-/*
- * SelectQuery.java
- *
- * Created on 15. leden 2006, 13:55
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-import java.util.ArrayList;
-import org.apache.log4j.Logger;
-
-/**
- * Object holding parameters of a select query.
- *
- * @author Tomas Kovarik
- * @version 0.1, Jan 15, 2006
- */
-public class SelectQuery {
-    /** Type of data we are working with. For the list of types see DBmapping class */
-    private String type;
-    /** List of triples for the WHERE part of the query */
-    private ArrayList whereList;
-    /** List of tuples for the ORDER BY part of the query */
-    private ArrayList orderbyList;
-    /** Instance of DBMapping object */
-    private DBMapping dbmap;
-    /** Instance of a logger */
-    private Logger logger;
-    
-    /**
-     * Create a new instance of SelectQuery. Initializes empty <code>whereList</code> and <code>orderbyList</code>
-     */
-    public SelectQuery() {
-        this.whereList = new ArrayList();
-        this.orderbyList = new ArrayList();
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Create new instance of the SelectQuery. Initializes <code>whereList</code> and <code>orderbyList</code>
-     *  with the given values
-     *
-     *  @param type     type of data we are working with
-     *  @param where    List of triples for the WHERE part of the query
-     *  @param orderby  List of tuples for the ORDER BY part of the query
-     *  @throws DBLayerException in case the given type was not found in the DBMapping class
-     */
-    public SelectQuery(String type, ArrayList where, ArrayList orderby) throws DBLayerException {
-        this.whereList = where;
-        this.orderbyList = orderby;
-        setType(type);
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Add an item (triplet) to the list of triples for the WHERE part of the query
-     *
-     *  @param field    name of the field (left operand)
-     *  @param operator operator connecting operands
-     *  @param value    value of the field (right operand)
-     */
-    public void addWhere(String field, String operator, String value) {
-        String[] triple = {new String(field), new String(operator), new String(value) };
-        whereList.add(triple);
-    }
-    
-    /**
-     *  Add an item (tuple) to the list of tuples for the ORDER BY part of the query
-     *
-     *  @param field    name of the field for sorting
-     *  @param value    direction of sorting (<code>ASC</code> or <code>DESC</code>)
-     */
-    public void addOrderby(String field, String direction) {
-        String[] tuple = { new String(field), new String(direction) };
-        orderbyList.add(tuple);
-    }
-    
-    /**
-     *  Set the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @param type Type of data we are working with
-     *  @throws DBLayerException in case the given type was not found in the DBMapping class
-     */
-    public void setType(String type) throws DBLayerException {
-        if (dbmap.checkType(type)) {
-            this.type = type;
-        } else {
-            logger.error("Type '"+type+"' not found in DB mapping");
-            throw new DBLayerException("Type '"+type+"' not found in DB mapping");
-        }
-    }
-    
-    /**
-     *  Get the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @return Type of data we are working with
-     */
-    public String getType() {
-        return this.type;
-    }
-    
-    /**
-     *  Transform data in this object to the SQL query.
-     *
-     *  @return String with the SQL query constructed from the data stored in the object
-     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
-     */
-    public String toSQL() throws DBLayerException{
-        StringBuffer sql;
-        String from;
-        StringBuffer where;
-        StringBuffer orderby;
-        String fieldName;
-        String[] triple;
-        String[] tuple;
-        
-        // Initialize StringBuffers
-        where = new StringBuffer();
-        sql = new StringBuffer();
-        orderby = new StringBuffer();
-        // Get the table names we will be working with
-        from = dbmap.getTableName(this.type);
-        // Construct WHERE clause
-        for (int i=0;i<whereList.size();i++) {
-            if (i>0) {
-                where.append(" AND ");
-            }
-            triple = (String[])whereList.get(i);
-            fieldName = dbmap.getFieldName(triple[0], this.type);
-            where.append(fieldName);
-            where.append(" ");
-            where.append(triple[1]);
-            where.append(" ");
-            where.append("'"+triple[2]+"'");
-        }
-        // Construct orderby clause
-        for (int i=0;i<orderbyList.size();i++) {
-            if (i>0) {
-                orderby.append(", ");
-            }
-            tuple = (String[])orderbyList.get(i);
-            fieldName = dbmap.getFieldName(tuple[0], this.type);
-            orderby.append(fieldName);
-            orderby.append(" ");
-            orderby.append(tuple[1]);
-        }
-        // Construct SQL query
-        sql.append("SELECT * FROM ");
-        sql.append(from);
-        if (whereList.size() != 0) {
-            sql.append(" WHERE ");
-            sql.append(where);
-        }
-        if (orderbyList.size() != 0) {
-            sql.append(" ");
-            sql.append(orderby);
-        }
-        
-        logger.debug(sql.toString());
-        return sql.toString();
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/UpdateQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/UpdateQuery.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/UpdateQuery.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,161 +0,0 @@
-/*
- * UpdateQuery.java
- *
- * Created on 15. leden 2006, 13:56
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-import java.util.ArrayList;
-import org.apache.log4j.Logger;
-
-/**
- * Object holding parameters of delte query
- *
- * @author Tomas Kovarik
- * @version 0.1, Jan 15, 2006
- */
-public class UpdateQuery {
-    /** Type of data we are working with. For the list of types see DBmapping class */
-    private String type;
-    /** List of triples for the WHERE part of the query */
-    private ArrayList whereList;
-    // Array of tuples containing the data we want to insert
-    private ArrayList data;
-    /** Instance of DBMapping object */
-    private DBMapping dbmap;
-    /** Instance of a logger */
-    private Logger logger;
-    
-    /**
-     * Creates a new instance of UpdateQuery. Initializes empty <code>whereList</code> and <code>data</code> array.
-     */
-    public UpdateQuery() {
-        whereList = new ArrayList();
-        data = new ArrayList();
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-        
-    }
-    
-    /**
-     *  Create new instance of the DeleteQuery. Initializes <code>whereList</code> and <code>data</code> with the given values
-     *
-     *  @param type         type of data we are working with
-     *  @param whereList    List of triples for the WHERE clause
-     *  @param updateData   List of tuples with the updated data
-     *  @throws DBLayetException in case the given type was not found in the DBMapping class
-     */
-    public UpdateQuery(String type, ArrayList where, ArrayList updateData) throws DBLayerException {
-        this.whereList = where;
-        this.data = updateData;
-        setType(type);
-        dbmap = new DBMapping();
-        logger = Logger.getLogger(this.getClass().getPackage().getName());
-    }
-    
-    /**
-     *  Add an item (triplet) to the list of triples for the WHERE part of the query
-     *
-     *  @param field    name of the field (left operand)
-     *  @param operator operator connecting operands
-     *  @param value    value of the field (right operand)
-     */
-    public void addWhere(String field, String operator, String value) {
-        String[] triple = {new String(field), new String(operator), new String(value) };
-        whereList.add(triple);
-    }
-    
-    /**
-     *  Add an item (tuple) to the list of values which will be updated
-     *
-     *  @param field    name of the field (column)
-     *  @param value    value of the field (column)
-     */
-    public void addData(String field, String value) {
-        String[] tuple = {new String(field), new String(value) };
-        data.add(tuple);
-    }
-    
-    /**
-     *  Set the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @param type Type of data we are working with
-     *  @throws DBLayerException in case the given type was not found in the DBMapping class
-     */
-    public void setType(String type) throws DBLayerException {
-        if (dbmap.checkType(type)) {
-            this.type = type;
-        } else {
-            logger.error("Type '"+type+"' not found in DB mapping");
-            throw new DBLayerException("Type '"+type+"' not found in DB mapping");
-        }
-    }
-    
-    /**
-     *  Get the type of data we are working with. For the list of types see DBmapping class.
-     *
-     *  @return Type of data we are working with
-     */
-    public String getType() {
-        return this.type;
-    }
-    
-    /**
-     *  Transform data in this object to the SQL query.
-     *
-     *  @return String with the SQL query constructed from the data stored in the object
-     *  @throws DBLayerException in case some part of the SQL query cannot be constructed
-     */
-    public String toSQL() throws DBLayerException {
-        StringBuffer sql;
-        String table;
-        StringBuffer where;
-        StringBuffer update;
-        String fieldName;
-        String[] triple;
-        String[] tuple;
-        
-        // Initialize StringBuffers
-        where = new StringBuffer();
-        sql = new StringBuffer();
-        update = new StringBuffer();
-        // Get the name of the table we want to update
-        table = dbmap.getTableName(this.type);
-        // Construct WHERE clause
-        for (int i=0;i<whereList.size();i++) {
-            if (i>0) {
-                where.append(" AND ");
-            }
-            triple = (String[])whereList.get(i);
-            fieldName = dbmap.getFieldName(triple[0], this.type);
-            where.append(fieldName);
-            where.append(" ");
-            where.append(triple[1]);
-            where.append(" ");
-            where.append("'"+triple[2]+"'");
-        }
-        // Construct swction of the query containing updated data
-        for (int i=0;i<data.size();i++) {
-            if (i>0) {
-                update.append(", ");
-            }
-            tuple = (String[])data.get(i);
-            fieldName = dbmap.getFieldName(tuple[0], this.type);
-            update.append(fieldName);
-            update.append(" = ");
-            update.append("'"+tuple[1]+"'");
-        }
-        // Construct whole SQL query
-        sql.append("UPDATE ");
-        sql.append(table);
-        sql.append(" SET ");
-        sql.append(update);
-        sql.append(" ");
-        sql.append(where);
-        
-        logger.debug(sql.toString());
-        return sql.toString();
-    }
-}

Deleted: trunk/src/net/sf/plantlore/client/dblayer/UserRecord.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/UserRecord.java	2006-02-18 20:04:05 UTC (rev 38)
+++ trunk/src/net/sf/plantlore/client/dblayer/UserRecord.java	2006-02-18 20:05:29 UTC (rev 39)
@@ -1,251 +0,0 @@
-/*
- * UserRecord.java
- *
- * Created on 16. leden 2006, 2:32
- *
- */
-
-package net.sf.plantlore.client.dblayer;
-
-/**
- *  Data holder object containing information about a user
- *
- *  @author Tomas Kovarik
- *  @version 0.1, Jan 16, 2006
- */
-public class UserRecord {
-    /** Parameters of the user */
-    private int id;
-    private String login;
-    private String firstName;
-    private String surname;
-    private String email;
-    private String address;
-    private java.util.Date whenCreated;
-    private java.util.Date whenDropped;
-    private String note;
-    private int exportRight;
-    private int importRight;
-    private String role;
-    
-    /** Creates a new instance of UserRecord */
-    public UserRecord() {
-        
-    }
-    
-    /**
-     *   Get user id
-     *   @return id of the user
-     *   @see setID
-     */
-    public int getID() {
-        return this.id;
-    }
-    
-    /**
-     *   Set user id
-     *   @param id   id of the user
-     *   @see getID
-     */
-    public void setID(int id) {
-        this.id = id;
-    }
-    
-    /**
-     *   Get login name of the user
-     *   @return login name of the user
-     *   @see setLogin
-     */
-    public String getLogin() {
-        return this.login;
-    }
-    
-    /**
-     *   Set login name of the user
-     *   @param login string containing login name of the user
-     *   @see getLogin
-     */
-    public void setLogin(String login) {
-        this.login = login;
-    }
-    
-    /**
-     *   Get first name of the user
-     *   @return string containing the first name of the user
-     *   @see setFirstName
-     */
-    public String getFirstName() {
-        return this.firstName;
-    }
-    
-    /**
-     *   Set first name of the user
-     *   @param firstName string containing the first name of the user
-     *   @see getFirstName
-     */
-    public void setFirstName(String firstName) {
-        this.firstName = firstName;
-    }
-    
-    /**
-     *   Get surname of the user
-     *   @return string containing surname of the user
-     *   @see setSurname
-     */
-    public String getSurname() {
-        return this.surname;
-    }
-    
-    /**
-     *   Set surname of the user
-     *   @param surname string containing surname of the user
-     *   @see getSurname
-     */
-    public void setSurname(String surname) {
-        this.surname = surname;
-    }
-    
-    /**
-     *   Get email of the user
-     *   @return string containing email of the user
-     *   @see setEmail
-     */
-    public String getEmail() {
-        return this.email;
-    }
-    
-    /**
-     *   Set email of the user
-     *   @param contact string containing email of the user
-     *   @see getEmail
-     */
-    public void setEmail(String email) {
-        this.email = email;
-    }
-    
-    /**
-     *   Get address of the user
-     *   @return string containing address of the user
-     *   @see setAddress
-     */
-    public String getAddress() {
-        return this.address;
-    }
-    
-    /**
-     *   Set address of the user
-     *   @param contact string containing address of the user
-     *   @see getAddress
-     */
-    public void setAddress(String address) {
-        this.address = address;
-    }
-    
-    /**
-     *   Get date when the user was created
-     *   @return date when the user was added to the system
-     *   @see setWhenCreated
-     */
-    public java.util.Date getWhenCreated() {
-        return this.whenCreated;
-    }
-    
-    /**
-     *   Set date when the user was created
-     *   @param whenCreated date when the user was added to the system
-     *   @see getWhenCreated
-     */
-    public void setWhenCreated(java.util.Date whenCreated) {
-        this.whenCreated = whenCreated;
-    }
-    
-    /**
-     *   Get date when the user was droped
-     *   @return date when the user was deleted from the system
-     *   @see setWhenDropped
-     */
-    public java.util.Date getWhenDropped() {
-        return this.whenDropped;
-    }
-    
-    /**
-     *   Set date when the user was droped
-     *   @param whenDropped date when the user was deleted from the system
-     *   @see getWhenDropped
-     */
-    public void setWhenDropped(java.util.Date whenDropped) {
-        this.whenDropped = whenDropped;
-    }
-    
-    /**
-     *   Get note about the user
-     *   @return string containing note about the user
-     *   @see setNote
-     */
-    public String getNote() {
-        return this.note;
-    }
-    
-    /**
-     *   Set note about the user
-     *   @param contact string containing note about the user
-     *   @see getNote
-     */
-    public void setNote(String note) {
-        this.note = note;
-    }
-    
-    /**
-     *  Get the information about the export right of the user
-     *  @return information about the export right of the user
-     *  @see setExportRight
-     */
-    public int getExportRight() {
-        return this.exportRight;
-    }
-    
-    /**
-     *   Set the information about the export right of the user
-     *   @param exportRight information about the export right of the user
-     *   @see getExportRight
-     */
-    public void setExportRight(int exportRight) {
-        this.exportRight = exportRight;
-    }
-    
-    /**
-     *  Get the information about the import right of the user
-     *  @return information about the import right of the user
-     *  @see setImportRight
-     */
-    public int getImportRight() {
-        return this.importRight;
-    }
-    
-    /**
-     *   Set the information about the imoprt right of the user
-     *   @param importRight information about the import right of the user
-     *   @see getImportRight
-     */
-    public void setImportRight(int importRight) {
-        this.importRight = importRight;
-    }
-    
-    /**
-     *  Get role of the user
-     *  @return String representation of the role of the user
-     *  @see setRole
-     */
-    public String getRole() {
-        return this.role;
-    }
-    
-    /**
-     *   Set the role of the user
-     *   @param role String representation of the role of the user
-     *   @see getRole
-     */
-    public void setRole(String role) {
-        this.role = role;
-    }
-}



From fraktalek at gmx.net  Sun Feb 19 17:21:17 2006
From: fraktalek at gmx.net (fraktalek)
Date: Sun, 19 Feb 2006 17:21:17 +0100
Subject: [Plantlore-dev] Re: Java RMI - jak si to stoji
In-Reply-To: <f4dc39b90602180630g4f6b71efw4d9045efa244a1d8@mail.gmail.com>
References: <f4dc39b90602180317g1c8a03bcvba4d5cdbbc9669b@mail.gmail.com> <f4dc39b90602180630g4f6b71efw4d9045efa244a1d8@mail.gmail.com>
Message-ID: <200602191721.17089.fraktalek@gmx.net>

Souhlas, aktualizace si budou resit uzivatele. Je to nejbezpecnejsi, stoji nas 
to nejmin prace :)

On Saturday 18 February 2006 15:30, Erik Kratochvil wrote:
> No dobre, trochu sem to dorozmyslel a zda se, ze sem asi mel nejakou
> temnou chvilku ;)
>
> Proc vlastne by se mely takovy aktualizace vubec delat?
>
> Proti tomu uvazovanymu pouziti mluvi bezpecnost - klient si
> preprogramuje tridu a timhle mechanismem by ji mohl vnutit serveru ==
> security risk jako prase... (naopak zase nejakej zaskodnickej server
> by mohl vnutit neco klientum, no hruuzaa).
>
> Nechal sem se nejak unest moznostma toho RMI, myslim, ze uplne
> postacujici bude, kdyz nechame uzivatele se starat o aktualizace
> "tradicnim zpusobem" (tj. stahni si novou verzi).
>
> Uf, radsi uz nepremejslim.
> _______________________________________________
> Plantlore-dev mailing list
> Plantlore-dev at lists.berlios.de
> http://lists.berlios.de/mailman/listinfo/plantlore-dev


From fraktalek at berlios.de  Tue Feb 21 23:21:09 2006
From: fraktalek at berlios.de (fraktalek at berlios.de)
Date: Tue, 21 Feb 2006 23:21:09 +0100
Subject: [Plantlore-dev] r41 - in trunk: analysis analysis/biocase analysis/database documentation
Message-ID: <200602212221.k1LML91f021886@sheep.berlios.de>

Author: fraktalek
Date: 2006-02-21 23:21:07 +0100 (Tue, 21 Feb 2006)
New Revision: 41

Modified:
   trunk/analysis/analysis_requirements_business.sxw
   trunk/analysis/architektura systemu.odt
   trunk/analysis/biocase/BioCASE.odt
   trunk/analysis/database/Popis DB modelu.odt
   trunk/analysis/uc.odt
   trunk/documentation/Zprava o stavu projektu.odt
Log:
Changes thanks to dr. Riha.


Modified: trunk/analysis/analysis_requirements_business.sxw
===================================================================
(Binary files differ)

Modified: trunk/analysis/architektura systemu.odt
===================================================================
(Binary files differ)

Modified: trunk/analysis/biocase/BioCASE.odt
===================================================================
(Binary files differ)

Modified: trunk/analysis/database/Popis DB modelu.odt
===================================================================
(Binary files differ)

Modified: trunk/analysis/uc.odt
===================================================================
(Binary files differ)

Modified: trunk/documentation/Zprava o stavu projektu.odt
===================================================================
(Binary files differ)



From Lada at berlios.de  Thu Feb 23 07:04:23 2006
From: Lada at berlios.de (Lada at berlios.de)
Date: Thu, 23 Feb 2006 07:04:23 +0100
Subject: [Plantlore-dev] r43 - trunk/src/net/sf/plantlore/l10n
Message-ID: <200602230604.k1N64NTq020606@sheep.berlios.de>

Author: Lada
Date: 2006-02-23 07:03:43 +0100 (Thu, 23 Feb 2006)
New Revision: 43

Modified:
   trunk/src/net/sf/plantlore/l10n/Plantlore.properties
   trunk/src/net/sf/plantlore/l10n/Plantlore_cs_CZ.properties
   trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
Log:
Update properties for history

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-02-23 01:42:47 UTC (rev 42)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore.properties	2006-02-23 06:03:43 UTC (rev 43)
@@ -26,3 +26,5 @@
 authorMgr=Author manager
 
 publicationMgr=Publication manager
+
+History= History - undo
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore_cs_CZ.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore_cs_CZ.properties	2006-02-23 01:42:47 UTC (rev 42)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore_cs_CZ.properties	2006-02-23 06:03:43 UTC (rev 43)
@@ -13,3 +13,5 @@
 authorMgr=Author manager
 
 publicationMgr=Publication manager
+
+History= History - undo
\ No newline at end of file

Modified: trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties
===================================================================
--- trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-02-23 01:42:47 UTC (rev 42)
+++ trunk/src/net/sf/plantlore/l10n/Plantlore_en.properties	2006-02-23 06:03:43 UTC (rev 43)
@@ -12,3 +12,5 @@
 authorMgr=Author manager
 
 publicationMgr=Publication manager
+
+History= History - undo
\ No newline at end of file



From Lada at berlios.de  Thu Feb 23 02:43:07 2006
From: Lada at berlios.de (Lada at berlios.de)
Date: Thu, 23 Feb 2006 02:43:07 +0100
Subject: [Plantlore-dev] r42 - in trunk/src/net/sf/plantlore/client: . dblayer history
Message-ID: <200602230143.k1N1h7VP032326@sheep.berlios.de>

Author: Lada
Date: 2006-02-23 02:42:47 +0100 (Thu, 23 Feb 2006)
New Revision: 42

Added:
   trunk/src/net/sf/plantlore/client/history/
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
   trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
   trunk/src/net/sf/plantlore/client/history/HistoryView.java
Modified:
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/AppCoreView.java
   trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java
Log:
Second try commit. Add history for selected occurrence. Add historyRecord. Update AppCoreView, AppCoreCtr, DBmapping for work with history - Odkaz na historii jednoho nalezu je dan zatim do menu, ale do budoucna bude u tabulky s nalezama a v menu bude odkaz do celkove historie

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -24,6 +24,10 @@
 import net.sf.plantlore.client.authors.AuthorManagerCtrl;
 import net.sf.plantlore.client.authors.AuthorManagerView;
 import net.sf.plantlore.client.dblayer.DBMapping;
+import net.sf.plantlore.client.history.History;
+import net.sf.plantlore.client.history.HistoryCtrl;
+import net.sf.plantlore.client.history.HistoryView;
+
 import org.apache.log4j.Logger;
 
 /** Application core controller.
@@ -42,6 +46,10 @@
     SettingsCtrl settingsCtrl;
     Preferences prefs;
     
+    History historyModel;
+    HistoryView historyView;
+    HistoryCtrl historyCtrl;
+    
     /** Creates a new instance of AppCoreCtrl */
     public AppCoreCtrl(AppCore model, AppCoreView view)
     {
@@ -56,6 +64,7 @@
         view.addHelpAboutListener(new HelpAboutListener());
         view.addDataAuthorsListener(new DataAuthorsListener());
         view.addDataPublicationsListener(new DataPublicationsListener());
+        view.addDataHistoryListener(new DataHistoryListener());
     }
     
     /** Handles click to menu item Settings.
@@ -161,5 +170,19 @@
         public void actionPerformed(ActionEvent actionEvent) {
             // Open publication manager - not implemented yet
         }
+    }   
+    
+    class DataHistoryListener implements ActionListener {
+    	public void actionPerformed(ActionEvent actionEvent)
+        {
+            System.out.println("Undo selected");
+            //toto volani historie nebude v menu, ale jako tlacitko pro vybrany zaznam        
+            //o vybranem zaznamu predame informace, ktere chceme o nem v historii zobrazit
+            //jmeno rosliny, jmeno autora a lokaci a idOccurrences
+            historyModel = new History(model.getDatabase(),"Adis Abeba", "Lada", "Praha v?chod", 1);
+            historyView = new HistoryView(historyModel);
+            historyCtrl = new HistoryCtrl(historyModel, historyView);
+            historyView.setVisible(true);
+        }
     }    
 }

Modified: trunk/src/net/sf/plantlore/client/AppCoreView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreView.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/AppCoreView.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -63,6 +63,7 @@
     private JMenuItem helpAbout = new JMenuItem(L10n.getString("helpAbout"));
     private JMenuItem dataAuthors = new JMenuItem(L10n.getString("authorMgr"));
     private JMenuItem dataPublications = new JMenuItem(L10n.getString("publicationMgr"));    
+    private JMenuItem dataHistory = new JMenuItem(L10n.getString("History"));
     
     private JLabel statusLabel;
     
@@ -126,7 +127,8 @@
         
         dataMenu.setMnemonic(KeyEvent.VK_D);
         dataMenu.add(dataAuthors);
-        dataMenu.add(dataPublications);        
+        dataMenu.add(dataPublications);   
+        dataMenu.add(dataHistory); 
 
         helpMenu.setMnemonic(KeyEvent.VK_H);
         helpMenu.add(helpContents);
@@ -277,6 +279,13 @@
         dataPublications.addActionListener(al);
     }    
     
+    /** Adds a listener to the HistoryData menu item.
+    *
+    */
+    public void addDataHistoryListener(ActionListener al) {
+        dataHistory.addActionListener(al);
+    }
+    
     /** Returns the frame of the main window.
      *
      */

Modified: trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java
===================================================================
--- trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/dblayer/DBMapping.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -26,7 +26,8 @@
     private Hashtable PUBLICATION;
     private Hashtable METADATA;
     private Hashtable HABITAT;
-    private Hashtable OCCURRENCE;                
+    private Hashtable OCCURRENCE;  
+    private Hashtable HISTORY;
     
     public static final int USERRECORD = 1;
     public static final int AUTHORRECORD = 2;
@@ -34,7 +35,8 @@
     public static final int PUBLICATIONRECORD = 4;
     public static final int METADATARECORD = 5;
     public static final int HABITATRECORD = 6;    
-    public static final int OCCURENCERECORD = 7;        
+    public static final int OCCURENCERECORD = 7;  
+    public static final int HISTORYRECORD = 8;
     
     /** List of tables for available entities*/
     private String AUTHOR_TABLES = "TAUTHORS";
@@ -44,6 +46,8 @@
     private String METADATA_TABLES = "TMETADATA";
     private String HABITAT_TABLES = "THABITATS, TVILLAGES, TPHYTOCHORIA, TTERRITORIES";
     private String OCCURENCE_TABLES = "TOCCURRENCES, TMETADATA, TPLANTS, TPUBLICATIONS, THABITATS, TUSER";
+    private String HISTORY_TABLES = "THISTORY JOIN THISTORYCOLUMN JOIN THISTORYCHANGE ON (THISTORY.ccolumnid = THISTORYCOLUMN.cid) ON (THISTORY.cchangeid = THISTORYCHANGE.cid) ";
+    
     /** Instance of a logger */
     private Logger logger;
     
@@ -59,6 +63,7 @@
         initMetadata();
         initHabitat();
         initOccurrence();
+        initHistory();
     }
         
     /**
@@ -84,7 +89,9 @@
             case HABITATRECORD:
                 return this.HABITAT_TABLES;                
             case OCCURENCERECORD:
-                return this.OCCURENCE_TABLES;                            
+                return this.OCCURENCE_TABLES;  
+            case HISTORYRECORD:
+                return this.HISTORY_TABLES;
             default:
                 logger.error("No table defined for type "+type);
                 throw new DBLayerException("No table defined for type "+type);                
@@ -123,6 +130,9 @@
             case OCCURENCERECORD:
                 value = getOccurrenceField(key);
                 break;
+            case HISTORYRECORD:
+            	value = getHistoryField(key);
+            	break;
             default:            
                 logger.error("No fields defined for type "+type);
                 throw new DBLayerException("No fields defined for type "+type);
@@ -234,6 +244,21 @@
     }
 
     /**
+     *  Get a specified field from history mapping.
+     *
+     *  @param key  String key representing a database column
+     *  @return     name of the database column. If the given key is not found <code>null</code> is returned
+     */
+    private String getHistoryField(String key) {       
+    	if (HISTORY.containsKey(key)) {
+    		System.out.println((String)HISTORY.get(key));
+            return (String)HISTORY.get(key);
+        } else {        	
+            return null;
+        }
+    }    
+    
+    /**
      *  Initialization of the mapping of Users.
      */
     private void initUser() {
@@ -349,4 +374,18 @@
         OCCURRENCE.put("updatedwho","TOCCURRENCES.CUPDATEWHO");
         OCCURRENCE.put("note","TOCCURRENCES.CNOTE");                
     }    
+    
+    private void initHistory() {
+    	HISTORY = new Hashtable(10);
+    	HISTORY.put("cid","THISOTRY.CID");
+    	HISTORY.put("oldValue","THISTORY.COLDVALUE");
+    	HISTORY.put("newValue","THISTORY.CNEWVALUE");
+    	HISTORY.put("tableName","THISTORYCOLUMN.CTABLENAME");
+    	HISTORY.put("columnName","THISTORYCOLUMN.CCOLUMNNAME");
+    	HISTORY.put("occurrenceId","THISTORYCHANGE.COCCURRENCEID");
+    	HISTORY.put("recordId","THISTORYCHANGE.CRECORDID");
+    	HISTORY.put("operation","THISTORYCHANGE.COPEREATION");
+    	HISTORY.put("when","THISTORYCHANGE.CWHEN");
+    	HISTORY.put("who","THISTORYCHANGE.CWHO");    	
+    }
 }

Added: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -0,0 +1,355 @@
+/**
+ * 
+ */
+package net.sf.plantlore.client.history;
+
+import java.util.Observable;
+import net.sf.plantlore.client.dblayer.DBLayer;
+import net.sf.plantlore.client.dblayer.DBLayerException;
+import net.sf.plantlore.client.dblayer.DBMapping;
+import net.sf.plantlore.client.dblayer.query.Query;
+import net.sf.plantlore.client.dblayer.query.SelectQuery;
+import net.sf.plantlore.client.dblayer.result.Result;
+import net.sf.plantlore.common.record.HistoryRecord;
+
+import org.apache.log4j.Logger;
+
+
+/**
+ * @author Lada
+ *
+ */
+public class History extends Observable {
+
+	/** Instance of a logger */
+    private Logger logger;
+
+    /** Exception with details about an error */
+    private DBLayerException error = null;
+    /** Instance of a database management object */
+    private DBLayer database;   
+    
+    //result - searchig history for rocord
+    private Result resultHistory;
+    private Object[][] historyData;
+
+    /** Name of the table where value was changed*/
+	private String tableName;  
+	/** Name of the column where value was changed*/
+	private String columnName;
+	/** Unique value identified record. 
+	 * Foring key referenced to table TOCCURRENCES */	
+	private int occurrenceId;
+	/**Unique value identified record in table where value was changed */
+	private int recordId;
+	/** Operation whitch was used*/   
+	private String operation;
+	/** Date and time when the reccord was changed*/
+	private java.util.Date when;	
+	/** Old value of attribute*/    
+	private String oldValue;
+	/** New value of attribute*/
+	private String newValue;
+   /** Name of user who did changed*/
+	private String nameUser;
+
+	//Informations about occurrences
+	private String namePlant;
+	private String nameAuthor;
+	private String location;
+	
+    
+    /** Creates a new instance of History 
+     *  
+     *  v konstruktoru predame jednotlive informace, ktere chceme zobrazit o nalezu
+     * */
+    public History(DBLayer database, String namePlant, String nameAuthor, String location, int idOcc)
+    {
+       logger = Logger.getLogger(this.getClass().getPackage().getName());	 
+       this.database = database;	
+       
+       setOccurrenceId(idOcc);
+       setNamePlant(namePlant);
+       setNameAuthor(nameAuthor);
+       setLocation(location);
+	   
+	   //dohledani historie zmen pro nalez s id occurrenceId
+	   searchHistoryData(occurrenceId);
+    }	
+
+    /**
+     * Tato funkce dohleda data ulozene v historii pro nalez urceni id 
+     * 
+     * @param idOccurrence
+     */
+     
+    public void searchHistoryData(Integer idOccurrence)
+    {
+    	String idOcc = new String();
+    	
+    	 // Create new Select query
+        Query query = new SelectQuery();
+        query.setType(DBMapping.HISTORYRECORD);
+        query.addWhere("occurrenceId","=",idOcc.valueOf(idOccurrence));
+        query.addOrderby("when", "ASC");
+        
+        Result result = null;
+        try {
+            // Execute query
+            result = database.executeQuery(query);        
+        } catch (DBLayerException e) {
+            // Log and set an error                   
+            logger.error("Searching history failed. Unable to execute search query.");
+            //setError(e);           
+        } finally {                              
+            // Save history data
+        	logger.debug("Searching history ends successfully");
+            saveResult(result);                
+        }      
+    }
+    
+    /**
+     * 
+     * @param result
+     */
+    public void saveResult(Result result) {
+    	this.resultHistory = result;
+    	int from = 0;
+    	int to = result.getNumRows();
+    	
+    	logger.debug("Retrieving query results.");
+        try {
+            // Retrieve selected row interval
+            Object[] objectHistory = database.more(this.resultHistory, from, to);  
+            int countResutl = objectHistory.length;
+            logger.debug("Results retrieved. Count: "+ countResutl);
+            
+            System.out.println(objectHistory);
+
+        } catch (DBLayerException e) {
+            // Log and set error in case of an exception
+            logger.error("Processing search results failed: "+e.toString());            
+        }
+    	
+    }
+    
+    public Object[][] getData() {
+ 	    historyData = new Object[][]{{new Boolean(false),"12.01.2006","Lada","village","Stritez", "Slavice"},
+		          {new Boolean(false),"12.01.2006","Lada","village","Stritez", "Slavice"}};
+
+    	return this.historyData;
+    }
+    
+
+    /**
+     * Tato funkce bude menit hodnoty v DB (DELETE v historii, zmena v jakekoliv 
+     * tabulce pro kterou se zaznamenava historie) - UNDO
+     * 
+     * bude volana z CTR po stisku klavesy
+     * jako parametr dostane seznam oznacenych zmen, ktere se maji vratit
+     * 
+     */
+    public void undo()
+    {
+    	
+    }
+    
+    /**
+     * Tato funkce bude overovat prava, zda dany uzivatel ma
+     * pravo provest UNDO - spravne by se uzivateli nevela
+     * historie zobrazit pokud nema prava, takze overeni prav
+     * musi byt volano jiz v konstruktoru nebo na miste, kde 
+     * se vola undo pro dany zaznam, coz by bylo asi nejlogictejsi
+     * !!! OVERIT TUTO MYSLENKU 
+     * pokud to tak bude, tak po zavolani historie vime, ze je autor nebo ma prava
+     * jeste je tu otazka, zda editace od admina zakaze zruseni teto editace neadminem 
+     */
+    public void checkRight()
+    {
+    	
+    }
+    
+    /**
+     *  overeni, zda nechce vratit starsi zmenu aniz by chtel vratit mladsi
+     *  nebo spise, pokud oznaci starsi v tu chvili se mu oznaci i ty mlatsi pro
+     *  stejeny atribut
+     */
+    public void checkCorrectMark()
+    {
+    	
+    }
+       
+    
+    //****************************//
+    //****Get and set metods*****//
+    //**************************//
+    
+
+   public String getNamePlant() {
+		  return this.namePlant;
+	   }
+
+   public void setNamePlant(String namePlant) {
+		  this.namePlant = namePlant;
+	}    
+   
+   public String getNameAuthor() {
+		  return this.nameAuthor;
+	   }
+
+   public void setNameAuthor(String nameAuthor) {
+	  this.nameAuthor = nameAuthor;
+   } 
+   
+   public String getLocation() {
+		  return this.location;
+	   }
+
+   public void setLocation(String location) {
+		  this.location = location;
+	}    
+   
+    /**
+	*   Get name of the table where value was changed
+	*   @return of the table where value was changed	
+	*/
+   public String getTableName() {
+	  return this.tableName;
+   }
+
+   /**
+	*   Set name of the table where value was changed
+	*   @param tableName string containing of the table where value was changed
+	*/
+   public void setTableName(String tableName) {
+	  this.tableName = tableName;
+   }
+
+   /**
+   *   Get name of the column where value was changed
+   *   @return  name of the column where value was changed
+   */
+  public String getColumnName() {
+	 return this.columnName;
+  }
+
+  /**
+   *   Set  name of the column where value was changed
+   *   @param columnName string containing  name of the column where value was changed
+   */
+  public void setColumnName(String columnName) {
+	 this.columnName = columnName;
+  }
+	/**
+	 *   Get identifier of the occurrence whitch was changed
+	 *   @return foreign identifier of the occurrence whitch was changed
+	 */
+	public int getOccurrenceId() {
+	   return this.occurrenceId;
+	}
+
+	/**
+	 *   Set identifier of the occurrence whitch was changed
+	 *   @param occurrenceId identifier of the occurrence whitch was changed
+	 */
+	public void setOccurrenceId(int occurrenceId) {
+	   this.occurrenceId= occurrenceId;
+	}	
+	
+   /**
+	 *   Get identifier of the record whitch was changed
+	 *   @return identifier of the record whitch was changed
+	 */
+	public int getRecordId() {
+	   return this.recordId;
+	}
+
+	/**
+	 *   Set identifier of the record whitch was changed
+	 *   @param recordId string containing identifier of the record whitch was changed
+	 */
+	public void setRecordId(int recordId) {
+	   this.recordId = recordId;
+	}
+	  
+	/**
+	*   Get operation whitch was used
+	*   @return operation whitch was used
+	*/
+	public String getOperation() {
+	  return this.operation;
+	}
+
+	/**
+	*   Set operation whitch was used
+	*   @param operation string containing operation whitch was used 
+	*/
+	public void setOperation(String operation) {
+	  this.operation = operation;
+	}
+	 
+	   
+	/**
+	*   Get date and time when the reccord was changed
+	*   @return date and time when the reccord was changed
+	*/         
+    public java.util.Date getWhen() {
+	  return this.when;
+    }
+ 
+   /**
+	*   Set date and time when the reccord was changed
+	*   @param when date and time when the reccord was changed
+	*/            
+    public void setWhen(java.util.Date when) {
+	  this.when = when;
+    }     	  
+ 
+	/**
+	*   Get name of user who did changed
+	*   @return name of user who did changed
+	*/
+    public String getNameUser() {
+	  return this.nameUser;
+    }
+
+    /**
+	*   Set name of user who did changed
+	*   @param nameUser string containing name of user who did changed	
+	*/
+    public void setNameUser(String nameUser) {
+	  this.nameUser = nameUser;
+    }  
+    
+	/**
+	*   Get old value of atribute whitch was changed
+	*   @return old value of atribute whitch was changed
+	*/
+    public String getOldValue() {
+	  return this.oldValue;
+    }
+
+    /**
+	*   Set old value of atribute whitch was changed
+	*   @param oldValue string containing old value of atribute whitch was changed
+	*/
+    public void setOldValue(String oldValue) {
+	  this.oldValue = oldValue;
+    }
+	   
+	 /**
+	*   Get new value of atribute whitch was changed
+	*   @return new value of atribute whitch was changed 
+	*/
+    public String getNewValue() {
+	  return this.newValue;
+    }
+
+    /**
+	*   Set new value of atribute whitch was changed
+	*   @param newValue string containing new value of atribute whitch was changed
+	*/
+    public void setNewValue(String newValue) {
+	  this.newValue = newValue;
+    }    
+}

Added: trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/history/HistoryCtrl.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -0,0 +1,157 @@
+/**
+ * 
+ */
+package net.sf.plantlore.client.history;
+
+import java.awt.event.ActionEvent;
+import java.awt.event.ActionListener;
+import java.awt.event.WindowEvent;
+import java.awt.event.WindowListener;
+
+import net.sf.plantlore.client.Settings;
+import net.sf.plantlore.client.SettingsView;
+
+
+import org.apache.log4j.Logger;
+
+/**
+ * @author Lada
+ *
+ */
+public class HistoryCtrl {
+
+	private Logger logger;
+    private History model;
+    private HistoryView view;
+    
+    /** Creates a new instance of HistoryCtrl */
+    public HistoryCtrl(History model, HistoryView view)
+    {
+        logger = Logger.getLogger(this.getClass().getPackage().getName());        
+        this.model = model;
+        this.view = view;
+                     
+        view.addOkButtonListener(new okButtonListener());
+        view.addCancelButtonListener(new cancelButtonListener());
+        view.addHelpButtonListener(new helpButtonListener());
+        view.addPreviousButtonListener(new previousButtonListener());
+        view.addNextButtonListener(new nextButtonListener());
+        view.addSelectAllButtonListener(new selectAllButtonListener());
+        view.addUnselectAllButtonListener(new unselectAllButtonListener());
+        view.addUnselectAllButtonListener(new unselectAllButtonListener());
+        view.addUndoToButtonListener(new undoToButtonListener());
+    }
+    
+    /** 
+    * On Ok makes the model store() the preferences and hides the view.
+    * 
+    */
+   class okButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {       
+           view.dispose();           
+       }
+   }
+  
+   /**
+    * On Cancel just hides the view.
+    *
+    */
+   class cancelButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+    	   view.dispose();
+       }
+   }
+   
+   /**
+    * On Help should call help.
+    *
+    */
+   class helpButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+    	   System.out.println("Tady se bude volat Help!");
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class previousButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+          
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class nextButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+          
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class selectAllButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+    	   int countRow = view.getTable().getRowCount();
+           for (int row=0; row < countRow; row++)
+           {
+         	  //System.out.println(view.getTable().getValueAt(row, 0));         	
+         	  view.getTable().setValueAt(true, row, 0);           	
+           } 
+           view.repaint();
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class unselectAllButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+    	   int countRow = view.getTable().getRowCount();
+           for (int row=0; row < countRow; row++)
+           {
+         	  //System.out.println(view.getTable().getValueAt(row, 0));         	  
+         	  view.getTable().setValueAt(false, row, 0);           	
+           }
+           view.repaint();
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class undoSelectedButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+          
+       }
+   }
+   
+   /**
+    * 
+    *
+    */
+   class undoToButtonListener implements ActionListener {
+       public void actionPerformed(ActionEvent actionEvent)
+       {
+          
+       }
+   }
+    
+
+}

Added: trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/history/HistoryTableModel.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -0,0 +1,88 @@
+package net.sf.plantlore.client.history;
+
+import javax.swing.DefaultCellEditor;
+import javax.swing.JCheckBox;
+import javax.swing.table.AbstractTableModel;
+
+/** 
+ *
+ * @author Lada
+ */
+public class HistoryTableModel extends AbstractTableModel
+{
+    private String[] columnNames = {"Mark", "Date", "User", "Item", "Old value", "New value"};
+    private Object[][] data;
+
+    public final static int MARK = 0;
+    public final static int DATE = 1; 
+    public final static int USER = 2;
+    public final static int ITEM = 3;
+    public final static int OLD_VALUE = 4;
+    public final static int NEW_VALUE = 5;
+    
+    /** Creates a new instance of HistoryTableModel */
+    public HistoryTableModel()
+    {    	
+    }
+
+    /** Creates a new instance of HistoryTableModel with data*/
+    public HistoryTableModel(Object[][] tableData)
+    {
+    	data = tableData;
+    }
+    
+    //povoleni editace sloupce pro vyber radku
+    public boolean isCellEditable(int row, int column) 
+    {
+    	if (column == MARK )
+    	{
+    		return true;
+    	}
+    	return false;
+    }
+    
+    //pro zmenu hodnoty v tabulce
+    public void setValueAt(Object value, int row, int column)
+    {
+        data[row][column] = value;
+    }
+ 
+    //vyzadam si hodnotu dane polozky
+    public Object getValueAt(int row, int column)
+    {
+        return data[row][column];
+    }    
+    
+    //vyzadam si pocet zobrazenych radku
+    public int getRowCount()
+    {
+        return data.length;
+    }
+    
+    public int getColumnCount()
+    {
+        return columnNames.length;
+    }
+
+    public String getColumnName(int column){
+        return columnNames[column];
+    }
+    
+    //nastaveni datoveho typu pro jednotlive sloupce
+    //implicitne je zobrazovan string
+    public Class getColumnClass(int column) {
+    	Class dataType = super.getColumnClass(column);
+    	if (column == MARK){
+    		dataType = Boolean.class;
+    	}
+    	//FIXME: do budoucna by sloupec DATE mel byt typu Date
+    	//else if (column == DATE){
+    	//	dataType = java.util.Date.class;
+    	//}
+    	else {
+    		dataType = String.class;
+    	}    		
+        return dataType;
+    }
+    
+}

Added: trunk/src/net/sf/plantlore/client/history/HistoryView.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-02-21 22:21:07 UTC (rev 41)
+++ trunk/src/net/sf/plantlore/client/history/HistoryView.java	2006-02-23 01:42:47 UTC (rev 42)
@@ -0,0 +1,435 @@
+package net.sf.plantlore.client.history;
+
+
+import java.awt.FlowLayout;
+import java.awt.GridBagConstraints;
+import java.awt.GridBagLayout;
+import java.awt.event.ActionListener;
+import java.awt.event.WindowListener;
+import java.util.Observable;
+import java.util.Observer;
+import javax.swing.AbstractAction;
+
+import javax.swing.JButton;
+import javax.swing.JCheckBox;
+import javax.swing.JComboBox;
+import javax.swing.JRadioButton;
+import javax.swing.JDialog;
+import javax.swing.JLabel;
+import javax.swing.JPanel;
+import javax.swing.JTable;
+import javax.swing.table.TableColumn;
+import javax.swing.table.TableColumnModel;
+import javax.swing.DefaultCellEditor;
+import javax.swing.table.DefaultTableModel;
+import javax.swing.table.AbstractTableModel;
+import javax.swing.JScrollPane;
+
+import net.sf.plantlore.common.ComponentAdjust;
+import net.sf.plantlore.common.record.OccurenceRecord;
+import net.sf.plantlore.l10n.L10n;
+
+/**
+ * 
+ * @author Lada
+ *
+ */
+public class HistoryView extends JDialog implements Observer {
+
+	private History model;
+	//Panels
+    private JPanel buttonsPane;
+    private JPanel infoRecordPanel;
+    private JPanel infoInsertPanel;
+    private JPanel infoEditPanel;
+    //Labels
+    private JLabel nameLabel;    
+    private JLabel authorLabel;
+    private JLabel locationLabel;    
+    private JLabel dateLabel;
+    private JLabel insertWhoLabel;
+    private JLabel nameValueLabel;
+    private JLabel authorValueLabel;
+    private JLabel locationValueLabel;
+    private JLabel dateValueLabel;
+    private JLabel insertWhoValueLabel;
+    //JTable
+    private JTable tableEditList;
+    private DefaultTableModel tableModel;
+    private JScrollPane jsp;
+    //data
+    private Object[][] dateTable;
+    //Buttons
+    private JButton nextButton;
+    private JButton previousButton;
+    private JButton selectAllButton;
+    private JButton unselectAllButton;
+    private JButton undoSelectedButton;
+    private JButton undoToButton;
+    private JButton okButton;
+    private JButton cancelButton;
+    private JButton helpButton;
+    
+    
+    /** Creates a new instance of HistoryView */
+    public HistoryView(History model)
+    {
+        this.model = model;
+        init();
+    }
+
+    public void update(Observable observable, Object object)
+    {
+    } 
+    
+    /** 
+     *
+     * The top initializing method.
+     *
+     */
+    private void init()
+    {
+    	//Set properties of this dialog
+    	setTitle(L10n.getString("History"));
+    	setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);    	
+        setSize(700,600);
+        setVisible(false);
+        
+        //initialization of the subPanel
+        initButtonsPane();
+        
+        //Layout (JDialog)
+        setLayout(new GridBagLayout());
+        GridBagConstraints gbConstraints;       
+        gbConstraints = new GridBagConstraints();
+            
+        //Add panel with information about record
+        infoRecordPanel = new JPanel();
+ 	    infoRecordPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Details of the record"));
+ 	    infoRecordPanel.setLayout(new java.awt.GridBagLayout()); 
+ 	    gbConstraints = new GridBagConstraints();
+        gbConstraints.gridy = 0;
+        gbConstraints.gridx = 0;       
+        gbConstraints.weighty = 0.1;
+        gbConstraints.weightx = 1.0;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        gbConstraints.anchor = GridBagConstraints.NORTH;
+        gbConstraints.fill = GridBagConstraints.BOTH;  
+        add(infoRecordPanel, gbConstraints);
+         
+        //Add panel with information about record created
+        infoInsertPanel = new JPanel();
+ 	    infoInsertPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("Record created"));
+ 	    infoInsertPanel.setLayout(new java.awt.GridBagLayout()); 
+ 	    gbConstraints = new GridBagConstraints();
+ 	    gbConstraints.gridy = 1;
+        gbConstraints.gridx = 0;
+        gbConstraints.weighty = 0.1;
+        gbConstraints.weightx = 1;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        gbConstraints.anchor = GridBagConstraints.NORTH;
+        gbConstraints.fill = GridBagConstraints.BOTH;  
+        add(infoInsertPanel, gbConstraints);
+        
+        //Add panel with list of changes
+        infoEditPanel = new JPanel();
+ 	    infoEditPanel.setBorder(javax.swing.BorderFactory.createTitledBorder("List of changes"));
+ 	    infoEditPanel.setLayout(new java.awt.GridBagLayout()); 
+ 	    gbConstraints = new GridBagConstraints();
+ 	    gbConstraints.gridy = 2;
+        gbConstraints.gridx = 0;
+        gbConstraints.weighty = 0.75;
+        gbConstraints.weightx = 1;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        gbConstraints.anchor = GridBagConstraints.NORTH;
+        gbConstraints.fill = GridBagConstraints.BOTH;  
+        add(infoEditPanel, gbConstraints);
+        
+        //Add panel with ok, cancle and help buttons
+        gbConstraints.gridy = 3;
+        gbConstraints.gridx = 0;
+        gbConstraints.weighty = 0.05;
+        gbConstraints.weightx = 1.0;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        gbConstraints.anchor = GridBagConstraints.SOUTHEAST;
+        add(buttonsPane, gbConstraints);
+       
+        // Add labels to the infoRecordPanel panel
+        nameLabel = new JLabel();
+        nameLabel.setText("Name:"); 
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 0;       
+        gbConstraints.weightx = 0.1;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
+        infoRecordPanel.add(nameLabel, gbConstraints);    
+        
+        nameValueLabel = new JLabel();
+        nameValueLabel.setText(model.getNamePlant());        
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 0;       
+        gbConstraints.weightx = 0.9;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
+        infoRecordPanel.add(nameValueLabel, gbConstraints);   
+        
+        authorLabel = new JLabel();
+        authorLabel.setText("Author:"); 
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 1;
+        gbConstraints.weightx = 0.1;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
+        infoRecordPanel.add(authorLabel, gbConstraints);
+        
+        authorValueLabel = new JLabel();
+        authorValueLabel.setText(model.getNameAuthor());   
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 1;
+        gbConstraints.weightx = 0.9;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
+        infoRecordPanel.add(authorValueLabel, gbConstraints);
+        
+        locationLabel = new JLabel();
+        locationLabel.setText("Location:");  
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 2;
+        gbConstraints.weightx = 0.1;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
+        infoRecordPanel.add(locationLabel, gbConstraints);
+        
+        locationValueLabel = new JLabel();
+        locationValueLabel.setText(model.getLocation());  
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 2;
+        gbConstraints.weightx = 0.9;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
+        infoRecordPanel.add(locationValueLabel, gbConstraints);
+
+        // Add labels to the infoInsertPanel panel
+        dateLabel = new JLabel();
+        dateLabel.setText("Date record creation:"); 
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 0;       
+        gbConstraints.weightx = 0.1;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
+        infoInsertPanel.add(dateLabel, gbConstraints);    
+        
+        dateValueLabel = new JLabel();
+        dateValueLabel.setText("getCreateWhen()");        
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 0;       
+        gbConstraints.weightx = 0.9;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
+        infoInsertPanel.add(dateValueLabel, gbConstraints);   
+        
+        insertWhoLabel = new JLabel();
+        insertWhoLabel.setText("User who record created:"); 
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 1;
+        gbConstraints.weightx = 0.1;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 10, 0, 0);
+        infoInsertPanel.add(insertWhoLabel, gbConstraints);
+        
+        insertWhoValueLabel = new JLabel();
+        insertWhoValueLabel.setText("getCreateWho()");   
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 1;
+        gbConstraints.weightx = 0.9;
+        gbConstraints.anchor = java.awt.GridBagConstraints.WEST;
+        gbConstraints.insets = new java.awt.Insets(0, 5, 0, 5);
+        infoInsertPanel.add(insertWhoValueLabel, gbConstraints);              
+        
+        // Add table to the infoEditPanel panel    
+        //!!!pro velke mnozstvi dat je lepsi pouzit AbstractTableModel, ktera umoznuje postupne nacitani do pameti
+        // defaultTableModel vytvari odkazy na vsechny zapouzdrene informace
+        
+        Object[][] data = model.getData();
+          
+        tableEditList = new JTable(new HistoryTableModel(data));
+        TableColumnModel tcm = tableEditList.getColumnModel();
+        TableColumn tc = tcm.getColumn(HistoryTableModel.MARK);
+        tc.setCellEditor(new MyCheckBoxEditor());
+        tableEditList.setPreferredScrollableViewportSize(new java.awt.Dimension(500, 100)); 
+        tableEditList.setAutoResizeMode(JTable.AUTO_RESIZE_ALL_COLUMNS);
+        jsp = new JScrollPane(tableEditList);                     
+
+        
+        gbConstraints = new java.awt.GridBagConstraints();
+        gbConstraints.gridx = 0;
+        gbConstraints.gridy = 0;
+        gbConstraints.anchor = java.awt.GridBagConstraints.CENTER;
+        gbConstraints.fill = java.awt.GridBagConstraints.BOTH;
+        gbConstraints.weightx = 1;        
+        gbConstraints.weighty = 0.7;  
+        gbConstraints.gridheight = 6;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        jsp.setMinimumSize(new java.awt.Dimension(500, 100));        
+        jsp.setPreferredSize(new java.awt.Dimension(500, 100));        
+        infoEditPanel.add(jsp, gbConstraints);
+        jsp.add(tableEditList);
+        jsp.setViewportView(tableEditList); 
+        
+        //Add buttons to the infoEditPanel panel       
+        previousButton = new JButton("Previous");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 4;   
+        gbConstraints.weighty = 0.1; 
+        gbConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        previousButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        previousButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(previousButton, gbConstraints);
+        
+        nextButton = new JButton("Next");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 5;         
+        gbConstraints.anchor = java.awt.GridBagConstraints.SOUTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        nextButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        nextButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(nextButton, gbConstraints);
+                
+        selectAllButton = new JButton("Select all");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 0;        
+        gbConstraints.anchor = java.awt.GridBagConstraints.NORTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        selectAllButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        selectAllButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(selectAllButton, gbConstraints);
+        
+        unselectAllButton = new JButton("Unselect all");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 1;        
+        gbConstraints.anchor = java.awt.GridBagConstraints.NORTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        unselectAllButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        unselectAllButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(unselectAllButton, gbConstraints);
+        
+        undoSelectedButton = new JButton("Undo selected secord");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 2;        
+        gbConstraints.anchor = java.awt.GridBagConstraints.NORTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        undoSelectedButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        undoSelectedButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(undoSelectedButton, gbConstraints);
+        
+        undoToButton = new JButton("Undo to selected record");
+        gbConstraints = new GridBagConstraints();
+        gbConstraints.gridx = 1;
+        gbConstraints.gridy = 3;        
+        gbConstraints.anchor = java.awt.GridBagConstraints.NORTH;
+        gbConstraints.insets = new java.awt.Insets(5, 5, 5, 5);
+        undoToButton.setMinimumSize(new java.awt.Dimension(110, 25));        
+        undoToButton.setPreferredSize(new java.awt.Dimension(110, 25));
+        infoEditPanel.add(undoToButton, gbConstraints);
+        
+    }   
+    
+    //editace bunky v tabulce
+    public class MyCheckBoxEditor extends DefaultCellEditor {
+        public MyCheckBoxEditor() {
+            super(new JCheckBox());
+        }               
+    }
+    
+    public JTable getTable()
+    {
+    	return this.tableEditList;
+    }
+    
+    /** 
+    *  Constructs the buttons pane.
+    */
+   private void initButtonsPane()
+   {
+       ComponentAdjust ca = new ComponentAdjust();
+              
+       okButton = new JButton(L10n.getString("Ok"));
+       cancelButton = new JButton(L10n.getString("Cancel"));
+       helpButton = new JButton(L10n.getString("Help"));
+       okButton.setActionCommand("OK");
+       cancelButton.setActionCommand("CANCEL");
+       helpButton.setActionCommand("HELP");
+       
+       ca.add(okButton);
+       ca.add(cancelButton);
+       ca.add(helpButton);
+       ca.setMaxWidth();
+       
+       buttonsPane = new JPanel();                    
+       buttonsPane.setLayout(new FlowLayout());
+       buttonsPane.add(okButton);
+       buttonsPane.add(cancelButton);
+       buttonsPane.add(helpButton);
+   }
+   
+   
+   /** Adds a listener to the whole window events.
+   *
+   */
+  public void addListener(WindowListener wl) 
+  {
+      addWindowListener(wl);
+  }  
+  
+  public void addOkButtonListener(ActionListener al) {
+     okButton.addActionListener(al);     
+  }  
+  
+  public void addCancelButtonListener(ActionListener al) {	     
+	     cancelButton.addActionListener(al);	     
+	  }  
+  
+  public void addHelpButtonListener(ActionListener al) {
+	     helpButton.addActionListener(al);
+	  }  
+  
+  public void addNextButtonListener(ActionListener al) {
+      nextButton.addActionListener(al);
+  }
+  
+  public void addPreviousButtonListener(ActionListener al) {
+      previousButton.addActionListener(al);
+  }
+  
+  public void addSelectAllButtonListener(ActionListener al) {
+      selectAllButton.addActionListener(al);
+  }
+  
+  public void addUnselectAllButtonListener(ActionListener al) {
+      unselectAllButton.addActionListener(al);
+  }
+  
+  public void addUndoSelectedButtonListener(ActionListener al) {
+      undoSelectedButton.addActionListener(al);
+  }
+  
+  public void addUndoToButtonListener(ActionListener al) {
+      undoToButton.addActionListener(al);
+  }
+}



From discontinuum at gmail.com  Sat Feb 25 22:17:52 2006
From: discontinuum at gmail.com (Erik Kratochvil)
Date: Sat, 25 Feb 2006 22:17:52 +0100
Subject: [Plantlore-dev] RMI - par poznamek
Message-ID: <f4dc39b90602251317m7e10420fgdb46cff3009e171a@mail.gmail.com>


-------------- next part --------------
A non-text attachment was scrubbed...
Name: RMI.odt
Type: application/octet-stream
Size: 20541 bytes
Desc: not available
URL: <https://lists.berlios.de/pipermail/plantlore-dev/attachments/20060225/d97c6c20/attachment.obj>

