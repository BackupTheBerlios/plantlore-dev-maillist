<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Plantlore-dev] r73 - in trunk/src/net/sf/plantlore: client client/authors client/history middleware server server/tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/plantlore-dev/2006-March/index.html" >
   <LINK REL="made" HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r73%20-%20in%20trunk/src/net/sf/plantlore%3A%20client%20client/authors%20client/history%20middleware%20server%20server/tools&In-Reply-To=%3C200603261225.k2QCPIWI025478%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000067.html">
   <LINK REL="Next"  HREF="000069.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Plantlore-dev] r73 - in trunk/src/net/sf/plantlore: client client/authors client/history middleware server server/tools</H1>
    <B>krater at berlios.de</B> 
    <A HREF="mailto:plantlore-dev%40lists.berlios.de?Subject=Re%3A%20%5BPlantlore-dev%5D%20r73%20-%20in%20trunk/src/net/sf/plantlore%3A%20client%20client/authors%20client/history%20middleware%20server%20server/tools&In-Reply-To=%3C200603261225.k2QCPIWI025478%40sheep.berlios.de%3E"
       TITLE="[Plantlore-dev] r73 - in trunk/src/net/sf/plantlore: client client/authors client/history middleware server server/tools">krater at berlios.de
       </A><BR>
    <I>Sun Mar 26 14:25:18 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000067.html">[Plantlore-dev] r72 - trunk/src/net/sf/plantlore/server
</A></li>
        <LI>Next message: <A HREF="000069.html">[Plantlore-dev] r74 - in trunk/src/net/sf/plantlore: client/authors middleware server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#68">[ date ]</a>
              <a href="thread.html#68">[ thread ]</a>
              <a href="subject.html#68">[ subject ]</a>
              <a href="author.html#68">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: krater
Date: 2006-03-26 14:25:09 +0200 (Sun, 26 Mar 2006)
New Revision: 73

Added:
   trunk/src/net/sf/plantlore/server/Guard.java
   trunk/src/net/sf/plantlore/server/Plantlore.java
   trunk/src/net/sf/plantlore/server/RMIServer.java
   trunk/src/net/sf/plantlore/server/RMIServerControl.java
   trunk/src/net/sf/plantlore/server/ServerView.java
   trunk/src/net/sf/plantlore/server/Undertaker.java
   trunk/src/net/sf/plantlore/server/tools/
   trunk/src/net/sf/plantlore/server/tools/RMI.java
Removed:
   trunk/src/net/sf/plantlore/client/Test.java
   trunk/src/net/sf/plantlore/server/DBLayer.java
   trunk/src/net/sf/plantlore/server/MyDBLayer.java
   trunk/src/net/sf/plantlore/server/Tracker.java
Modified:
   trunk/src/net/sf/plantlore/client/AppCore.java
   trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
   trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
   trunk/src/net/sf/plantlore/client/history/History.java
   trunk/src/net/sf/plantlore/middleware/DBLayer.java
   trunk/src/net/sf/plantlore/middleware/RMIDBLayerFactory.java
   trunk/src/net/sf/plantlore/middleware/RemoteDBLayerFactory.java
   trunk/src/net/sf/plantlore/server/ConnectionInfo.java
   trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
   trunk/src/net/sf/plantlore/server/RMIRemoteDBLayerFactory.java
   trunk/src/net/sf/plantlore/server/SelectQuery.java
   trunk/src/net/sf/plantlore/server/Server.java
Log:
Partial Commit. No Errors.

Modified: trunk/src/net/sf/plantlore/client/AppCore.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCore.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/client/AppCore.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -7,12 +7,13 @@
 
 package net.sf.plantlore.client;
 
+import java.rmi.RemoteException;
 import java.util.Observable;
 import java.util.prefs.Preferences;
 
 // Imports for temporary db access
 import net.sf.plantlore.client.dblayer.FirebirdDBLayer;
-import net.sf.plantlore.server.DBLayer;
+import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.server.DBLayerException;
 import net.sf.plantlore.server.HibernateDBLayer;
 
@@ -34,10 +35,12 @@
 //        database = new FirebirdDBLayer(&quot;localhost&quot;, &quot;3050&quot;, &quot;/mnt/data/temp/plantloreHIB.fdb&quot;, &quot;sysdba&quot;, &quot;masterkey&quot;);
         database = new HibernateDBLayer();
         try {
-            database.initialize();
+            database.initialize(null, null, null); // FIXME sem prijdou samosebou rozumne hodnoty
         } catch (DBLayerException e) {
             System.out.println(&quot;Error initializing database: &quot;+e.toString());
-        }                                                                                           
+        } catch(RemoteException e) {
+        	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+        }
         
     }
     

Modified: trunk/src/net/sf/plantlore/client/AppCoreCtrl.java
===================================================================
--- trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/client/AppCoreCtrl.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -12,9 +12,9 @@
 import java.awt.event.KeyEvent;
 import java.awt.event.WindowAdapter;
 import java.awt.event.WindowEvent;
+import java.rmi.RemoteException;
 import java.util.prefs.Preferences;
 import javax.swing.AbstractAction;
-import net.sf.plantlore.server.DBLayer;
 import net.sf.plantlore.server.DBLayerException;
 import net.sf.plantlore.client.dblayer.FirebirdDBLayer;
 import net.sf.plantlore.common.record.Plant;
@@ -29,6 +29,7 @@
 import net.sf.plantlore.client.history.HistoryCtrl;
 import net.sf.plantlore.client.history.HistoryView;
 import net.sf.plantlore.l10n.L10n;
+import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.server.HibernateDBLayer;
 
 import org.apache.log4j.Logger;
@@ -109,11 +110,13 @@
             DBLayer dbl = new HibernateDBLayer();
             try
             {
-                dbl.initialize();
+                dbl.initialize(null, null, null); // FIXME inicializace DB na dvou mistech?? zjistit proc
             } catch (DBLayerException ex)
             {
                 System.out.println(&quot;Exception while initializing DBLayer: &quot;+ex.getMessage());
                 ex.printStackTrace();
+            } catch(RemoteException e) {
+            	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
             }
             /*
             Query sq = new SelectQuery();

Deleted: trunk/src/net/sf/plantlore/client/Test.java
===================================================================
--- trunk/src/net/sf/plantlore/client/Test.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/client/Test.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,24 +0,0 @@
-package net.sf.plantlore.client;
-
-
-import net.sf.plantlore.middleware.*;
-
-public class Test {
-
-	public static void main(String[] args) {
-		try {
-			
-			DBLayerFactory factory = new RMIDBLayerFactory();
-			DBLayer db = factory.create();
-			
-			db.initialize();
-			
-			factory.destroy(db);
-			
-			
-			// Be ugly: while(1) factory.create(); // flooding
-					
-		} catch(Exception e) {}
-	}
-
-}

Modified: trunk/src/net/sf/plantlore/client/authors/AuthorManager.java
===================================================================
--- trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/client/authors/AuthorManager.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -7,11 +7,12 @@
 
 package net.sf.plantlore.client.authors;
 
+import java.rmi.RemoteException;
 import java.util.ArrayList;
 import java.util.Observable;
 import net.sf.plantlore.common.PlantloreConstants;
 import net.sf.plantlore.common.record.Author;
-import net.sf.plantlore.server.DBLayer;
+import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.server.DBLayerException;
 import net.sf.plantlore.client.dblayer.query.DeleteQuery;
 import net.sf.plantlore.client.dblayer.query.InsertQuery;
@@ -116,7 +117,7 @@
                 author.setUrl(url);
                 author.setNote(note);
                 // Execute query
-                int rowId;
+                int rowId = -1;
                 try {
                     // Execute query
                     rowId = database.executeInsert(author);
@@ -127,13 +128,15 @@
                     // Set operation state to finished
                     done = true;
                     return null;
-                }         
+                } catch(RemoteException e) {
+                	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                }
                 logger.info(&quot;Author &quot;+firstName+&quot; &quot;+surname+&quot; saved successfuly.&quot;);
                 if (isResultAvailable()) {                
                     searchAuthor();
                 }
                 done = true;
-                return rowId;
+                return rowId; // FIXME: Proc vracim rowId typu int, kdyz navratova hodnota je Object?
             }
         };
         worker.start();
@@ -158,6 +161,8 @@
                     // Set operation state to finished                    
                     done = true;       
                     return null;
+                } catch(RemoteException e) {
+                	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
                 }
                 // Execute author search - required in order to display up-to-date data in the table of authors
                 searchAuthor();                
@@ -183,7 +188,13 @@
                 // Operation not finished yet
                 done = false;                
                 // Create new Select query
-                SelectQuery query = database.createQuery(Author.class);
+                SelectQuery query;
+                try {
+                	query = database.createQuery(Author.class);
+                } catch(RemoteException e) {
+                	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                	return null;
+                }
                 if (searchName != null)
                     query.addRestriction(PlantloreConstants.RESTR_LIKE, &quot;firstName&quot;, null, &quot;%&quot;+searchName+&quot;%&quot;, null);
                 if (searchOrganization != null) 
@@ -268,7 +279,13 @@
                 logger.debug(&quot;Retrieving query results: &quot;+from+&quot; - &quot;+to);                
                 try {
                     // Retrieve selected row interval
-                    Object[] objArray = database.more(resultId, from, to);                
+                	Object[] objArray;
+                	try {
+                		objArray = database.more(resultId, from, to);
+                	} catch(RemoteException e) {
+                    	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
+                    	return;
+                    }
                     logger.debug(&quot;Results retrieved. Count: &quot;+objArray.length);
                     // Create storage for the results
                     this.data = new ArrayList(objArray.length);
@@ -332,11 +349,13 @@
     }
        
     public int getResultRows() {
-        if (resultId != 0) {
-            return database.getNumRows(resultId);
-        } else {
-            return 0;
+    	int result = 0;
+        if (resultId != 0) try {
+        	result = database.getNumRows(resultId);
+        } catch(RemoteException e) {
+        	System.err.println(&quot;Kdykoliv se pracuje s DBLayer nebo SelectQuery, musite hendlovat RemoteException&quot;);
         }
+        return result;
     }
     
     /**

Modified: trunk/src/net/sf/plantlore/client/history/History.java
===================================================================
--- trunk/src/net/sf/plantlore/client/history/History.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/client/history/History.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -4,7 +4,8 @@
 package net.sf.plantlore.client.history;
 
 import java.util.Observable;
-import net.sf.plantlore.server.DBLayer;
+
+import net.sf.plantlore.middleware.DBLayer;
 import net.sf.plantlore.server.DBLayerException;
 import net.sf.plantlore.client.dblayer.query.Query;
 import net.sf.plantlore.client.dblayer.query.SelectQuery;

Modified: trunk/src/net/sf/plantlore/middleware/DBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/middleware/DBLayer.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,3 +1,10 @@
+/*
+ * DBLayer.java
+ *
+ * Created on 14. leden 2006, 23:25
+ *
+ */
+
 package net.sf.plantlore.middleware;
 
 import java.io.Serializable;
@@ -3,10 +10,37 @@
 import java.rmi.Remote;
 import java.rmi.RemoteException;
+import net.sf.plantlore.client.dblayer.result.Result;
+import net.sf.plantlore.server.DBLayerException;
+import net.sf.plantlore.server.SelectQuery;
 
-/** The interface used for the communication with the (possibly remote) database. */
-public interface DBLayer extends Serializable, Remote {
-	
-	public void initialize() throws RemoteException;
-	public void close() throws RemoteException;
+/**
+ * Interface for database access.
+ * 
+ * TODO: Zdokumentovat metody interface!
+ *
+ * @author Tom&#225;&#353; Kova&#345;&#237;k, Erik Kratochv&#237;l
+ */
+public interface DBLayer extends Remote, Serializable {
+    
+    /** Initialize database connection */
+    void initialize(String dbID, String user, String password) throws DBLayerException, RemoteException;
+    
+    public int executeInsert(Object data) throws DBLayerException, RemoteException;
+    
+    public void executeDelete(Object data) throws DBLayerException, RemoteException;
+        
+    public void executeUpdate(Object data) throws DBLayerException, RemoteException;
+    
+    public Object[] more(int resultId, int from, int to) throws DBLayerException, RemoteException;
+    
+    public Object[] next(int resultId) throws DBLayerException, RemoteException;
 
+    public int getNumRows(int resultId) throws RemoteException;
+        
+    public void close(Result QRes) throws DBLayerException, RemoteException;
+    
+    public SelectQuery createQuery(Class classname) throws RemoteException;
+
+    public int executeQuery(SelectQuery query) throws DBLayerException, RemoteException;    
+        
 }

Modified: trunk/src/net/sf/plantlore/middleware/RMIDBLayerFactory.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/RMIDBLayerFactory.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/middleware/RMIDBLayerFactory.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -4,13 +4,10 @@
 import java.rmi.RemoteException;
 import java.rmi.registry.LocateRegistry;
 import java.rmi.registry.Registry;
-import java.util.Collection;
 import java.util.Hashtable;
-import java.util.Vector;
 
 import net.sf.plantlore.server.ConnectionInfo;
-import net.sf.plantlore.server.MyDBLayer;
-import net.sf.plantlore.server.Tracker;
+import net.sf.plantlore.server.HibernateDBLayer;
 import net.sf.plantlore.middleware.RemoteDBLayerFactory;
 
 
@@ -20,8 +17,12 @@
  * all the details how the DBLayer is created or where those objects really are.   
  * &lt;br/&gt;
  * The RMIDBLayerFactory keeps track of all database layers it has created and where they
- * were actually created. It implements the Tracker interface so that some managing tool can have a look
- * at the information about connections.
+ * were actually created.
+ * &lt;table&gt;
+ * &lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;th&gt;remote factory&lt;/th&gt;&lt;th&gt;database&lt;/th&gt;&lt;th&gt;stub&lt;/th&gt;&lt;th&gt;client&lt;/th&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;th&gt;local&lt;/th&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;&quot;localhost (direct connection)&quot;&lt;/td&gt;&lt;/tr&gt;
+ * &lt;tr&gt;&lt;th&gt;stub&lt;/th&gt;&lt;td&gt;yes&lt;/td&gt;&lt;td&gt;null&lt;/td&gt;&lt;td&gt;yes&lt;/td&gt;&lt;td&gt;&quot;localhost -&gt; server name&quot;&lt;/td&gt;&lt;/tr&gt;
+ * &lt;/table&gt;
  * 
  *  
  * TODO: Pou&#382;&#237;vat logger a property file, pokud dojde k n&#283;jak&#253;m v&#253;jimk&#225;m, je&#382; je nutno logovat.
@@ -30,20 +31,17 @@
  * @since 2006-03-11
  * @version 1.0 &#946; not tested
   */
-public class RMIDBLayerFactory implements DBLayerFactory, Tracker&lt;ConnectionInfo&gt; {
+public class RMIDBLayerFactory implements DBLayerFactory {
 
 	/** Keep information about connected clients. */
 	private Hashtable&lt;DBLayer, ConnectionInfo&gt; client = new Hashtable&lt;DBLayer, ConnectionInfo&gt;(10);
 	
 
-	/** Return all information about connected clients. */
-	public Collection&lt;ConnectionInfo&gt; getClients() { return new Vector&lt;ConnectionInfo&gt;(client.values()); }
-
 	/** Create a new local DBLayer. */
 	public DBLayer create() {
 		//Create a new DBLayer and save information about that connection 
-		DBLayer db = new MyDBLayer();
-		ConnectionInfo info = new ConnectionInfo(null, db, &quot;localhost (direct connection)&quot;);
+		DBLayer db = new HibernateDBLayer();
+		ConnectionInfo info = new ConnectionInfo(null, db, null, &quot;localhost (direct connection)&quot;);
 		client.put(db, info);
 		return db;
 	}
@@ -57,10 +55,10 @@
 	public DBLayer create(String host, short port) throws RemoteException, NotBoundException {
 		// Connect to the remote server and obtain the RemoteDBLayerFactory
 		Registry registry = LocateRegistry.getRegistry(host, port);
-		RemoteDBLayerFactory remoteFactory = (RemoteDBLayerFactory) registry.lookup(RemoteDBLayerFactory.RemoteFactoryID);
+		RemoteDBLayerFactory remoteFactory = (RemoteDBLayerFactory) registry.lookup(RemoteDBLayerFactory.ID);
 		// Get the stub from the remote factory and save the information about the connection
 		DBLayer stub = remoteFactory.create();
-		ConnectionInfo info = new ConnectionInfo(remoteFactory, stub, &quot;localhost -&gt; &quot; + host + &quot;:&quot; + port);
+		ConnectionInfo info = new ConnectionInfo(remoteFactory, null, stub, &quot;localhost -&gt; &quot; + host + &quot;:&quot; + port);
 		client.put(stub, info);
 		return stub;
 	}
@@ -69,11 +67,11 @@
 	 * Disconnect the dblayer from the server (and destroy the object on the server).
 	 */
 	public void destroy(DBLayer db) throws RemoteException {
-		assert(db != null);
-		db.close(); // close the connection
+		if(db == null) return;
 		ConnectionInfo info = client.remove(db);
-		// Destroy the remote object on the server
-		if(info != null &amp;&amp; info.getRemoteFactory() != null) info.getRemoteFactory().destroy(info.getDatabase());
+		if(info == null) return;
+		if(info.getRemoteFactory() != null) info.getRemoteFactory().destroy(info.getStub());
+		//else db.close(); // close the connection
 	}
 	
 

Modified: trunk/src/net/sf/plantlore/middleware/RemoteDBLayerFactory.java
===================================================================
--- trunk/src/net/sf/plantlore/middleware/RemoteDBLayerFactory.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/middleware/RemoteDBLayerFactory.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -13,7 +13,7 @@
 public interface RemoteDBLayerFactory extends Remote {
 	
 	/** The name the Remote Factory will be bound to. */
-	static final String RemoteFactoryID = &quot;PlantloreRemoteDBLayerFactoryID&quot;;
+	static final String ID = &quot;PlantloreRemoteDBLayerFactoryID&quot;;
 	
 	/** 
 	 * Create a new DBLayer on the server and return a remote reference of that object. 

Modified: trunk/src/net/sf/plantlore/server/ConnectionInfo.java
===================================================================
--- trunk/src/net/sf/plantlore/server/ConnectionInfo.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/ConnectionInfo.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -19,17 +19,19 @@
 	
 	private RemoteDBLayerFactory remoteFactory = null;
 	private DBLayer database = null;
+	private DBLayer stub = null;
 	private String clientHost = null;
 	
 	/**
 	 * Create a new record holding the information about the client's connection.
 	 * 
 	 * @param remoteFactory	The RemoteDBLayerFactory that created the remote object.
-	 * @param db	Either the remote object or the remote reference (stub) of that object.
+	 * @param db	 The remote object.
+	 * @param stub The remote reference (stub) of that object.
 	 * @param client		Host name of the computer where client dwells.
 	 */
-	public ConnectionInfo(RemoteDBLayerFactory remoteFactory, DBLayer db, String client) {
-		this.remoteFactory = remoteFactory; this.database = db; this.clientHost = client;
+	public ConnectionInfo(RemoteDBLayerFactory remoteFactory, DBLayer db, DBLayer stub, String client) {
+		this.remoteFactory = remoteFactory; this.database = db; this.stub = stub; this.clientHost = client;
 	}
 
 	/** The name of the host where the client is hiding. */
@@ -42,9 +44,12 @@
 	 * If it is null, the object is local. */
 	public RemoteDBLayerFactory getRemoteFactory() { return remoteFactory; }
 	
+	/** Stub. */
+	public DBLayer getStub() { return stub; }
+	
 	@Override
 	public String toString() {
-		return database + ((remoteFactory == null) ? &quot; (remote object)&quot; : &quot; (stub)&quot; );
+		return database + &quot; @ &quot; + clientHost;
 	}
 
 }

Deleted: trunk/src/net/sf/plantlore/server/DBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/DBLayer.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/DBLayer.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,44 +0,0 @@
-/*
- * DBLayer.java
- *
- * Created on 14. leden 2006, 23:25
- *
- */
-
-package net.sf.plantlore.server;
-
-import java.rmi.Remote;
-import java.util.Collection;
-import net.sf.plantlore.client.dblayer.query.InsertQuery;
-import net.sf.plantlore.client.dblayer.query.Query;
-import net.sf.plantlore.client.dblayer.result.Result;
-
-/**
- * Interface for database access.
- *
- * @author Tomas Kovarik
- */
-public interface DBLayer extends Remote {
-    
-    /** Initialize database connection */
-    void initialize() throws DBLayerException;
-    
-    public int executeInsert(Object data) throws DBLayerException;
-    
-    public void executeDelete(Object data) throws DBLayerException;
-        
-    public void executeUpdate(Object data) throws DBLayerException;
-    
-    public Object[] more(int resultId, int from, int to) throws DBLayerException;
-    
-    public Object[] next(int resultId) throws DBLayerException;
-
-    public int getNumRows(int resultId);
-        
-    public void close(Result QRes) throws DBLayerException;
-    
-    public SelectQuery createQuery(Class classname);
-
-    public int executeQuery(SelectQuery query) throws DBLayerException;    
-        
-}

Added: trunk/src/net/sf/plantlore/server/Guard.java
===================================================================
--- trunk/src/net/sf/plantlore/server/Guard.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/Guard.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,12 @@
+package net.sf.plantlore.server;
+
+import java.rmi.Remote;
+import java.rmi.RemoteException;
+
+public interface Guard extends Remote {
+	
+	final static String ID = &quot;PlantloreRMIServerGuard&quot;;
+
+	Server certify(String authorizationInfo) throws RemoteException;
+	
+}

Modified: trunk/src/net/sf/plantlore/server/HibernateDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/HibernateDBLayer.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -8,61 +8,64 @@
 package net.sf.plantlore.server;
 
 import java.io.File;
-import java.util.Collection;
+import java.rmi.server.Unreferenced;
 import java.util.Hashtable;
-import java.util.Iterator;
 import org.apache.log4j.Logger;
-import org.hibernate.FetchMode;
 import org.hibernate.HibernateException;
 import org.hibernate.ScrollableResults;
 import org.hibernate.Session;
 import org.hibernate.SessionFactory;
 import org.hibernate.cfg.Configuration;
-import net.sf.plantlore.client.dblayer.query.*;
 import net.sf.plantlore.client.dblayer.result.Result;
-import net.sf.plantlore.common.record.*;
+import net.sf.plantlore.middleware.DBLayer;
+
 import org.hibernate.Transaction;
-import java.util.List;
-import org.hibernate.criterion.DetachedCriteria;
-import org.hibernate.criterion.Order;
-import org.hibernate.criterion.Projections;
-import org.hibernate.criterion.Restrictions;
-import net.sf.plantlore.common.PlantloreConstants;
 
+
 /**
  *  Implementation of DBLayer using Hibernate OR mapping to access the database.
  *
- *  @author Tomas Kovarik
+ *  @author Tom&#225;&#353; Kova&#345;&#237;k (database parts), Erik Kratochv&#237;l (rmi parts)
+ *  @version far from ready
  */
-public class HibernateDBLayer implements DBLayer {
+public class HibernateDBLayer implements DBLayer, Unreferenced {
     /** Instance of a logger */
     private Logger logger;
     /** Configuration file for Hibernate */
     private File configFile;   
     /** Hibernate session */
     private Session session;
-    /** Query object used for building SELECT queries */
-    private DetachedCriteria query;
     /** Pool of select queries */        
-    private Hashtable results;
+    private Hashtable&lt;Integer, ScrollableResults&gt; results;
     /** Maximum result ID used */
     private int maxResultId;
     
+    /** Creates a new instance of HibernateDBLayer.
+     * 
+     *  @param undertaker The object that is responsible for cleanup if the client crashes. 
+     */
+    public HibernateDBLayer(Undertaker undertaker) {
+    	this();
+    	this.undertaker = undertaker; 
+    }
+    
     /** Creates a new instance of HibernateDBLayer */
     public HibernateDBLayer() {
         logger = Logger.getLogger(this.getClass().getPackage().getName());        
-        // Initialize pool of select queries
-        results = new Hashtable();
+        // Initialize pool of select queries, initial capacity = 8
+        results = new Hashtable&lt;Integer, ScrollableResults&gt;(8); 
         // Initialize maximum result id
         maxResultId = 0;
     }    
     
     /**
      *  Initialize database connection. Fire up Hibernate and open a session.
-     *
+     *  
+     *  FIXME prepracovat initialize tak, aby pouzival zaslane informace &amp; nacitala prava!
+     *  
      *  @throws DBLayerException when the hibernate or database connection cannot be initialized
      */
-    public void initialize() throws DBLayerException {
+    public void initialize(String dbID, String user, String password) throws DBLayerException {
         Configuration cfg;
         // File containing Hibernate configuration
         configFile = new File(&quot;hibernate.cfg.xml&quot;);        
@@ -73,6 +76,7 @@
             logger.fatal(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());
             throw new DBLayerException(&quot;Cannot load Hibernate configuration. Details: &quot;+e.getMessage());            
         }
+        
         cfg.setProperty(&quot;hibernate.connection.url&quot;, &quot;jdbc:firebirdsql:localhost/3050:c:/Kovo/DatabaseTest/database/plantlore.fdb&quot;);
         cfg.setProperty(&quot;hibernate.connection.username&quot;, &quot;sysdba&quot;);
         cfg.setProperty(&quot;hibernate.connection.password&quot;, &quot;masterkey&quot;);        
@@ -180,7 +184,7 @@
             throw new DBLayerException(&quot;Cannot read rows starting at the given index: &quot;+from);            
         }
         // Get results for the given resultId
-        ScrollableResults res = (ScrollableResults)results.get(resultId);
+        ScrollableResults res = results.get(resultId);
         // Move ResultSet to the first row we want to read. In case we want to read the first row,
         // move the pointer before the first row, else move it to the given position
         try {
@@ -221,7 +225,7 @@
      */
     public Object[] next(int resultId) throws DBLayerException {
         // Get results for the given resultId
-        ScrollableResults res = (ScrollableResults)results.get(resultId);
+        ScrollableResults res = results.get(resultId);
         // In case no more rows are available, return null
         try {
             if (!res.next()) {
@@ -236,7 +240,7 @@
     
     public int getNumRows(int resultId) {
         // Get results for the given resultId
-        ScrollableResults res = (ScrollableResults)results.get(resultId);        
+        ScrollableResults res = results.get(resultId);        
         int currentRow = res.getRowNumber();
         res.afterLast();
         int numRows = res.getRowNumber();
@@ -268,6 +272,9 @@
      */
     public SelectQuery createQuery(Class classname) {
         SelectQuery query = new SelectQuery(session.createCriteria(classname));
+        // TODO Tady se objekt query zaregistruje a exportuje pro remote usage.
+        
+        
         return query;
     }    
     
@@ -298,4 +305,17 @@
         results.put(maxResultId, res);
         return maxResultId;
     }
+    
+    
+    
+    
+    
+    
+    //===============================================================
+    // What happens to unreferenced objects? They get buried by the untertaker!
+    
+	private Undertaker undertaker = null;
+	public void unreferenced() { if(undertaker != null) undertaker.bury(this); }
+	//===============================================================
+	      
 }
\ No newline at end of file

Deleted: trunk/src/net/sf/plantlore/server/MyDBLayer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/MyDBLayer.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/MyDBLayer.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,20 +0,0 @@
-package net.sf.plantlore.server;
-
-import java.rmi.RemoteException;
-
-import net.sf.plantlore.middleware.DBLayer;
-
-/** Only a test. This class will be replaced with Kovo's database layer (much more sophisticated, at least we hope). */
-public class MyDBLayer implements DBLayer {
-
-	
-	public void initialize() throws RemoteException {
-		System.out.println(&quot;initialized&quot;);
-	}
-
-	
-	public void close() throws RemoteException {
-		System.out.println(&quot;destroyed&quot;);
-	}
-
-}

Added: trunk/src/net/sf/plantlore/server/Plantlore.java
===================================================================
--- trunk/src/net/sf/plantlore/server/Plantlore.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/Plantlore.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,9 @@
+package net.sf.plantlore.server;
+
+public class Plantlore {
+
+	public static void main(String[] args) {
+		
+	}
+
+}

Modified: trunk/src/net/sf/plantlore/server/RMIRemoteDBLayerFactory.java
===================================================================
--- trunk/src/net/sf/plantlore/server/RMIRemoteDBLayerFactory.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/RMIRemoteDBLayerFactory.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -8,11 +8,12 @@
 import java.util.Vector;
 
 import net.sf.plantlore.middleware.DBLayer;
+import net.sf.plantlore.server.HibernateDBLayer;
 import net.sf.plantlore.middleware.RemoteDBLayerFactory;
 
 /**
  * RMIRemoteDBLayerFactory is responsible for creating and exporting instances of DBLayer.
- * Remote references to these objects are returned to the caller. 
+ * Remote references to these objects are returned to the caller. All methods are synchronized. 
  * &lt;br/&gt;
  * The proper way to disconnect all remote clients from the server has these steps:
  * &lt;ol&gt;
@@ -24,31 +25,36 @@
  * connections effectively&lt;/li&gt;
  * &lt;/ol&gt;
  * 
- * FIXME: Ov&#283;&#345;it, jestli n&#225;hodou nen&#237; mo&#382;n&#233; tento objekt pomoc&#237; reflection proskenovat a zavolat metodu
- * disconnectAll(). Nem&#283;lo by to j&#237;t, ale je pot&#345;eba se ujistit! Je-li to mo&#382;n&#233;, je nutn&#233; metodu odstranit! 
- * 
  * TODO: Pou&#382;&#237;vat logger a property file, pokud dojde k n&#283;jak&#253;m v&#253;jimk&#225;m, je&#382; je nutno logovat.
+ * TODO:  maxConnectionsPerIP &amp; maxConnectionsTotal by se asi m&#283;ly na&#269;&#237;tat z n&#283;jak&#233;ho config souboru.
  * 
  * @author Erik Kratochv&#237;l
  * @since 2006-03-13
- * @version 1.0
+ * @version 1.0 
  */
 public class RMIRemoteDBLayerFactory extends UnicastRemoteObject
-	implements RemoteDBLayerFactory, Tracker&lt;ConnectionInfo&gt; {
+	implements RemoteDBLayerFactory, Undertaker {
 	
+	
+	
 	/** Maximum number of connections from one IP. */
 	private int maxConnectionsPerIP = 1;
 	
+	/** Maximum number of clients. */
+	private int maxConnectionsTotal = 8;
+	
 	/** Keep information about connected clients. */
-	private Hashtable&lt;DBLayer, ConnectionInfo&gt; client = new Hashtable&lt;DBLayer, ConnectionInfo&gt;(10);
+	private Hashtable&lt;DBLayer, ConnectionInfo&gt; client = 
+		new Hashtable&lt;DBLayer, ConnectionInfo&gt;(maxConnectionsTotal);
 	
-	/** Create a new RMIDBLayerFactory.
+	/** 
+	 * Create a new RMIDBLayerFactory.
 	 * @throws RemoteException If the RMI encounters an error.
 	 */
 	public RMIRemoteDBLayerFactory() throws RemoteException {}
 	
 	/** Return all information about connected clients. */
-	public Collection&lt;ConnectionInfo&gt; getClients() { return new Vector&lt;ConnectionInfo&gt;(client.values()); }
+	public synchronized Collection&lt;ConnectionInfo&gt; getClients() { return new Vector&lt;ConnectionInfo&gt;(client.values()); }
 	
 	/**
 	 *  Shall the server open another conenction for the host?
@@ -57,6 +63,7 @@
 	 * @return	True if the connection should be allowed.
 	 */
 	private boolean allowConnection(String host) {
+		if(client.size() &gt;= maxConnectionsTotal) return false;
 		int c = 0;
 		for(ConnectionInfo info : client.values())
 			if(info.getClientHost().equalsIgnoreCase(host)) c++; // HA! C++ in Java! Strange!
@@ -69,51 +76,63 @@
 	 * @return Remote reference (stub) of the remote DBLayer object.
 	 * @throws RemoteException If the RMI encounters an error.
 	 */
-	public DBLayer create() throws RemoteException {
+	public synchronized DBLayer create() throws RemoteException {
 		// Apply the connection policy ~ see AllowConnection(host)
 		String clientHost = &quot;unable to comply&quot;;
 		try { clientHost = RemoteServer.getClientHost(); } catch(Exception e) {}
-		if( !allowConnection(clientHost) ) throw new RemoteException(&quot;Too many connections from this IP!&quot;);
-		// Create a new DBLayer, export it, and keep the stub.
-		DBLayer database = new MyDBLayer();
+		if( !allowConnection(clientHost) ) 
+			throw new RemoteException(&quot;Too many connections from this IP (or the server is full)!&quot;);
+		// Create a new DBLayer, export it, and keep the stub. Also set the Undertaker of this object.
+		DBLayer database = new HibernateDBLayer(this);
 		DBLayer stub = (DBLayer) UnicastRemoteObject.exportObject(database);
 		// Save the information about this connection.
-		ConnectionInfo info = new ConnectionInfo(null, database, clientHost);
+		ConnectionInfo info = new ConnectionInfo(null, database, stub, clientHost); // remoteFactory is null because of security reasons.
 		client.put(stub, info);
+
 		return stub;
 	}
 	
 	/**
 	 * Disconnect the DBLayer from the server and unexport the object to prevent it from
-	 * accepting more remote calls.
+	 * accepting more remote calls. 
 	 * 
-	 * @param db	The DBLayer that should be disconnected (from the database server and RMI middleware).
+	 * @param db	The DBLayer object (not stub!) that should be disconnected.
 	 * @throws RemoteException If the RMI encounters an error.
 	 */	
-	private void disconnect(DBLayer db)  throws RemoteException {
-		assert(db != null);
-		db.close(); // duplicate!
+	protected void disconnect(DBLayer db)  throws RemoteException {
+		if(db == null) return;
+		//db.close();
 		// Unexport the object even if there is an action in progress.
 		UnicastRemoteObject.unexportObject(db, true);
 	}
 
 	/**
-	 * Destroy the remote object associated with the stub. 
+	 * Destroy the remote object associated with the stub (and remove it from the list of connected clients).
 	 * 
 	 * @param stub The remote reference to the remote object that is to be destroyed.
 	 * @throws RemoteException If the RMI encounters an error.
 	 */	
-	public void destroy(DBLayer stub) throws RemoteException {
+	public synchronized void destroy(DBLayer stub) throws RemoteException {
 		ConnectionInfo info = client.remove(stub);
-		if(info != null &amp;&amp; info.getDatabase() != null)
-			disconnect(info.getDatabase());
+		if(info != null) disconnect(info.getDatabase());
 	}
 	
 	/** Terminate the connection of all connected clients. */
-	public void disconnectAll() {
-		for (ConnectionInfo info : client.values()) {
-			try { disconnect(info.getDatabase()); } catch (Exception e) {}
-		}
+	public synchronized void disconnectAll() {
+		for (ConnectionInfo info : client.values()) 
+			try { disconnect(info.getDatabase()); } catch (Exception e) {}		
+		// Clear the list of opened connections - none is now opened.
+		client.clear();
 	}
+	
+	/** Take care of DBLayer whose client has &quot;crashed&quot;. */
+	public synchronized void bury(DBLayer database) {
+		DBLayer stub = null;
+		for(ConnectionInfo info : client.values())
+			if(info.getDatabase().equals(database)) { stub = info.getStub(); break; }
+		try { destroy(stub); } catch(RemoteException e) { /* eat */}
+	}
+	
 
+
 }

Added: trunk/src/net/sf/plantlore/server/RMIServer.java
===================================================================
--- trunk/src/net/sf/plantlore/server/RMIServer.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/RMIServer.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,138 @@
+package net.sf.plantlore.server;
+
+import java.rmi.AlreadyBoundException;
+import java.rmi.RemoteException;
+import java.rmi.registry.LocateRegistry;
+import java.rmi.registry.Registry;
+import java.rmi.server.UnicastRemoteObject;
+import java.util.Collection;
+
+import net.sf.plantlore.middleware.RemoteDBLayerFactory;
+import net.sf.plantlore.server.tools.*;
+
+/**
+ * The &quot;starter&quot; class. This class is capable of binding a particular implementation
+ * of the RemoteDBLayer interface to the rmiregistry. 
+ * &lt;br/&gt;
+ *  The server is terminated
+ *  &lt;=&gt; 
+ *  All remote objects that has been exported are unexported.
+ *  
+ * TODO: Pou&#382;&#237;t p&#345;i oznamov&#225;n&#237; chyb Logger. Chyby by se m&#283;ly zobrazovat lokalizovan&#283; - pou&#382;&#237;t odpov&#237;daj&#237;c&#237; property file.
+ * 
+ * 
+ * @see RemoteDBLayerFactory, RMIDBLayerFactory
+ * @author Erik Kratochv&#237;l
+ * @since 2006-03-11
+ * @version 0.9 Under construction
+ */
+public class RMIServer extends UnicastRemoteObject implements Server&lt;ConnectionInfo&gt; {
+	
+	/** The default port where the rmiregistry listens. To that rmiregistry the RemoteDBLayerFactory will be bound to. */
+	public static final int DEFAULT_PORT = Registry.REGISTRY_PORT;
+	
+	private RMIRemoteDBLayerFactory remoteFactory = null;
+	private int port = DEFAULT_PORT;
+	private Guard guard = null;
+
+	/** Create a new instance of RMIServer running on the default port. */
+	public RMIServer() throws RemoteException, AlreadyBoundException {
+		this(DEFAULT_PORT);
+	}
+	
+	/** Create a new instance of RMIServer running on the specified port. */
+	public RMIServer(int port) throws RemoteException, AlreadyBoundException { 
+		this.port = port;
+		// Control object that will return the server after the client passed a valid certif. information
+		guard = new RMIServerControl(this);
+		RMI.bind(port, guard, Guard.ID);
+	}
+	
+	/** Get the information about the connected clients. */
+	public synchronized Collection&lt;ConnectionInfo&gt; getClients() { return remoteFactory.getClients(); }
+
+	/**
+	 * Disconnect the selected client.
+	 * 
+	 * @param client The client to be kicked.
+	 */
+	public synchronized void disconnect(ConnectionInfo client) {
+		try { remoteFactory.destroy(client.getStub()); } catch(RemoteException e) {}
+	}
+	
+	/** 
+	 * Bind a new RemoteDBLayerFactory to the rmiregistry on the specified &lt;code&gt;port&lt;/code&gt;. 
+	 * If the rmiregistry is not currently running on that port, it will be created. 
+	 * 
+	 * @return The RemoteDBLayerFactory.
+	 * @throws AlreadyBoundException If another RemoteDBLayerFactory is already bound to the rmiregistry. 
+	 */
+	public synchronized void start() throws AlreadyBoundException {
+		try {
+			// Locate (or start) the rmiregistry on the specified port
+			Registry registry;
+			try {	registry = LocateRegistry.createRegistry(port); }
+			catch(Exception e) { registry = LocateRegistry.getRegistry(port); }
+			// Create a new factory or reuse an existing one.
+			if(remoteFactory == null) remoteFactory = new RMIRemoteDBLayerFactory();
+			// Bind the factory to the rmiregistry. 
+			registry.bind(RemoteDBLayerFactory.ID, remoteFactory);
+		}
+		catch(RemoteException e) { System.err.println(e); } // FIXME: use logger
+	}
+	
+	/** 
+	 * Unbind the RemoteDBLayerFactory from the rmiregistry on the specified &lt;code&gt;port&lt;/code&gt;. 
+	 * The rmiregistry on the specified port is &lt;b&gt;not&lt;/b&gt; stopped, because some other programs may be still
+	 * using it!
+	 * 
+	 * FIXME: Krom toho stejn&#283; neum&#237;m rmiregistry ukon&#269;it pomoc&#237; javy.
+	 * 
+	 * @param harsh		Be harsh and disconnect every client connected to the server.
+	 */
+	public synchronized void stop(boolean harsh) {
+		if(remoteFactory == null) return;
+		try {
+			// 1. Unbind the RemoteDBLayerFactory from the rmiregistry 
+			// -&gt; noone can obtain the stub of the remote factory anymore
+			RMI.unbind(port, RemoteDBLayerFactory.ID);
+			
+			// 2. Unexport the remote factory -&gt; noone can make a remote call anymore
+			RMI.unexport(remoteFactory);
+			
+			// 3. Disconnect all users from the server.
+			if(harsh) remoteFactory.disconnectAll();
+
+			// 4. Disconnect this object from the RMI -&gt;
+			UnicastRemoteObject.unexportObject(this, true);
+			
+			// 5. Disconnect the control guard and unexport it
+			RMI.unbind(port, Guard.ID);
+			RMI.unexport(guard);
+		}
+		catch(Exception e) { System.err.println(e); } // FIXME: use logger
+	}
+	
+	
+	/** 
+	 * Initialize the codebase java.rmi.server.property to the specified directory or the
+	 * current working directory if the specified directory is null.
+	 * 
+	 *  @param directory	The directory that shall serve as a codebase. */
+	public static void initialize(String directory) {
+		String codebase = &quot;file:/&quot; + ((directory != null) ? directory : System.getProperty(&quot;user.dir&quot;)) + &quot;/&quot;;
+		codebase = codebase.replaceAll(&quot; &quot;, &quot;%20&quot;); // to prevent the MalformedURLException
+		System.setProperty(&quot;java.rmi.server.codebase&quot;, codebase);
+		System.out.println(&quot;java.rmi.server.codebase = &quot; + codebase);
+		
+		System.setProperty(&quot;java.rmi.dgc.leaseValue&quot;, &quot;30000&quot;); // 30 seconds, just for DEBUG.REASONS
+	}
+	
+	
+	/** Static initialization. */
+	static {
+		initialize(null);
+	}
+	
+
+}

Added: trunk/src/net/sf/plantlore/server/RMIServerControl.java
===================================================================
--- trunk/src/net/sf/plantlore/server/RMIServerControl.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/RMIServerControl.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,19 @@
+package net.sf.plantlore.server;
+
+import java.rmi.RemoteException;
+import java.rmi.server.UnicastRemoteObject;
+
+public class RMIServerControl extends UnicastRemoteObject implements Guard {
+	
+	private Server server;
+
+	public RMIServerControl(Server server) throws RemoteException {
+		this.server = server;
+	}
+	
+	public Server certify(String authorizationInfo) throws RemoteException {
+		if(authorizationInfo.equals(&quot;poweroverwhelming&quot;)) return server;
+		return null;
+	}
+	
+}

Modified: trunk/src/net/sf/plantlore/server/SelectQuery.java
===================================================================
--- trunk/src/net/sf/plantlore/server/SelectQuery.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/SelectQuery.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -8,6 +8,7 @@
 package net.sf.plantlore.server;
 
 import java.io.Serializable;
+import java.rmi.Remote;
 import java.util.Collection;
 import net.sf.plantlore.common.PlantloreConstants;
 import org.hibernate.Criteria;
@@ -18,9 +19,9 @@
 
 /**
  *
- * @author Tomas Kovarik
+ * @author Tom&#225;&#353; Kova&#345;&#237;k, Erik Kratochv&#237;l
  */
-public class SelectQuery implements Serializable {
+public class SelectQuery implements Serializable, Remote {
     Criteria criteria;
     
     /** Creates a new instance of Selectcriteria */

Modified: trunk/src/net/sf/plantlore/server/Server.java
===================================================================
--- trunk/src/net/sf/plantlore/server/Server.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/Server.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,91 +1,16 @@
 package net.sf.plantlore.server;
 
+import java.io.Serializable;
 import java.rmi.AlreadyBoundException;
+import java.rmi.Remote;
 import java.rmi.RemoteException;
-import java.rmi.registry.LocateRegistry;
-import java.rmi.registry.Registry;
-import java.rmi.server.UnicastRemoteObject;
+import java.util.Collection;
 
-import net.sf.plantlore.middleware.RemoteDBLayerFactory;
-
-/**
- * The &quot;starter&quot; class. This class is capable of binding a particular implementation
- * of the RemoteDBLayer interface to the rmiregistry. 
- * &lt;br/&gt;
- *  If the server is terminated, all remote objects that live within the server's memory are destroyed as well!
- *  
- * TODO: 
- * 1. Pou&#382;&#237;t p&#345;i oznamov&#225;n&#237; chyb Logger. 
- * 2. Chyby by se m&#283;ly zobrazovat lokalizovan&#283; - pou&#382;&#237;t odpov&#237;daj&#237;c&#237; property file.
- * 
- * 
- * @see RemoteDBLayerFactory, RMIDBLayerFactory
- * @author Erik Kratochv&#237;l
- * @since 2006-03-11
- * @version 0.9 Under construction
- */
-public class Server {
+public interface Server&lt;E&gt; extends Remote, Serializable {
 	
-	/** The default port where the rmiregistry listens. To that rmiregistry the RemoteDBLayerFactory will be bound to. */
-	public static final short DEFAULT_PORT = Registry.REGISTRY_PORT;
+	Collection&lt;? extends E&gt;	getClients() throws RemoteException;
+	void disconnect(E client) throws RemoteException;
+	void start() throws RemoteException, AlreadyBoundException;
+	void stop(boolean harsh) throws RemoteException;
 	
-	/** Initialize the codebase java.rmi.server.property to the specified directory or the
-	 * current working directory if the specified directory is null. */
-	public static void initialize(String directory) {
-		String codebase = &quot;file:/&quot; + ((directory != null) ? directory : System.getProperty(&quot;user.dir&quot;)) + &quot;/&quot;;
-		codebase = codebase.replaceAll(&quot; &quot;, &quot;%20&quot;); // to prevent the MalformedURLException
-		System.setProperty(&quot;java.rmi.server.codebase&quot;, codebase);
-	}
-
-	/** 
-	 * Bind a new RemoteDBLayerFactory to the rmiregistry on the specified &lt;code&gt;port&lt;/code&gt;. 
-	 * If the rmiregistry is not currently running on that port, it will be created. 
-	 * 
-	 * @return The RemoteDBLayerFactory &lt;b&gt;object&lt;/b&gt; (not stub!) that has been bound to the rmiregistry or null if the call was unsuccessful.
-	 * @throws AlreadyBoundException If another RemoteDBLayerFactory is already bound to the rmiregistry. 
-	 */
-	public static RemoteDBLayerFactory start(short port) throws AlreadyBoundException {
-		RemoteDBLayerFactory remoteFactory = null;
-		try {
-			// Locate (or start) the rmiregistry on the specified port
-			Registry registry;
-			try {	registry = LocateRegistry.createRegistry(port); }
-			catch(Exception e) { registry = LocateRegistry.getRegistry(port); }
-			// Rebind a new factory. This can be potentially dangerous as 
-			remoteFactory = new RMIRemoteDBLayerFactory();
-			registry.bind(RemoteDBLayerFactory.RemoteFactoryID, remoteFactory);
-		}
-		catch(RemoteException e) { System.err.println(e); } // FIXME: use logger
-		
-		return remoteFactory;
-	}
-	
-	/** Unbind the RemoteDBLayerFactory from the rmiregistry on the specified &lt;code&gt;port&lt;/code&gt;. 
-	 * The rmiregistry on the specified port is &lt;b&gt;not&lt;/b&gt; stopped, because some other programs may be still
-	 * using it!
-	 * &lt;hr/&gt; 
-	 * Note: The RemoteDBLayerFactory is not destroyed either! It is because some clients may have some opened
-	 * connections and they may ask the RemoteDBLayerFactory do destroy their DBLayer objects eventually. 
-	 * The RemoteDBLayerFactory will
-	 * be &lt;i&gt;destroyed&lt;/i&gt; (here it means &lt;i&gt;becomes unaccessible&lt;/i&gt;) 
-	 * when all clients are disconnected (i.e. when they forget their remote references to the RemoteDBLayerFactory), 
-	 * because only then all references and remote references will be lost
-	 * -&gt; the garbage collector will be able to sweep it.
-	 */
-	public static void stop(RemoteDBLayerFactory remoteFactory, short port) {
-		try {
-			// 1. Unbind the RemoteDBLayerFactory from the rmiregistry 
-			// -&gt; noone can obtain the stub of the remote factory anymore
-			Registry registry = LocateRegistry.getRegistry(port);
-			registry.unbind(RemoteDBLayerFactory.RemoteFactoryID);
-			// 2. Unexport the remote factory -&gt; noone can make a remote call anymore
-			UnicastRemoteObject.unexportObject(remoteFactory, true);
-			// 3. Disconnect all users from the server.
-			/* SHALL I? */
-		}
-		catch(Exception e) { System.err.println(e); } // FIXME: use logger
-	}
-	
-
-
 }

Added: trunk/src/net/sf/plantlore/server/ServerView.java
===================================================================
--- trunk/src/net/sf/plantlore/server/ServerView.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/ServerView.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,93 @@
+package net.sf.plantlore.server;
+
+import java.awt.*;
+import java.awt.event.*;
+import java.util.Observable;
+import java.util.Observer;
+
+import javax.swing.*;
+
+
+public class ServerView implements Observer {
+	
+	private JList list;
+	private RMIServer model;
+	
+	
+	public ServerView(RMIServer model) {
+		this.model = model;
+	}
+	
+	
+	private class LeftAction extends AbstractAction {
+		
+	    public LeftAction(String text, ImageIcon icon, String desc, Integer mnemonic) {
+	        super(text, icon);
+	        putValue(SHORT_DESCRIPTION, desc);
+	        putValue(MNEMONIC_KEY, mnemonic);
+	    }
+	    
+	    public void actionPerformed(ActionEvent e) {
+	        Object o = list.getSelectedValue();
+	        if(o != null) {
+	        	ConnectionInfo client = (ConnectionInfo) o;
+	        	System.out.println(&quot;disconnecting &quot; + client);
+	        	model.disconnect(client);
+	        }
+	    }
+	}
+	
+	private void createGUI() {
+		// Create and set up the window.
+        JFrame frame = new JFrame(&quot;Planlore server&quot;);
+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
+        
+        list = new JList();
+        JScrollPane listScroll = new JScrollPane(list);
+        listScroll.setPreferredSize(new Dimension(350, 80));
+        
+        JPanel panel = new JPanel();
+        panel.setLayout(new FlowLayout(FlowLayout.RIGHT));
+        JButton disconnect = new JButton(new LeftAction(&quot;Disconnect&quot;, null, &quot;Disconnect selected clients from the server.&quot;, KeyEvent.VK_D));
+        panel.add(disconnect);
+        
+        frame.getContentPane().add(listScroll, BorderLayout.CENTER);
+        frame.getContentPane().add(panel, BorderLayout.SOUTH);
+        
+        frame.pack();
+        frame.setVisible(true);
+	}
+
+	
+
+	
+	
+	public void update(Observable observed, Object arg) {
+		list.setListData(model.getClients().toArray());
+	}
+
+
+
+	
+	
+	
+	public static void main(String[] args) {
+		// Set beautiful Windows look &amp; feel.
+        String lookAndFeel = UIManager.getSystemLookAndFeelClassName();
+        try { UIManager.setLookAndFeel(lookAndFeel); }
+        catch (Exception e) { JFrame.setDefaultLookAndFeelDecorated(true); }
+        
+        
+        try{
+        	RMIServer model = new RMIServer();
+        	ServerView view = new ServerView(model);
+        	view.createGUI();
+        	model.start();
+        	
+        } catch(Exception e) { System.err.println(e); }
+        
+        
+        
+	}
+	
+}

Deleted: trunk/src/net/sf/plantlore/server/Tracker.java
===================================================================
--- trunk/src/net/sf/plantlore/server/Tracker.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/Tracker.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -1,9 +0,0 @@
-package net.sf.plantlore.server;
-
-import java.util.Collection;
-
-public interface Tracker&lt;E&gt; {
-	
-	Collection&lt;? extends E&gt;	getClients();
-	
-}

Added: trunk/src/net/sf/plantlore/server/Undertaker.java
===================================================================
--- trunk/src/net/sf/plantlore/server/Undertaker.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/Undertaker.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,9 @@
+package net.sf.plantlore.server;
+
+import net.sf.plantlore.middleware.DBLayer;
+
+public interface Undertaker {
+	
+	void bury(DBLayer db);
+
+}

Added: trunk/src/net/sf/plantlore/server/tools/RMI.java
===================================================================
--- trunk/src/net/sf/plantlore/server/tools/RMI.java	2006-03-26 01:35:26 UTC (rev 72)
+++ trunk/src/net/sf/plantlore/server/tools/RMI.java	2006-03-26 12:25:09 UTC (rev 73)
@@ -0,0 +1,51 @@
+package net.sf.plantlore.server.tools;
+
+import java.rmi.*;
+import java.rmi.registry.*;
+import java.rmi.server.UnicastRemoteObject;
+
+
+
+
+public class RMI {
+	
+	public static void bind(Remote object, String name) 
+	throws RemoteException, AccessException, AlreadyBoundException {
+		
+		bind(Registry.REGISTRY_PORT, object, name);
+	}
+	
+	
+	public static void bind(int port, Remote object, String name) 
+	throws RemoteException, AccessException, AlreadyBoundException {
+		
+		// Locate (or start) the rmiregistry on the specified port
+		Registry registry;
+		try {	registry = LocateRegistry.createRegistry(port); }
+		catch(Exception e) { registry = LocateRegistry.getRegistry(port); }
+	
+		// Bind the object to the rmiregistry.
+		registry.bind(name, object);
+	}
+	
+	
+	
+	public static void unbind(String name)
+	throws RemoteException, AccessException, NotBoundException {
+		
+		unbind(Registry.REGISTRY_PORT, name);
+	}
+	
+	
+	public static void unbind(int port, String name) 
+	throws RemoteException, AccessException, NotBoundException {
+		Registry registry = LocateRegistry.getRegistry(port);
+		registry.unbind(name);
+	}
+	
+	
+	public static void unexport(Remote object) throws NoSuchObjectException {
+		UnicastRemoteObject.unexportObject(object, true);
+	}
+
+}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000067.html">[Plantlore-dev] r72 - trunk/src/net/sf/plantlore/server
</A></li>
	<LI>Next message: <A HREF="000069.html">[Plantlore-dev] r74 - in trunk/src/net/sf/plantlore: client/authors middleware server
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#68">[ date ]</a>
              <a href="thread.html#68">[ thread ]</a>
              <a href="subject.html#68">[ subject ]</a>
              <a href="author.html#68">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/plantlore-dev">More information about the Plantlore-dev
mailing list</a><br>
</body></html>
